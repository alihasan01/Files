(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("geometry_core", [], factory);
	else if(typeof exports === 'object')
		exports["geometry_core"] = factory();
	else
		root["geometry_core"] = factory();
})(this, function() {
return (this["webpackJsonp"] = this["webpackJsonp"] || []).push([["geometry-core"],{

/***/ "./lib/Constant.js":
/*!*************************!*\
  !*** ./lib/Constant.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
/** Commonly used constant values. */
class Constant {
}
Constant.oneMillimeter = 0.001;
Constant.oneCentimeter = 0.01;
Constant.oneMeter = 1.0;
Constant.oneKilometer = 1000.0;
Constant.diameterOfEarth = 12742.0 * Constant.oneKilometer;
Constant.circumferenceOfEarth = 40075.0 * Constant.oneKilometer;
Constant.radiansPerDegree = 0.0174532925;
exports.Constant = Constant;


/***/ }),

/***/ "./lib/Geometry.js":
/*!*************************!*\
  !*** ./lib/Geometry.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
// import { Point2d } from "./Geometry2d";
/* tslint:disable:variable-name jsdoc-format no-empty*/
const Point2dVector2d_1 = __webpack_require__(/*! ./geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ./geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
/** Enumeration of the 6 possible orderings of XYZ axis order */
var AxisOrder;
(function (AxisOrder) {
    /** Right handed system, X then Y then Z */
    AxisOrder[AxisOrder["XYZ"] = 0] = "XYZ";
    /** Right handed system, Y then Z then X */
    AxisOrder[AxisOrder["YZX"] = 1] = "YZX";
    /** Right handed system, Z then X then Y */
    AxisOrder[AxisOrder["ZXY"] = 2] = "ZXY";
    /** Left handed system, X then Z then Y */
    AxisOrder[AxisOrder["XZY"] = 4] = "XZY";
    /** Left handed system, Y then X then Z */
    AxisOrder[AxisOrder["YXZ"] = 5] = "YXZ";
    /** Left handed system, Z then Y then X */
    AxisOrder[AxisOrder["ZYX"] = 6] = "ZYX";
})(AxisOrder = exports.AxisOrder || (exports.AxisOrder = {}));
/* Enumeration of the 3 axes AxisIndex.X, AxisIndex.Y, AxisIndex.Z */
var AxisIndex;
(function (AxisIndex) {
    AxisIndex[AxisIndex["X"] = 0] = "X";
    AxisIndex[AxisIndex["Y"] = 1] = "Y";
    AxisIndex[AxisIndex["Z"] = 2] = "Z";
})(AxisIndex = exports.AxisIndex || (exports.AxisIndex = {}));
/* Standard views.   Used in `Matrix3d.createStandardViewAxes (index: StandardViewIndex, worldToView :boolean)`
*/
var StandardViewIndex;
(function (StandardViewIndex) {
    StandardViewIndex[StandardViewIndex["Top"] = 1] = "Top";
    StandardViewIndex[StandardViewIndex["Bottom"] = 2] = "Bottom";
    StandardViewIndex[StandardViewIndex["Left"] = 3] = "Left";
    StandardViewIndex[StandardViewIndex["Right"] = 4] = "Right";
    StandardViewIndex[StandardViewIndex["Front"] = 5] = "Front";
    StandardViewIndex[StandardViewIndex["Back"] = 6] = "Back";
    StandardViewIndex[StandardViewIndex["Iso"] = 7] = "Iso";
    StandardViewIndex[StandardViewIndex["RightIso"] = 8] = "RightIso";
})(StandardViewIndex = exports.StandardViewIndex || (exports.StandardViewIndex = {}));
/** Enumeration among choice for how a coordinate transformation should incorporate scaling. */
var AxisScaleSelect;
(function (AxisScaleSelect) {
    /** All axes of unit length. */
    AxisScaleSelect[AxisScaleSelect["Unit"] = 0] = "Unit";
    /** On each axis, the vector length matches the longest side of the range of the data. */
    AxisScaleSelect[AxisScaleSelect["LongestRangeDirection"] = 1] = "LongestRangeDirection";
    /** On each axis, the vector length matches he length of the corresponding edge of the range. */
    AxisScaleSelect[AxisScaleSelect["NonUniformRangeContainment"] = 2] = "NonUniformRangeContainment";
})(AxisScaleSelect = exports.AxisScaleSelect || (exports.AxisScaleSelect = {}));
class Geometry {
    /** Points and vectors can be emitted in two forms:
      *
      * *  preferJSONArray === true :       [x,y,z]
      * *  preferJSONArray === false :      {x: 1, y: 2, z: 3}
      */
    // possible names for this class: Geometry, Distance, Units
    static correctSmallMetricDistance(distance, replacement = 0.0) {
        if (Math.abs(distance) < Geometry.smallMetricDistance) {
            return replacement;
        }
        return distance;
    }
    /**
   * @returns If `a` is large enough, return `1/a`, using Geometry.smallMetricDistance as the tolerance for declaring it as divide by zero.  Otherwise return `undefined`.
   * @param a denominator of division
   */
    static inverseMetricDistance(a) { return (Math.abs(a) <= Geometry.smallMetricDistance) ? undefined : 1.0 / a; }
    /**
     * @returns If `a` is large enough, return `1/a`, using the square of Geometry.smallMetricDistance as the tolerance for declaring it as divide by zero.  Otherwise return `undefined`.
     * @param a denominator of division
     */
    static inverseMetricDistanceSquared(a) {
        return (Math.abs(a) <= Geometry.smallMetricDistanceSquared) ? undefined : 1.0 / a;
    }
    static isSameCoordinate(x, y, tol) {
        if (tol)
            return Math.abs(x - y) < Math.abs(tol);
        return Math.abs(x - y) < Geometry.smallMetricDistance;
    }
    static isSameCoordinateSquared(x, y) {
        return Math.abs(Math.sqrt(x) - Math.sqrt(y)) < Geometry.smallMetricDistance;
    }
    static isSamePoint3d(dataA, dataB) { return dataA.distance(dataB) < Geometry.smallMetricDistance; }
    static isSameXYZ(dataA, dataB) { return dataA.distance(dataB) < Geometry.smallMetricDistance; }
    static isSamePoint3dXY(dataA, dataB) { return dataA.distanceXY(dataB) < Geometry.smallMetricDistance; }
    static isSameVector3d(dataA, dataB) { return dataA.distance(dataB) < Geometry.smallMetricDistance; }
    static isSamePoint2d(dataA, dataB) { return dataA.distance(dataB) < Geometry.smallMetricDistance; }
    static isSameVector2d(dataA, dataB) { return dataA.distance(dataB) < Geometry.smallMetricDistance; }
    /**
     * Lexical comparison of (a.x,a.y) (b.x,b.y) with x as first test, y second.
     */
    static lexicalXYLessThan(a, b) {
        if (a.x < b.x)
            return -1;
        else if (a.x > b.x)
            return 1;
        if (a.y < b.y)
            return -1;
        else if (a.y > b.y)
            return 1;
        return 0;
    }
    /**
     * Lexical comparison of (a.x,a.y) (b.x,b.y) with y as first test, x second.
     */
    static lexicalYXLessThan(a, b) {
        if (a.y < b.y)
            return -1;
        else if (a.y > b.y)
            return 1;
        if (a.x < b.x)
            return -1;
        else if (a.x > b.x)
            return 1;
        return 0;
    }
    static lexicalXYZLessThan(a, b) {
        if (a.x < b.x)
            return -1;
        else if (a.x > b.x)
            return 1;
        if (a.y < b.y)
            return -1;
        else if (a.y > b.y)
            return 1;
        if (a.z < b.z)
            return -1;
        else if (a.z > b.z)
            return 1;
        return 0;
    }
    static isSmallRelative(value) { return Math.abs(value) < Geometry.smallAngleRadians; }
    static isSmallAngleRadians(value) { return Math.abs(value) < Geometry.smallAngleRadians; }
    static isAlmostEqualNumber(a, b) {
        const sumAbs = 1.0 + Math.abs(a) + Math.abs(b);
        return Math.abs(a - b) <= Geometry.smallAngleRadians * sumAbs;
    }
    static isDistanceWithinTol(distance, tol) {
        return Math.abs(distance) <= Math.abs(tol);
    }
    static isSmallMetricDistance(distance) {
        return Math.abs(distance) <= Geometry.smallMetricDistance;
    }
    static isSmallMetricDistanceSquared(distanceSquared) {
        return Math.abs(distanceSquared) <= Geometry.smallMetricDistanceSquared;
    }
    static cyclic3dAxis(axis) {
        /* Direct test for the most common cases, avoid modulo */
        if (axis >= 0) {
            if (axis < 3)
                return axis;
            if (axis < 6)
                return axis - 3;
            return axis % 3;
        }
        const j = axis + 3;
        if (j >= 0)
            return j;
        return 2 - ((-axis - 1) % 3);
    }
    /** Return the AxisOrder for which axisIndex is the first named axis.
     * * `axisIndex===0`returns AxisOrder.XYZ
     * * `axisIndex===1`returns AxisOrder.YZX
     * * `axisIndex===2`returns AxisOrder.ZXY
     */
    static axisIndexToRightHandedAxisOrder(axisIndex) {
        if (axisIndex === 0)
            return 0 /* XYZ */;
        if (axisIndex === 1)
            return 1 /* YZX */;
        if (axisIndex === 2)
            return 2 /* ZXY */;
        return Geometry.axisIndexToRightHandedAxisOrder(Geometry.cyclic3dAxis(axisIndex));
    }
    /** @returns the largest absolute distance from a to either of b0 or b1 */
    static maxAbsDiff(a, b0, b1) { return Math.max(Math.abs(a - b0), Math.abs(a - b1)); }
    /** @returns the largest absolute absolute value among x,y,z */
    static maxAbsXYZ(x, y, z) {
        return Geometry.maxXYZ(Math.abs(x), Math.abs(y), Math.abs(z));
    }
    /** @returns the largest absolute absolute value among x,y */
    static maxAbsXY(x, y) {
        return Geometry.maxXY(Math.abs(x), Math.abs(y));
    }
    /** @returns the largest signed value among a, b, c */
    static maxXYZ(a, b, c) {
        let q = a;
        if (b > q)
            q = b;
        if (c > q)
            q = c;
        return q;
    }
    /** @returns the largest signed value among a, b*/
    static maxXY(a, b) {
        let q = a;
        if (b > q)
            q = b;
        return q;
    }
    /** @returns Return the hypotenuse sqrt(x\*x + y\*y). This is much faster than Math.hypot(x,y).*/
    static hypotenuseXY(x, y) { return Math.sqrt(x * x + y * y); }
    /** @returns Return the squared hypotenuse (x\*x + y\*y). */
    static hypotenuseSquaredXY(x, y) { return x * x + y * y; }
    /** @returns Return the square of x */
    static square(x) { return x * x; }
    /** @returns Return the hypotenuse sqrt(x\*x + y\*y). This is much faster than Math.hypot(x,y, z).*/
    static hypotenuseXYZ(x, y, z) { return Math.sqrt(x * x + y * y + z * z); }
    static hypotenuseSquaredXYZ(x, y, z) { return x * x + y * y + z * z; }
    static hypotenuseXYZW(x, y, z, w) { return Math.sqrt(x * x + y * y + z * z + w * w); }
    static hypotenuseSquaredXYZW(x, y, z, w) { return x * x + y * y + z * z + w * w; }
    /**
     * Return the distance between xy points given as numbers.
     * @param x0 x coordinate of point 0
     * @param y0 y coordinate of point 0
     * @param x1 x coordinate of point 1
     * @param y1 y coordinate of point 1
     */
    static distanceXYXY(x0, y0, x1, y1) {
        return Geometry.hypotenuseXY(x1 - x0, y1 - y0);
    }
    /**
     * Return the distance between xyz points given as numbers.
     * @param x0 x coordinate of point 0
     * @param y0 y coordinate of point 0
     * @param z0 z coordinate of point 0
     * @param x1 x coordinate of point 1
     * @param y1 y coordinate of point 1
     * @param z1 z coordinate of point 1
     */
    static distanceXYZXYZ(x0, y0, z0, x1, y1, z1) {
        return Geometry.hypotenuseXYZ(x1 - x0, y1 - y0, z1 - z0);
    }
    /** @returns Returns the triple product of 3 vectors provided as x,y,z number sequences.
     *
     * * The triple product is the determinant of the 3x3 matrix with the 9 numbers placed in either row or column order.
     * * The triple product is positive if the 3 vectors form a right handed coordinate system.
     * * The triple product is negative if the 3 vectors form a left handed coordinate system.
     * * Treating the 9 numbers as 3 vectors U, V, W, any of these formulas gives the same result:
     *
     * ** U dot (V cross W)
     * ** V dot (W cross U)
     * ** W dot (U cross V)
     * **  (-U dot (W cross V))  -- (note the negative -- reversing cross product order changes the sign)
     * ** (-V dot (U cross W)) -- (note the negative -- reversing cross product order changes the sign)
     * ** (-W dot (V cross U)) -- (note the negative -- reversing cross product order changes the sign)
     * * the triple product is 6 times the (signed) volume of the tetrahedron with the three vectors as edges from a common vertex.
     */
    static tripleProduct(ux, uy, uz, vx, vy, vz, wx, wy, wz) {
        return ux * (vy * wz - vz * wy)
            + uy * (vz * wx - vx * wz)
            + uz * (vx * wy - vy * wx);
    }
    /**
   * @returns Returns curvature magnitude from a first and second derivative vector.
   * @param ux  first derivative x component
   * @param uy first derivative y component
   * @param uz first derivative z component
   * @param vx second derivative x component
   * @param vy second derivative y component
   * @param vz second derivative z component
   */
    static curvatureMagnitude(ux, uy, uz, vx, vy, vz) {
        let q = uy * vz - uz * vy;
        let sum = q * q;
        q = uz * vx - ux * vz;
        sum += q * q;
        q = ux * vy - uy * vx;
        sum += q * q;
        const a = Math.sqrt(ux * ux + uy * uy + uz * uz);
        const b = Math.sqrt(sum);
        // (sum and a are both nonnegative)
        const aaa = a * a * a;
        // radius of curvature = aaa / b;
        // curvature = b/aaa
        const tol = Geometry.smallAngleRadians;
        if (aaa > tol * b)
            return b / aaa;
        return 0; // hm.. maybe should be infinte?
    }
    /** Returns the determinant of 3x3 matrix with x and y rows taken from 3 points, third row from corresponding numbers.
     *
     */
    static tripleProductXYW(columnA, weightA, columnB, weightB, columnC, weightC) {
        return Geometry.tripleProduct(columnA.x, columnB.x, columnC.x, columnA.y, columnB.y, columnC.y, weightA, weightB, weightC);
    }
    /** Returns the determinant of 3x3 matrix with x and y rows taken from 3 points, third row from corresponding numbers.
     *
     */
    static tripleProductPoint4dXYW(columnA, columnB, columnC) {
        return Geometry.tripleProduct(columnA.x, columnB.x, columnC.x, columnA.y, columnB.y, columnC.y, columnA.w, columnB.w, columnC.w);
    }
    /**  2D cross product of vectors layed out as scalars. */
    static crossProductXYXY(ux, uy, vx, vy) {
        return ux * vy - uy * vx;
    }
    /**  3D cross product of vectors layed out as scalars. */
    static crossProductXYZXYZ(ux, uy, uz, vx, vy, vz, result) {
        return Point3dVector3d_1.Vector3d.create(uy * vz - uz * vy, uz * vx - ux * vz, ux * vy - uy * vx, result);
    }
    /**  magnitude of 3D cross product of vectors, with the vectors presented as */
    static crossProductMagnitude(ux, uy, uz, vx, vy, vz) {
        return Geometry.hypotenuseXYZ(uy * vz - uz * vy, uz * vx - ux * vz, ux * vy - uy * vx);
    }
    /**  3D dot product of vectors layed out as scalars. */
    static dotProductXYZXYZ(ux, uy, uz, vx, vy, vz) {
        return ux * vx + uy * vy + uz * vz;
    }
    static clampToStartEnd(x, a, b) {
        if (a > b)
            return Geometry.clampToStartEnd(x, b, a);
        if (x < a)
            return a;
        if (b < x)
            return b;
        return x;
    }
    static clamp(value, min, max) { return Math.max(min, Math.min(max, value)); }
    /** simple interpolation between values, but choosing (based on fraction) a or b as starting point for maximum accuracy. */
    static interpolate(a, f, b) {
        return f <= 0.5 ? a + f * (b - a) : b - (1.0 - f) * (b - a);
    }
    /** given an axisOrder (e.g. XYZ, YZX, ZXY, XZYLeftHanded etc) and an (integer) offset, resolve to an axis index. */
    static axisOrderToAxis(order, index) {
        const axis = order <= 2 /* ZXY */ ? order + index : (order - 4 /* XZY */) - index;
        return Geometry.cyclic3dAxis(axis);
    }
    /** Return (a modulo period), e.g. for use as a cyclid index.  Both a and period may be negative. */
    static modulo(a, period) {
        if (period <= 0) {
            if (period === 0)
                return a;
            return -Geometry.modulo(-a, -period);
        }
        if (a >= 0) {
            if (a < period)
                return a;
            if (a < 2 * period)
                return a - period;
        }
        else {
            a += period; // hopefully move into primary period without division and floor
            if (a > 0)
                return a;
        }
        const m = Math.floor(a / period);
        return a - m * period;
    }
    /** return 0 if the value is undefined, 1 if defined. */
    static defined01(value) { return value === undefined ? 0 : 1; }
    /** normally, return numerator/denominator.
     * but if the ratio would exceed Geometry.largeFractionResult, return undefined.
     */
    static conditionalDivideFraction(numerator, denominator) {
        if (Math.abs(denominator) * Geometry.largeFractionResult > Math.abs(numerator))
            return numerator / denominator;
        return undefined;
    }
    /** return the 0, 1, or 2 pairs of (c,s) values that solve
     * {constCoff + cosCoff * c + sinCoff * s = }
     * with the constraint {c*c+s*s = 1}
     */
    static solveTrigForm(constCoff, cosCoff, sinCoff) {
        {
            const delta2 = cosCoff * cosCoff + sinCoff * sinCoff;
            const constCoff2 = constCoff * constCoff;
            // let nSolution = 0;
            let result;
            if (delta2 > 0.0) {
                const lambda = -constCoff / delta2;
                const a2 = constCoff2 / delta2;
                const D2 = 1.0 - a2;
                if (D2 >= 0.0) {
                    const mu = Math.sqrt(D2 / delta2);
                    /* c0,s0 = closest approach of line to origin */
                    const c0 = lambda * cosCoff;
                    const s0 = lambda * sinCoff;
                    // nSolution = 2;
                    result = [Point2dVector2d_1.Vector2d.create(c0 - mu * sinCoff, s0 + mu * cosCoff), Point2dVector2d_1.Vector2d.create(c0 + mu * sinCoff, s0 - mu * cosCoff)];
                }
            }
            return result;
        }
    }
    /** normally,  return the number result of conditionalDivideFraction.
     * but if conditionalDivideFraction fails return specified default number.
     */
    static safeDivideFraction(numerator, denominator, defaultResult) {
        const a = Geometry.conditionalDivideFraction(numerator, denominator);
        if (a !== undefined)
            return a;
        return defaultResult;
    }
    /** For a line f(x) whose function values at x0 and x1 are f0 and f1, return the x value at which f(x)=fTarget;
     */
    static inverseInterpolate(x0, f0, x1, f1, targetF = 0, defaultResult) {
        const g = Geometry.conditionalDivideFraction(targetF - f0, f1 - f0);
        if (g)
            return Geometry.interpolate(x0, g, x1);
        return defaultResult;
    }
    /** For a line f(x) whose function values at x=0 and x=1 are f0 and f1, return the x value at which f(x)=fTarget;
     */
    static inverseInterpolate01(f0, f1, targetF = 0) {
        return Geometry.conditionalDivideFraction(targetF - f0, f1 - f0);
    }
    /** Return true if json is an array with at least minEntries, and all entries are numbers (including those beyond minEntries) */
    static isNumberArray(json, minEntries = 0) {
        if (Array.isArray(json) && json.length >= minEntries) {
            let entry;
            for (entry of json) {
                //        if (!(entry as number) && entry !== 0.0)
                if (!Number.isFinite(entry))
                    return false;
            }
            return true;
        }
        return false;
    }
    /** Return true if json is an array of at least numNumberArrays, with at least minEntries in each number array.
     */
    static isArrayOfNumberArray(json, numNumberArray, minEntries = 0) {
        if (Array.isArray(json) && json.length >= numNumberArray) {
            let entry;
            for (entry of json)
                if (!Geometry.isNumberArray(entry, minEntries))
                    return false;
            return true;
        }
        return false;
    }
    /** return the number of steps to take so that numSteps * stepSize >= total.
     * minCount is returned for both (a) setSize 0 or less and (b) stepSize > total.
     * A small tolerance is applied for almost
    */
    static stepCount(stepSize, total, minCount = 1, maxCount = 101) {
        if (stepSize <= 0)
            return minCount;
        if (stepSize >= total)
            return minCount;
        const stepCount = Math.floor((total + 0.999999 * stepSize) / stepSize);
        if (stepCount < minCount)
            return minCount;
        if (stepCount > maxCount)
            return maxCount;
        return stepCount;
    }
    /** Test if x is in simple 0..1 interval.  But optionally skip the test.  (this odd behavior is very convenient for code that sometimes does not do the filtering.)
     * @param x value to test.
     * @param apply01 if false, accept all x.
     */
    static isIn01(x, apply01 = true) { return apply01 ? x >= 0.0 && x <= 1.0 : true; }
    /** Test if x is in simple 0..1 interval.  But optionally skip the test.  (this odd behavior is very convenient for code that sometimes does not do the filtering.)
     * @param x value to test.
     * @param apply01 if false, accept all x.
     */
    static isIn01WithTolerance(x, tolerance) { return x + tolerance >= 0.0 && x - tolerance <= 1.0; }
    /**
     * restrict x so it is in the interval `[a,b]`, allowing a,b to be in either order.
     * @param x
     * @param a (usually the lower) interval limit
     * @param b (usually the upper) interval limit
     */
    static restrictToInterval(x, a, b) {
        if (a <= b) {
            if (x < a)
                return a;
            if (x > b)
                return b;
            return x;
        }
        // reversed interval ....
        if (x < b)
            return b;
        if (x > a)
            return a;
        return x;
    }
}
Geometry.smallMetricDistance = 1.0e-6;
Geometry.smallMetricDistanceSquared = 1.0e-12;
Geometry.smallAngleRadians = 1.0e-12;
Geometry.smallAngleRadiansSquared = 1.0e-24;
Geometry.largeFractionResult = 1.0e10;
Geometry.fullCircleRadiansMinusSmallAngle = 2.0 * Math.PI - 1.0e-12; // smallAngleRadians less than 360degrees
exports.Geometry = Geometry;


/***/ }),

/***/ "./lib/bspline/BSpline1dNd.js":
/*!************************************!*\
  !*** ./lib/bspline/BSpline1dNd.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Bspline */
// import { Point2d } from "../Geometry2d";
/* tslint:disable:variable-name jsdoc-format no-empty no-console*/
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
/** Bspline knots and poles for 1d-to-Nd. */
class BSpline1dNd {
    get degree() { return this.knots.degree; }
    get order() { return this.knots.degree + 1; }
    get numSpan() { return this.numPoles - this.knots.degree; }
    get numPoles() { return this.packedData.length / this.poleLength; }
    getPoint3dPole(i, result) { return Point3dVector3d_1.Point3d.createFromPacked(this.packedData, i, result); }
    /**
     * initialize arrays for given spline dimensions.
     * @param numPoles number of poles
     * @param poleLength number of coordinates per pole (e.g.. 3 for 3D unweighted, 4 for 3d weighted, 2 for 2d unweighted, 3 for 2d weigthed)
     * @param order number of poles in support for a section of the bspline
     */
    constructor(numPoles, poleLength, order, knots) {
        this.knots = knots;
        this.packedData = new Float64Array(numPoles * poleLength);
        this.poleLength = poleLength;
        this.basisBuffer = new Float64Array(order);
        this.poleBuffer = new Float64Array(poleLength);
        this.basisBuffer1 = new Float64Array(order);
        this.basisBuffer2 = new Float64Array(order);
        this.poleBuffer1 = new Float64Array(poleLength);
        this.poleBuffer2 = new Float64Array(poleLength);
    }
    static create(numPoles, poleLength, order, knots) {
        return new BSpline1dNd(numPoles, poleLength, order, knots);
    }
    spanFractionToKnot(span, localFraction) {
        return this.knots.spanFractionToKnot(span, localFraction);
    }
    // ASSUME f is sized for {order} basis funtions !!!
    evaluateBasisFunctionsInSpan(spanIndex, spanFraction, f, df, ddf) {
        if (spanIndex < 0)
            spanIndex = 0;
        if (spanIndex >= this.numSpan)
            spanIndex = this.numSpan - 1;
        const knotIndex0 = spanIndex + this.degree - 1;
        const globalKnot = this.knots.baseKnotFractionToKnot(knotIndex0, spanFraction);
        return df ?
            this.knots.evaluateBasisFunctions1(knotIndex0, globalKnot, f, df, ddf) :
            this.knots.evaluateBasisFunctions(knotIndex0, globalKnot, f);
    }
    evaluateBuffersInSpan(spanIndex, spanFraction) {
        this.evaluateBasisFunctionsInSpan(spanIndex, spanFraction, this.basisBuffer);
        this.sumPoleBufferForSpan(spanIndex);
    }
    evaluateBuffersInSpan1(spanIndex, spanFraction) {
        this.evaluateBasisFunctionsInSpan(spanIndex, spanFraction, this.basisBuffer, this.basisBuffer1);
        this.sumPoleBufferForSpan(spanIndex);
        this.sumPoleBuffer1ForSpan(spanIndex);
    }
    /** sum poles by the weights in the basisBuffer, using poles for given span */
    sumPoleBufferForSpan(spanIndex) {
        this.poleBuffer.fill(0);
        let k = spanIndex * this.poleLength;
        for (const f of this.basisBuffer) {
            for (let j = 0; j < this.poleLength; j++) {
                this.poleBuffer[j] += f * this.packedData[k++];
            }
        }
    }
    /** sum poles by the weights in the basisBuffer, using poles for given span */
    sumPoleBuffer1ForSpan(spanIndex) {
        this.poleBuffer1.fill(0);
        let k = spanIndex * this.poleLength;
        for (const f of this.basisBuffer1) {
            for (let j = 0; j < this.poleLength; j++) {
                this.poleBuffer1[j] += f * this.packedData[k++];
            }
        }
    }
    /** sum poles by the weights in the basisBuffer, using poles for given span */
    sumPoleBuffer2ForSpan(spanIndex) {
        this.poleBuffer2.fill(0);
        let k = spanIndex * this.poleLength;
        for (const f of this.basisBuffer2) {
            for (let j = 0; j < this.poleLength; j++) {
                this.poleBuffer2[j] += f * this.packedData[k++];
            }
        }
    }
    evaluateBuffersAtKnot(u, numDerivative = 0) {
        const knotIndex0 = this.knots.knotToLeftKnotIndex(u);
        if (numDerivative < 1) {
            this.knots.evaluateBasisFunctions(knotIndex0, u, this.basisBuffer);
            this.sumPoleBufferForSpan(knotIndex0 - this.degree + 1);
        }
        else if (numDerivative === 1) {
            this.knots.evaluateBasisFunctions1(knotIndex0, u, this.basisBuffer, this.basisBuffer1);
            this.sumPoleBufferForSpan(knotIndex0 - this.degree + 1);
            this.sumPoleBuffer1ForSpan(knotIndex0 - this.degree + 1);
        }
        else {
            this.knots.evaluateBasisFunctions1(knotIndex0, u, this.basisBuffer, this.basisBuffer1, this.basisBuffer2);
            this.sumPoleBufferForSpan(knotIndex0 - this.degree + 1);
            this.sumPoleBuffer1ForSpan(knotIndex0 - this.degree + 1);
            this.sumPoleBuffer2ForSpan(knotIndex0 - this.degree + 1);
        }
    }
    reverseInPlace() {
        // reverse poles in blocks ...
        const b = this.poleLength;
        const data = this.packedData;
        for (let i0 = 0, j0 = b * (this.numPoles - 1); i0 < j0; i0 += b, j0 -= b) {
            let t = 0;
            for (let i = 0; i < b; i++) {
                t = data[i0 + i];
                data[i0 + i] = data[j0 + i];
                data[j0 + i] = t;
            }
        }
        this.knots.reflectKnots();
    }
    /**
     * Test if the leading and trailing polygon coordinates are replicated in the manner of a "closed" bspline polygon which has been expanded
     * to act as a normal bspline.
     * @returns true if `degree` leading and trailing polygon blocks match
     */
    testCloseablePolygon() {
        const degree = this.degree;
        const blockSize = this.poleLength;
        const indexDelta = (this.numPoles - this.degree) * blockSize;
        const data = this.packedData;
        const numValuesToTest = degree * blockSize;
        for (let i0 = 0; i0 < numValuesToTest; i0++) {
            if (!Geometry_1.Geometry.isSameCoordinate(data[i0], data[i0 + indexDelta]))
                return false;
        }
        return true;
    }
}
exports.BSpline1dNd = BSpline1dNd;


/***/ }),

/***/ "./lib/bspline/BSplineCurve.js":
/*!*************************************!*\
  !*** ./lib/bspline/BSplineCurve.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Bspline */
// import { Point2d } from "../Geometry2d";
/* tslint:disable:variable-name jsdoc-format no-empty no-console*/
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Range_1 = __webpack_require__(/*! ../geometry3d/Range */ "./lib/geometry3d/Range.js");
const Ray3d_1 = __webpack_require__(/*! ../geometry3d/Ray3d */ "./lib/geometry3d/Ray3d.js");
const Plane3dByOriginAndVectors_1 = __webpack_require__(/*! ../geometry3d/Plane3dByOriginAndVectors */ "./lib/geometry3d/Plane3dByOriginAndVectors.js");
const CurvePrimitive_1 = __webpack_require__(/*! ../curve/CurvePrimitive */ "./lib/curve/CurvePrimitive.js");
const CurveLocationDetail_1 = __webpack_require__(/*! ../curve/CurveLocationDetail */ "./lib/curve/CurveLocationDetail.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const KnotVector_1 = __webpack_require__(/*! ./KnotVector */ "./lib/bspline/KnotVector.js");
const PointHelpers_1 = __webpack_require__(/*! ../geometry3d/PointHelpers */ "./lib/geometry3d/PointHelpers.js");
const BezierCurve3dH_1 = __webpack_require__(/*! ./BezierCurve3dH */ "./lib/bspline/BezierCurve3dH.js");
const BezierCurve3d_1 = __webpack_require__(/*! ./BezierCurve3d */ "./lib/bspline/BezierCurve3d.js");
const BSpline1dNd_1 = __webpack_require__(/*! ./BSpline1dNd */ "./lib/bspline/BSpline1dNd.js");
const BezierPolynomials_1 = __webpack_require__(/*! ../numerics/BezierPolynomials */ "./lib/numerics/BezierPolynomials.js");
const Bezier1dNd_1 = __webpack_require__(/*! ./Bezier1dNd */ "./lib/bspline/Bezier1dNd.js");
const Point4d_1 = __webpack_require__(/*! ../geometry4d/Point4d */ "./lib/geometry4d/Point4d.js");
/**
 * Base class for BSplineCurve3d and BSplineCurve3dH.
 * * A bspline curve consists of a set of knots and a set of poles.
 * * The bspline curve is a function of the independent "knot axis" variable
 * * The curve "follows" the poles loosely.
 * * The is a set of polynomial spans.
 * * The polynomial spans all have same `degree`.
 * * Within each span, the polynomial of that `degree` is controlled by `order = degree + 1` contiguous points called poles.
 * * The is a strict relationship between knot and poles counts:  `numPoles + order = numKnots + 2'
 * * The number of spans is `numSpan = numPoles - degree`
 * * For a given `spanIndex`:
 * * * The `order` poles begin at index `spanIndex`.
 * * * The `2*order` knots begin as span index
 * * * The knot interval for this span is from `knot[degree+span-1] to knot[degree+span]`
 * * The active part of the knot axis is `knot[degree-1] < knot < knot[degree-1 + numSpan]` i.e. `knot[degree-1] < knot < knot[numPoles]
 *
 * Nearly all bsplines are "clamped ".
 * * Clamping make the curve pass through its first and last poles, with tangents directed along the first and last edges of the control polygon.
 * * The knots for a clampled bspline have `degree` copies of the lowest knot value and `degree` copies of the highest knot value.
 * * For instance, the knot vector `[0,0,0,1,2,3,3,3]
 * * * can be evaluated from `0<=knot<=3`
 * * * has 3 spans: 0 to 1, 1 to 2, 2 to 3
 * * * has 6 poles
 * * * passes through its first and last poles.
 * * `create` methods may allow classic convention that has an extra knot at the beginning and end of the knot vector.
 * * * The extra knots (first and last) were never referenced by the bspline recurrance relations.
 * * * When the `ceate` methods recognize the classic setup (`numPoles + order = numKnots`), the extra knot is not saved with the BSplineCurve3dBase knots.
 *
 * * The weighted variant has the problem that CurvePrimitive 3d typing does not allow undefined result where Point4d has zero weight.
 * * The convention for these is to return 000 in such places.
 *
 * * Note the class relationships:
 * * * BSpline1dNd knows the bspline reucurrance relations for control points (poles) with no physical meaning.
 * * * BsplineCurve3dBase owns a protected BSpline1dNd
 * * * BsplineCurve3dBase is derived from CurvePrimitive, which creates obligation to act as a 3D curve, such as
 * * * * evaluate fraction to point and derivatives wrt fraction
 * * * * compute intersection with plane
 * * * BSplineCurve3d and BSplineCurve3dH have variant logic driven by whether or not there are "weights" on the poles.
 * * * * For `BSplineCurve3d`, the xyz value of pole calculations are "final" values for 3d evaluation
 * * * * For `BSplineCurve3dH`, various `BSpline1dNd` results with xyzw have to be normalized back to xyz.
 *
 * * These classes do not support "periodic" variants.
 * * * Periodic curves need to have certain leading knots and poles replicated at the end
 */
class BSplineCurve3dBase extends CurvePrimitive_1.CurvePrimitive {
    constructor(poleDimension, numPoles, order, knots) {
        super();
        this._bcurve = BSpline1dNd_1.BSpline1dNd.create(numPoles, poleDimension, order, knots);
    }
    get degree() { return this._bcurve.degree; }
    get order() { return this._bcurve.order; }
    get numSpan() { return this._bcurve.numSpan; }
    get numPoles() { return this._bcurve.numPoles; }
    /**
   * return a simple array form of the knots.  optionally replicate the first and last
   * in classic over-clamped manner
   */
    copyKnots(includeExtraEndKnot) { return this._bcurve.knots.copyKnots(includeExtraEndKnot); }
    /**
   * Set the flag indicating the bspline might be suitable for having wrapped "closed" interpretation.
   */
    setWrappable(value) {
        this._bcurve.knots.wrappable = value;
    }
    fractionToPoint(fraction, result) {
        return this.knotToPoint(this._bcurve.knots.fractionToKnot(fraction), result);
    }
    /** Construct a ray with
     * * origin at the fractional position along the arc
     * * direction is the first derivative, i.e. tangent along the curve
     */
    fractionToPointAndDerivative(fraction, result) {
        const knot = this._bcurve.knots.fractionToKnot(fraction);
        result = this.knotToPointAndDerivative(knot, result);
        result.direction.scaleInPlace(this._bcurve.knots.knotLength01);
        return result;
    }
    /** Construct a plane with
     * * origin at the fractional position along the arc
     * * x axis is the first derivative, i.e. tangent along the curve
     * * y axis is the second derivative
     */
    fractionToPointAnd2Derivatives(fraction, result) {
        const knot = this._bcurve.knots.fractionToKnot(fraction);
        result = this.knotToPointAnd2Derivatives(knot, result);
        const a = this._bcurve.knots.knotLength01;
        result.vectorU.scaleInPlace(a);
        result.vectorV.scaleInPlace(a * a);
        return result;
    }
    /**
     * Return the start point of hte curve.
     */
    startPoint() { return this.evaluatePointInSpan(0, 0.0); }
    /**
     * Return the end point of the curve
     */
    endPoint() { return this.evaluatePointInSpan(this.numSpan - 1, 1.0); }
    /** Reverse the curve in place.
     * * Poles are reversed
     * * knot values are mirrored around the middle of the
     */
    reverseInPlace() { this._bcurve.reverseInPlace(); }
    /**
     * Return an array with this curve's bezier fragments.
     */
    collectBezierSpans(prefer3dH) {
        const result = [];
        const numSpans = this.numSpan;
        for (let i = 0; i < numSpans; i++) {
            if (this._bcurve.knots.isIndexOfRealSpan(i)) {
                const span = this.getSaturatedBezierSpan3dOr3dH(i, prefer3dH);
                if (span)
                    result.push(span);
            }
        }
        return result;
    }
    /** Given a pole index, return the starting index for the contiguous array. */
    poleIndexToDataIndex(poleIndex) {
        if (poleIndex >= 0 && poleIndex < this.numPoles)
            return poleIndex * this._bcurve.poleLength;
        return undefined;
    }
    /** Search for the curve point that is closest to the spacePoint.
     *
     * * If the space point is exactly on the curve, this is the reverse of fractionToPoint.
     * * Since CurvePrimitive should always have start and end available as candidate points, this method should always succeed
     * @param spacePoint point in space
     * @param extend true to extend the curve (if possible)
     * @returns Returns a CurveLocationDetail structure that holds the details of the close point.
     */
    closestPoint(spacePoint, _extend) {
        const point = this.fractionToPoint(0);
        const result = CurveLocationDetail_1.CurveLocationDetail.createCurveFractionPointDistance(this, 0.0, point, point.distance(spacePoint));
        this.fractionToPoint(1.0, point);
        result.updateIfCloserCurveFractionPointDistance(this, 1.0, spacePoint, spacePoint.distance(point));
        let span;
        const numSpans = this.numSpan;
        for (let i = 0; i < numSpans; i++) {
            if (this._bcurve.knots.isIndexOfRealSpan(i)) {
                span = this.getSaturatedBezierSpan3dOr3dH(i, true, span);
                if (span) {
                    if (span.updateClosestPointByTruePerpendicular(spacePoint, result)) {
                        // the detail records the span bezier -- promote it to the parent curve . ..
                        result.curve = this;
                        result.fraction = span.fractionToParentFraction(result.fraction);
                    }
                }
            }
        }
        return result;
    }
    /** Implement `CurvePrimitive.appendPlaneIntersections`
     * @param plane A plane (e.g. specific type Plane3dByOriginAndUnitNormal or Point4d)
     * @param result growing array of plane intersections
     * @return number of intersections appended to the array.
    */
    appendPlaneIntersectionPoints(plane, result) {
        const numPole = this.numPoles;
        const order = this.order;
        const allCoffs = new Float64Array(numPole);
        const numSpan = this.numSpan;
        const point4d = Point4d_1.Point4d.create();
        // compute all pole altitudes from the plane
        const minMax = Range_1.Range1d.createNull();
        // Put the altitudes of all the bspline poles in one array.
        for (let i = 0; i < numPole; i++) {
            allCoffs[i] = plane.weightedAltitude(this.getPolePoint4d(i, point4d));
            minMax.extendX(allCoffs[i]);
        }
        // A univaraite bspline throught the altitude poles gives altitude as function of the bspline knot.
        // The (bspline) altitude function for each span is `order` consecutive altitudes.
        // If those altitutdes bracket zero, the span may potentially have a crossing.
        // When that occurs,
        let univariateBezier;
        let numFound = 0;
        let previousFraction = -1000.0;
        if (minMax.containsX(0.0)) {
            for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {
                if (this._bcurve.knots.isIndexOfRealSpan(spanIndex)) { // ignore trivial knot intervals.
                    // outer range test ...
                    minMax.setNull();
                    minMax.extendArraySubset(allCoffs, spanIndex, order);
                    if (minMax.containsX(0.0)) {
                        // pack the bspline support into a univariate bezier ...
                        univariateBezier = BezierPolynomials_1.UnivariateBezier.createArraySubset(allCoffs, spanIndex, order, univariateBezier);
                        // saturate and solve the bezier
                        Bezier1dNd_1.Bezier1dNd.saturate1dInPlace(univariateBezier.coffs, this._bcurve.knots, spanIndex);
                        const roots = univariateBezier.roots(0.0, true);
                        if (roots) {
                            for (const spanFraction of roots) {
                                // promote each local bezier fraction to global fraction.
                                // savet the curve evaluation at that fraction.
                                numFound++;
                                const fraction = this._bcurve.knots.spanFractionToFraction(spanIndex, spanFraction);
                                if (!Geometry_1.Geometry.isAlmostEqualNumber(fraction, previousFraction)) {
                                    const detail = CurveLocationDetail_1.CurveLocationDetail.createCurveEvaluatedFraction(this, fraction);
                                    result.push(detail);
                                    previousFraction = fraction;
                                }
                            }
                        }
                    }
                }
            }
        }
        return numFound;
    }
}
exports.BSplineCurve3dBase = BSplineCurve3dBase;
/**
 * A BSplineCurve3d is a bspline curve whose poles are Point3d.
 * See BSplineCurve3dBase for description of knots, order, degree.
 */
class BSplineCurve3d extends BSplineCurve3dBase {
    initializeWorkBezier() {
        if (this._workBezier === undefined)
            this._workBezier = BezierCurve3dH_1.BezierCurve3dH.createOrder(this.order);
        return this._workBezier;
    }
    isSameGeometryClass(other) { return other instanceof BSplineCurve3d; }
    tryTransformInPlace(transform) { PointHelpers_1.Point3dArray.multiplyInPlace(transform, this._bcurve.packedData); return true; }
    getPolePoint3d(poleIndex, result) {
        const k = this.poleIndexToDataIndex(poleIndex);
        if (k !== undefined) {
            const data = this._bcurve.packedData;
            return Point3dVector3d_1.Point3d.create(data[k], data[k + 1], data[k + 2], result);
        }
        return undefined;
    }
    getPolePoint4d(poleIndex, result) {
        const k = this.poleIndexToDataIndex(poleIndex);
        if (k !== undefined) {
            const data = this._bcurve.packedData;
            return Point4d_1.Point4d.create(data[k], data[k + 1], data[k + 2], 1.0, result);
        }
        return undefined;
    }
    spanFractionToKnot(span, localFraction) {
        return this._bcurve.spanFractionToKnot(span, localFraction);
    }
    constructor(numPoles, order, knots) {
        super(3, numPoles, order, knots);
    }
    /** Return a simple array of arrays with the control points as `[[x,y,z],[x,y,z],..]` */
    copyPoints() { return PointHelpers_1.Point3dArray.unpackNumbersToNestedArrays(this._bcurve.packedData, 3); }
    /** Return a simple array of the control points coordinates */
    copyPointsFloat64Array() { return this._bcurve.packedData.slice(); }
    /**
     * return a simple array form of the knots.  optionally replicate the first and last
     * in classic over-clamped manner
     */
    copyKnots(includeExtraEndKnot) { return this._bcurve.knots.copyKnots(includeExtraEndKnot); }
    /** Create a bspline with uniform knots. */
    static createUniformKnots(poles, order) {
        const numPoles = poles instanceof Float64Array ? poles.length / 3 : poles.length;
        if (order < 1 || numPoles < order)
            return undefined;
        const knots = KnotVector_1.KnotVector.createUniformClamped(poles.length, order - 1, 0.0, 1.0);
        const curve = new BSplineCurve3d(numPoles, order, knots);
        if (poles instanceof Float64Array) {
            for (let i = 0; i < 3 * numPoles; i++)
                curve._bcurve.packedData[i] = poles[i];
        }
        else {
            let i = 0;
            for (const p of poles) {
                curve._bcurve.packedData[i++] = p.x;
                curve._bcurve.packedData[i++] = p.y;
                curve._bcurve.packedData[i++] = p.z;
            }
        }
        return curve;
    }
    /** Create a bspline with given knots.
     *
     * *  Two count conditions are recognized:
     *
     * ** If poleArray.length + order == knotArray.length, the first and last are assumed to be the
     *      extraneous knots of classic clamping.
     * ** If poleArray.length + order == knotArray.length + 2, the knots are in modern form.
     *
     */
    static create(poleArray, knotArray, order) {
        let numPoles = poleArray.length;
        if (poleArray instanceof Float64Array) {
            numPoles /= 3; // blocked as xyz
        }
        const numKnots = knotArray.length;
        // shift knots-of-interest limits for overclampled case ...
        const skipFirstAndLast = (numPoles + order === numKnots);
        if (order < 1 || numPoles < order)
            return undefined;
        const knots = KnotVector_1.KnotVector.create(knotArray, order - 1, skipFirstAndLast);
        const curve = new BSplineCurve3d(numPoles, order, knots);
        if (poleArray instanceof Float64Array) {
            let i = 0;
            for (const coordinate of poleArray) {
                curve._bcurve.packedData[i++] = coordinate;
            }
        }
        else {
            let i = 0;
            for (const p of poleArray) {
                curve._bcurve.packedData[i++] = p.x;
                curve._bcurve.packedData[i++] = p.y;
                curve._bcurve.packedData[i++] = p.z;
            }
        }
        return curve;
    }
    clone() {
        const knotVector1 = this._bcurve.knots.clone();
        const curve1 = new BSplineCurve3d(this.numPoles, this.order, knotVector1);
        curve1._bcurve.packedData = this._bcurve.packedData.slice();
        return curve1;
    }
    cloneTransformed(transform) {
        const curve1 = this.clone();
        curve1.tryTransformInPlace(transform);
        return curve1;
    }
    /** Evaluate at a position given by fractional position within a span. */
    evaluatePointInSpan(spanIndex, spanFraction) {
        this._bcurve.evaluateBuffersInSpan(spanIndex, spanFraction);
        return Point3dVector3d_1.Point3d.createFrom(this._bcurve.poleBuffer);
    }
    evaluatePointAndTangentInSpan(spanIndex, spanFraction) {
        this._bcurve.evaluateBuffersInSpan1(spanIndex, spanFraction);
        return Ray3d_1.Ray3d.createCapture(Point3dVector3d_1.Point3d.createFrom(this._bcurve.poleBuffer), Point3dVector3d_1.Vector3d.createFrom(this._bcurve.poleBuffer1));
    }
    /** Evaluate at a positioni given by a knot value.  */
    knotToPoint(u, result) {
        this._bcurve.evaluateBuffersAtKnot(u);
        return Point3dVector3d_1.Point3d.createFrom(this._bcurve.poleBuffer, result);
    }
    /** Evaluate at a position given by a knot value.  */
    knotToPointAndDerivative(u, result) {
        this._bcurve.evaluateBuffersAtKnot(u, 1);
        if (!result)
            return Ray3d_1.Ray3d.createCapture(Point3dVector3d_1.Point3d.createFrom(this._bcurve.poleBuffer), Point3dVector3d_1.Vector3d.createFrom(this._bcurve.poleBuffer1));
        result.origin.setFrom(this._bcurve.poleBuffer);
        result.direction.setFrom(this._bcurve.poleBuffer1);
        return result;
    }
    /** Evaluate at a position given by a knot value.  Return point with 2 derivatives. */
    knotToPointAnd2Derivatives(u, result) {
        this._bcurve.evaluateBuffersAtKnot(u, 2);
        return Plane3dByOriginAndVectors_1.Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(this._bcurve.poleBuffer[0], this._bcurve.poleBuffer[1], this._bcurve.poleBuffer[2], this._bcurve.poleBuffer1[0], this._bcurve.poleBuffer1[1], this._bcurve.poleBuffer1[2], this._bcurve.poleBuffer2[0], this._bcurve.poleBuffer2[1], this._bcurve.poleBuffer2[2], result);
    }
    fractionToPoint(fraction, result) {
        return this.knotToPoint(this._bcurve.knots.fractionToKnot(fraction), result);
    }
    fractionToPointAndDerivative(fraction, result) {
        const knot = this._bcurve.knots.fractionToKnot(fraction);
        result = this.knotToPointAndDerivative(knot, result);
        result.direction.scaleInPlace(this._bcurve.knots.knotLength01);
        return result;
    }
    /** Construct a plane with
     * * origin at the fractional position along the arc
     * * x axis is the first derivative, i.e. tangent along the arc
     * * y axis is the second derivative, i.e. in the plane and on the center side of the tangent.
     * If the arc is circular, the second derivative is directly towards the center
     */
    fractionToPointAnd2Derivatives(fraction, result) {
        const knot = this._bcurve.knots.fractionToKnot(fraction);
        result = this.knotToPointAnd2Derivatives(knot, result);
        const a = this._bcurve.knots.knotLength01;
        result.vectorU.scaleInPlace(a);
        result.vectorV.scaleInPlace(a * a);
        return result;
    }
    isAlmostEqual(other) {
        if (other instanceof BSplineCurve3d) {
            return this._bcurve.knots.isAlmostEqual(other._bcurve.knots)
                && PointHelpers_1.Point3dArray.isAlmostEqual(this._bcurve.packedData, other._bcurve.packedData);
        }
        return false;
    }
    isInPlane(plane) {
        return PointHelpers_1.Point3dArray.isCloseToPlane(this._bcurve.packedData, plane);
    }
    quickLength() { return PointHelpers_1.Point3dArray.sumEdgeLengths(this._bcurve.packedData); }
    emitStrokableParts(handler, options) {
        const needBeziers = handler.announceBezierCurve !== undefined;
        const workBezier = this.initializeWorkBezier();
        const numSpan = this.numSpan;
        let numStrokes;
        for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {
            const bezier = this.getSaturatedBezierSpan3dOr3dH(spanIndex, false, workBezier);
            if (bezier) {
                numStrokes = bezier.strokeCount(options);
                if (needBeziers) {
                    handler.announceBezierCurve(bezier, numStrokes, this, spanIndex, this._bcurve.knots.spanFractionToFraction(spanIndex, 0.0), this._bcurve.knots.spanFractionToFraction(spanIndex, 1.0));
                }
                else {
                    handler.announceIntervalForUniformStepStrokes(this, numStrokes, this._bcurve.knots.spanFractionToFraction(spanIndex, 0.0), this._bcurve.knots.spanFractionToFraction(spanIndex, 1.0));
                }
            }
        }
    }
    emitStrokes(dest, options) {
        const workBezier = this.initializeWorkBezier();
        const numSpan = this.numSpan;
        for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {
            const bezier = this.getSaturatedBezierSpan3dH(spanIndex, workBezier);
            if (bezier)
                bezier.emitStrokes(dest, options);
        }
    }
    /**
     * return true if the spline is (a) unclamped with (degree-1) matching knot intervals,
     * (b) (degree-1) wrapped points,
     * (c) marked wrappable from construction time.
     */
    get isClosable() {
        if (!this._bcurve.knots.wrappable)
            return false;
        if (!this._bcurve.knots.testClosable())
            return false;
        if (!this._bcurve.testCloseablePolygon())
            return false;
        return true;
    }
    /**
     * Return a BezierCurveBase for this curve.  The concrete return type may be BezierCuve3d or BezierCurve3dH according to this type.
     * @param spanIndex
     * @param result optional reusable curve.  This will only be reused if it is a BezierCurve3d with matching order.
     */
    getSaturatedBezierSpan3dOr3dH(spanIndex, prefer3dH, result) {
        if (prefer3dH)
            return this.getSaturatedBezierSpan3dH(spanIndex, result);
        return this.getSaturatedBezierSpan3d(spanIndex, result);
    }
    /**
     * Return a CurvePrimitive (which is a BezierCurve3d) for a specified span of this curve.
     * @param spanIndex
     * @param result optional reusable curve.  This will only be reused if it is a BezierCurve3d with matching order.
     */
    getSaturatedBezierSpan3d(spanIndex, result) {
        if (spanIndex < 0 || spanIndex >= this.numSpan)
            return undefined;
        const order = this.order;
        if (result === undefined || !(result instanceof BezierCurve3d_1.BezierCurve3d) || result.order !== order)
            result = BezierCurve3d_1.BezierCurve3d.createOrder(order);
        const bezier = result;
        bezier.loadSpanPoles(this._bcurve.packedData, spanIndex);
        bezier.saturateInPlace(this._bcurve.knots, spanIndex);
        return result;
    }
    /**
     * Return a CurvePrimitive (which is a BezierCurve3dH) for a specified span of this curve.
     * @param spanIndex
     * @param result optional reusable curve.  This will only be reused if it is a BezierCurve3d with matching order.
     */
    getSaturatedBezierSpan3dH(spanIndex, result) {
        if (spanIndex < 0 || spanIndex >= this.numSpan)
            return undefined;
        const order = this.order;
        if (result === undefined || !(result instanceof BezierCurve3dH_1.BezierCurve3dH) || result.order !== order)
            result = BezierCurve3dH_1.BezierCurve3dH.createOrder(order);
        const bezier = result;
        bezier.loadSpan3dPolesWithWeight(this._bcurve.packedData, spanIndex, 1.0);
        bezier.saturateInPlace(this._bcurve.knots, spanIndex);
        return bezier;
    }
    /**
     * Set the flag indicating the bspline might be suitable for having wrapped "closed" interpretation.
     */
    setWrappable(value) {
        this._bcurve.knots.wrappable = value;
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleBSplineCurve3d(this);
    }
    extendRange(rangeToExtend, transform) {
        const buffer = this._bcurve.packedData;
        const n = buffer.length - 2;
        if (transform) {
            for (let i0 = 0; i0 < n; i0 += 3)
                rangeToExtend.extendTransformedXYZ(transform, buffer[i0], buffer[i0 + 1], buffer[i0 + 2]);
        }
        else {
            for (let i0 = 0; i0 < n; i0 += 3)
                rangeToExtend.extendXYZ(buffer[i0], buffer[i0 + 1], buffer[i0 + 2]);
        }
    }
}
exports.BSplineCurve3d = BSplineCurve3d;


/***/ }),

/***/ "./lib/bspline/BSplineCurve3dH.js":
/*!****************************************!*\
  !*** ./lib/bspline/BSplineCurve3dH.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Bspline */
// import { Point2d } from "../Geometry2d";
/* tslint:disable:variable-name jsdoc-format no-empty no-console*/
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Point4d_1 = __webpack_require__(/*! ../geometry4d/Point4d */ "./lib/geometry4d/Point4d.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const KnotVector_1 = __webpack_require__(/*! ./KnotVector */ "./lib/bspline/KnotVector.js");
const PointHelpers_1 = __webpack_require__(/*! ../geometry3d/PointHelpers */ "./lib/geometry3d/PointHelpers.js");
const BezierCurve3dH_1 = __webpack_require__(/*! ./BezierCurve3dH */ "./lib/bspline/BezierCurve3dH.js");
const BSplineCurve_1 = __webpack_require__(/*! ./BSplineCurve */ "./lib/bspline/BSplineCurve.js");
/**
 * Weighted (Homogeneous) BSplineCurve in 3d
 */
class BSplineCurve3dH extends BSplineCurve_1.BSplineCurve3dBase {
    initializeWorkBezier() {
        if (this._workBezier === undefined)
            this._workBezier = BezierCurve3dH_1.BezierCurve3dH.createOrder(this.order);
        return this._workBezier;
    }
    isSameGeometryClass(other) { return other instanceof BSplineCurve3dH; }
    tryTransformInPlace(transform) { PointHelpers_1.Point4dArray.multiplyInPlace(transform, this._bcurve.packedData); return true; }
    getPolePoint3d(poleIndex, result) {
        const k = this.poleIndexToDataIndex(poleIndex);
        if (k !== undefined) {
            const data = this._bcurve.packedData;
            const divw = Geometry_1.Geometry.conditionalDivideFraction(1.0, data[k + 3]);
            if (divw !== undefined)
                return Point3dVector3d_1.Point3d.create(data[k] * divw, data[k + 1] * divw, data[k + 2] * divw, result);
        }
        return undefined;
    }
    getPolePoint4d(poleIndex, result) {
        const k = this.poleIndexToDataIndex(poleIndex);
        if (k !== undefined) {
            const data = this._bcurve.packedData;
            return Point4d_1.Point4d.create(data[k], data[k + 1], data[k + 2], data[k + 3], result);
        }
        return undefined;
    }
    spanFractionToKnot(span, localFraction) {
        return this._bcurve.spanFractionToKnot(span, localFraction);
    }
    constructor(numPoles, order, knots) {
        super(4, numPoles, order, knots);
    }
    /** Return a simple array of arrays with the control points as `[[x,y,z,w],[x,y,z,w],..]` */
    copyPoints() { return PointHelpers_1.Point3dArray.unpackNumbersToNestedArrays(this._bcurve.packedData, 4); }
    /** Return a simple array of the control points coordinates */
    copyPointsFloat64Array() { return this._bcurve.packedData.slice(); }
    /** Create a bspline with uniform knots.
     * * Control points may be supplied as:
     *   * array of Point4d, with weight already multiplied into the `[wx,wy,wz,w]`
     *   * array of Point3d, with implied weight 1.
     *   * Float64Array, blocked as xyzw, i.e. 4 doubles per control point.
     * @param controlPoints pole data in array form as noted above.
     * @param order  curve order (1 more than degree)
     */
    static createUniformKnots(controlPoints, order) {
        const numPoles = (controlPoints instanceof Float64Array) ? controlPoints.length / 4 : controlPoints.length;
        if (order < 1 || numPoles < order)
            return undefined;
        const knots = KnotVector_1.KnotVector.createUniformClamped(controlPoints.length, order - 1, 0.0, 1.0);
        const curve = new BSplineCurve3dH(numPoles, order, knots);
        let i = 0;
        if (controlPoints[0] instanceof Point3dVector3d_1.Point3d) {
            for (const p of controlPoints) {
                curve._bcurve.packedData[i++] = p.x;
                curve._bcurve.packedData[i++] = p.y;
                curve._bcurve.packedData[i++] = p.z;
                curve._bcurve.packedData[i++] = 1.0;
            }
        }
        else if (controlPoints[0] instanceof Point4d_1.Point4d) {
            for (const p of controlPoints) {
                curve._bcurve.packedData[i++] = p.x;
                curve._bcurve.packedData[i++] = p.y;
                curve._bcurve.packedData[i++] = p.z;
                curve._bcurve.packedData[i++] = p.w;
            }
        }
        else if (controlPoints instanceof Float64Array) {
            const qPoles = controlPoints;
            const numQ = qPoles.length;
            for (let k = 0; k < numQ; k++) {
                curve._bcurve.packedData[k] = qPoles[k];
            }
        }
        else {
            return undefined;
        }
        return curve;
    }
    /** Create a bspline with given knots.
     *
     * *  Two count conditions are recognized:
     *
     * ** If poleArray.length + order == knotArray.length, the first and last are assumed to be the
     *      extraneous knots of classic clamping.
     * ** If poleArray.length + order == knotArray.length + 2, the knots are in modern form.
     *
     */
    static create(controlPoints, knotArray, order) {
        let numPoles = controlPoints.length;
        if (controlPoints instanceof Float64Array) {
            numPoles /= 4; // blocked as xyz
        }
        const numKnots = knotArray.length;
        // shift knots-of-interest limits for overclampled case ...
        const skipFirstAndLast = (numPoles + order === numKnots);
        if (order < 1 || numPoles < order)
            return undefined;
        const knots = KnotVector_1.KnotVector.create(knotArray, order - 1, skipFirstAndLast);
        const curve = new BSplineCurve3dH(numPoles, order, knots);
        if (controlPoints instanceof Float64Array) {
            let i = 0;
            for (const coordinate of controlPoints) {
                curve._bcurve.packedData[i++] = coordinate;
            }
        }
        else if (controlPoints[0] instanceof Point4d_1.Point4d) {
            let i = 0;
            for (const p of controlPoints) {
                curve._bcurve.packedData[i++] = p.x;
                curve._bcurve.packedData[i++] = p.y;
                curve._bcurve.packedData[i++] = p.z;
                curve._bcurve.packedData[i++] = p.w;
            }
        }
        else if (controlPoints[0] instanceof Point3dVector3d_1.Point3d) {
            let i = 0;
            for (const p of controlPoints) {
                curve._bcurve.packedData[i++] = p.x;
                curve._bcurve.packedData[i++] = p.y;
                curve._bcurve.packedData[i++] = p.z;
                curve._bcurve.packedData[i++] = 1.0;
            }
        }
        return curve;
    }
    clone() {
        const knotVector1 = this._bcurve.knots.clone();
        const curve1 = new BSplineCurve3dH(this.numPoles, this.order, knotVector1);
        curve1._bcurve.packedData = this._bcurve.packedData.slice();
        return curve1;
    }
    cloneTransformed(transform) {
        const curve1 = this.clone();
        curve1.tryTransformInPlace(transform);
        return curve1;
    }
    /** Evaluate at a position given by fractional position within a span. */
    evaluatePointInSpan(spanIndex, spanFraction, result) {
        this._bcurve.evaluateBuffersInSpan(spanIndex, spanFraction);
        const xyzw = this._bcurve.poleBuffer;
        return Point4d_1.Point4d.createRealPoint3dDefault000(xyzw[0], xyzw[1], xyzw[2], xyzw[3], result);
    }
    /** Evaluate at a position given by fractional position within a span. */
    evaluatePointAndTangentInSpan(spanIndex, spanFraction, result) {
        this._bcurve.evaluateBuffersInSpan1(spanIndex, spanFraction);
        const xyzw = this._bcurve.poleBuffer;
        const dxyzw = this._bcurve.poleBuffer1;
        return Point4d_1.Point4d.createRealDerivativeRay3dDefault000(xyzw[0], xyzw[1], xyzw[2], xyzw[3], dxyzw[0], dxyzw[1], dxyzw[2], dxyzw[3], result);
    }
    /** Evaluate at a positioni given by a knot value. */
    knotToPoint(u, result) {
        this._bcurve.evaluateBuffersAtKnot(u);
        const xyzw = this._bcurve.poleBuffer;
        return Point4d_1.Point4d.createRealPoint3dDefault000(xyzw[0], xyzw[1], xyzw[2], xyzw[3], result);
    }
    /** Evaluate at a position given by a knot value.  */
    knotToPointAndDerivative(u, result) {
        this._bcurve.evaluateBuffersAtKnot(u, 1);
        const xyzw = this._bcurve.poleBuffer;
        const dxyzw = this._bcurve.poleBuffer1;
        return Point4d_1.Point4d.createRealDerivativeRay3dDefault000(xyzw[0], xyzw[1], xyzw[2], xyzw[3], dxyzw[0], dxyzw[1], dxyzw[2], dxyzw[3], result);
    }
    /** Evaluate at a position given by a knot value.  Return point with 2 derivatives. */
    knotToPointAnd2Derivatives(u, result) {
        this._bcurve.evaluateBuffersAtKnot(u, 2);
        const xyzw = this._bcurve.poleBuffer;
        const dxyzw = this._bcurve.poleBuffer1;
        const ddxyzw = this._bcurve.poleBuffer2;
        return Point4d_1.Point4d.createRealDerivativePlane3dByOriginAndVectorsDefault000(xyzw[0], xyzw[1], xyzw[2], xyzw[3], dxyzw[0], dxyzw[1], dxyzw[2], dxyzw[3], ddxyzw[0], ddxyzw[1], ddxyzw[2], ddxyzw[3], result);
    }
    isAlmostEqual(other) {
        if (other instanceof BSplineCurve3dH) {
            return this._bcurve.knots.isAlmostEqual(other._bcurve.knots)
                && PointHelpers_1.Point4dArray.isAlmostEqual(this._bcurve.packedData, other._bcurve.packedData);
        }
        return false;
    }
    isInPlane(plane) {
        return PointHelpers_1.Point4dArray.isCloseToPlane(this._bcurve.packedData, plane);
    }
    quickLength() { return PointHelpers_1.Point3dArray.sumEdgeLengths(this._bcurve.packedData); }
    emitStrokableParts(handler, options) {
        const needBeziers = handler.announceBezierCurve;
        const workBezier = this.initializeWorkBezier();
        const numSpan = this.numSpan;
        let numStrokes;
        for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {
            const bezier = this.getSaturatedBezierSpan3dOr3dH(spanIndex, false, workBezier);
            if (bezier) {
                numStrokes = bezier.strokeCount(options);
                if (needBeziers) {
                    handler.announceBezierCurve(bezier, numStrokes, this, spanIndex, this._bcurve.knots.spanFractionToFraction(spanIndex, 0.0), this._bcurve.knots.spanFractionToFraction(spanIndex, 1.0));
                }
                else {
                    handler.announceIntervalForUniformStepStrokes(this, numStrokes, this._bcurve.knots.spanFractionToFraction(spanIndex, 0.0), this._bcurve.knots.spanFractionToFraction(spanIndex, 1.0));
                }
            }
        }
    }
    emitStrokes(dest, options) {
        const workBezier = this.initializeWorkBezier();
        const numSpan = this.numSpan;
        for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {
            const bezier = this.getSaturatedBezierSpan3dH(spanIndex, workBezier);
            if (bezier)
                bezier.emitStrokes(dest, options);
        }
    }
    /**
     * return true if the spline is (a) unclamped with (degree-1) matching knot intervals,
     * (b) (degree-1) wrapped points,
     * (c) marked wrappable from construction time.
     */
    get isClosable() {
        if (!this._bcurve.knots.wrappable)
            return false;
        const degree = this.degree;
        const leftKnotIndex = this._bcurve.knots.leftKnotIndex;
        const rightKnotIndex = this._bcurve.knots.rightKnotIndex;
        const period = this._bcurve.knots.rightKnot - this._bcurve.knots.leftKnot;
        const indexDelta = rightKnotIndex - leftKnotIndex;
        for (let k0 = leftKnotIndex - degree + 1; k0 < leftKnotIndex + degree - 1; k0++) {
            const k1 = k0 + indexDelta;
            if (!Geometry_1.Geometry.isSameCoordinate(this._bcurve.knots.knots[k0] + period, this._bcurve.knots.knots[k1]))
                return false;
        }
        const poleIndexDelta = this.numPoles - this.degree;
        for (let p0 = 0; p0 < degree; p0++) {
            const p1 = p0 + poleIndexDelta;
            if (!Geometry_1.Geometry.isSamePoint3d(this.getPolePoint3d(p0), this.getPolePoint3d(p1)))
                return false;
        }
        return true;
    }
    /**
     * Return a CurvePrimitive (which is a BezierCurve3dH) for a specified span of this curve.
     * @param spanIndex
     * @param result optional reusable curve.  This will only be reused if it is a BezierCurve3d with matching order.
     */
    getSaturatedBezierSpan3dH(spanIndex, result) {
        if (spanIndex < 0 || spanIndex >= this.numSpan)
            return undefined;
        const order = this.order;
        if (result === undefined || !(result instanceof BezierCurve3dH_1.BezierCurve3dH) || result.order !== order)
            result = BezierCurve3dH_1.BezierCurve3dH.createOrder(order);
        const bezier = result;
        bezier.loadSpan4dPoles(this._bcurve.packedData, spanIndex);
        bezier.saturateInPlace(this._bcurve.knots, spanIndex);
        return result;
    }
    /**
     * Return a BezierCurveBase for this curve.  Because BSplineCurve3dH is homogeneous, the returned BezierCurveBase is always homogeneous.
     * @param spanIndex
     * @param result optional reusable curve.  This will only be reused if it is a BezierCurve3dH with matching order.
     */
    getSaturatedBezierSpan3dOr3dH(spanIndex, _prefer3dH, result) {
        return this.getSaturatedBezierSpan3dH(spanIndex, result);
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleBSplineCurve3dH(this);
    }
    extendRange(rangeToExtend, transform) {
        const buffer = this._bcurve.packedData;
        const n = buffer.length - 3;
        if (transform) {
            for (let i0 = 0; i0 < n; i0 += 4)
                rangeToExtend.extendTransformedXYZW(transform, buffer[i0], buffer[i0 + 1], buffer[i0 + 2], buffer[i0 + 3]);
        }
        else {
            for (let i0 = 0; i0 < n; i0 += 4)
                rangeToExtend.extendXYZW(buffer[i0], buffer[i0 + 1], buffer[i0 + 2], buffer[i0 + 3]);
        }
    }
}
exports.BSplineCurve3dH = BSplineCurve3dH;


/***/ }),

/***/ "./lib/bspline/BSplineSurface.js":
/*!***************************************!*\
  !*** ./lib/bspline/BSplineSurface.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Bspline */
// import { Point2d } from "./Geometry2d";
/* tslint:disable:variable-name jsdoc-format no-empty no-console*/
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const Matrix3d_1 = __webpack_require__(/*! ../geometry3d/Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const PointHelpers_1 = __webpack_require__(/*! ../geometry3d/PointHelpers */ "./lib/geometry3d/PointHelpers.js");
const Plane3dByOriginAndVectors_1 = __webpack_require__(/*! ../geometry3d/Plane3dByOriginAndVectors */ "./lib/geometry3d/Plane3dByOriginAndVectors.js");
const KnotVector_1 = __webpack_require__(/*! ./KnotVector */ "./lib/bspline/KnotVector.js");
const Point4d_1 = __webpack_require__(/*! ../geometry4d/Point4d */ "./lib/geometry4d/Point4d.js");
const GeometryQuery_1 = __webpack_require__(/*! ../curve/GeometryQuery */ "./lib/curve/GeometryQuery.js");
/**
 * UVSelect is an integer indicating uDirection (0) or vDirection (1) in a bspline surface parameterization.
 */
var UVSelect;
(function (UVSelect) {
    UVSelect[UVSelect["uDirection"] = 0] = "uDirection";
    UVSelect[UVSelect["VDirection"] = 1] = "VDirection";
})(UVSelect = exports.UVSelect || (exports.UVSelect = {}));
var WeightStyle;
(function (WeightStyle) {
    /** There are no weights. */
    WeightStyle[WeightStyle["UnWeighted"] = 0] = "UnWeighted";
    /**
     * * Data is weighted
     * * point with normalized coordinate `[x,y,z]` and weight `w` has weights already multiplied in as `[x*w,y*w,z*w,w]`
     * */
    WeightStyle[WeightStyle["WeightsAlreadyAppliedToCoordinates"] = 1] = "WeightsAlreadyAppliedToCoordinates";
    /**
     * * Data is weighted
     * * point with normalized coordinate `[x,y,z]` and weight `w` has is `[x,y,z,w]`
     * */
    WeightStyle[WeightStyle["WeightsSeparateFromCoordinates"] = 2] = "WeightsSeparateFromCoordinates";
})(WeightStyle = exports.WeightStyle || (exports.WeightStyle = {}));
/** Bspline knots and poles for 2d-to-Nd.
 * * This abstract class in not independently instantiable -- GeometryQuery methods must be implemented by derived classes.
 */
class BSpline2dNd extends GeometryQuery_1.GeometryQuery {
    degreeUV(select) { return this.knots[select].degree; }
    orderUV(select) { return this.knots[select].degree + 1; }
    numSpanUV(select) { return this._numPoles[select] - this.knots[select].degree; }
    numPolesTotal() { return this.coffs.length / this.poleDimension; }
    numPolesUV(select) { return this._numPoles[select]; }
    poleStepUV(select) { return select === 0 ? 1 : this._numPoles[0]; }
    static validOrderAndPoleCounts(orderU, numPolesU, orderV, numPolesV, numUV) {
        if (orderU < 2 || numPolesU < orderU)
            return false;
        if (orderV < 2 || numPolesV < orderV)
            return false;
        if (numPolesU * numPolesV !== numUV)
            return false;
        return true;
    }
    getPoint3dPole(i, j, result) {
        return Point3dVector3d_1.Point3d.createFromPacked(this.coffs, i + j * this._numPoles[0], result);
    }
    // Get a pole (from i,j indices) as Point3d, assuming data is stored xyzw
    getPoint3dPoleXYZW(i, j, result) {
        return Point3dVector3d_1.Point3d.createFromPackedXYZW(this.coffs, i + j * this._numPoles[0], result);
    }
    /**
     * @param value numeric value to convert to strict 0 or 1.
     * @returns Return 0 for 0 input, 1 for any nonzero input.
     */
    numberToUVSelect(value) { return value === 0 ? 0 : 1; }
    /** extend a range, treating each block as simple XYZ */
    extendRangeXYZ(rangeToExtend, transform) {
        const buffer = this.coffs;
        const pd = this.poleDimension;
        const n = buffer.length + 1 - pd;
        if (transform) {
            for (let i0 = 0; i0 < n; i0 += pd)
                rangeToExtend.extendTransformedXYZ(transform, buffer[i0], buffer[i0 + 1], buffer[i0 + 2]);
        }
        else {
            for (let i0 = 0; i0 < n; i0 += pd)
                rangeToExtend.extendXYZ(buffer[i0], buffer[i0 + 1], buffer[i0 + 2]);
        }
    }
    /** extend a range, treating each block as homogeneous xyzw, with weight at offset 3 */
    extendRangeXYZH(rangeToExtend, transform) {
        const buffer = this.coffs;
        const pd = this.poleDimension;
        const n = buffer.length + 1 - pd;
        let w = 0;
        let divW = 0;
        if (transform) {
            for (let i0 = 0; i0 < n; i0 += pd) {
                w = buffer[i0 + 3];
                if (w !== 0.0) {
                    divW = 1.0 / w;
                    rangeToExtend.extendTransformedXYZ(transform, buffer[i0] * divW, buffer[i0 + 1] * divW, buffer[i0 + 2] * divW);
                }
            }
        }
        else {
            for (let i0 = 0; i0 < n; i0 += pd) {
                w = buffer[i0 + 3];
                if (w !== 0.0) {
                    divW = 1.0 / w;
                    rangeToExtend.extendXYZ(buffer[i0] * divW, buffer[i0 + 1] * divW, buffer[i0 + 2] * divW);
                }
            }
        }
    }
    /**
       * evaluate the surface at u and v fractions. Return a (squared, right handed) coordinate frame at that point on the surface.
       * @param fractionU u parameter
       * @param fractionV v parameter
       * @param result undefined if surface derivatives are parallel (or either alone is zero)
       */
    fractionToRigidFrame(fractionU, fractionV, result) {
        const skewVectors = this.fractionToPointAndDerivatives(fractionU, fractionV);
        if (!skewVectors)
            return undefined;
        const axes = Matrix3d_1.Matrix3d.createColumnsInAxisOrder(0 /* XYZ */, skewVectors.vectorU, skewVectors.vectorV, undefined);
        const axes1 = Matrix3d_1.Matrix3d.createRigidFromMatrix3d(axes, 0 /* XYZ */, axes);
        if (axes1)
            result = Transform_1.Transform.createOriginAndMatrix(skewVectors.origin, axes1, result);
        return result;
    }
    /**
     * initialize arrays for given spline dimensions.
     */
    constructor(numPolesU, numPolesV, poleLength, knotsU, knotsV) {
        super();
        const orderU = knotsU.degree + 1;
        const orderV = knotsV.degree + 1;
        this.knots = [knotsU, knotsV];
        this.coffs = new Float64Array(numPolesU * numPolesV * poleLength);
        this.poleDimension = poleLength;
        this._basisBufferUV = [new Float64Array(orderU), new Float64Array(orderV)];
        this._basisBuffer1UV = [new Float64Array(orderU), new Float64Array(orderV)];
        this._numPoles = [numPolesU, numPolesV];
        this._poleBuffer = new Float64Array(poleLength);
        this._poleBuffer1UV = [new Float64Array(poleLength), new Float64Array(poleLength)];
    }
    /**
     * Map a position, specified as (uv direction, bezier span, fraction within the bezier), to an overal knot value.
     * @param select selector indicating U or V direction.
     * @param span index of bezier span
     * @param localFraction fractional coordinate within the bezier span
     */
    spanFractionToKnot(select, span, localFraction) {
        return this.knots[select].spanFractionToKnot(span, localFraction);
    }
    // ASSUME f is sized for {order} basis funtions !!!
    spanFractionsToBasisFunctions(select, spanIndex, spanFraction, f, df) {
        spanIndex = Geometry_1.Geometry.clampToStartEnd(spanIndex, 0, this.numSpanUV(select));
        const knotIndex0 = spanIndex + this.degreeUV(select) - 1;
        const globalKnot = this.knots[select].baseKnotFractionToKnot(knotIndex0, spanFraction);
        return df ?
            this.knots[select].evaluateBasisFunctions1(knotIndex0, globalKnot, f, df) :
            this.knots[select].evaluateBasisFunctions(knotIndex0, globalKnot, f);
    }
    /** sum poles by the weights in the basisBuffer, using poles for given span */
    sumPoleBufferForSpan(spanIndexU, spanIndexV) {
        const poleBuffer = this._poleBuffer;
        const coffs = this.coffs;
        poleBuffer.fill(0);
        const m = this.poleDimension;
        const stepV = this.poleDimension * this._numPoles[0];
        let kU = m * spanIndexU + spanIndexV * stepV;
        let g = 0;
        for (const fV of this._basisBufferUV[1]) {
            let k = kU;
            for (const fU of this._basisBufferUV[0]) {
                g = fU * fV;
                for (let j = 0; j < m; j++) {
                    poleBuffer[j] += g * coffs[k++];
                }
            }
            kU += stepV;
        }
    }
    /** sum derivatives by the weights in the basisBuffer, using poles for given span */
    sumpoleBufferDerivativesForSpan(spanIndexU, spanIndexV) {
        const poleBuffer1U = this._poleBuffer1UV[0];
        const poleBuffer1V = this._poleBuffer1UV[1];
        poleBuffer1U.fill(0);
        poleBuffer1V.fill(0);
        const m = this.poleDimension;
        const stepV = this.poleDimension * this._numPoles[0];
        let kU = m * spanIndexU + spanIndexV * stepV;
        // U partial derivatives ...
        let g = 0;
        for (const fV of this._basisBufferUV[1]) {
            let k = kU;
            for (const fU of this._basisBuffer1UV[0]) {
                g = fU * fV;
                for (let j = 0; j < m; j++) {
                    poleBuffer1U[j] += g * this.coffs[k++];
                }
            }
            kU += stepV;
        }
        // V partial derivatives ...
        kU = m * spanIndexU + spanIndexV * stepV;
        for (const fV of this._basisBuffer1UV[1]) {
            let k = kU;
            for (const fU of this._basisBufferUV[0]) {
                g = fU * fV;
                for (let j = 0; j < m; j++) {
                    poleBuffer1V[j] += g * this.coffs[k++];
                }
            }
            kU += stepV;
        }
    }
    evaluateBuffersAtKnot(u, v, numDerivative = 0) {
        const knotIndex0U = this.knots[0].knotToLeftKnotIndex(u);
        const knotIndex0V = this.knots[1].knotToLeftKnotIndex(v);
        const poleIndex0U = knotIndex0U - this.degreeUV(0) + 1;
        const poleIndex0V = knotIndex0V - this.degreeUV(1) + 1;
        if (numDerivative < 1) {
            this.knots[0].evaluateBasisFunctions(knotIndex0U, u, this._basisBufferUV[0]);
            this.knots[1].evaluateBasisFunctions(knotIndex0V, v, this._basisBufferUV[1]);
            this.sumPoleBufferForSpan(poleIndex0U, poleIndex0V);
        }
        else {
            this.knots[0].evaluateBasisFunctions1(knotIndex0U, u, this._basisBufferUV[0], this._basisBuffer1UV[0]);
            this.knots[1].evaluateBasisFunctions1(knotIndex0V, v, this._basisBufferUV[1], this._basisBuffer1UV[1]);
            this.sumPoleBufferForSpan(poleIndex0U, poleIndex0V);
            this.sumpoleBufferDerivativesForSpan(poleIndex0U, poleIndex0V);
        }
    }
    // Swap numSwap entries in coffs, starting at i0 and i1 (absolute indices -- not blocks)
    swapBlocks(i0, i1, numSwap) {
        let a;
        for (let i = 0; i < numSwap; i++) {
            a = this.coffs[i0 + i];
            this.coffs[i0 + i] = this.coffs[i1 + i];
            this.coffs[i1 + i] = a;
        }
    }
    /**
     * Reverse the parameter direction for either u or v.
     * @param select direction to reverse -- 0 for u, 1 for v.
     */
    reverseInPlace(select) {
        const m = this.poleDimension;
        const numU = this.numPolesUV(0);
        const numV = this.numPolesUV(1);
        if (select === 0) {
            // reverse within rows.
            for (let j = 0; j < numV; j++) {
                const rowStart = j * numU * m;
                for (let i0 = 0, i1 = numU - 1; i0 < i1; i0++, i1--) {
                    this.swapBlocks(rowStart + i0 * m, rowStart + i1 * m, m);
                }
            }
        }
        else {
            // swap full rows ..
            const numPerRow = m * numU;
            for (let i0 = 0, i1 = (numV - 1) * numPerRow; i0 < i1; i0 += numPerRow, i1 -= numPerRow) {
                this.swapBlocks(i0, i1, numPerRow);
            }
        }
        this.knots[select].reflectKnots();
    }
    /**
     * Set the flag indicating the bspline might be suitable for having wrapped "closed" interpretation.
     */
    setWrappable(select, value) {
        this.knots[select].wrappable = value;
    }
    /**
     * Test if `degree` leading and trailing (one of U or V) blocks match, as if the data is an unwrapped closed spline in the slected direction.
     * @param select select U or V direction
     * @returns true if coordinates matched.
     */
    isClosable(select) {
        if (!this.knots[select].wrappable)
            return false;
        if (!this.knots[select].testClosable())
            return false;
        const numU = this.numPolesUV(0);
        const numV = this.numPolesUV(1);
        const blockSize = this.poleDimension;
        const rowToRowStep = numU * blockSize;
        const degreeU = this.degreeUV(0);
        const degreeV = this.degreeUV(1);
        const data = this.coffs;
        if (select === 0) {
            const numTest = blockSize * degreeU; // degreeU contiguous poles.
            for (let row = 0; row < numV; row++) {
                const i0 = row * rowToRowStep;
                const i1 = i0 + rowToRowStep - numTest;
                for (let i = 0; i < numTest; i++) {
                    if (!Geometry_1.Geometry.isSameCoordinate(data[i0 + i], data[i1 + i]))
                        return false;
                }
            }
        }
        else {
            // Test the entire multi-row contiguous block in one loop . ..
            const numTest = degreeV * rowToRowStep;
            const i1 = blockSize * numU * numV - numTest;
            for (let i = 0; i < numTest; i++) {
                if (!Geometry_1.Geometry.isSameCoordinate(data[i], data[i1 + i]))
                    return false;
            }
        }
        return true;
    }
}
exports.BSpline2dNd = BSpline2dNd;
/**  BSplineSurface3d is a parametric surface in xyz space.
 * * This (BSplineSurface3d) is an unweighted surface.   Use the separate class BSplineSurface3dH for a weighted surface.
 *
 * The various static "create" methods have subtle differences in how grid sizes are conveyed:
 * | Method | control point array | counts |
 * | create | flat array of [x,y,z] | arguments numPolesU, numPolesV |
 * | createGrid | array of array of [x,y,z ] | There are no `numPolesU` or `numPolesV` args. The counts are conveyed by the deep arrays |
 */
class BSplineSurface3d extends BSpline2dNd {
    isSameGeometryClass(other) { return other instanceof BSplineSurface3d; }
    tryTransformInPlace(transform) { PointHelpers_1.Point3dArray.multiplyInPlace(transform, this.coffs); return true; }
    getPole(i, j, result) {
        return this.getPoint3dPole(i, j, result);
    }
    constructor(numPolesU, numPolesV, knotsU, knotsV) {
        super(numPolesU, numPolesV, 3, knotsU, knotsV);
    }
    /**
     * Return control points json arrays.
     * * if `flatArray===true`, each point appears as an array [x,y,z] in row-major order of a containing array.
     * * if `flatArray===false` each row of points is an an array of [x,y,z] in an array.  Each of these row arrays is in the result array.
     * @param flatArray if true, retur
     */
    getPointArray(flatArray = true) {
        if (flatArray)
            return PointHelpers_1.Point3dArray.unpackNumbersToNestedArrays(this.coffs, 3);
        return PointHelpers_1.Point3dArray.unpackNumbersToNestedArraysIJK(this.coffs, 3, this.numPolesUV(0));
    }
    /**
     * Return control points json arrays.
     * * Each row of points is an an array.
     * * Within the array for each row, each point is an array [x,y,z]
     */
    getPointGridJSON() {
        const result = {
            points: PointHelpers_1.Point3dArray.unpackNumbersToNestedArraysIJK(this.coffs, 3, this.numPolesUV(0)),
            weighStyle: WeightStyle.UnWeighted,
            numCartesianDimensions: 3,
        };
        return result;
    }
    /** Return a simple array of the control points coordinates */
    copyPointsFloat64Array() { return this.coffs.slice(); }
    /**
     * return a simple array form of the knots.  optionally replicate the first and last
     * in classic over-clamped manner
     */
    copyKnots(select, includeExtraEndKnot) { return this.knots[select].copyKnots(includeExtraEndKnot); }
    /** Create a bspline surface.
     * * This `create` variant takes control points in a "flattened" array, with
     *  points from succeeding U rows packed together in one array.  Use `createGrid` if the points are in
     *  a row-by-row grid structure
     * * knotArrayU and knotArrayV are optional -- uniform knots are implied if they are omited (undefined).
     * *  When knots are given, two knot count conditions are recognized:
     * * + If poleArray.length + order == knotArray.length, the first and last are assumed to be the
     *      extraneous knots of classic clamping.
     * * + If poleArray.length + order == knotArray.length + 2, the knots are in modern form that does not have
     *      the classic unused first and last knot.
     * @param controlPointArray Array of points, ordered along the U direction.
     * @param numPoleU number of poles in each row in the U direction.
     * @param orderU order for the U direction polynomial (`order` is one more than the `degree`.  "cubic" polynomial is order 4.)
     * @param KnotArrayU knots for the V direction.  See note above about knot counts.
     * @param numPoleV number of poles in each row in the U direction.
     * @param orderV order for the V direction polynomial (`order` is one more than the `degree`.  "cubic" polynomial is order 4.)
     * @param KnotArrayV knots for the V direction.  See note above about knot counts.
     */
    static create(controlPointArray, numPolesU, orderU, knotArrayU, numPolesV, orderV, knotArrayV) {
        let numPoles = controlPointArray.length;
        if (controlPointArray instanceof Float64Array)
            numPoles /= 3;
        if (!this.validOrderAndPoleCounts(orderU, numPolesU, orderV, numPolesV, numPoles))
            return undefined;
        // shift knots-of-interest limits for overclampled case ...
        const numKnotsU = knotArrayU ? knotArrayU.length : numPolesU + orderU - 2;
        const numKnotsV = knotArrayV ? knotArrayV.length : numPolesV + orderV - 2;
        const skipFirstAndLastU = (numPolesU + orderU === numKnotsU);
        const skipFirstAndLastV = (numPolesV + orderV === numKnotsV);
        const knotsU = knotArrayU ?
            KnotVector_1.KnotVector.create(knotArrayU, orderU - 1, skipFirstAndLastU) :
            KnotVector_1.KnotVector.createUniformClamped(numPolesU, orderU - 1, 0.0, 1.0);
        const knotsV = knotArrayV ?
            KnotVector_1.KnotVector.create(knotArrayV, orderV - 1, skipFirstAndLastV) :
            KnotVector_1.KnotVector.createUniformClamped(numPolesV, orderV - 1, 0.0, 1.0);
        const surface = new BSplineSurface3d(numPolesU, numPolesV, knotsU, knotsV);
        if (controlPointArray instanceof Float64Array) {
            let i = 0;
            for (const coordinate of controlPointArray) {
                surface.coffs[i++] = coordinate;
            }
        }
        else {
            let i = 0;
            for (const p of controlPointArray) {
                surface.coffs[i++] = p.x;
                surface.coffs[i++] = p.y;
                surface.coffs[i++] = p.z;
            }
        }
        return surface;
    }
    /** Create a bspline surface.
     * * This `create` variant takes control points in a "grid" array, with the points from
     * each grid row `[rowIndex]` being an independent array `points[rowIndex][indexAlongRow][x,y,z]`
     * * knotArrayU and knotArrayV are optional -- uniform knots are implied if they are omited (undefined).
     * *  When knots are given, two knot count conditions are recognized:
     * * + If poleArray.length + order == knotArray.length, the first and last are assumed to be the
     *      extraneous knots of classic clamping.
     * * + If poleArray.length + order == knotArray.length + 2, the knots are in modern form that does not have
     *      the classic unused first and last knot.
     * @param controlPointArray Array of points, ordered along the U direction.
     * @param numPoleU number of poles in each row in the U direction.
     * @param orderU order for the U direction polynomial (`order` is one more than the `degree`.  "cubic" polynomial is order 4.)
     * @param KnotArrayU knots for the V direction.  See note above about knot counts.
     * @param numPoleV number of poles in each row in the U direction.
     * @param orderV order for the V direction polynomial (`order` is one more than the `degree`.  "cubic" polynomial is order 4.)
     * @param KnotArrayV knots for the V direction.  See note above about knot counts.
     */
    static createGrid(points, orderU, knotArrayU, orderV, knotArrayV) {
        const numPolesV = points.length;
        const numPolesU = points[0].length;
        const numPoles = numPolesU * numPolesV;
        // shift knots-of-interest limits for overclampled case ...
        const numKnotsU = knotArrayU ? knotArrayU.length : numPolesU + orderU - 2;
        const numKnotsV = knotArrayV ? knotArrayV.length : numPolesV + orderV - 2;
        const skipFirstAndLastU = (numPolesU + orderU === numKnotsU);
        const skipFirstAndLastV = (numPolesV + orderV === numKnotsV);
        if (!this.validOrderAndPoleCounts(orderU, numPolesU, orderV, numPolesV, numPoles))
            return undefined;
        const knotsU = knotArrayU ?
            KnotVector_1.KnotVector.create(knotArrayU, orderU - 1, skipFirstAndLastU) :
            KnotVector_1.KnotVector.createUniformClamped(numPolesU, orderU - 1, 0.0, 1.0);
        const knotsV = knotArrayV ?
            KnotVector_1.KnotVector.create(knotArrayV, orderV - 1, skipFirstAndLastV) :
            KnotVector_1.KnotVector.createUniformClamped(numPolesU, orderU - 1, 0.0, 1.0);
        const surface = new BSplineSurface3d(numPolesU, numPolesV, knotsU, knotsV);
        let i = 0;
        for (const row of points) {
            for (const xyz of row) {
                surface.coffs[i++] = xyz[0];
                surface.coffs[i++] = xyz[1];
                surface.coffs[i++] = xyz[2];
            }
        }
        return surface;
    }
    /**
     * @returns Return a complete copy of the bspline surface.
     */
    clone() {
        const knotVector1U = this.knots[0].clone();
        const knotVector1V = this.knots[1].clone();
        const surface1 = new BSplineSurface3d(this.numPolesUV(0), this.numPolesUV(1), knotVector1U, knotVector1V);
        surface1.coffs = this.coffs.slice();
        return surface1;
    }
    /**
     * Return a complete copy of the bspline surface, with a transform applied to the control points.
     * @param transform transform to apply to the control points
     */
    cloneTransformed(transform) {
        const surface1 = this.clone();
        surface1.tryTransformInPlace(transform);
        return surface1;
    }
    /** Evaluate at a position given by u and v coordinates in knot space.
     * @param u u value, in knot range.
     * @param v v value in knot range.
   * @returns Return the xyz coordinates on the surface.
     */
    knotToPoint(u, v) {
        this.evaluateBuffersAtKnot(u, v);
        return Point3dVector3d_1.Point3d.createFrom(this._poleBuffer);
    }
    /** Evaluate at a position given by a knot value.  */
    knotToPointAndDerivatives(u, v, result) {
        this.evaluateBuffersAtKnot(u, v, 1);
        return Plane3dByOriginAndVectors_1.Plane3dByOriginAndVectors.createOriginAndVectorsArrays(this._poleBuffer, this._poleBuffer1UV[0], this._poleBuffer1UV[1], result);
    }
    /** Evalute at a position given by fractional coordinte in each direction.
       * @param fractionU u coordinate, as a fraction of the knot range.
       * @param fractionV v coordinate, as a fraction of the knot range.
     * @returns Return the xyz coordinates on the surface.
     */
    fractionToPoint(fractionU, fractionV) {
        return this.knotToPoint(this.knots[0].fractionToKnot(fractionU), this.knots[1].fractionToKnot(fractionV));
    }
    /**
     * evaluate the surface at u and v fractions.
     * @returns plane with origin at the surface point, direction vectors are derivatives in the u and v directions.
     * @param fractionU u coordinate, as a fraction of the knot range.
     * @param fractionV v coordinate, as a fraction of the knot range.
     * @param result optional pre-allocated object for return values.
     * @returns Returns point and derivative directions.
     */
    fractionToPointAndDerivatives(fractionU, fractionV, result) {
        const knotU = this.knots[0].fractionToKnot(fractionU);
        const knotV = this.knots[1].fractionToKnot(fractionV);
        return this.knotToPointAndDerivatives(knotU, knotV, result);
    }
    isAlmostEqual(other) {
        if (other instanceof BSplineSurface3d) {
            return this.knots[0].isAlmostEqual(other.knots[0])
                && this.knots[1].isAlmostEqual(other.knots[1])
                && PointHelpers_1.Point3dArray.isAlmostEqual(this.coffs, other.coffs);
        }
        return false;
    }
    isInPlane(plane) {
        return PointHelpers_1.Point3dArray.isCloseToPlane(this.coffs, plane);
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleBSplineSurface3d(this);
    }
    extendRange(rangeToExtend, transform) {
        this.extendRangeXYZ(rangeToExtend, transform);
    }
}
exports.BSplineSurface3d = BSplineSurface3d;
/**  BsplinceCurve in xyzw homogeneous space */
class BSplineSurface3dH extends BSpline2dNd {
    isSameGeometryClass(other) { return other instanceof BSplineSurface3dH; }
    tryTransformInPlace(transform) {
        PointHelpers_1.Point4dArray.multiplyInPlace(transform, this.coffs);
        return true;
    }
    getPole(i, j, result) {
        return this.getPoint3dPoleXYZW(i, j, result);
    }
    constructor(numPolesU, numPolesV, knotsU, knotsV) {
        super(numPolesU, numPolesV, 4, knotsU, knotsV);
    }
    /** Return a simple array of the control points. */
    copyPoints4d() { return PointHelpers_1.Point4dArray.unpackToPoint4dArray(this.coffs); }
    /** Return a simple array of the control points. */
    copyPointsAndWeights(points, weights, formatter = Point3dVector3d_1.Point3d.create) {
        PointHelpers_1.Point4dArray.unpackFloat64ArrayToPointsAndWeights(this.coffs, points, weights, formatter);
    }
    /**
     * return a simple array form of the knots.  optionally replicate the first and last
     * in classic over-clamped manner
     */
    copyKnots(select, includeExtraEndKnot) { return this.knots[select].copyKnots(includeExtraEndKnot); }
    /** Create a weighted bspline surface, with control points and weights each organized as flattened array of points continuing from one U row to the next.
     * * This `create` variant takes control points in a "flattened" array, with
     *  points from succeeding U rows packed together in one array.  Use `createGrid` if the points are in
     *  a deeper grid array structure.
     * * knotArrayU and knotArrayV are optional -- uniform knots are implied if they are omited (undefined).
     * *  When knots are given, two knot count conditions are recognized:
     * * * If poleArray.length + order == knotArray.length, the first and last are assumed to be the
     *      extraneous knots of classic clamping.
     * * * If poleArray.length + order == knotArray.length + 2, the knots are in modern form that does not have
     *      the classic unused first and last knot.
     * @param controlPointArray Array of points, ordered along the U direction.
     * @param weightArray array of weights, ordered along the U direction.
     * @param numPoleU number of poles in each row in the U direction.
     * @param orderU order for the U direction polynomial (`order` is one more than the `degree`.  "cubic" polynomial is order 4.)
     * @param KnotArrayU optional knots for the V direction.  See note above about knot counts.
     * @param numPoleV number of poles in each row in the U direction.
     * @param orderV order for the V direction polynomial (`order` is one more than the `degree`.  "cubic" polynomial is order 4.)
     * @param KnotArrayV optional knots for the V direction.  See note above about knot counts.
     */
    static create(controlPointArray, weightArray, numPolesU, orderU, knotArrayU, numPolesV, orderV, knotArrayV) {
        const numPoles = controlPointArray.length;
        if (numPolesU * numPolesV !== numPoles)
            return undefined;
        if (!this.validOrderAndPoleCounts(orderU, numPolesU, orderV, numPolesV, numPoles))
            return undefined;
        const numKnotsU = knotArrayU ? knotArrayU.length : numPolesU + orderU - 2;
        const numKnotsV = knotArrayV ? knotArrayV.length : numPolesV + orderV - 2;
        const skipFirstAndLastU = (numPolesU + orderU === numKnotsU);
        const skipFirstAndLastV = (numPolesV + orderV === numKnotsV);
        const knotsU = knotArrayU ?
            KnotVector_1.KnotVector.create(knotArrayU, orderU - 1, skipFirstAndLastU) :
            KnotVector_1.KnotVector.createUniformClamped(numPolesU, orderU - 1, 0.0, 1.0);
        const knotsV = knotArrayV ?
            KnotVector_1.KnotVector.create(knotArrayV, orderV - 1, skipFirstAndLastV) :
            KnotVector_1.KnotVector.createUniformClamped(numPolesV, orderV - 1, 0.0, 1.0);
        const surface = new BSplineSurface3dH(numPolesU, numPolesV, knotsU, knotsV);
        PointHelpers_1.Point4dArray.packPointsAndWeightsToFloat64Array(controlPointArray, weightArray, surface.coffs);
        return surface;
    }
    /** Create a bspline with given knots.
     *
     *   Two count conditions are recognized in each direction:
     *
     * ** If poleArray.length + order == knotArray.length, the first and last are assumed to be the
     *      extraneous knots of classic clamping.
     * ** If poleArray.length + order == knotArray.length + 2, the knots are in modern form.
     *
     */
    static createGrid(xyzwGrid, weightStyle, orderU, knotArrayU, orderV, knotArrayV) {
        const numPolesV = xyzwGrid.length;
        const numPolesU = xyzwGrid[0].length;
        const numPoles = numPolesU * numPolesV;
        if (!this.validOrderAndPoleCounts(orderU, numPolesU, orderV, numPolesV, numPoles))
            return undefined;
        // const numPoles = numPolesU * numPolesV;
        // shift knots-of-interest limits for overclampled case ...
        const numKnotsU = knotArrayU.length;
        const numKnotsV = knotArrayV.length;
        const skipFirstAndLastU = (numPolesU + orderU === numKnotsU);
        const skipFirstAndLastV = (numPolesV + orderV === numKnotsV);
        const knotsU = KnotVector_1.KnotVector.create(knotArrayU, orderU - 1, skipFirstAndLastU);
        const knotsV = KnotVector_1.KnotVector.create(knotArrayV, orderV - 1, skipFirstAndLastV);
        const surface = new BSplineSurface3dH(numPolesU, numPolesV, knotsU, knotsV);
        if (weightStyle === WeightStyle.WeightsSeparateFromCoordinates) {
            let i = 0;
            for (const row of xyzwGrid) {
                for (const point of row) {
                    const w = point[3];
                    surface.coffs[i++] = point[0] * w;
                    surface.coffs[i++] = point[1] * w;
                    surface.coffs[i++] = point[2] * w;
                    surface.coffs[i++] = point[3];
                }
            }
        }
        else {
            // implicit WeightStyle.WeightsAlreadyAppliedToCoordinates
            let i = 0;
            for (const row of xyzwGrid) {
                for (const point of row) {
                    surface.coffs[i++] = point[0];
                    surface.coffs[i++] = point[1];
                    surface.coffs[i++] = point[2];
                    surface.coffs[i++] = point[3];
                }
            }
        }
        return surface;
    }
    clone() {
        const knotVector1U = this.knots[0].clone();
        const knotVector1V = this.knots[1].clone();
        const surface1 = new BSplineSurface3dH(this.numPolesUV(0), this.numPolesUV(1), knotVector1U, knotVector1V);
        surface1.coffs = this.coffs.slice();
        return surface1;
    }
    cloneTransformed(transform) {
        const surface1 = this.clone();
        surface1.tryTransformInPlace(transform);
        return surface1;
    }
    /**
      * Return control points json arrays.
      * * Each row of points is an an array.
      * * Within the array for each row, each point is an array [wx,wy,wz,w].
      */
    getPointGridJSON() {
        const result = {
            points: PointHelpers_1.Point3dArray.unpackNumbersToNestedArraysIJK(this.coffs, 4, this.numPolesUV(0)),
            numCartesianDimensions: 3,
            weightStyle: WeightStyle.WeightsAlreadyAppliedToCoordinates,
        };
        return result;
    }
    /** Evaluate at a position given by a knot value.  */
    knotToPoint4d(u, v) {
        this.evaluateBuffersAtKnot(u, v);
        return Point4d_1.Point4d.createFromPackedXYZW(this._poleBuffer, 0);
    }
    /** Evaluate at a position given by a knot value.  */
    knotToPointAndDerivatives(u, v, result) {
        this.evaluateBuffersAtKnot(u, v, 1);
        return Plane3dByOriginAndVectors_1.Plane3dByOriginAndVectors.createOriginAndVectorsWeightedArrays(this._poleBuffer, this._poleBuffer1UV[0], this._poleBuffer1UV[1], result);
    }
    fractionToPoint4d(fractionU, fractionV) {
        return this.knotToPoint4d(this.knots[0].fractionToKnot(fractionU), this.knots[1].fractionToKnot(fractionV));
    }
    /**
     * * evaluate the surface and return the cartesian (weight = 1) point.
     * * if the surface XYZW point has weight0, returns point3d at 000.
     * @param fractionU u direction fraction
     * @param fractionV v direction fraction
     * @param result optional result
     */
    fractionToPoint(fractionU, fractionV, result) {
        const point4d = this.knotToPoint4d(this.knots[0].fractionToKnot(fractionU), this.knots[1].fractionToKnot(fractionV));
        return point4d.realPointDefault000(result);
    }
    /**
   * * evaluate the surface and return the cartesian (weight = 1) point.
   * * if the surface XYZW point has weight0, returns point3d at 000.
   * @param knotU u direction knot
   * @param knotV v direction knot
   * @param result optional result
   */
    knotToPoint(knotU, knotV, result) {
        const point4d = this.knotToPoint4d(knotU, knotV);
        return point4d.realPointDefault000(result);
    }
    /**
     * evaluate the surface at u and v fractions.
     * @returns plane with origin at the surface point, direction vectors are derivatives in the u and v directions.
     * @param fractionU u coordinate, as a fraction of the knot range.
     * @param fractionV v coordinate, as a fraction of the knot range.
     * @param result optional pre-allocated object for return values.
     * @returns Returns point and derivative directions.
     */
    fractionToPointAndDerivatives(fractionU, fractionV, result) {
        const knotU = this.knots[0].fractionToKnot(fractionU);
        const knotV = this.knots[1].fractionToKnot(fractionV);
        return this.knotToPointAndDerivatives(knotU, knotV, result);
    }
    isAlmostEqual(other) {
        if (other instanceof BSplineSurface3dH) {
            return this.knots[0].isAlmostEqual(other.knots[0])
                && this.knots[1].isAlmostEqual(other.knots[1])
                && PointHelpers_1.Point4dArray.isAlmostEqual(this.coffs, other.coffs);
        }
        return false;
    }
    isInPlane(plane) {
        return PointHelpers_1.Point4dArray.isCloseToPlane(this.coffs, plane);
    }
    /**
     * Pass `this` (strongly typed) to `handler.handleBsplineSurface3dH(this)`.
     * @param handler double dispatch handler.
     */
    dispatchToGeometryHandler(handler) {
        return handler.handleBSplineSurface3dH(this);
    }
    /**
     * extend a range to include the (optionally transformed) points of this surface
     * @param rangeToExtend range that is updaatd to include this surface range
     * @param transform transform to apply to the surface points
     */
    extendRange(rangeToExtend, transform) {
        this.extendRangeXYZH(rangeToExtend, transform);
    }
}
exports.BSplineSurface3dH = BSplineSurface3dH;


/***/ }),

/***/ "./lib/bspline/Bezier1dNd.js":
/*!***********************************!*\
  !*** ./lib/bspline/Bezier1dNd.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Segment1d_1 = __webpack_require__(/*! ../geometry3d/Segment1d */ "./lib/geometry3d/Segment1d.js");
const Point4d_1 = __webpack_require__(/*! ../geometry4d/Point4d */ "./lib/geometry4d/Point4d.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const PointHelpers_1 = __webpack_require__(/*! ../geometry3d/PointHelpers */ "./lib/geometry3d/PointHelpers.js");
const BezierPolynomials_1 = __webpack_require__(/*! ../numerics/BezierPolynomials */ "./lib/numerics/BezierPolynomials.js");
/**
 * Implements a multidimensional bezier curve of fixed order.
 * BezierCurve3d implements with blockSize 3.
 * BezierCurve3dH implements with blockSize 4.
 */
class Bezier1dNd {
    // constructor CAPTURES the control points array.
    constructor(blockSize, polygon) {
        this._blockSize = blockSize;
        this._order = Math.floor(polygon.length / blockSize); // This should be an integer!!!
        this._packedData = polygon;
        this._basis = new BezierPolynomials_1.UnivariateBezier(this._order);
    }
    /** return a clone of the data array */
    clonePolygon(result) {
        const n = this._packedData.length;
        if (!result || result.length !== n)
            return this._packedData.slice();
        /** move data into the supplied result */
        for (let i = 0; i < n; i++)
            result[i] = this._packedData[i];
        return result;
    }
    /** Return the bezier order */
    get order() { return this._order; }
    /** return the packed data array.  This is a REFERENCE to the array. */
    get packedData() { return this._packedData; }
    /** Create a Bezier1dNd, using the structure of `data[0]` to determine the beizer order. */
    static create(data) {
        if (data.length < 1)
            return undefined;
        if (data[0] instanceof Point3dVector3d_1.Point3d) {
            const polygon = new Float64Array(data.length * 3);
            let i = 0;
            for (const p of data) {
                polygon[i++] = p.x;
                polygon[i++] = p.y;
                polygon[i++] = p.z;
            }
            return new Bezier1dNd(3, polygon);
        }
        else if (data[0] instanceof Point4d_1.Point4d) {
            const polygon = new Float64Array(data.length * 4);
            let i = 0;
            for (const p of data) {
                polygon[i++] = p.x;
                polygon[i++] = p.y;
                polygon[i++] = p.z;
                polygon[i++] = p.w;
            }
            return new Bezier1dNd(4, polygon);
        }
        else if (data[0] instanceof Point2dVector2d_1.Point2d) {
            const polygon = new Float64Array(data.length * 2);
            let i = 0;
            for (const p of data) {
                polygon[i++] = p.x;
                polygon[i++] = p.y;
            }
            return new Bezier1dNd(2, polygon);
        }
        return undefined;
    }
    /** Return the curve value at bezier fraction `s`
     * @return buffer of length `blockSize`.
     */
    evaluate(s, buffer) {
        return this._basis.sumBasisFunctions(s, this._packedData, this._blockSize, buffer);
    }
    /** Return the curve derivative value at bezier fraction `s`
     * @return buffer of length `blockSize`.
     */
    evaluateDerivative(s, buffer) {
        return this._basis.sumBasisFunctionDerivatives(s, this._packedData, this._blockSize, buffer);
    }
    /** get a single point of the polygon as a simple array.  */
    getPolygonPoint(i, buffer) {
        if (!buffer)
            buffer = new Float64Array(this._blockSize);
        if (i >= 0 && i < this._order) {
            const k0 = this._blockSize * i;
            for (let k = 0; k < this._blockSize; k++)
                buffer[k] = this._packedData[k0 + k];
            return buffer;
        }
        return undefined;
    }
    /** set a single point of the polygon as a simple array.  */
    setPolygonPoint(i, buffer) {
        if (i >= 0 && i < this._order) {
            const k0 = this._blockSize * i;
            for (let k = 0; k < this._blockSize; k++)
                this._packedData[k0 + k] = buffer[k];
        }
    }
    /** Load order * dimension doubles from data[dimension * spanIndex] as poles
     * @param data packed source array.  block size in `data` assumed to match dimension for this.
     * @param spanIndex block index in data.
     */
    loadSpanPoles(data, spanIndex) {
        let k = spanIndex * this._blockSize;
        for (let i = 0; i < this._packedData.length; i++)
            this._packedData[i] = data[k++];
    }
    /** Load order * (dataDimension + 1)  doubles from data[dataDimension * spanIndex] as poles with weight inserted
     * @param data packed array of data.
     * @param dataDimension dimension of data. Must have `dataDimension+1=this.order`
     * @param spanIndex index of first data block to access.
     * @param weight weight to append to each block
     */
    loadSpanPolesWithWeight(data, dataDimension, spanIndex, weight) {
        let destIndex = 0;
        const order = this._order;
        let dataIndex = spanIndex * dataDimension;
        for (let i = 0; i < order; i++) {
            for (let j = 0; j < dataDimension; j++)
                this._packedData[destIndex++] = data[dataIndex++];
            this._packedData[destIndex++] = weight;
        }
    }
    /**  return a json array of arrays with each control point as a lower level array of numbers */
    unpackToJsonArrays() {
        return PointHelpers_1.Point3dArray.unpackNumbersToNestedArrays(this._packedData, this._blockSize);
    }
    /** equality test with usual metric tolerances */
    isAlmostEqual(other) {
        if (other instanceof Bezier1dNd) {
            if (this._blockSize !== other._blockSize)
                return false;
            if (this._order !== other._order)
                return false;
            if (this._packedData.length !== other._packedData.length)
                return false;
            for (let i = 0; i < this._packedData.length; i++) {
                if (!Geometry_1.Geometry.isSameCoordinate(this._packedData[i], other._packedData[i]))
                    return false;
            }
            return true;
        }
        return false;
    }
    /** block-by-block reversal */
    reverseInPlace() {
        const m = this._blockSize;
        const n = this._order;
        let i, j;
        let a;
        for (i = 0, j = (n - 1) * m; i < j; i += m, j -= m) {
            for (let k = 0; k < m; k++) {
                a = this._packedData[i + k];
                this._packedData[i + k] = this._packedData[j + k];
                this._packedData[j + k] = a;
            }
        }
    }
    //
    /**
     * interpolate at `fraction` between poleA and poleB.
     * * Data is left "in place" in poleIndexA
     * @param poleIndexA first pole index
     * @param fraction fractional position
     * @param poleIndexB second pole index
     */
    interpolatePoleInPlace(poleIndexA, fraction, poleIndexB) {
        let i0 = poleIndexA * this._blockSize;
        let i1 = poleIndexB * this._blockSize;
        const data = this._packedData;
        for (let i = 0; i < this._blockSize; i++, i0++, i1++) {
            data[i0] += fraction * (data[i1] - data[i0]);
        }
    }
    /**
     *
     * @param knots
     * @param spanIndex index of span whose (unsaturated) poles are in the bezie.
     * @param optional function for `setInterval (knotA, knotB)` call to announce knot limits.
     */
    saturateInPlace(knots, spanIndex) {
        const degree = knots.degree;
        const kA = spanIndex + degree - 1; // left knot index of the active span
        const kB = kA + 1;
        if (spanIndex < 0 || spanIndex >= knots.numSpans)
            return false;
        const knotArray = knots.knots;
        const knotA = knotArray[kA];
        const knotB = knotArray[kB];
        this.setInterval(knotA, knotB);
        for (let numInsert = degree - 1; numInsert > 0; numInsert--) {
            //  left numInsert poles are pulled forward
            let k0 = kA - numInsert;
            if (knotArray[k0] < knotA) {
                let k1 = kB;
                for (let i = 0; i < numInsert; i++, k0++, k1++) {
                    const knot0 = knotArray[k0];
                    const knot1 = knotArray[k1];
                    const fraction = (knotA - knot0) / (knot1 - knot0);
                    this.interpolatePoleInPlace(i, fraction, i + 1);
                }
            }
        }
        for (let numInsert = degree - 1; numInsert > 0; numInsert--) {
            let k2 = kB + numInsert;
            if (knotArray[k2] > knotB) {
                for (let i = 0; i < numInsert; i++, k2--) {
                    const knot2 = knotArray[k2]; // right side of moving window
                    // left side of window ia always the (previously saturated) knotA
                    const fraction = (knotB - knot2) / (knotA - knot2);
                    this.interpolatePoleInPlace(degree - i, fraction, degree - i - 1);
                }
            }
        }
        return true;
    }
    /**
     * Saturate a univaraite bspline coefficient array in place
     * * On input, the array is the coefficients one span of a bspline, packed in an array of `(knots.order)` values.
     * * These are modified in place, and on return are a bezier for the same knot interval.
     * @param coffs input as bspline coefficients, returned as bezier coefficients
     * @param knots knot vector
     * @param spanIndex index of span whose (unsaturated) poles are in the coefficients.
     * @param optional function for `setInterval (knotA, knotB)` call to announce knot limits.
     */
    static saturate1dInPlace(coffs, knots, spanIndex) {
        const degree = knots.degree;
        const kA = spanIndex + degree - 1; // left knot index of the active span
        const kB = kA + 1;
        if (spanIndex < 0 || spanIndex >= knots.numSpans)
            return false;
        const knotArray = knots.knots;
        const knotA = knotArray[kA];
        const knotB = knotArray[kB];
        for (let numInsert = degree - 1; numInsert > 0; numInsert--) {
            //  left numInsert poles are pulled forward
            let k0 = kA - numInsert;
            if (knotArray[k0] < knotA) {
                let k1 = kB;
                for (let i = 0; i < numInsert; i++, k0++, k1++) {
                    const knot0 = knotArray[k0];
                    const knot1 = knotArray[k1];
                    const fraction = (knotA - knot0) / (knot1 - knot0);
                    coffs[i] = coffs[i] + fraction * (coffs[i + 1] - coffs[i]);
                }
            }
        }
        for (let numInsert = degree - 1; numInsert > 0; numInsert--) {
            let k2 = kB + numInsert;
            let k;
            if (knotArray[k2] > knotB) {
                for (let i = 0; i < numInsert; i++, k2--) {
                    const knot2 = knotArray[k2]; // right side of moving window
                    // left side of window ia always the (previously saturated) knotA
                    const fraction = (knotB - knot2) / (knotA - knot2);
                    k = degree - i;
                    coffs[k] += fraction * (coffs[k - 1] - coffs[k]);
                }
            }
        }
        return true;
    }
    /**
     * Apply deCasteljou interpolations to isolate a smaller bezier polygon, representing interval 0..fraction of the original
     * @param fracton "end" fraction for split.
     * @returns false if fraction is 0 -- no changes applied.
     */
    subdivideInPlaceKeepLeft(fraction) {
        if (Geometry_1.Geometry.isAlmostEqualNumber(fraction, 1.0))
            return true;
        if (Geometry_1.Geometry.isAlmostEqualNumber(fraction, 0.0))
            return false;
        const g = 1.0 - fraction; // interpolations will pull towards right indices
        const order = this.order;
        for (let level = 1; level < order; level++) {
            for (let i1 = order - 1; i1 >= level; i1--) {
                this.interpolatePoleInPlace(i1, g, i1 - 1); // leave updates to right
            }
        }
        return true;
    }
    /**
     * Apply deCasteljou interpolations to isolate a smaller bezier polygon, representing interval 0..fraction of the original
     * @param fracton "end" fraction for split.
     * @returns false if fraction is 0 -- no changes applied.
     */
    subdivideInPlaceKeepRight(fraction) {
        if (Geometry_1.Geometry.isAlmostEqualNumber(fraction, 0.0))
            return true;
        if (Geometry_1.Geometry.isAlmostEqualNumber(fraction, 1.0))
            return false;
        const order = this.order;
        for (let level = 1; level < order; level++) {
            for (let i0 = 0; i0 + level < order; i0++)
                this.interpolatePoleInPlace(i0, fraction, i0 + 1); // leave updates to left.
        }
        return true;
    }
    /**
     * Saturate a univaraite bspline coefficient array in place
     * @param fracton0 fracton for first split.   This is the start of the output polygon
     * @param fracton1 fracton for first split.   This is the start of the output polygon
     * @return false if fractions are (almost) identical.
     */
    subdivideToIntervalInPlace(fraction0, fraction1) {
        if (Geometry_1.Geometry.isAlmostEqualNumber(fraction0, fraction1))
            return false;
        if (fraction1 < fraction0) {
            this.subdivideToIntervalInPlace(fraction0, fraction1);
            this.reverseInPlace();
            return true;
        }
        this.subdivideInPlaceKeepLeft(fraction1);
        this.subdivideInPlaceKeepRight(fraction0 / fraction1);
        return true;
    }
    /** create or update the mapping to parent curve. */
    setInterval(a, b) {
        this.interval = Segment1d_1.Segment1d.create(a, b, this.interval);
    }
    /** map a fraction to the parent space. */
    fractionToParentFraction(fraction) { return this.interval ? this.interval.fractionToPoint(fraction) : fraction; }
}
exports.Bezier1dNd = Bezier1dNd;


/***/ }),

/***/ "./lib/bspline/BezierCurve3d.js":
/*!**************************************!*\
  !*** ./lib/bspline/BezierCurve3d.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Point4d_1 = __webpack_require__(/*! ../geometry4d/Point4d */ "./lib/geometry4d/Point4d.js");
const Ray3d_1 = __webpack_require__(/*! ../geometry3d/Ray3d */ "./lib/geometry3d/Ray3d.js");
const Plane3dByOriginAndVectors_1 = __webpack_require__(/*! ../geometry3d/Plane3dByOriginAndVectors */ "./lib/geometry3d/Plane3dByOriginAndVectors.js");
const StrokeOptions_1 = __webpack_require__(/*! ../curve/StrokeOptions */ "./lib/curve/StrokeOptions.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Angle_1 = __webpack_require__(/*! ../geometry3d/Angle */ "./lib/geometry3d/Angle.js");
const LineString3d_1 = __webpack_require__(/*! ../curve/LineString3d */ "./lib/curve/LineString3d.js");
const BezierCurveBase_1 = __webpack_require__(/*! ./BezierCurveBase */ "./lib/bspline/BezierCurveBase.js");
const BezierPolynomials_1 = __webpack_require__(/*! ../numerics/BezierPolynomials */ "./lib/numerics/BezierPolynomials.js");
// ================================================================================================================
// ================================================================================================================
// ================================================================================================================
// ================================================================================================================
/** 3d Bezier curve class.
 * * Use BezierCurve3dH if the curve has weights.
 * * The control points (xyz) are managed as the _packedData buffer in the _polygon member of BezierCurveBase.
 */
class BezierCurve3d extends BezierCurveBase_1.BezierCurveBase {
    isSameGeometryClass(other) { return other instanceof BezierCurve3d; }
    tryTransformInPlace(transform) {
        const data = this._workData0;
        for (let i = 0; i < this._polygon.order; i++) {
            this._polygon.getPolygonPoint(i, data);
            transform.multiplyXYZToFloat64Array(data[0], data[1], data[2], data);
            this._polygon.setPolygonPoint(i, data);
        }
        return true;
    }
    /** Return a specific pole as a full `[x,y,z] Point3d` */
    getPolePoint3d(i, result) {
        const data = this._polygon.getPolygonPoint(i, this._workData0);
        if (data)
            return Point3dVector3d_1.Point3d.create(data[0], data[1], data[2], result);
        return undefined;
    }
    /** Return a specific pole as a full `[w*x,w*y,w*z, w] Point4d` */
    getPolePoint4d(i, result) {
        const data = this._polygon.getPolygonPoint(i, this._workData0);
        if (data)
            return Point4d_1.Point4d.create(data[0], data[1], data[2], 1.0, result);
        return undefined;
    }
    /**
     * Capture a polygon as the data for a new `BezierCurve3d`
     * @param polygon complete packed data and order.
     */
    constructor(polygon) {
        super(3, polygon);
        this._workRay0 = Ray3d_1.Ray3d.createXAxis();
        this._workRay1 = Ray3d_1.Ray3d.createXAxis();
    }
    /** Return poles as a linestring */
    copyPointsAsLineString() {
        const result = LineString3d_1.LineString3d.create();
        for (let i = 0; i < this._polygon.order; i++)
            result.addPoint(this.getPolePoint3d(i));
        return result;
    }
    /** Create a curve with given points.
     * * If input is `Point2d[]`, the points are promoted with `z=0` and `w=1`
     * * If input is `Point3d[]`, the points are promoted with w=1`
     *
     */
    static create(data) {
        if (data.length < 1)
            return undefined;
        const polygon = new Float64Array(data.length * 3);
        if (data[0] instanceof Point3dVector3d_1.Point3d) {
            let i = 0;
            for (const p of data) {
                polygon[i++] = p.x;
                polygon[i++] = p.y;
                polygon[i++] = p.z;
            }
            return new BezierCurve3d(polygon);
        }
        else if (data[0] instanceof Point2dVector2d_1.Point2d) {
            let i = 0;
            for (const p of data) {
                polygon[i++] = p.x;
                polygon[i++] = p.y;
                polygon[i++] = 0.0;
            }
            return new BezierCurve3d(polygon);
        }
        return undefined;
    }
    /** create a bezier curve of specified order, filled with zeros */
    static createOrder(order) {
        const polygonArray = new Float64Array(order * 3); // This is initialized to zeros!!
        return new BezierCurve3d(polygonArray);
    }
    /** Load order * 3 doubles from data[3 * spanIndex] as poles */
    loadSpanPoles(data, spanIndex) {
        this._polygon.loadSpanPoles(data, spanIndex);
    }
    clone() {
        return new BezierCurve3d(this._polygon.clonePolygon());
    }
    clonePartialCurve(f0, f1) {
        const partialCurve = new BezierCurve3d(this._polygon.clonePolygon());
        partialCurve._polygon.subdivideToIntervalInPlace(f0, f1);
        return partialCurve;
    }
    /**
     * Return a curve after transform.
     */
    cloneTransformed(transform) {
        const curve1 = this.clone();
        curve1.tryTransformInPlace(transform);
        return curve1;
    }
    /** Return a (deweighted) point on the curve. If deweight fails, returns 000 */
    fractionToPoint(fraction, result) {
        this._polygon.evaluate(fraction, this._workData0);
        return Point3dVector3d_1.Point3d.create(this._workData0[0], this._workData0[1], this._workData0[2], result);
    }
    /** Return the cartesian point and derivative vector. */
    fractionToPointAndDerivative(fraction, result) {
        this._polygon.evaluate(fraction, this._workData0);
        this._polygon.evaluateDerivative(fraction, this._workData1);
        return Ray3d_1.Ray3d.createXYZUVW(this._workData0[0], this._workData0[1], this._workData0[2], this._workData1[0], this._workData1[1], this._workData1[2], result);
    }
    /** Construct a plane with
     * * origin at the fractional position along the arc
     * * x axis is the first derivative, i.e. tangent along the arc
     * * y axis is the second derivative, i.e. in the plane and on the center side of the tangent.
     * If the arc is circular, the second derivative is directly towards the center
     */
    fractionToPointAnd2Derivatives(fraction, result) {
        const epsilon = 1.0e-8;
        const a = 1.0 / (2.0 * epsilon);
        if (!result)
            result = Plane3dByOriginAndVectors_1.Plane3dByOriginAndVectors.createXYPlane();
        const ray = this.fractionToPointAndDerivative(fraction, this._workRay0);
        result.origin.setFrom(ray.origin);
        result.vectorU.setFrom(ray.direction);
        const ray0 = this.fractionToPointAndDerivative(fraction - epsilon, this._workRay0);
        const ray1 = this.fractionToPointAndDerivative(fraction + epsilon, this._workRay1);
        Point3dVector3d_1.Vector3d.createAdd2Scaled(ray0.direction, -a, ray1.direction, a, result.vectorV);
        return result;
    }
    isAlmostEqual(other) {
        if (other instanceof BezierCurve3d) {
            return this._polygon.isAlmostEqual(other._polygon);
        }
        return false;
    }
    /**
     * Assess legnth and turn to determine a stroke count.
     * @param options stroke options structure.
     */
    strokeCount(options) {
        const data = this._polygon.packedData;
        let dx0 = data[3] - data[0];
        let dy0 = data[4] - data[1];
        let dz0 = data[5] - data[2];
        let dx1, dy1, dz1; // first differences of leading edge
        // let ex, ey, ez; // second differences.
        let sweepRadians = 0.0;
        let sumLength = Geometry_1.Geometry.hypotenuseXYZ(dx0, dy0, dz0);
        const n = data.length;
        for (let i = 6; i + 2 < n; i += 3) {
            dx1 = data[i] - data[i - 3];
            dy1 = data[i + 1] - data[i - 2];
            dz1 = data[i + 2] - data[i - 1];
            //        ex = dx1 - dx0; ey = dy1 - dy0; ez = dz1 - dz0;
            sweepRadians += Angle_1.Angle.radiansBetweenVectorsXYZ(dx0, dy0, dz0, dx1, dy1, dz1);
            sumLength += Geometry_1.Geometry.hypotenuseXYZ(dx1, dy1, dz1);
            dx0 = dx1;
            dy0 = dy1;
            dz0 = dz1;
        }
        const numPerSpan = StrokeOptions_1.StrokeOptions.applyAngleTol(options, StrokeOptions_1.StrokeOptions.applyMaxEdgeLength(options, 1, sumLength), sweepRadians, 0.2);
        return numPerSpan;
    }
    /**
     * convert to bspline curve and dispatch to handler
     * @param handler handelr to receive strongly typed geometry
     */
    dispatchToGeometryHandler(handler) {
        return handler.handleBezierCurve3d(this);
    }
    extendRange(rangeToExtend, transform) {
        const order = this.order;
        if (!transform) {
            this.allocateAndZeroBezierWorkData(order - 1, 0, 0);
            const bezier = this._workBezier;
            this.getPolePoint3d(0, this._workPoint0);
            rangeToExtend.extend(this._workPoint0);
            this.getPolePoint3d(order - 1, this._workPoint0);
            rangeToExtend.extend(this._workPoint0);
            for (let axisIndex = 0; axisIndex < 3; axisIndex++) {
                BezierPolynomials_1.BezierPolynomialAlgebra.componentDifference(bezier.coffs, this._polygon.packedData, 3, order, axisIndex);
                const roots = bezier.roots(0.0, true);
                if (roots) {
                    for (const r of roots) {
                        this.fractionToPoint(r, this._workPoint0);
                        rangeToExtend.extend(this._workPoint0);
                    }
                }
            }
        }
        else {
            this.allocateAndZeroBezierWorkData(order - 1, order, 0);
            const bezier = this._workBezier;
            const componentCoffs = this._workCoffsA; // to hold transformed copy of x,y,z in turn.
            this.getPolePoint3d(0, this._workPoint0);
            rangeToExtend.extendTransformedPoint(transform, this._workPoint0);
            this.getPolePoint3d(order - 1, this._workPoint0);
            rangeToExtend.extendTransformedPoint(transform, this._workPoint0);
            const data = this._polygon.packedData;
            for (let axisIndex = 0; axisIndex < 3; axisIndex++) {
                // apply one row of the transform to get the transformed coff by itself
                for (let i = 0, k = 0; i < order; i++, k += 3)
                    componentCoffs[i] = transform.multiplyComponentXYZ(axisIndex, data[k], data[k + 1], data[k + 2]);
                BezierPolynomials_1.BezierPolynomialAlgebra.univariateDifference(componentCoffs, bezier.coffs);
                const roots = bezier.roots(0.0, true);
                if (roots && roots.length > 0) {
                    for (const r of roots) {
                        this.fractionToPoint(r, this._workPoint0);
                        rangeToExtend.extendTransformedPoint(transform, this._workPoint0);
                    }
                }
            }
        }
    }
}
exports.BezierCurve3d = BezierCurve3d;


/***/ }),

/***/ "./lib/bspline/BezierCurve3dH.js":
/*!***************************************!*\
  !*** ./lib/bspline/BezierCurve3dH.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Point4d_1 = __webpack_require__(/*! ../geometry4d/Point4d */ "./lib/geometry4d/Point4d.js");
const Ray3d_1 = __webpack_require__(/*! ../geometry3d/Ray3d */ "./lib/geometry3d/Ray3d.js");
const Plane3dByOriginAndVectors_1 = __webpack_require__(/*! ../geometry3d/Plane3dByOriginAndVectors */ "./lib/geometry3d/Plane3dByOriginAndVectors.js");
const StrokeOptions_1 = __webpack_require__(/*! ../curve/StrokeOptions */ "./lib/curve/StrokeOptions.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Angle_1 = __webpack_require__(/*! ../geometry3d/Angle */ "./lib/geometry3d/Angle.js");
const BezierPolynomials_1 = __webpack_require__(/*! ../numerics/BezierPolynomials */ "./lib/numerics/BezierPolynomials.js");
const BezierCurveBase_1 = __webpack_require__(/*! ./BezierCurveBase */ "./lib/bspline/BezierCurveBase.js");
// ================================================================================================================
// ================================================================================================================
/** 3d curve with homogeneous weights. */
class BezierCurve3dH extends BezierCurveBase_1.BezierCurveBase {
    isSameGeometryClass(other) { return other instanceof BezierCurve3dH; }
    /**
     * Apply (multiply by) an affine transform
     * @param transform
     */
    tryTransformInPlace(transform) {
        const data = this._workData0;
        for (let i = 0; i < this._polygon.order; i++) {
            this._polygon.getPolygonPoint(i, data);
            transform.multiplyXYZWToFloat64Array(data[0], data[1], data[2], data[3], data);
            this._polygon.setPolygonPoint(i, data);
        }
        return true;
    }
    /**
     * Apply (multiply by) a perspective transform
     * @param matrix
     */
    tryMultiplyMatrix4dInPlace(matrix) {
        matrix.multiplyBlockedFloat64ArrayInPlace(this._polygon.packedData);
    }
    /** Return a specific pole as a full `[x,y,z,x] Point4d` */
    getPolePoint4d(i, result) {
        const data = this._polygon.getPolygonPoint(i, this._workData0);
        if (data)
            return Point4d_1.Point4d.create(data[0], data[1], data[2], data[3], result);
        return undefined;
    }
    /** Return a specific pole normalized to weight 1
     */
    getPolePoint3d(i, result) {
        const data = this._polygon.getPolygonPoint(i, this._workData0);
        if (data)
            return Point3dVector3d_1.Point3d.createFromPackedXYZW(data, 0, result);
        return undefined;
    }
    /**
     * @returns true if all weights are within tolerance of 1.0
     */
    isUnitWeight(tolerance) {
        if (tolerance === undefined)
            tolerance = Geometry_1.Geometry.smallAngleRadians;
        const aLow = 1.0 - tolerance;
        const aHigh = 1.0 + tolerance;
        const data = this._polygon.packedData;
        const n = data.length;
        let a;
        for (let i = 3; i < n; i += 4) {
            a = data[i];
            if (a < aLow || a > aHigh)
                return false;
        }
        return true;
    }
    /**
     * Capture a polygon as the data for a new `BezierCurve3dH`
     * @param polygon complete packed data and order.
     */
    constructor(polygon) {
        super(4, polygon);
        this._workRay0 = Ray3d_1.Ray3d.createXAxis();
        this._workRay1 = Ray3d_1.Ray3d.createXAxis();
    }
    /** Create a curve with given points.
     * * If input is `Point2d[]`, the points are promoted with `z=0` and `w=1`
     * * If input is `Point3d[]`, the points are promoted with w=1`
     *
     */
    static create(data) {
        if (data.length < 1)
            return undefined;
        const polygon = new Float64Array(data.length * 4);
        if (data[0] instanceof Point3dVector3d_1.Point3d) {
            let i = 0;
            for (const p of data) {
                polygon[i++] = p.x;
                polygon[i++] = p.y;
                polygon[i++] = p.z;
                polygon[i++] = 1.0;
            }
            return new BezierCurve3dH(polygon);
        }
        else if (data[0] instanceof Point4d_1.Point4d) {
            let i = 0;
            for (const p of data) {
                polygon[i++] = p.x;
                polygon[i++] = p.y;
                polygon[i++] = p.z;
                polygon[i++] = p.w;
            }
            return new BezierCurve3dH(polygon);
        }
        else if (data[0] instanceof Point2dVector2d_1.Point2d) {
            let i = 0;
            for (const p of data) {
                polygon[i++] = p.x;
                polygon[i++] = p.y;
                polygon[i++] = 0.0;
                polygon[i++] = 1.0;
            }
            return new BezierCurve3dH(polygon);
        }
        return undefined;
    }
    /** create a bezier curve of specified order, filled with zeros */
    static createOrder(order) {
        const polygonArray = new Float64Array(order * 4); // and we trust that this is all zeros !!!
        return new BezierCurve3dH(polygonArray);
    }
    /** Load order * 4 doubles from data[3 * spanIndex] as poles (with added weight) */
    loadSpan3dPolesWithWeight(data, spanIndex, weight) {
        this._polygon.loadSpanPolesWithWeight(data, 3, spanIndex, weight);
    }
    /** Load order * 4 doubles from data[3 * spanIndex] as poles (with added weight) */
    loadSpan4dPoles(data, spanIndex) {
        this._polygon.loadSpanPoles(data, spanIndex);
    }
    clone() {
        return new BezierCurve3dH(this._polygon.clonePolygon());
    }
    /**
     * Return a curve after transform.
     */
    cloneTransformed(transform) {
        const curve1 = this.clone();
        curve1.tryTransformInPlace(transform);
        return curve1;
    }
    /** Return a (deweighted) point on the curve. If deweight fails, returns 000 */
    fractionToPoint(fraction, result) {
        this._polygon.evaluate(fraction, this._workData0);
        result = Point3dVector3d_1.Point3d.createFromPackedXYZW(this._workData0, 0, result);
        return result ? result : Point3dVector3d_1.Point3d.createZero();
    }
    /** Return a (deweighted) point on the curve. If deweight fails, returns 000 */
    fractionToPoint4d(fraction, result) {
        this._polygon.evaluate(fraction, this._workData0);
        return Point4d_1.Point4d.createFromPackedXYZW(this._workData0, 0, result);
    }
    /** Return the cartesian point and derivative vector. */
    fractionToPointAndDerivative(fraction, result) {
        this._polygon.evaluate(fraction, this._workData0);
        this._polygon.evaluateDerivative(fraction, this._workData1);
        result = Ray3d_1.Ray3d.createWeightedDerivative(this._workData0, this._workData1, result);
        if (result)
            return result;
        // Bad. Very Bad.  Return origin and x axis.   Should be undefined, but usual cartesian typs do not allow that
        return Ray3d_1.Ray3d.createXAxis();
    }
    /** Construct a plane with
     * * origin at the fractional position along the arc
     * * x axis is the first derivative, i.e. tangent along the arc
     * * y axis is the second derivative, i.e. in the plane and on the center side of the tangent.
     * If the arc is circular, the second derivative is directly towards the center
     */
    fractionToPointAnd2Derivatives(fraction, result) {
        const epsilon = 1.0e-8;
        const a = 1.0 / (2.0 * epsilon);
        if (!result)
            result = Plane3dByOriginAndVectors_1.Plane3dByOriginAndVectors.createXYPlane();
        const ray = this.fractionToPointAndDerivative(fraction, this._workRay0);
        result.origin.setFrom(ray.origin);
        result.vectorU.setFrom(ray.direction);
        const ray0 = this.fractionToPointAndDerivative(fraction - epsilon, this._workRay0);
        const ray1 = this.fractionToPointAndDerivative(fraction + epsilon, this._workRay1);
        Point3dVector3d_1.Vector3d.createAdd2Scaled(ray0.direction, -a, ray1.direction, a, result.vectorV);
        return result;
    }
    isAlmostEqual(other) {
        if (other instanceof BezierCurve3dH) {
            return this._polygon.isAlmostEqual(other._polygon);
        }
        return false;
    }
    /**
     * Assess legnth and turn to determine a stroke count.
     * @param options stroke options structure.
     */
    strokeCount(options) {
        // ugh.   for pure 3d case, local dx,dy,dz vars worked efficiently.
        // managing the weights is tricky, so just do the easy code with temporary point vars.
        this.getPolePoint3d(0, this._workPoint0);
        this.getPolePoint3d(1, this._workPoint1);
        let numStrokes = 1;
        if (this._workPoint0 && this._workPoint1) {
            let dx0 = this._workPoint1.x - this._workPoint0.x;
            let dy0 = this._workPoint1.y - this._workPoint0.y;
            let dz0 = this._workPoint1.z - this._workPoint0.z;
            let dx1, dy1, dz1; // first differences of leading edge
            let sumRadians = 0.0;
            let thisLength = Geometry_1.Geometry.hypotenuseXYZ(dx0, dy0, dz0);
            this._workPoint1.setFromPoint3d(this._workPoint0);
            let sumLength = thisLength;
            let maxLength = thisLength;
            let maxRadians = 0.0;
            let thisRadians;
            for (let i = 2; this.getPolePoint3d(i, this._workPoint1); i++) {
                dx1 = this._workPoint1.x - this._workPoint0.x;
                dy1 = this._workPoint1.y - this._workPoint0.y;
                dz1 = this._workPoint1.z - this._workPoint0.z;
                thisRadians = Angle_1.Angle.radiansBetweenVectorsXYZ(dx0, dy0, dz0, dx1, dy1, dz1);
                sumRadians += thisRadians;
                maxRadians = Geometry_1.Geometry.maxAbsXY(thisRadians, maxRadians);
                thisLength = Geometry_1.Geometry.hypotenuseXYZ(dx1, dy1, dz1);
                sumLength += thisLength;
                maxLength = Geometry_1.Geometry.maxXY(maxLength, thisLength);
                dx0 = dx1;
                dy0 = dy1;
                dz0 = dz1;
                this._workPoint0.setFrom(this._workPoint1);
            }
            const length1 = maxLength * this.degree; // This may be larger than sumLength
            const length2 = Math.sqrt(length1 * sumLength); // This is in between
            let radians1 = maxRadians * (this.degree - 1); // As if worst case keeps happening.
            if (this.degree < 3)
                radians1 *= 3; // so quadratics aren't understroked
            const radians2 = Math.sqrt(radians1 * sumRadians);
            numStrokes = StrokeOptions_1.StrokeOptions.applyAngleTol(options, StrokeOptions_1.StrokeOptions.applyMaxEdgeLength(options, this.degree, length2), radians2, 0.1);
        }
        return numStrokes;
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleBezierCurve3dH(this);
    }
    /**
     * Form dot products of each pole with given coefficients. Return as entries in products array.
     * @param products array of (scalar) dot products
     * @param ax x coefficient
     * @param ay y coefficient
     * @param az z coefficient
     * @param aw w coefficient
     */
    poleProductsXYZW(products, ax, ay, az, aw) {
        const n = this.numPoles;
        const data = this._polygon.packedData;
        for (let i = 0, k = 0; i < n; i++, k += 4)
            products[i] = ax * data[k] + ay * data[k + 1] + az * data[k + 2] + aw * data[k + 3];
    }
    /** Find the closest point within the bezier span, using true perpendicular test (but no endpoint test)
     * * If closer than previously recorded, update the CurveLocationDetail
     * * This assumes this bezier is saturated.
     * @param spacePoint point being projected
     * @param detail pre-allocated detail to record (evolving) closest point.
     * @returns true if an updated occured, false if either (a) no perpendicular projections or (b) perpendiculars were not closer.
     */
    updateClosestPointByTruePerpendicular(spacePoint, detail) {
        let numUpdates = 0;
        let roots;
        if (this.isUnitWeight()) {
            // unweighted !!!
            const productOrder = 2 * this.order - 2;
            this.allocateAndZeroBezierWorkData(productOrder, 0, 0);
            const bezier = this._workBezier;
            // closestPoint condition is:
            //   (spacePoint - curvePoint) DOT curveTangent = 0;
            // Each product (x,y,z) of the DOT is the product of two bezier polynonmials
            BezierPolynomials_1.BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(bezier.coffs, this._polygon.packedData, 4, this.order, 1.0, 0, -spacePoint.x, 0);
            BezierPolynomials_1.BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(bezier.coffs, this._polygon.packedData, 4, this.order, 1.0, 1, -spacePoint.y, 1);
            BezierPolynomials_1.BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(bezier.coffs, this._polygon.packedData, 4, this.order, 1.0, 2, -spacePoint.z, 2);
            roots = bezier.roots(0.0, true);
        }
        else {
            // This bezier has weights.
            // The pure cartesian closest point condition is
            //   (spacePoint - X/w) DOT (X' w - w' X)/ w^2 = 0
            // ignoring denominator and using bezier coefficient differences for the derivative, making the numerator 0 is
            //   (w * spacePoint - X) DOT ( DELTA X * w - DELTA w * X) = 0
            const orderA = this.order;
            const orderB = 2 * this.order - 2; // products of component and component difference.
            const productOrder = orderA + orderB - 1;
            this.allocateAndZeroBezierWorkData(productOrder, orderA, orderB);
            const bezier = this._workBezier;
            const workA = this._workCoffsA;
            const workB = this._workCoffsB;
            const packedData = this._polygon.packedData;
            for (let i = 0; i < 3; i++) {
                // x representing loop pass:   (w * spacePoint.x - curve.x(s), 1.0) * (curveDelta.x(s) * curve.w(s) - curve.x(s) * curveDelta.w(s))
                // (and p.w is always 1)
                BezierPolynomials_1.BezierPolynomialAlgebra.scaledComponentSum(workA, packedData, 4, orderA, 3, spacePoint.at(i), // w * spacePoint.x
                i, -1.0); // curve.x(s) * 1.0
                BezierPolynomials_1.BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(workB, packedData, 4, orderA, 1.0, 3, 1.0, i);
                BezierPolynomials_1.BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(workB, packedData, 4, orderA, -1.0, i, 1.0, 3);
                BezierPolynomials_1.BezierPolynomialAlgebra.accumulateProduct(bezier.coffs, workA, workB);
            }
            roots = bezier.roots(0.0, true);
        }
        if (roots) {
            for (const fraction of roots) {
                const xyz = this.fractionToPoint(fraction);
                const a = xyz.distance(spacePoint);
                numUpdates += detail.updateIfCloserCurveFractionPointDistance(this, fraction, xyz, a) ? 1 : 0;
            }
        }
        return numUpdates > 0;
    }
    extendRange(rangeToExtend, transform) {
        const order = this.order;
        if (!transform) {
            this.allocateAndZeroBezierWorkData(order * 2 - 2, 0, 0);
            const bezier = this._workBezier;
            const data = this._polygon.packedData;
            this.getPolePoint3d(0, this._workPoint0);
            rangeToExtend.extend(this._workPoint0);
            this.getPolePoint3d(order - 1, this._workPoint0);
            rangeToExtend.extend(this._workPoint0);
            // Example:
            // For x component ...
            //     coefficients of (weighted x) are at axisIndex=0
            //     deweighted polynomial is (x(s)/w(s))
            //    its derivative (to be zeroed) is
            //              (x'(s)*w(s) -x(s) * w'(s)) / w^2(s)
            // The coefficients of the derivatives are (degree times) differences of successive coffs.
            // Make the numerator zero to get extrema
            for (let axisIndex = 0; axisIndex < 3; axisIndex++) {
                bezier.zero();
                BezierPolynomials_1.BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(bezier.coffs, data, 4, order, 1.0, axisIndex, 0.0, 3);
                BezierPolynomials_1.BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(bezier.coffs, data, 4, order, -1.0, 3, 0.0, axisIndex);
                const roots = bezier.roots(0.0, true);
                if (roots) {
                    for (const r of roots) {
                        this.fractionToPoint(r, this._workPoint0);
                        rangeToExtend.extend(this._workPoint0);
                    }
                }
            }
        }
        else {
            this.allocateAndZeroBezierWorkData(order * 2 - 2, order, order);
            const componentCoffs = this._workCoffsA; // to hold transformed copy of x,y,z in turn.
            const weightCoffs = this._workCoffsB; // to hold weights
            const bezier = this._workBezier;
            this.getPolePoint3d(0, this._workPoint0);
            rangeToExtend.extendTransformedPoint(transform, this._workPoint0);
            this.getPolePoint3d(order - 1, this._workPoint0);
            rangeToExtend.extendTransformedPoint(transform, this._workPoint0);
            const data = this._polygon.packedData; // Example:
            // For x component ...
            //     coefficients of (weighted x) are at axisIndex=0
            //     deweighted polynomial is (x(s)/w(s))
            //    its derivative (to be zeroed) is
            //              (x'(s)*w(s) -x(s) * w'(s)) / w^2(s)
            // The coefficients of the derivatives are (degree times) differences of successive coffs.
            // Make the numerator zero to get extrema
            // apply one row of the transform to get the transformed coff by itself
            let weight;
            for (let axisIndex = 0; axisIndex < 3; axisIndex++) {
                bezier.zero();
                for (let i = 0, k = 0; i < order; i++, k += 4) {
                    weight = data[k + 3];
                    componentCoffs[i] = transform.multiplyComponentXYZW(axisIndex, data[k], data[k + 1], data[k + 2], weight);
                    weightCoffs[i] = weight;
                }
                BezierPolynomials_1.BezierPolynomialAlgebra.accumulateProductWithDifferences(bezier.coffs, componentCoffs, weightCoffs, 1.0);
                BezierPolynomials_1.BezierPolynomialAlgebra.accumulateProductWithDifferences(bezier.coffs, weightCoffs, componentCoffs, -1.0);
                const roots = bezier.roots(0.0, true);
                if (roots && roots.length > 0) {
                    for (const r of roots) {
                        this.fractionToPoint(r, this._workPoint0);
                        rangeToExtend.extendTransformedPoint(transform, this._workPoint0);
                    }
                }
            }
        }
    }
}
exports.BezierCurve3dH = BezierCurve3dH;


/***/ }),

/***/ "./lib/bspline/BezierCurveBase.js":
/*!****************************************!*\
  !*** ./lib/bspline/BezierCurveBase.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Bspline */
// import { Point2d } from "../Geometry2d";
/* tslint:disable:variable-name jsdoc-format no-empty no-console*/
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const CurvePrimitive_1 = __webpack_require__(/*! ../curve/CurvePrimitive */ "./lib/curve/CurvePrimitive.js");
const Bezier1dNd_1 = __webpack_require__(/*! ./Bezier1dNd */ "./lib/bspline/Bezier1dNd.js");
const BezierPolynomials_1 = __webpack_require__(/*! ../numerics/BezierPolynomials */ "./lib/numerics/BezierPolynomials.js");
/**
 * Base class for CurvePrimitve (necessarily 3D) with _polygon.
 * * This has a Bezier1dNd polygon as a member, and implements dimension-indendent methods
 * * This exists to support BezeierCurve3d and BezierCurve3dH.
 * * The implementations of "pure 3d" queries is based on calling `getPolePoint3d`.
 * * This has the subtle failure difference that `getPolePoint3d` call with a valid index on on a 3d curve always succeeds, but on 3dH curve fails when weight is zero.
 */
class BezierCurveBase extends CurvePrimitive_1.CurvePrimitive {
    constructor(blockSize, data) {
        super();
        this._polygon = new Bezier1dNd_1.Bezier1dNd(blockSize, data);
        this._workPoint0 = Point3dVector3d_1.Point3d.create();
        this._workPoint1 = Point3dVector3d_1.Point3d.create();
        this._workData0 = new Float64Array(blockSize);
        this._workData1 = new Float64Array(blockSize);
    }
    /** reverse the poles in place */
    reverseInPlace() { this._polygon.reverseInPlace(); }
    /** saturate the pole in place, using knot intervals from `spanIndex` of the `knotVector` */
    saturateInPlace(knotVector, spanIndex) {
        const boolstat = this._polygon.saturateInPlace(knotVector, spanIndex);
        if (boolstat) {
            this.setInterval(knotVector.spanFractionToFraction(spanIndex, 0.0), knotVector.spanFractionToFraction(spanIndex, 1.0));
        }
        return boolstat;
    }
    get degree() {
        return this._polygon.order - 1;
    }
    get order() { return this._polygon.order; }
    get numPoles() { return this._polygon.order; }
    setInterval(a, b) { this._polygon.setInterval(a, b); }
    fractionToParentFraction(fraction) { return this._polygon.fractionToParentFraction(fraction); }
    /** append stroke points to a linestring, based on `strokeCount` and `fractionToPoint` from derived class*/
    emitStrokes(dest, options) {
        const numPerSpan = this.strokeCount(options);
        const fractionStep = 1.0 / numPerSpan;
        for (let i = 0; i <= numPerSpan; i++) {
            const fraction = i * fractionStep;
            this.fractionToPoint(fraction, this._workPoint0);
            dest.appendStrokePoint(this._workPoint0);
        }
    }
    /** announce intervals with stroke counts */
    emitStrokableParts(handler, _options) {
        const numPerSpan = this.strokeCount(_options);
        handler.announceIntervalForUniformStepStrokes(this, numPerSpan, 0.0, 1.0);
    }
    /** Return a simple array of arrays with the control points as `[[x,y,z],[x,y,z],..]` */
    copyPolesAsJsonArray() { return this._polygon.unpackToJsonArrays(); }
    /** return true if all poles are on a plane. */
    isInPlane(plane) {
        let point = this._workPoint0;
        for (let i = 0;; i++) {
            point = this.getPolePoint3d(i, point);
            if (!point)
                return true;
            if (!plane.isPointInPlane(point))
                break; // which gets to return false, which isotherwise unreachable . . .
        }
        return false;
    }
    polygonLength() {
        if (!this.getPolePoint3d(0, this._workPoint0))
            return 0.0;
        let i = 0;
        let sum = 0.0;
        while (this.getPolePoint3d(++i, this._workPoint1)) {
            sum += this._workPoint0.distance(this._workPoint1);
            this._workPoint0.setFrom(this._workPoint1);
        }
        return sum;
    }
    startPoint() {
        const result = this.getPolePoint3d(0); // ASSUME non-trivial pole set -- if null comes back, it bubbles out
        return result;
    }
    endPoint() {
        const result = this.getPolePoint3d(this.order - 1); // ASSUME non-trivial pole set
        return result;
    }
    quickLength() { return this.polygonLength(); }
    /**
     * set up the _workBezier members with specific order.
     * * Try to reuse existing members if their sizes match.
     * * Ignore members corresponding to args that are 0 or negative.
     * @param primaryBezierOrder order of expected bezier
     * @param orderA length of _workCoffsA (simple array)
     * @param orderB length of _workdCoffsB (simple array)
     */
    allocateAndZeroBezierWorkData(primaryBezierOrder, orderA, orderB) {
        if (primaryBezierOrder > 0) {
            if (this._workBezier !== undefined && this._workBezier.order === primaryBezierOrder) {
                this._workBezier.zero();
            }
            else
                this._workBezier = new BezierPolynomials_1.UnivariateBezier(primaryBezierOrder);
        }
        if (orderA > 0) {
            if (this._workCoffsA !== undefined && this._workCoffsA.length === orderA)
                this._workCoffsA.fill(0);
            else
                this._workCoffsA = new Float64Array(orderA);
        }
        if (orderB > 0) {
            if (this._workCoffsB !== undefined && this._workCoffsB.length === orderB)
                this._workCoffsB.fill(0);
            else
                this._workCoffsB = new Float64Array(orderB);
        }
    }
}
exports.BezierCurveBase = BezierCurveBase;


/***/ }),

/***/ "./lib/bspline/KnotVector.js":
/*!***********************************!*\
  !*** ./lib/bspline/KnotVector.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Bspline */
// import { Point2d } from "../Geometry2d";
/* tslint:disable:variable-name jsdoc-format no-empty no-console*/
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const PointHelpers_1 = __webpack_require__(/*! ../geometry3d/PointHelpers */ "./lib/geometry3d/PointHelpers.js");
/**
 * Array of non-decreasing numbers acting as a knot array for bsplines.
 *
 * * Essential identity: numKnots = numPoles + order = numPoles + degree - 1
 * * Various bspline libraries have confusion over how many "end knots" are needed. "Many" libraries (including Microstation)
 *     incorrectly demand "order" knots at each end for clamping.   But only "order - 1" are really needed.
 * * This class uses the "order-1" convention.
 * * This class provides queries to convert among spanIndex and knotIndex
 * * A span is a single interval of the knots.
 * * The left knot of span {k} is knot {k+degree-1}
 * * This class provides queries to convert among spanFraction, fraction of knot range, and knot
 * * core computations (evaluateBasisFucntions) have leftKnotIndex and global knot value as inputs.  Caller's need to
 * know their primary values (global knot, spanFraction).
 */
class KnotVector {
    /**
     *
     * * If knots is a number array or Float64Array, the those values become the local knot array.
     * * If knots is a simple number, the local knot array is allocated to that size but left as zeros.
     * @param knots
     * @param degree
     */
    constructor(knots, degree) {
        this.degree = degree;
        this._possibleWrap = false;
        // default values to satisfy compiler -- real values hapn setupFixedValues or final else defers to user
        this._knot0 = 0.0;
        this._knot1 = 1.0;
        // satisfy the initialize checker ..
        if (Array.isArray(knots)) {
            this.knots = new Float64Array(knots.length);
            this.setKnots(knots);
            this.setupFixedValues();
        }
        else if (knots instanceof Float64Array) {
            this.knots = knots.slice();
            this.setupFixedValues();
        }
        else { // caller is responsible for filling array separately ...
            this.knots = new Float64Array(knots);
        }
    }
    get leftKnot() { return this._knot0; }
    get rightKnot() { return this._knot1; }
    get leftKnotIndex() { return this.degree - 1; }
    get rightKnotIndex() { return this.knots.length - this.degree; }
    get wrappable() { return this._possibleWrap; }
    set wrappable(value) { this._possibleWrap = value; }
    get numSpans() { return this.rightKnotIndex - this.leftKnotIndex; }
    /** copy degree and knots to a new KnotVector. */
    clone() { return new KnotVector(this.knots, this.degree); }
    setupFixedValues() {
        // These should be read-only . ..
        this._knot0 = this.knots[this.degree - 1];
        this._knot1 = this.knots[this.knots.length - this.degree];
    }
    /** @returns Return the total knot distance from beginning to end. */
    get knotLength01() { return this._knot1 - this._knot0; }
    /** @returns true if all numeric values have wraparound conditions for "closed" knotVector. */
    testClosable() {
        const leftKnotIndex = this.leftKnotIndex;
        const rightKnotIndex = this.rightKnotIndex;
        const period = this.rightKnot - this.leftKnot;
        const degree = this.degree;
        const indexDelta = rightKnotIndex - leftKnotIndex;
        for (let k0 = leftKnotIndex - degree + 1; k0 < leftKnotIndex + degree - 1; k0++) {
            const k1 = k0 + indexDelta;
            if (!Geometry_1.Geometry.isSameCoordinate(this.knots[k0] + period, this.knots[k1]))
                return false;
        }
        return true;
    }
    isAlmostEqual(other) {
        if (this.degree !== other.degree)
            return false;
        return PointHelpers_1.NumberArray.isAlmostEqual(this.knots, other.knots, KnotVector.knotTolerance);
    }
    setKnots(knots, skipFirstAndLast) {
        const numAllocate = skipFirstAndLast ? knots.length - 2 : knots.length;
        if (numAllocate !== this.knots.length)
            this.knots = new Float64Array(numAllocate);
        if (skipFirstAndLast) {
            for (let i = 1; i + 1 < knots.length; i++)
                this.knots[i - 1] = knots[i];
        }
        else {
            for (let i = 0; i < knots.length; i++)
                this.knots[i] = knots[i];
        }
        this.setupFixedValues();
    }
    /**
     * Create knot vector with {degree-1} replicated knots at start and end, and uniform knots between.
     * @param numPoles Number of poles
     * @param degree degree of polynomial
     * @param a0 left knot value for active interval
     * @param a1 right knot value for active interval
     */
    static createUniformClamped(numPoles, degree, a0, a1) {
        const knots = new KnotVector(numPoles + degree - 1, degree);
        let k = 0;
        for (let m = 0; m < degree; m++)
            knots.knots[k++] = a0;
        const du = 1.0 / (numPoles - degree);
        for (let i = 1; i + degree < numPoles; i++)
            knots.knots[k++] = a0 + i * du * (a1 - a0);
        for (let m = 0; m < degree; m++)
            knots.knots[k++] = a1;
        knots.setupFixedValues();
        return knots;
    }
    /**
     * Create knot vector with {degree-1} replicated knots at start and end, and uniform knots between.
     * @param  numInterval number of intervals in knot space.  (NOT POLE COUNT)
     * @param degree degree of polynomial
     * @param a0 left knot value for active interval
     * @param a1 right knot value for active interval
     */
    static createUniformWrapped(numInterval, degree, a0, a1) {
        const knots = new KnotVector(numInterval + 2 * degree - 1, degree);
        const du = 1.0 / numInterval;
        for (let i = 1 - degree, k = 0; i < numInterval + degree; i++, k++) {
            knots.knots[k] = Geometry_1.Geometry.interpolate(a0, i * du, a1);
        }
        knots.setupFixedValues();
        return knots;
    }
    /**
     * Create knot vector with given knot values and degree.
     * @param knotArray knot values
     * @param degree degree of polynomial
     * @param skipFirstAndLast true to skip class overclamped end knots.
     */
    static create(knotArray, degree, skipFirstAndLast) {
        const numAllocate = skipFirstAndLast ? knotArray.length - 2 : knotArray.length;
        const knots = new KnotVector(numAllocate, degree);
        knots.setKnots(knotArray, skipFirstAndLast);
        return knots;
    }
    /**
     * Return the average of degree consecutive knots begining at spanIndex.
     */
    grevilleKnot(spanIndex) {
        if (spanIndex < 0)
            return this.leftKnot;
        if (spanIndex > this.rightKnotIndex)
            return this.rightKnot;
        let sum = 0.0;
        for (let i = spanIndex; i < spanIndex + this.degree; i++)
            sum += this.knots[i];
        return sum / this.degree;
    }
    /** Return an array sized for a set of the basis function values. */
    createBasisArray() { return new Float64Array(this.degree + 1); }
    // public createTargetArray(numCoff: number): Float64Array { return new Float64Array(numCoff); }
    baseKnotFractionToKnot(knotIndex0, localFraction) {
        const knot0 = this.knots[knotIndex0];
        return knot0 + localFraction * (this.knots[knotIndex0 + 1] - knot0);
    }
    spanFractionToKnot(spanIndex, localFraction) {
        const k = this.spanIndexToLeftKnotIndex(spanIndex);
        return this.knots[k] + localFraction * (this.knots[k + 1] - this.knots[k]);
    }
    spanFractionToFraction(spanIndex, localFraction) {
        const knot = this.spanFractionToKnot(spanIndex, localFraction);
        return (knot - this.leftKnot) / (this.rightKnot - this.leftKnot);
    }
    fractionToKnot(fraction) {
        return Geometry_1.Geometry.interpolate(this.knots[this.degree - 1], fraction, this.knots[this.knots.length - this.degree]);
    }
    /**
     * Evaluate basis fucntions f[] at knot value u.
     *
     * @param u knot value for evaluation
     * @param f array of basis values.  ASSUMED PROPER LENGTH
     */
    evaluateBasisFunctions(knotIndex0, u, f) {
        f[0] = 1.0;
        if (this.degree < 1)
            return;
        // direct compute for linear part ...
        const u0 = this.knots[knotIndex0];
        const u1 = this.knots[knotIndex0 + 1];
        f[1] = (u - u0) / (u1 - u0);
        f[0] = 1.0 - f[1];
        if (this.degree < 2)
            return;
        for (let depth = 1; depth < this.degree; depth++) {
            let kLeft = knotIndex0 - depth;
            let kRight = kLeft + depth + 1;
            let gCarry = 0.0;
            for (let step = 0; step <= depth; step++) {
                const tLeft = this.knots[kLeft++];
                const tRight = this.knots[kRight++];
                const fraction = (u - tLeft) / (tRight - tLeft);
                const g1 = f[step] * fraction;
                const g0 = f[step] * (1.0 - fraction);
                f[step] = gCarry + g0;
                gCarry = g1;
            }
            f[depth + 1] = gCarry;
        }
    }
    /**
     * Evaluate basis fucntions f[] at knot value u.
     *
     * @param u knot value for evaluation
     * @param f array of basis values.  ASSUMED PROPER LENGTH
     */
    evaluateBasisFunctions1(knotIndex0, u, f, df, ddf) {
        f[0] = 1.0;
        df[0] = 0.0;
        if (this.degree < 1)
            return;
        // direct compute for linear part ...
        const u0 = this.knots[knotIndex0];
        const u1 = this.knots[knotIndex0 + 1];
        // ah = 1/(u1-u0)      is the derivative of fraction0
        // (-ah) is the derivative of fraction1.
        let ah = 1.0 / (u1 - u0);
        f[1] = (u - u0) * ah;
        f[0] = 1.0 - f[1];
        df[0] = -ah;
        df[1] = ah;
        if (ddf) { // first derivative started constant, second derivative started zero.
            ddf[0] = 0.0;
            ddf[1] = 0.0;
        }
        if (this.degree < 2)
            return;
        for (let depth = 1; depth < this.degree; depth++) {
            let kLeft = knotIndex0 - depth;
            let kRight = kLeft + depth + 1;
            let gCarry = 0.0;
            let dgCarry = 0.0;
            let ddgCarry = 0.0;
            // f, df, ddf, are each row vectors with product of `step` ilnear terms.
            // f is multiplied on the right by matrix V.  Each row has 2 nonzero entries (which sum to 1)  (0,0,1-fraction, fraction,0,0,0)
            //    Each row of the derivative dV is two entries (0,0, -1/h, 1/h,0,0,0)
            // Hence fnew = f * V
            //      dfnew = df * V + f * dV
            //      ddfnew = ddf * V + df*dV + df * dV + f * ddV
            // but ddV is zero so
            //      ddfnew = ddf * V + 2 * df * dV
            for (let step = 0; step <= depth; step++) {
                const tLeft = this.knots[kLeft++];
                const tRight = this.knots[kRight++];
                ah = 1.0 / (tRight - tLeft);
                const fraction = (u - tLeft) * ah;
                const fraction1 = 1.0 - fraction;
                const g1 = f[step] * fraction;
                const g0 = f[step] * fraction1;
                const dg1 = df[step] * fraction + f[step] * ah;
                const dg0 = df[step] * fraction1 - f[step] * ah;
                const dfSave = 2.0 * df[step] * ah;
                f[step] = gCarry + g0;
                df[step] = dgCarry + dg0;
                gCarry = g1;
                dgCarry = dg1;
                if (ddf) { // do the backward reference to df before rewriting df !!!
                    const ddg1 = ddf[step] * fraction + dfSave;
                    const ddg0 = ddf[step] * fraction1 - dfSave;
                    ddf[step] = ddgCarry + ddg0;
                    ddgCarry = ddg1;
                }
            }
            f[depth + 1] = gCarry;
            df[depth + 1] = dgCarry;
            if (ddf)
                ddf[depth + 1] = ddgCarry;
        }
    }
    knotToLeftKnotIndex(u) {
        // Anything to left is in the first span . .
        const firstLeftKnot = this.degree - 1;
        if (u < this.knots[firstLeftKnot + 1])
            return firstLeftKnot;
        // Anything to right is in the last span ...
        const lastLeftKnot = this.knots.length - this.degree - 1;
        if (u >= this.knots.length - this.degree)
            return this.knots[lastLeftKnot];
        // ugh ... linear search ...
        for (let i = firstLeftKnot + 1; i < lastLeftKnot; i++)
            if (u < this.knots[i + 1])
                return i; // testing against right side skips over multiple knot cases???
        return lastLeftKnot;
    }
    /**
     * Given a span index, return the index of the knot at its left.
     * @param spanIndex index of span
     */
    spanIndexToLeftKnotIndex(spanIndex) {
        const d = this.degree;
        if (spanIndex <= 0.0)
            return d - 1;
        return Math.min(spanIndex + d - 1, this.knots.length - d);
    }
    spanIndexToSpanLength(spanIndex) {
        const k = this.spanIndexToLeftKnotIndex(spanIndex);
        return this.knots[k + 1] - this.knots[k];
    }
    /**
     * Given a span index, test if it is withn range and has nonzero length.
     * * note that a false return does not imply there are no more spans.  This may be a double knot (zero length span) followed by more real spans
     * @param spanIndex index of span to test.
     */
    isIndexOfRealSpan(spanIndex) {
        if (spanIndex >= 0 && spanIndex < this.knots.length - this.degree)
            return !Geometry_1.Geometry.isSmallMetricDistance(this.spanIndexToSpanLength(spanIndex));
        return false;
    }
    reflectKnots() {
        const a = this.leftKnot;
        const b = this.rightKnot;
        const numKnots = this.knots.length;
        for (let i = 0; i < numKnots; i++)
            this.knots[i] = a + (b - this.knots[i]);
        this.knots.reverse();
    }
    /**
     * return a simple array form of the knots.  optionally replicate the first and last
     * in classic over-clamped manner
     */
    copyKnots(includeExtraEndKnot) {
        const wrap = this.wrappable && this.testClosable();
        const leftIndex = this.leftKnotIndex;
        const rightIndex = this.rightKnotIndex;
        const a0 = this.leftKnot;
        const a1 = this.rightKnot;
        const delta = a1 - a0;
        const degree = this.degree;
        const values = [];
        if (includeExtraEndKnot) {
            if (wrap) {
                values.push(this.knots[rightIndex - degree] - delta);
            }
            else {
                values.push(this.knots[0]);
            }
        }
        for (const u of this.knots)
            values.push(u);
        if (includeExtraEndKnot) {
            if (wrap) {
                values.push(this.knots[leftIndex + degree] + delta);
            }
            else
                values.push(values[values.length - 1]);
        }
        return values;
    }
}
KnotVector.knotTolerance = 1.0e-9;
exports.KnotVector = KnotVector;


/***/ }),

/***/ "./lib/clipping/ClipPlane.js":
/*!***********************************!*\
  !*** ./lib/clipping/ClipPlane.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Point4d_1 = __webpack_require__(/*! ../geometry4d/Point4d */ "./lib/geometry4d/Point4d.js");
const Plane3dByOriginAndUnitNormal_1 = __webpack_require__(/*! ../geometry3d/Plane3dByOriginAndUnitNormal */ "./lib/geometry3d/Plane3dByOriginAndUnitNormal.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const GrowableFloat64Array_1 = __webpack_require__(/*! ../geometry3d/GrowableFloat64Array */ "./lib/geometry3d/GrowableFloat64Array.js");
const Polynomials_1 = __webpack_require__(/*! ../numerics/Polynomials */ "./lib/numerics/Polynomials.js");
const ClipUtils_1 = __webpack_require__(/*! ./ClipUtils */ "./lib/clipping/ClipUtils.js");
/** A ClipPlane is a single plane represented as
 * * An inward unit normal (u,v,w)
 * * A signedDistance
 *
 * Hence
 * * The halfspace function evaluation for "point" [x,y,z,] is: ([x,y,z] DOT (u,v,w)l - signedDistance)
 * * POSITIVE values of the halfspace function are "inside"
 * * ZERO value of the halfspace function is "on"
 * * NEGATIVE value of the halfspace function is "outside"
 * * A representative point on the plane is (signedDistance*u, signedDistance * v, signedDistance *w)
 */
class ClipPlane {
    constructor(normal, distance, invisible, interior) {
        this._invisible = invisible;
        this._interior = interior;
        this._inwardNormal = normal;
        this._distanceFromOrigin = distance;
    }
    /**
     * @returns Return true if all members are almostEqual to corresponding members of other.
     * @param other clip plane to compare
     */
    isAlmostEqual(other) {
        return Geometry_1.Geometry.isSameCoordinate(this._distanceFromOrigin, other._distanceFromOrigin)
            && this._inwardNormal.isAlmostEqual(other._inwardNormal)
            && this._interior === other._interior
            && this._invisible === other._invisible;
    }
    /** @return a cloned plane */
    clone() {
        const result = new ClipPlane(this._inwardNormal.clone(), this._distanceFromOrigin, this._invisible, this._interior);
        return result;
    }
    /** @return Return a cloned plane with coordinate data negated. */
    cloneNegated() {
        const plane = new ClipPlane(this._inwardNormal.clone(), this._distanceFromOrigin, this._invisible, this._interior);
        plane.negateInPlace();
        return plane;
    }
    /** Create a ClipPlane from Plane3dByOriginAndUnitNormal. */
    static createPlane(plane, invisible = false, interior = false, result) {
        const distance = plane.getNormalRef().dotProduct(plane.getOriginRef());
        if (result) {
            result._invisible = invisible;
            result._interior = interior;
            result._inwardNormal = plane.getNormalRef().clone();
            result._distanceFromOrigin = distance;
            return result;
        }
        return new ClipPlane(plane.getNormalRef().clone(), distance, invisible, interior);
    }
    /**
     * * Create a ClipPlane with direct normal and signedDistance.
     * * The vector is normalized for storage.
     */
    static createNormalAndDistance(normal, distance, invisible = false, interior = false, result) {
        const normalized = normal.normalize();
        if (normalized) {
            if (result) {
                result._invisible = invisible;
                result._interior = interior;
                result._inwardNormal = normalized;
                result._distanceFromOrigin = distance;
            }
            return new ClipPlane(normalized, distance, invisible, interior);
        }
        return undefined;
    }
    /** Create a ClipPlane
     * * "normal" is the inward normal of the plane. (It is internally normalized)
     * * "point" is any point of the plane.
     * * The stored distance for the plane is the dot product of the point with the normal (i.e. treat the point's xyz as a vector from the origin.)
     */
    static createNormalAndPoint(normal, point, invisible = false, interior = false, result) {
        const normalized = normal.normalize();
        if (normalized) {
            const distance = normalized.dotProduct(point);
            if (result) {
                result._invisible = invisible;
                result._interior = interior;
                result._inwardNormal = normalized;
                result._distanceFromOrigin = distance;
            }
            return new ClipPlane(normalized, distance, invisible, interior);
        }
        return undefined;
    }
    /** Create a ClipPlane
     * * "normal" is the inward normal of the plane. (It is internally normalized)
     * * "point" is any point of the plane.
     * * The stored distance for the plane is the dot product of the point with the normal (i.e. treat the point's xyz as a vector from the origin.)
     */
    static createNormalAndPointXYZXYZ(normalX, normalY, normalZ, originX, originY, originZ, invisible = false, interior = false) {
        const normal = Point3dVector3d_1.Vector3d.create(normalX, normalY, normalZ);
        const normalized = normal.normalizeInPlace();
        if (normalized) {
            const distance = normal.dotProductXYZ(originX, originY, originZ);
            return new ClipPlane(normal, distance, invisible, interior);
        }
        return undefined;
    }
    /**
     * return a json object of the form
     * `{"normal":[u,v,w],"dist":signedDistanceValue,"interior":true,"invisible":true}`
     */
    toJSON() {
        const val = {};
        val.normal = this.inwardNormalRef.toJSON();
        val.dist = this.distance;
        if (this.interior)
            val.interior = true;
        if (this.invisible)
            val.invisible = true;
        return val;
    }
    static fromJSON(json, result) {
        if (json && json.normal && Number.isFinite(json.dist)) {
            return ClipPlane.createNormalAndDistance(Point3dVector3d_1.Vector3d.fromJSON(json.normal), json.dist, !!json.invisible, !!json.interior);
        }
        return ClipPlane.createNormalAndDistance(Point3dVector3d_1.Vector3d.unitZ(), 0, false, false, result);
    }
    setFlags(invisible, interior) {
        this._invisible = invisible;
        this._interior = interior;
    }
    // Getters
    get distance() { return this._distanceFromOrigin; }
    get inwardNormalRef() { return this._inwardNormal; }
    get interior() { return this._interior; }
    get invisible() { return this._invisible; }
    static createEdgeAndUpVector(point0, point1, upVector, tiltAngle, result) {
        const edgeVector = Point3dVector3d_1.Vector3d.createFrom(point1.minus(point0));
        let normal = (upVector.crossProduct(edgeVector)).normalize();
        if (normal) {
            if (!tiltAngle.isAlmostZero) {
                const tiltNormal = Point3dVector3d_1.Vector3d.createRotateVectorAroundVector(normal, edgeVector, tiltAngle);
                if (tiltNormal) {
                    normal = tiltNormal.clone();
                }
            }
            normal.negate(normal);
            return ClipPlane.createNormalAndPoint(normal, point0, false, false, result);
        }
        return undefined;
    }
    static createEdgeXY(point0, point1, result) {
        const normal = Point3dVector3d_1.Vector3d.create(point0.y - point1.y, point1.x - point0.x);
        if (normal.normalizeInPlace())
            return ClipPlane.createNormalAndPoint(normal, point0, false, false, result);
        return undefined;
    }
    getPlane3d() {
        const d = this._distanceFromOrigin;
        // Normal should be normalized, will not return undefined
        return Plane3dByOriginAndUnitNormal_1.Plane3dByOriginAndUnitNormal.create(Point3dVector3d_1.Point3d.create(this._inwardNormal.x * d, this._inwardNormal.y * d, this._inwardNormal.z * d), this._inwardNormal);
    }
    getPlane4d() {
        return Point4d_1.Point4d.create(this._inwardNormal.x, this._inwardNormal.y, this._inwardNormal.z, -this._distanceFromOrigin);
    }
    setPlane4d(plane) {
        const a = Math.sqrt(plane.x * plane.x + plane.y * plane.y + plane.z * plane.z);
        const r = a === 0.0 ? 1.0 : 1.0 / a;
        this._inwardNormal.x = r * plane.x;
        this._inwardNormal.y = r * plane.y;
        this._inwardNormal.z = r * plane.z;
        this._distanceFromOrigin = -r * plane.w;
    }
    evaluatePoint(point) {
        return point.x * this._inwardNormal.x + point.y * this._inwardNormal.y + point.z * this._inwardNormal.z - this._distanceFromOrigin;
    }
    /** @returns return the dot product of the plane normal with the vector (NOT using the plane's distanceFromOrigin).
     */
    dotProductVector(vector) {
        return vector.x * this._inwardNormal.x + vector.y * this._inwardNormal.y + vector.z * this._inwardNormal.z;
    }
    /** @returns return the dot product of the plane normal with the point (treating the point xyz as a vector, and NOT using the plane's distanceFromOrigin).
     */
    dotProductPlaneNormalPoint(point) {
        return point.x * this._inwardNormal.x + point.y * this._inwardNormal.y + point.z * this._inwardNormal.z;
    }
    isPointOnOrInside(point, tolerance) {
        let value = this.evaluatePoint(point);
        if (tolerance) {
            value += tolerance;
        }
        return value >= 0.0;
    }
    isPointInside(point, tolerance) {
        let value = this.evaluatePoint(point);
        if (tolerance) {
            value += tolerance;
        }
        return value > 0.0;
    }
    isPointOn(point, tolerance = Geometry_1.Geometry.smallMetricDistance) {
        return Math.abs(this.evaluatePoint(point)) <= tolerance;
    }
    appendIntersectionRadians(arc, intersectionRadians) {
        const arcVectors = arc.toVectors();
        const alpha = this.evaluatePoint(arc.center);
        const beta = this.dotProductVector(arcVectors.vector0);
        const gamma = this.dotProductVector(arcVectors.vector90);
        Polynomials_1.AnalyticRoots.appendImplicitLineUnitCircleIntersections(alpha, beta, gamma, undefined, undefined, intersectionRadians);
    }
    announceClippedArcIntervals(arc, announce) {
        const breaks = ClipPlane._clipArcFractionArray;
        breaks.clear();
        this.appendIntersectionRadians(arc, breaks);
        arc.sweep.radiansArraytoPositivePeriodicFractions(breaks);
        return ClipUtils_1.ClipUtilities.selectIntervals01(arc, breaks, this, announce);
    }
    /**
     * * Compute intersection of (unbounded) segment with the plane.
     * * If the ends are on the same side of the plane, return undefined.
     * * If the intersection is an endpoint or interior to the segment return the fraction.
     * * If both ends are on, return undefined.
     */
    getBoundedSegmentSimpleIntersection(pointA, pointB) {
        const h0 = this.evaluatePoint(pointA);
        const h1 = this.evaluatePoint(pointB);
        if (h0 * h1 > 0.0)
            return undefined;
        if (h0 === 0.0 && h1 === 0.0) {
            return undefined;
        }
        return -h0 / (h1 - h0);
    }
    // Returns true if successful
    transformInPlace(transform) {
        const plane = this.getPlane3d();
        const matrix = transform.matrix;
        const newPoint = transform.multiplyPoint3d(plane.getOriginRef());
        // Normal transforms as the inverse transpose of the matrix part
        // BTW: If the matrix is orthogonal, this is a long way to multiply by the matrix part (mumble grumble)
        const newNormal = matrix.multiplyInverseTranspose(plane.getNormalRef());
        if (!newNormal)
            return false;
        plane.set(newPoint, newNormal);
        const normalized = (plane.getNormalRef()).normalize();
        if (!normalized)
            return false;
        this._inwardNormal = normalized;
        this._distanceFromOrigin = this._inwardNormal.dotProduct(plane.getOriginRef());
        return true;
    }
    setInvisible(invisible) {
        this._invisible = invisible;
    }
    /**  reverse the sign of all coefficients, so outside and inside reverse */
    negateInPlace() {
        this._inwardNormal = this._inwardNormal.negate();
        this._distanceFromOrigin = -this._distanceFromOrigin;
    }
    /**
     * Move the plane INWARD by given distance
     * @param offset distance of shift inwards
     */
    offsetDistance(offset) {
        this._distanceFromOrigin += offset;
    }
    convexPolygonClipInPlace(xyz, work) {
        work.length = 0;
        let numNegative = 0;
        ClipPlane.fractionTol = 1.0e-8;
        if (xyz.length > 2) {
            let xyz0 = xyz[xyz.length - 1];
            let a0 = this.evaluatePoint(xyz0);
            //    if (a0 >= 0.0)
            //      work.push_back (xyz0);
            for (const xyz1 of xyz) {
                const a1 = this.evaluatePoint(xyz1);
                if (a1 < 0)
                    numNegative++;
                if (a0 * a1 < 0.0) {
                    // simple crossing . . .
                    const f = -a0 / (a1 - a0);
                    if (f > 1.0 - ClipPlane.fractionTol && a1 >= 0.0) {
                        // the endpoint will be saved -- avoid the duplicate
                    }
                    else {
                        work.push(xyz0.interpolate(f, xyz1));
                    }
                }
                if (a1 >= 0.0)
                    work.push(xyz1);
                xyz0 = Point3dVector3d_1.Point3d.createFrom(xyz1);
                a0 = a1;
            }
        }
        if (work.length <= 2) {
            xyz.length = 0;
        }
        else if (numNegative > 0) {
            xyz.length = 0;
            for (const xyzi of work) {
                xyz.push(xyzi);
            }
            work.length = 0;
        }
    }
    polygonCrossings(xyz, crossings) {
        crossings.length = 0;
        if (xyz.length >= 2) {
            let xyz0 = xyz[xyz.length - 1];
            let a0 = this.evaluatePoint(xyz0);
            for (const xyz1 of xyz) {
                const a1 = this.evaluatePoint(xyz1);
                if (a0 * a1 < 0.0) {
                    // simple crossing. . .
                    const f = -a0 / (a1 - a0);
                    crossings.push(xyz0.interpolate(f, xyz1));
                }
                if (a1 === 0.0) { // IMPORTANT -- every point is directly tested here
                    crossings.push(xyz1);
                }
                xyz0 = Point3dVector3d_1.Point3d.createFrom(xyz1);
                a0 = a1;
            }
        }
    }
    convexPolygonSplitInsideOutside(xyz, xyzIn, xyzOut, altitudeRange) {
        xyzOut.length = 0;
        xyzIn.length = 0;
        // let numSplit = 0;
        ClipPlane.fractionTol = 1.0e-8;
        if (xyz.length > 2) {
            let xyz0 = xyz[xyz.length - 1];
            altitudeRange.setNull();
            let a0 = this.evaluatePoint(xyz0);
            altitudeRange.extendX(a0);
            //    if (a0 >= 0.0)
            //      work.push_back (xyz0);
            for (const xyz1 of xyz) {
                const a1 = this.evaluatePoint(xyz1);
                altitudeRange.extendX(a1);
                let nearZero = false;
                if (a0 * a1 < 0.0) {
                    // simple crossing. . .
                    const f = -a0 / (a1 - a0);
                    if (f > 1.0 - ClipPlane.fractionTol && a1 >= 0.0) {
                        // the endpoint will be saved -- avoid the duplicate
                        nearZero = true;
                    }
                    else {
                        const xyzA = xyz0.interpolate(f, xyz1);
                        xyzIn.push(xyzA);
                        xyzOut.push(xyzA);
                    }
                    // numSplit++;
                }
                if (a1 >= 0.0 || nearZero)
                    xyzIn.push(xyz1);
                if (a1 <= 0.0 || nearZero)
                    xyzOut.push(xyz1);
                xyz0 = Point3dVector3d_1.Point3d.createFrom(xyz1);
                a0 = a1;
            }
        }
    }
    multiplyPlaneByMatrix(matrix) {
        const plane = this.getPlane4d();
        matrix.multiplyTransposePoint4d(plane, plane);
        this.setPlane4d(plane);
    }
    /** announce the interval (if any) where a line is within the clip plane half space. */
    announceClippedSegmentIntervals(f0, f1, pointA, pointB, announce) {
        if (f1 < f0)
            return false;
        const h0 = -this.evaluatePoint(pointA);
        const h1 = -this.evaluatePoint(pointB);
        const delta = h1 - h0;
        const f = Geometry_1.Geometry.conditionalDivideFraction(-h0, delta);
        if (f === undefined) { // The segment is parallel to the plane.
            if (h0 <= 0.0) {
                if (announce)
                    announce(f0, f1);
                return true;
            }
            return false;
        }
        if (delta > 0) { // segment aims OUT
            if (f < f1)
                f1 = f;
        }
        else {
            // segment aims IN
            if (f > f0)
                f0 = f;
        }
        if (f1 < f0)
            return false;
        if (announce)
            announce(f0, f1);
        return true;
    }
}
// Static variable from original native c++ function ConvexPolygonClipInPlace
ClipPlane.fractionTol = 1.0e-8;
ClipPlane._clipArcFractionArray = new GrowableFloat64Array_1.GrowableFloat64Array();
exports.ClipPlane = ClipPlane;


/***/ }),

/***/ "./lib/clipping/ClipPrimitive.js":
/*!***************************************!*\
  !*** ./lib/clipping/ClipPrimitive.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
const ClipPlane_1 = __webpack_require__(/*! ./ClipPlane */ "./lib/clipping/ClipPlane.js");
const ConvexClipPlaneSet_1 = __webpack_require__(/*! ./ConvexClipPlaneSet */ "./lib/clipping/ConvexClipPlaneSet.js");
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Range_1 = __webpack_require__(/*! ../geometry3d/Range */ "./lib/geometry3d/Range.js");
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const PointHelpers_1 = __webpack_require__(/*! ../geometry3d/PointHelpers */ "./lib/geometry3d/PointHelpers.js");
const UnionOfConvexClipPlaneSets_1 = __webpack_require__(/*! ./UnionOfConvexClipPlaneSets */ "./lib/clipping/UnionOfConvexClipPlaneSets.js");
const Triangulation_1 = __webpack_require__(/*! ../topology/Triangulation */ "./lib/topology/Triangulation.js");
/**
 * Bit mask type for easily keeping track of defined vs undefined values and which parts of a clipping shape
 * should or should not be used.
 */
var ClipMask;
(function (ClipMask) {
    ClipMask[ClipMask["None"] = 0] = "None";
    ClipMask[ClipMask["XLow"] = 1] = "XLow";
    ClipMask[ClipMask["XHigh"] = 2] = "XHigh";
    ClipMask[ClipMask["YLow"] = 4] = "YLow";
    ClipMask[ClipMask["YHigh"] = 8] = "YHigh";
    ClipMask[ClipMask["ZLow"] = 16] = "ZLow";
    ClipMask[ClipMask["ZHigh"] = 32] = "ZHigh";
    ClipMask[ClipMask["XAndY"] = 15] = "XAndY";
    ClipMask[ClipMask["All"] = 63] = "All";
})(ClipMask = exports.ClipMask || (exports.ClipMask = {}));
/** Internal helper class holding XYZ components that serves as a representation of polygon edges defined by clip planes */
class PolyEdge {
    constructor(origin, next, normal, z) {
        this.origin = Point3dVector3d_1.Point3d.create(origin.x, origin.y, z);
        this.next = Point3dVector3d_1.Point3d.create(next.x, next.y, z);
        this.normal = normal;
    }
}
/**
 * Cache structure that holds a ClipPlaneSet and various parameters for adding new ClipPlanes to the set. This structure
 * will typically be fed to an additive function that will append new ClipPlanes to the cache based on these parameters.
 */
class PlaneSetParamsCache {
    constructor(zLow, zHigh, localOrigin, isMask = false, isInvisible = false, focalLength = 0.0) {
        this.clipPlaneSet = UnionOfConvexClipPlaneSets_1.UnionOfConvexClipPlaneSets.createEmpty();
        this.zLow = zLow;
        this.zHigh = zHigh;
        this.isMask = isMask;
        this.invisible = isInvisible;
        this.focalLength = focalLength;
        this.limitValue = 0;
        this.localOrigin = localOrigin ? localOrigin : Point3dVector3d_1.Point3d.create();
    }
}
exports.PlaneSetParamsCache = PlaneSetParamsCache;
/** Base class for clipping implementations that use
 *
 * * A ClipPlaneSet designated "clipPlanes"
 * * A ClipPlaneSet designated "maskPlanes"
 * * an "invisible" flag
 */
class ClipPrimitive {
    constructor(planeSet, isInvisible = false) {
        this._clipPlanes = planeSet;
        this._invisible = isInvisible;
    }
    /** Apply a transform to the clipper (e.g. transform all planes) */
    transformInPlace(transform) {
        if (this._clipPlanes)
            this._clipPlanes.transformInPlace(transform);
        if (this._maskPlanes)
            this._maskPlanes.transformInPlace(transform);
        return true;
    }
    /** Sets both the clip plane set and the mask set visibility */
    setInvisible(invisible) {
        this._invisible = invisible;
        if (this._clipPlanes)
            this._clipPlanes.setInvisible(invisible);
        if (this._maskPlanes)
            this._maskPlanes.setInvisible(invisible);
    }
    containsZClip() {
        if (this.fetchClipPlanesRef() !== undefined)
            for (const convexSet of this._clipPlanes.convexSets)
                for (const plane of convexSet.planes)
                    if (Math.abs(plane.inwardNormalRef.z) > 1.0e-6 && Math.abs(plane.distance) !== Number.MAX_VALUE)
                        return true;
        return false;
    }
    /**
     * Determines whether the given points fall inside or outside the set. If this set is defined by masking planes,
     * will check the mask planes only, provided that ignoreMasks is false. Otherwise, will check the clipplanes member.
     */
    classifyPointContainment(points, ignoreMasks) {
        if (this.fetchMaskPlanesRef() !== undefined) {
            if (ignoreMasks)
                return 1 /* StronglyInside */;
            switch (this._maskPlanes.classifyPointContainment(points, true)) {
                case 1 /* StronglyInside */:
                    return 3 /* StronglyOutside */;
                case 3 /* StronglyOutside */:
                    return 1 /* StronglyInside */;
                case 2 /* Ambiguous */:
                    return 2 /* Ambiguous */;
            }
        }
        return (this.fetchClipPlanesRef() === undefined) ? 1 /* StronglyInside */ : this._clipPlanes.classifyPointContainment(points, false);
    }
    static isLimitEdge(limitValue, point0, point1) {
        const tol = 1.0e-5 * limitValue;
        // High x-limit...
        if (Math.abs(point0.x - limitValue) < tol && Math.abs(point1.x - limitValue) < tol)
            return true;
        // Low x-limit...
        if (Math.abs(point0.x + limitValue) < tol && Math.abs(point1.x + limitValue) < tol)
            return true;
        // high y limit ...
        if (Math.abs(point0.y - limitValue) < tol && Math.abs(point1.y - limitValue) < tol)
            return true;
        // low y limit ...
        if (Math.abs(point0.y + limitValue) < tol && Math.abs(point1.y + limitValue) < tol)
            return true;
        return false;
    }
    /** Add an unbounded plane set (a) to the right of the line defined by two points, and (b) "ahead" of
     *  the start point (set is pushed to the set located within the PlaneSetParamsCache object given). This method can be used
     *  in the development of ClipShapes, by ClipShapes.
     */
    static addOutsideEdgeSetToParams(x0, y0, x1, y1, pParams, isInvisible = false) {
        const unit0 = Point3dVector3d_1.Vector3d.create();
        const vec0 = Point3dVector3d_1.Vector3d.create(x1 - x0, y1 - y0, 0.0);
        const point0 = Point3dVector3d_1.Point3d.create(x0 + pParams.localOrigin.x, y0 + pParams.localOrigin.y, 0.0);
        vec0.normalize(unit0);
        const unit1 = Point3dVector3d_1.Vector3d.create(unit0.y, -unit0.x, 0.0);
        const convexSet = ConvexClipPlaneSet_1.ConvexClipPlaneSet.createEmpty();
        convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndPoint(unit1, point0, isInvisible));
        convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndPoint(unit0, point0, isInvisible));
        convexSet.addZClipPlanes(isInvisible, pParams.zLow, pParams.zHigh);
        pParams.clipPlaneSet.convexSets.push(convexSet);
    }
    /**
     * Add a plane set representative of a 3d object based on the given array of 2d points and 3d parameters of the PlaneSetParamsCache,
     * where the returned value is stored in the params object given. The original points array given is not modified. This method
     * can be used in the development of ClipShapes, by ClipShapes.
     */
    static addShapeToParams(shape, pFlags, pParams) {
        const pPoints = shape.slice(0);
        // Add the closure point
        if (!pPoints[0].isExactEqual(pPoints[pPoints.length - 1]))
            pPoints.push(pPoints[0].clone());
        const area = PointHelpers_1.PolygonOps.areaXY(pPoints);
        const n = pPoints.length;
        const point0 = Point3dVector3d_1.Point3d.create();
        const point1 = Point3dVector3d_1.Point3d.create();
        const vector0 = Point3dVector3d_1.Vector3d.create();
        const vector1 = Point3dVector3d_1.Vector3d.create();
        const point0Local = Point3dVector3d_1.Point3d.create();
        let point1Local = Point3dVector3d_1.Point3d.create();
        const zVector = Point3dVector3d_1.Vector3d.create(0, 0, 1);
        let normal;
        let tangent;
        const convexSet = ConvexClipPlaneSet_1.ConvexClipPlaneSet.createEmpty();
        const reverse = area < 0.0;
        for (let i = 0; i < n; i++, point0.setFrom(point1), point0Local.setFrom(point1Local)) {
            point1Local = pPoints[i % n];
            point1Local.plus(pParams.localOrigin, point1);
            if (i && !point1.isAlmostEqual(point0, 1.0e-8)) {
                const bIsLimitPlane = ClipPrimitive.isLimitEdge(pParams.limitValue, point0Local, point1Local);
                const isInterior = (0 === (pFlags[i - 1] & 1)) || bIsLimitPlane;
                if (!pParams.focalLength) {
                    tangent = Point3dVector3d_1.Vector3d.createFrom(point1.minus(point0));
                    normal = zVector.crossProduct(tangent).normalize(); // Assumes that cross product is never zero vector
                    if (reverse)
                        normal.negate(normal);
                    convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndPoint(normal, point0, pParams.invisible, isInterior));
                }
                else {
                    vector1.setFrom(point1);
                    vector0.setFrom(point0);
                    normal = vector1.crossProduct(vector0).normalize();
                    if (reverse)
                        normal.negate();
                    convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndDistance(normal, 0.0, pParams.invisible, isInterior));
                }
            }
        }
        convexSet.addZClipPlanes(pParams.invisible, pParams.zLow, pParams.zHigh);
        if (convexSet.planes.length !== 0)
            pParams.clipPlaneSet.convexSets.push(convexSet);
    }
}
exports.ClipPrimitive = ClipPrimitive;
/**
 * A clipping volume defined by a shape (an array of 3d points using only x and y dimensions).
 * May be given either a ClipPlaneSet to store directly, or an array of polygon points as well as other parameters
 * for parsing clipplanes from the shape later.
 */
class ClipShape extends ClipPrimitive {
    constructor(polygon = [], zLow, zHigh, transform, isMask = false, invisible = false) {
        super(undefined, invisible); // ClipPlaneSets will be set up later after storing points
        this._isMask = false;
        this._zLowValid = false;
        this._zHighValid = false;
        this._transformValid = false;
        this._polygon = polygon;
        this.initSecondaryProps(isMask, zLow, zHigh, transform);
    }
    /** Returns true if this ClipShape is marked as invisible. */
    get invisible() { return this._invisible; }
    /** Return this transformFromClip, which may be undefined. */
    get transformFromClip() { return this._transformFromClip; }
    /** Return this transformToClip, which may be undefined. */
    get transformToClip() { return this._transformToClip; }
    /** Returns true if this ClipShape's transforms are currently set. */
    get transformValid() { return this._transformValid; }
    /** Returns true if this ClipShape's lower z boundary is set. */
    get zLowValid() { return this._zLowValid; }
    /** Returns true if this ClipShape's upper z boundary is set. */
    get zHighValid() { return this._zHighValid; }
    /** Return this zLow, which may be undefined. */
    get zLow() { return this._zLow; }
    /** Return this zHigh, which may be undefined. */
    get zHigh() { return this._zHigh; }
    /** Returns a reference to this ClipShape's polygon array. */
    get polygon() { return this._polygon; }
    /** Return this bspline curve, which may be undefined. */
    get bCurve() { return this._bCurve; }
    /** Returns true if this ClipShape is a masking set. */
    get isMask() { return this._isMask; }
    /**
     * Returns true if this ClipShape has been parsed, and currently contains a ClipPlaneSet in its cache.
     * This does not take into account validity of the ClipPlanes, given that the polygon array might have changed.
     */
    arePlanesDefined() {
        if (this._isMask)
            return this._maskPlanes !== undefined;
        return this._clipPlanes !== undefined;
    }
    /** Sets the polygon points array of this ClipShape to the array given (by reference). */
    setPolygon(polygon) {
        // Add closure point
        if (!polygon[0].isAlmostEqual(polygon[polygon.length - 1]))
            polygon.push(polygon[0].clone());
        this._polygon = polygon;
    }
    /**
     * If the clip plane set is already stored, return it. Otherwise, parse the clip planes out of the shape
     * defined by the set of polygon points.
     */
    fetchClipPlanesRef() {
        if (this._clipPlanes !== undefined)
            return this._clipPlanes;
        this._clipPlanes = UnionOfConvexClipPlaneSets_1.UnionOfConvexClipPlaneSets.createEmpty();
        this.parseClipPlanes(this._clipPlanes);
        if (this._transformValid)
            this._clipPlanes.transformInPlace(this._transformFromClip);
        return this._clipPlanes;
    }
    /**
     * If the masking clip plane set is already stored, return it. Otherwise, parse the mask clip planes out of the shape
     * defined by the set of polygon points.
     */
    fetchMaskPlanesRef() {
        if (!this._isMask)
            return undefined;
        if (this._maskPlanes !== undefined)
            return this._maskPlanes;
        this._maskPlanes = UnionOfConvexClipPlaneSets_1.UnionOfConvexClipPlaneSets.createEmpty();
        this.parseClipPlanes(this._maskPlanes);
        if (this._transformValid)
            this._maskPlanes.transformInPlace(this._transformFromClip);
        return this._maskPlanes;
    }
    /**
     * Initialize the members of the ClipShape class that may at times be undefined.
     * zLow and zHigh default to Number.MAX_VALUE, and the transform defaults to an identity transform
     */
    initSecondaryProps(isMask, zLow, zHigh, transform) {
        this._isMask = isMask;
        this._zLowValid = (zLow !== undefined);
        this._zLow = zLow;
        this._zHighValid = (zHigh !== undefined);
        this._zHigh = zHigh;
        this._transformValid = (transform !== undefined);
        if (false !== this._transformValid) {
            this._transformFromClip = transform;
            this._transformToClip = transform.inverse(); // could be undefined
        }
        else {
            this._transformFromClip = Transform_1.Transform.createIdentity();
            this._transformToClip = Transform_1.Transform.createIdentity();
        }
    }
    toJSON() {
        const val = {};
        val.shape = {};
        val.shape.points = [];
        for (const pt of this._polygon)
            val.shape.points.push(pt.toJSON());
        if (this.invisible)
            val.shape.invisible = true;
        if (this._transformFromClip && !this._transformFromClip.isIdentity)
            val.shape.trans = this._transformFromClip.toJSON();
        if (this.isMask)
            val.shape.mask = true;
        if (typeof (this.zLow) !== "undefined" && this.zLow !== -Number.MAX_VALUE)
            val.shape.zlow = this.zLow;
        if (typeof (this.zHigh) !== "undefined" && this.zHigh !== Number.MAX_VALUE)
            val.shape.zhigh = this.zHigh;
        return val;
    }
    static fromJSON(json, result) {
        if (!json.shape)
            return undefined;
        const points = [];
        if (json.shape.points)
            for (const pt of json.shape.points)
                points.push(Point3dVector3d_1.Point3d.fromJSON(pt));
        let trans;
        if (json.shape.trans)
            trans = Transform_1.Transform.fromJSON(json.shape.trans);
        let zLow;
        if (json.shape.zlow)
            zLow = json.shape.zlow;
        let zHigh;
        if (json.shape.zhigh)
            zHigh = json.shape.zhigh;
        let isMask = false;
        if (json.shape.mask)
            isMask = json.shape.mask;
        let invisible = false;
        if (json.shape.invisible)
            invisible = true;
        return ClipShape.createShape(points, zLow, zHigh, trans, isMask, invisible, result);
    }
    /** Returns a new ClipShape that is a deep copy of the ClipShape given */
    static createFrom(other, result) {
        const retVal = ClipShape.createEmpty(false, false, undefined, result);
        retVal._invisible = other._invisible;
        for (const point of other._polygon) {
            retVal._polygon.push(point.clone());
        }
        retVal._isMask = other._isMask;
        retVal._zLow = other._zLow;
        retVal._zHigh = other._zHigh;
        retVal._zLowValid = other._zLowValid;
        retVal._zHighValid = other._zHighValid;
        retVal._transformValid = other._transformValid;
        retVal._transformToClip = other._transformToClip ? other._transformToClip.clone() : undefined;
        retVal._transformFromClip = other._transformFromClip ? other._transformFromClip.clone() : undefined;
        retVal._bCurve = other._bCurve ? other._bCurve.clone() : undefined;
        // TODO: COPY _gpa AS WELL, ONCE IT IS IMPLEMENTED
        return retVal;
    }
    /** Create a new ClipShape from an array of points that make up a 2d shape (stores a deep copy of these points). */
    static createShape(polygon = [], zLow, zHigh, transform, isMask = false, invisible = false, result) {
        if (polygon.length < 3)
            return undefined;
        const pPoints = polygon.slice(0);
        // Add closure point
        if (!pPoints[0].isExactEqual(pPoints[pPoints.length - 1]))
            pPoints.push(pPoints[0]);
        if (result) {
            result._clipPlanes = undefined; // Start as undefined
            result._maskPlanes = undefined; // Start as undefined
            result._invisible = invisible;
            result._polygon = pPoints;
            result.initSecondaryProps(isMask, zLow, zHigh, transform);
            return result;
        }
        else {
            return new ClipShape(pPoints, zLow, zHigh, transform, isMask, invisible);
        }
    }
    /**
     * Create a ClipShape that exists as a 3 dimensional box of the range given. Optionally choose to
     * also store this shape's zLow and zHigh members from the range through the use of a ClipMask.
     */
    static createBlock(extremities, clipMask, isMask = false, invisible = false, transform, result) {
        const low = extremities.low;
        const high = extremities.high;
        const blockPoints = [];
        for (let i = 0; i < 5; i++)
            blockPoints.push(Point3dVector3d_1.Point3d.create());
        blockPoints[0].x = blockPoints[3].x = blockPoints[4].x = low.x;
        blockPoints[1].x = blockPoints[2].x = high.x;
        blockPoints[0].y = blockPoints[1].y = blockPoints[4].y = low.y;
        blockPoints[2].y = blockPoints[3].y = high.y;
        return ClipShape.createShape(blockPoints, (0 /* None */ !== (clipMask & 16 /* ZLow */)) ? low.z : undefined, 0 /* None */ !== (clipMask & 32 /* ZHigh */) ? high.z : undefined, transform, isMask, invisible, result);
    }
    /** Creates a new ClipShape with undefined members and a polygon points array of zero length. */
    static createEmpty(isMask = false, invisible = false, transform, result) {
        if (result) {
            result._clipPlanes = undefined;
            result._maskPlanes = undefined;
            result._invisible = invisible;
            result._bCurve = undefined;
            result._polygon.length = 0;
            result.initSecondaryProps(isMask, undefined, undefined, transform);
            return result;
        }
        return new ClipShape([], undefined, undefined, transform, isMask, invisible);
    }
    /** Checks to ensure that the member polygon has an area, and that the polygon is closed. */
    get isValidPolygon() {
        if (this._polygon.length < 3)
            return false;
        if (!this._polygon[0].isExactEqual(this._polygon[this._polygon.length - 1]))
            return false;
        return true;
    }
    /** Returns a deep copy of this instance of ClipShape, storing in an optional result */
    clone(result) {
        return ClipShape.createFrom(this, result);
    }
    /** Given the current polygon data, parses clip planes that together form an object, storing the result in the set given, either clipplanes or maskplanes. */
    parseClipPlanes(set) {
        const points = this._polygon;
        if (points.length === 3 && !this._isMask && points[0].isExactEqual(points[points.length - 1])) {
            this.parseLinearPlanes(set, this._polygon[0], this._polygon[1]);
            return true;
        }
        const direction = PointHelpers_1.PolygonOps.testXYPolygonTurningDirections(points);
        if (0 !== direction) {
            this.parseConvexPolygonPlanes(set, this._polygon, direction);
            return true;
        }
        else {
            this.parseConcavePolygonPlanes(set, this._polygon);
            return false;
        }
    }
    /** Given a start and end point, populate the given UnionOfConvexClipPlaneSets with ConvexClipPlaneSets defining the bounded region of linear planes. Returns true if successful. */
    parseLinearPlanes(set, start, end, cameraFocalLength) {
        // Handles the degenerate case of 2 distinct points (used by select by line).
        const normal = start.vectorTo(end);
        if (normal.magnitude() === 0.0)
            return false;
        normal.normalize(normal);
        const convexSet = ConvexClipPlaneSet_1.ConvexClipPlaneSet.createEmpty();
        if (cameraFocalLength === undefined) {
            const perpendicular = Point2dVector2d_1.Vector2d.create(-normal.y, normal.x);
            convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndPoint(Point3dVector3d_1.Vector3d.create(normal.x, normal.y), Point3dVector3d_1.Point3d.createFrom(start), this._invisible));
            convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndPoint(Point3dVector3d_1.Vector3d.create(-normal.x, -normal.y), Point3dVector3d_1.Point3d.createFrom(end), this._invisible));
            convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndPoint(Point3dVector3d_1.Vector3d.create(perpendicular.x, perpendicular.y), Point3dVector3d_1.Point3d.createFrom(start), this._invisible));
            convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndPoint(Point3dVector3d_1.Vector3d.create(-perpendicular.x, -perpendicular.y), Point3dVector3d_1.Point3d.createFrom(start), this._invisible));
        }
        else {
            const start3d = Point3dVector3d_1.Point3d.create(start.x, start.y, -cameraFocalLength);
            const end3d = Point3dVector3d_1.Point3d.create(end.x, end.y, -cameraFocalLength);
            const vecEnd3d = Point3dVector3d_1.Vector3d.createFrom(end3d);
            const perpendicular = vecEnd3d.crossProduct(Point3dVector3d_1.Vector3d.createFrom(start3d)).normalize();
            let endNormal = Point3dVector3d_1.Vector3d.createFrom(start3d).crossProduct(perpendicular).normalize();
            convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndDistance(perpendicular, 0.0, this._invisible));
            convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndDistance(endNormal, 0.0, this._invisible));
            perpendicular.negate();
            endNormal = vecEnd3d.crossProduct(perpendicular).normalize();
            convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndDistance(perpendicular, 0.0, this._invisible));
            convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndDistance(endNormal, 0.0, this._invisible));
        }
        convexSet.addZClipPlanes(this._invisible, this._zLow, this._zHigh);
        set.addConvexSet(convexSet);
        return true;
    }
    /** Given a convex polygon defined as an array of points, populate the given UnionOfConvexClipPlaneSets with ConvexClipPlaneSets defining the bounded region. Returns true if successful. */
    parseConvexPolygonPlanes(set, polygon, direction, cameraFocalLength) {
        const samePointTolerance = 1.0e-8; // This could possibly be replaced with more widely used constants
        const edges = [];
        const reverse = (direction < 0) !== this._isMask;
        for (let i = 0; i < polygon.length - 1; i++) {
            const z = (cameraFocalLength === undefined) ? 0.0 : -cameraFocalLength;
            const dir = Point2dVector2d_1.Vector2d.createFrom((polygon[i + 1].minus(polygon[i])));
            const magnitude = dir.magnitude();
            dir.normalize(dir);
            if (magnitude > samePointTolerance) {
                const normal = Point2dVector2d_1.Vector2d.create(reverse ? dir.y : -dir.y, reverse ? -dir.x : dir.x);
                edges.push(new PolyEdge(polygon[i], polygon[i + 1], normal, z));
            }
        }
        if (edges.length < 3) {
            return false;
        }
        if (this._isMask) {
            const last = edges.length - 1;
            for (let i = 0; i <= last; i++) {
                const edge = edges[i];
                const prevEdge = edges[i ? (i - 1) : last];
                const nextEdge = edges[(i === last) ? 0 : (i + 1)];
                const convexSet = ConvexClipPlaneSet_1.ConvexClipPlaneSet.createEmpty();
                const prevNormal = edge.normal.minus(prevEdge.normal);
                const nextNormal = edge.normal.minus(nextEdge.normal);
                prevNormal.normalize(prevNormal);
                nextNormal.normalize(nextNormal);
                // Create three-sided fans from each edge.   Note we could define the correct region
                // with only two planes for edge, but cannot then designate the "interior" status of the edges accurately.
                convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndPoint(Point3dVector3d_1.Vector3d.create(prevNormal.x, prevNormal.y), edge.origin, this._invisible, true));
                convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndPoint(Point3dVector3d_1.Vector3d.create(edge.normal.x, edge.normal.y), edge.origin, this._invisible, false));
                convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndPoint(Point3dVector3d_1.Vector3d.create(nextNormal.x, nextNormal.y), nextEdge.origin, this._invisible, true));
                convexSet.addZClipPlanes(this._invisible, this._zLow, this._zHigh);
                set.addConvexSet(convexSet);
            }
            set.addOutsideZClipSets(this._invisible, this._zLow, this._zHigh);
        }
        else {
            const convexSet = ConvexClipPlaneSet_1.ConvexClipPlaneSet.createEmpty();
            if (cameraFocalLength === undefined) {
                for (const edge of edges)
                    convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndPoint(Point3dVector3d_1.Vector3d.create(edge.normal.x, edge.normal.y), edge.origin));
            }
            else {
                if (reverse)
                    for (const edge of edges)
                        convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndDistance(Point3dVector3d_1.Vector3d.createFrom(edge.origin).crossProduct(Point3dVector3d_1.Vector3d.createFrom(edge.next)).normalize(), 0.0));
                else
                    for (const edge of edges)
                        convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndDistance(Point3dVector3d_1.Vector3d.createFrom(edge.next).crossProduct(Point3dVector3d_1.Vector3d.createFrom(edge.origin)).normalize(), 0.0));
            }
            convexSet.addZClipPlanes(this._invisible, this._zLow, this._zHigh);
            set.addConvexSet(convexSet);
        }
        return true;
    }
    /** Given a concave polygon defined as an array of points, populate the given UnionOfConvexClipPlaneSets with multiple ConvexClipPlaneSets defining the bounded region. Returns true if successful. */
    parseConcavePolygonPlanes(set, polygon, cameraFocalLength) {
        const triangulatedPolygon = Triangulation_1.Triangulator.earcutSingleLoop(polygon);
        Triangulation_1.Triangulator.cleanupTriangulation(triangulatedPolygon);
        triangulatedPolygon.announceFaceLoops((_graph, edge) => {
            if (!edge.isMaskSet(1 /* EXTERIOR */)) {
                const convexFacetPoints = edge.collectAroundFace((node) => {
                    if (!node.isMaskSet(1 /* EXTERIOR */))
                        return Point3dVector3d_1.Point3d.create(node.x, node.y, 0);
                });
                // parseConvexPolygonPlanes expects a closed loop (pushing the reference doesn't matter)
                convexFacetPoints.push(convexFacetPoints[0]);
                const direction = PointHelpers_1.PolygonOps.testXYPolygonTurningDirections(convexFacetPoints); // ###TODO: Can we expect a direction coming out of graph facet?
                this.parseConvexPolygonPlanes(set, convexFacetPoints, direction, cameraFocalLength);
            }
            return true;
        });
        return true;
    }
    /** Get the 3-dimensional range that this combination of ClipPlanes bounds in space. Returns the range/result
     *  if successful, otherwise, returns undefined. Transform will only be used for transforming the polygon points if clipplanes/maskplanes
     *  have not yet been set. Otherwise, we return the range of the planes without an applied transform.
     */
    getRange(returnMaskRange = false, transform, result) {
        let zHigh = Number.MAX_VALUE;
        let zLow = -Number.MAX_VALUE;
        transform = (transform === undefined) ? Transform_1.Transform.createIdentity() : transform;
        if (this._transformToClip !== undefined)
            transform.setMultiplyTransformTransform(transform, this._transformFromClip);
        if ((!returnMaskRange && this._isMask) || this._polygon === undefined)
            return undefined;
        if (this._zLowValid)
            zLow = this._zLow;
        if (this._zHighValid)
            zHigh = this._zHigh;
        const range = Range_1.Range3d.createNull(result);
        for (const point of this._polygon) {
            const shapePts = [
                Point3dVector3d_1.Point3d.create(point.x, point.y, zLow),
                Point3dVector3d_1.Point3d.create(point.x, point.y, zHigh),
            ];
            transform.multiplyPoint3dArray(shapePts, shapePts);
            range.extend(shapePts[0], shapePts[1]);
        }
        if (range.isNull) {
            return undefined;
        }
        return range;
    }
    /** Return true if the point lies inside/on this polygon (or not inside/on if this polygon is a mask). Otherwise, return false. */
    pointInside(point, onTolerance = Geometry_1.Geometry.smallMetricDistanceSquared) {
        if (this.fetchMaskPlanesRef() !== undefined)
            return !this._maskPlanes.isPointOnOrInside(point, onTolerance);
        return this.fetchClipPlanesRef().isPointOnOrInside(point, onTolerance);
    }
    transformInPlace(transform) {
        if (transform.isIdentity)
            return true;
        super.transformInPlace(transform);
        if (this._transformValid)
            transform.multiplyTransformTransform(this._transformFromClip, this._transformFromClip);
        else
            this._transformFromClip = transform;
        this._transformToClip = this._transformFromClip.inverse(); // could be undefined
        this._transformValid = true;
        return true;
    }
    multiplyPlanesTimesMatrix(matrix) {
        if (this._isMask)
            return false;
        this._clipPlanes = UnionOfConvexClipPlaneSets_1.UnionOfConvexClipPlaneSets.createEmpty();
        this._maskPlanes = undefined;
        this.parseClipPlanes(this._clipPlanes);
        this._clipPlanes.multiplyPlanesByMatrix(matrix);
        return true;
    }
    get isXYPolygon() {
        if (this._polygon.length === 0) // Note: This is a lenient check, as points array could also contain less than 3 points (not a polygon)
            return false;
        if (this._transformFromClip === undefined)
            return true;
        const testPoint = Point3dVector3d_1.Vector3d.create(0.0, 0.0, 1.0);
        this._transformFromClip.multiplyVectorXYZ(testPoint.x, testPoint.y, testPoint.z, testPoint);
        return testPoint.magnitudeXY() < 1.0e-8;
    }
    /** Transform the input point using this instance's transformToClip member */
    performTransformToClip(point) {
        if (this._transformToClip !== undefined)
            this._transformToClip.multiplyPoint3d(point);
    }
    /** Transform the input point using this instance's transformFromClip member */
    performTransformFromClip(point) {
        if (this._transformFromClip !== undefined)
            this._transformFromClip.multiplyPoint3d(point);
    }
}
exports.ClipShape = ClipShape;


/***/ }),

/***/ "./lib/clipping/ClipUtils.js":
/*!***********************************!*\
  !*** ./lib/clipping/ClipUtils.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
/** Enumerated type for describing where geometry lies with respect to clipping planes. */
var ClipPlaneContainment;
(function (ClipPlaneContainment) {
    ClipPlaneContainment[ClipPlaneContainment["StronglyInside"] = 1] = "StronglyInside";
    ClipPlaneContainment[ClipPlaneContainment["Ambiguous"] = 2] = "Ambiguous";
    ClipPlaneContainment[ClipPlaneContainment["StronglyOutside"] = 3] = "StronglyOutside";
})(ClipPlaneContainment = exports.ClipPlaneContainment || (exports.ClipPlaneContainment = {}));
/** Enumerated type for describing what must yet be done to clip a piece of geometry. */
var ClipStatus;
(function (ClipStatus) {
    ClipStatus[ClipStatus["ClipRequired"] = 0] = "ClipRequired";
    ClipStatus[ClipStatus["TrivialReject"] = 1] = "TrivialReject";
    ClipStatus[ClipStatus["TrivialAccept"] = 2] = "TrivialAccept";
})(ClipStatus = exports.ClipStatus || (exports.ClipStatus = {}));
/** Static class whose various methods are functions for clipping geometry. */
class ClipUtilities {
    static selectIntervals01(curve, unsortedFractions, clipper, announce) {
        unsortedFractions.push(0);
        unsortedFractions.push(1);
        unsortedFractions.sort();
        let f0 = unsortedFractions.at(0);
        let f1;
        let fMid;
        const testPoint = ClipUtilities._selectIntervals01TestPoint;
        const n = unsortedFractions.length;
        for (let i = 1; i < n; i++, f0 = f1) {
            f1 = unsortedFractions.at(i);
            fMid = 0.5 * (f0 + f1);
            if (f1 > f0 && (fMid >= 0.0 && fMid <= 1.0)) {
                curve.fractionToPoint(fMid, testPoint);
                if (clipper.isPointOnOrInside(testPoint)) {
                    if (announce)
                        announce(f0, f1, curve);
                    else
                        return true;
                }
            }
        }
        return false;
    }
    /**
     * Announce triples of (low, high, cp) for each entry in intervals
     * @param intervals source array
     * @param cp CurvePrimitive for announcement
     * @param announce funtion to receive data
     */
    static announceNNC(intervals, cp, announce) {
        if (announce) {
            for (const ab of intervals) {
                announce(ab.low, ab.high, cp);
            }
        }
        return intervals.length > 0;
    }
    static collectClippedCurves(curve, clipper) {
        const result = [];
        curve.announceClipIntervals(clipper, (fraction0, fraction1, curveA) => {
            if (fraction1 !== fraction0) {
                const partialCurve = curveA.clonePartialCurve(fraction0, fraction1);
                if (partialCurve)
                    result.push(partialCurve);
            }
        });
        return result;
    }
    /**
     * Clip a polygon down to regions defined by each shape of a ClipShape.
     * @return An multidimensional array of points, where each array is the boundary of part of the remaining polygon.
     */
    static clipPolygonToClipShape(polygon, clipShape) {
        const output = [];
        clipShape.fetchClipPlanesRef().polygonClip(polygon, output);
        return output;
    }
    /** Given an array of points, return whether or not processing is required to clip to a ClipPlaneSet region. */
    static pointSetSingleClipStatus(points, planeSet, tolerance) {
        if (planeSet.convexSets.length === 0)
            return 2 /* TrivialAccept */;
        for (const convexSet of planeSet.convexSets) {
            let allOutsideSinglePlane = false, anyOutside = false;
            for (const plane of convexSet.planes) {
                let numInside = 0, numOutside = 0;
                const planeDistance = plane.distance - tolerance;
                const currPt = Point3dVector3d_1.Point3d.create();
                const currVec = Point3dVector3d_1.Vector3d.create();
                for (let i = 0; i < points.length; i++) {
                    points.getPoint3dAt(i, currPt);
                    currVec.setFrom(currPt);
                    currVec.dotProduct(plane.inwardNormalRef) > planeDistance ? numInside++ : numOutside++;
                }
                anyOutside = (numOutside !== 0) ? true : anyOutside;
                if (numInside === 0) {
                    allOutsideSinglePlane = true;
                    break;
                }
            }
            if (!anyOutside) // totally inside this set - no clip required
                return 2 /* TrivialAccept */;
            if (!allOutsideSinglePlane)
                return 0 /* ClipRequired */;
        }
        return 1 /* TrivialReject */;
    }
}
ClipUtilities._selectIntervals01TestPoint = Point3dVector3d_1.Point3d.create();
exports.ClipUtilities = ClipUtilities;


/***/ }),

/***/ "./lib/clipping/ClipVector.js":
/*!************************************!*\
  !*** ./lib/clipping/ClipVector.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
const ClipPrimitive_1 = __webpack_require__(/*! ./ClipPrimitive */ "./lib/clipping/ClipPrimitive.js");
const Range_1 = __webpack_require__(/*! ../geometry3d/Range */ "./lib/geometry3d/Range.js");
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const LineSegment3d_1 = __webpack_require__(/*! ../curve/LineSegment3d */ "./lib/curve/LineSegment3d.js");
/** Class holding an array structure of shapes defined by clip plane sets */
class ClipVector {
    constructor(clips) {
        this.boundingRange = Range_1.Range3d.createNull();
        this._clips = clips ? clips : [];
    }
    /** Returns a reference to the array of ClipShapes. */
    get clips() { return this._clips; }
    /** Returns true if this ClipVector contains a ClipShape. */
    get isValid() { return this._clips.length > 0; }
    /** Create a ClipVector with an empty set of ClipShapes. */
    static createEmpty(result) {
        if (result) {
            result._clips.length = 0;
            return result;
        }
        return new ClipVector();
    }
    /** Create a ClipVector from an array of ClipShapes */
    static createClipShapeRefs(clips, result) {
        if (result) {
            result._clips = clips;
            return result;
        }
        return new ClipVector(clips);
    }
    /** Create a ClipVector from an array of ClipShapes, each one becoming a deep copy. */
    static createClipShapeClones(clips, result) {
        const clipClones = [];
        for (const clip of clips)
            clipClones.push(clip.clone());
        return ClipVector.createClipShapeRefs(clipClones, result);
    }
    /** Create a deep copy of another ClipVector */
    static createFrom(donor, result) {
        const retVal = result ? result : new ClipVector();
        retVal._clips.length = 0;
        for (const clip of donor._clips) {
            retVal._clips.push(clip.clone());
        }
        retVal.boundingRange.setFrom(donor.boundingRange);
        return retVal;
    }
    /** Parse this ClipVector into a JSON object. */
    toJSON() {
        if (!this.isValid)
            return [];
        const val = [];
        for (const clipShape of this.clips)
            val.push(clipShape.toJSON());
        return val;
    }
    /** Parse a JSON object into a new ClipVector. */
    static fromJSON(json, result) {
        result = result ? result : new ClipVector();
        result.clear();
        try {
            for (const clip of json) {
                const clipPrim = ClipPrimitive_1.ClipShape.fromJSON(clip);
                if (clipPrim)
                    result._clips.push(clipPrim);
            }
        }
        catch (e) {
            result.clear();
        }
        return result;
    }
    /** Returns a deep copy of this ClipVector (optionally stores it in the result param rather than create using new()) */
    clone(result) {
        return ClipVector.createFrom(this, result);
    }
    /** Empties out the array of ClipShapes. */
    clear() {
        this._clips.length = 0;
    }
    /** Append a deep copy of the given ClipShape to this ClipVector. */
    appendClone(clip) {
        this._clips.push(clip.clone());
    }
    /** Append a reference of the given ClipShape to this ClipVector. */
    appendReference(clip) {
        this._clips.push(clip);
    }
    /** Create and append a new ClipPrimitive to the array given a shape as an array of points. Returns true if successful. */
    appendShape(shape, zLow, zHigh, transform, isMask = false, invisible = false) {
        const clip = ClipPrimitive_1.ClipShape.createShape(shape, zLow, zHigh, transform, isMask, invisible);
        if (!clip)
            return false;
        this._clips.push(clip);
        return true;
    }
    /** Returns the three-dimensional range that this ClipVector spans, which may be null. */
    getRange(transform, result) {
        const range = Range_1.Range3d.createNull(result);
        for (const shape of this._clips) {
            const thisRange = shape.getRange(false, transform);
            if (thisRange !== undefined) {
                if (range.isNull)
                    range.setFrom(thisRange);
                else
                    range.intersect(thisRange, range);
            }
        }
        if (!this.boundingRange.isNull)
            range.intersect(this.boundingRange, range);
        return range;
    }
    /** Returns true if the given point lies inside all of this ClipVector's ClipShapes (by rule of intersection). */
    pointInside(point, onTolerance = Geometry_1.Geometry.smallMetricDistanceSquared) {
        if (!this.boundingRange.isNull && !this.boundingRange.containsPoint(point))
            return false;
        for (const clip of this._clips)
            if (!clip.pointInside(point, onTolerance))
                return false;
        return true;
    }
    /** Transforms this ClipVector to a new coordinate-system. Returns true if successful. */
    transformInPlace(transform) {
        for (const clip of this._clips)
            if (clip.transformInPlace(transform) === false)
                return false;
        if (!this.boundingRange.isNull)
            transform.multiplyRange(this.boundingRange, this.boundingRange);
        return true;
    }
    /**
     * A simple way of packaging this ClipVector's ClipShape points into a multidimensional array, while also
     * taking into account each ClipShape's individual transforms.
     *
     * Information out:
     *  - All of the loop points are stored in the multidimensional Point3d array given (will return unchanged upon failure)
     *  - If given a transform, will be set from the transformFromClip of the first ClipShape
     *  - The ClipMask of the final ClipShape is stored in the returned array at index 0
     *  - The last valid zLow found is stored in the returned array at index 1
     *  - The last valid zHigh found is stored in the returned array at index 2
     */
    extractBoundaryLoops(loopPoints, transform) {
        let clipM = 0 /* None */;
        let zBack = -Number.MAX_VALUE;
        let zFront = Number.MAX_VALUE;
        const retVal = [];
        let nLoops = 0;
        if (this._clips.length === 0)
            return retVal;
        const deltaTrans = Transform_1.Transform.createIdentity();
        for (const clip of this._clips) {
            if (clip !== this._clips[0]) { // Is not the first iteration
                let fwdTrans = Transform_1.Transform.createIdentity();
                let invTrans = Transform_1.Transform.createIdentity();
                if (this._clips[0].transformValid && clip.transformValid) {
                    fwdTrans = clip.transformFromClip.clone();
                    invTrans = this._clips[0].transformToClip.clone();
                }
                deltaTrans.setFrom(invTrans.multiplyTransformTransform(fwdTrans));
            }
            loopPoints[nLoops] = [];
            if (clip.polygon !== undefined) {
                clipM = 15 /* XAndY */;
                if (clip.zHighValid) {
                    clipM = clipM | 32 /* ZHigh */;
                    zFront = clip.zHigh;
                }
                if (clip.zLowValid) {
                    clipM = clipM | 16 /* ZLow */;
                    zBack = clip.zLow;
                }
                for (const point of clip.polygon)
                    loopPoints[nLoops].push(point.clone());
                deltaTrans.multiplyPoint3dArray(loopPoints[nLoops], loopPoints[nLoops]);
                nLoops++;
            }
        }
        retVal.push(clipM);
        retVal.push(zBack);
        retVal.push(zFront);
        if (transform)
            transform.setFrom(this._clips[0].transformFromClip);
        return retVal;
    }
    /** Sets this ClipVector and all of its members to the visibility specified. */
    setInvisible(invisible) {
        for (const clip of this._clips)
            clip.setInvisible(invisible);
    }
    /** For every clip, parse the member point array into the member clip plane object (only for clipPlanes member, not the mask) */
    parseClipPlanes() {
        for (const clip of this._clips)
            clip.fetchClipPlanesRef();
    }
    /** Returns true if able to successfully multiply all member ClipShape planes by the matrix given. */
    multiplyPlanesTimesMatrix(matrix) {
        let numErrors = 0;
        for (const clip of this._clips)
            if (clip.multiplyPlanesTimesMatrix(matrix) === false)
                numErrors++;
        return numErrors === 0 ? true : false;
    }
    /**
     * Determines whether the given points fall inside or outside this set of ClipShapes. If any set is defined by masking planes,
     * checks the mask planes only, provided that ignoreMasks is false. Otherwise, checks the _clipplanes member.
     */
    classifyPointContainment(points, ignoreMasks = false) {
        let currentContainment = 2 /* Ambiguous */;
        for (const primitive of this._clips) {
            const thisContainment = primitive.classifyPointContainment(points, ignoreMasks);
            if (2 /* Ambiguous */ === thisContainment)
                return 2 /* Ambiguous */;
            if (2 /* Ambiguous */ === currentContainment)
                currentContainment = thisContainment;
            else if (currentContainment !== thisContainment)
                return 2 /* Ambiguous */;
        }
        return currentContainment;
    }
    /**
     * Determines whether a 3D range lies inside or outside this set of ClipShapes. If any set is defined by masking planes,
     * checks the mask planes only, provided that ignoreMasks is false. Otherwise, checks the _clipplanes member.
     */
    classifyRangeContainment(range, ignoreMasks) {
        const corners = range.corners();
        return this.classifyPointContainment(corners, ignoreMasks);
    }
    /**
     * For an array of points (making up a LineString), tests whether the segment between each point lies inside the ClipVector.
     * If true, returns true immediately.
     */
    isAnyLineStringPointInside(points) {
        for (const clip of this._clips) {
            const clipPlaneSet = clip.fetchClipPlanesRef();
            for (let i = 0; i + 1 < points.length; i++) {
                const segment = LineSegment3d_1.LineSegment3d.create(points[i], points[i + 1]);
                if (clipPlaneSet.isAnyPointInOrOnFromSegment(segment))
                    return true;
            }
        }
        return false;
    }
    /** Note: Line segments are used to represent 1 dimensional intervals here, rather than segments. */
    sumSizes(intervals, begin, end) {
        let s = 0.0;
        for (let i = begin; i < end; i++)
            s += (intervals[i].x1 - intervals[i].x0);
        return s;
    }
    /**
     * For an array of points that make up a LineString, develops a line segment between each point pair,
     * and returns true if all segments lie inside this ClipVector.
     */
    isLineStringCompletelyContained(points) {
        const clipIntervals = [];
        for (let i = 0; i + 1 < points.length; i++) {
            const segment = LineSegment3d_1.LineSegment3d.create(points[i], points[i + 1]);
            let fractionSum = 0.0;
            let index0 = 0;
            for (const clip of this._clips) {
                const clipPlaneSet = clip.fetchClipPlanesRef();
                clipPlaneSet.appendIntervalsFromSegment(segment, clipIntervals);
                const index1 = clipIntervals.length;
                fractionSum += this.sumSizes(clipIntervals, index0, index1);
                index0 = index1;
                // ASSUME primitives are non-overlapping...
                if (fractionSum >= ClipVector._TARGET_FRACTION_SUM)
                    break;
            }
            if (fractionSum < ClipVector._TARGET_FRACTION_SUM)
                return false;
        }
        return true;
    }
}
ClipVector._TARGET_FRACTION_SUM = 0.99999999;
exports.ClipVector = ClipVector;


/***/ }),

/***/ "./lib/clipping/ConvexClipPlaneSet.js":
/*!********************************************!*\
  !*** ./lib/clipping/ConvexClipPlaneSet.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Range_1 = __webpack_require__(/*! ../geometry3d/Range */ "./lib/geometry3d/Range.js");
const Matrix3d_1 = __webpack_require__(/*! ../geometry3d/Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const PointHelpers_1 = __webpack_require__(/*! ../geometry3d/PointHelpers */ "./lib/geometry3d/PointHelpers.js");
const GrowableFloat64Array_1 = __webpack_require__(/*! ../geometry3d/GrowableFloat64Array */ "./lib/geometry3d/GrowableFloat64Array.js");
const ClipPlane_1 = __webpack_require__(/*! ./ClipPlane */ "./lib/clipping/ClipPlane.js");
const ClipUtils_1 = __webpack_require__(/*! ./ClipUtils */ "./lib/clipping/ClipUtils.js");
/**
 * A ConvexClipPlaneSet is a collection of ClipPlanes, often used for bounding regions of space.
 */
class ConvexClipPlaneSet {
    // private _parity: number;   <--- Not yet used
    // public get parity() { return this._parity; }
    // public set parity(value: number) { this._parity = value; }
    constructor(planes) {
        // this._parity = 1;
        this._planes = planes ? planes : [];
    }
    toJSON() {
        const val = [];
        for (const plane of this._planes) {
            val.push(plane.toJSON());
        }
        return val;
    }
    static fromJSON(json, result) {
        result = result ? result : new ConvexClipPlaneSet();
        result._planes.length = 0;
        if (!Array.isArray(json))
            return result;
        for (const thisJson of json) {
            const plane = ClipPlane_1.ClipPlane.fromJSON(thisJson);
            if (plane)
                result._planes.push(plane);
        }
        return result;
    }
    /**
     * @returns Return true if all members are almostEqual to corresponding members of other.  This includes identical order in array.
     * @param other clip plane to compare
     */
    isAlmostEqual(other) {
        if (this._planes.length !== other._planes.length)
            return false;
        for (let i = 0; i < this._planes.length; i++)
            if (!this._planes[i].isAlmostEqual(other._planes[i]))
                return false;
        return true;
    }
    static createPlanes(planes, result) {
        result = result ? result : new ConvexClipPlaneSet();
        for (const plane of planes)
            result._planes.push(plane);
        return result;
    }
    /**
     * Create new convex set using selected planes of a Range3d.
     * @param range range with coordinates
     * @param lowX true to clip at the low x plane
     * @param highX true to clip at the high x plane
     * @param lowY true to clip at the low y plane
     * @param highY true to clip at the high z plane
     * @param lowZ true to clip at the low z plane
     * @param highZ true to clip at the high z plane
     */
    static createRange3dPlanes(range, lowX = true, highX = true, lowY = true, highY = true, lowZ = true, highZ = true) {
        const result = ConvexClipPlaneSet.createEmpty();
        if (lowX)
            result.planes.push(ClipPlane_1.ClipPlane.createNormalAndPointXYZXYZ(1, 0, 0, range.low.x, 0, 0));
        if (highX)
            result.planes.push(ClipPlane_1.ClipPlane.createNormalAndPointXYZXYZ(-1, 0, 0, range.high.x, 0, 0));
        if (lowY)
            result.planes.push(ClipPlane_1.ClipPlane.createNormalAndPointXYZXYZ(0, 1, 0, 0, range.low.y, 0));
        if (highY)
            result.planes.push(ClipPlane_1.ClipPlane.createNormalAndPointXYZXYZ(0, -1, 0, 0, range.high.y, 0));
        if (lowZ)
            result.planes.push(ClipPlane_1.ClipPlane.createNormalAndPointXYZXYZ(0, 0, 1, 0, 0, range.low.z));
        if (highZ)
            result.planes.push(ClipPlane_1.ClipPlane.createNormalAndPointXYZXYZ(0, 0, -1, 0, 0, range.high.z));
        return result;
    }
    static createEmpty(result) {
        if (result) {
            result._planes.length = 0;
            return result;
        }
        return new ConvexClipPlaneSet();
    }
    /** negate all planes of the set. */
    negateAllPlanes() {
        for (const plane of this._planes)
            plane.negateInPlace();
    }
    static createXYBox(x0, y0, x1, y1, result) {
        result = result ? result : new ConvexClipPlaneSet();
        result._planes.length = 0;
        const clip0 = ClipPlane_1.ClipPlane.createNormalAndDistance(Point3dVector3d_1.Vector3d.create(-1, 0, 0), -x1, false, true);
        const clip1 = ClipPlane_1.ClipPlane.createNormalAndDistance(Point3dVector3d_1.Vector3d.create(1, 0, 0), x0, false, true);
        const clip2 = ClipPlane_1.ClipPlane.createNormalAndDistance(Point3dVector3d_1.Vector3d.create(0, -1, 0), -y1, false, true);
        const clip3 = ClipPlane_1.ClipPlane.createNormalAndDistance(Point3dVector3d_1.Vector3d.create(0, 1, 0), y0, false, true);
        if (clip0 && clip1 && clip2 && clip3) {
            result._planes.push(clip0, clip1, clip2, clip3);
        }
        return result;
    }
    static createXYPolyLine(points, interior, leftIsInside, result) {
        result = result ? result : new ConvexClipPlaneSet();
        result._planes.length = 0;
        for (let i0 = 0; (i0 + 1) < points.length; i0++) {
            const edgeVector = Point3dVector3d_1.Vector3d.createStartEnd(points[i0], points[i0 + 1]);
            const perp = edgeVector.unitPerpendicularXY();
            perp.z = 0.0;
            if (!leftIsInside)
                perp.negate();
            const perpNormalized = perp.normalize();
            if (perpNormalized) {
                const clip = ClipPlane_1.ClipPlane.createNormalAndPoint(perp, points[i0], interior[i0], interior[i0]);
                if (clip) {
                    result._planes.push(clip);
                }
            }
        }
        return result;
    }
    /**
     * Create a convexClipPlaneSet with planes whose "inside" normal is to the left of each segment.
     * @param points array of points.
     */
    static createXYPolyLineInsideLeft(points, result) {
        result = result ? result : new ConvexClipPlaneSet();
        result._planes.length = 0;
        for (let i0 = 0; (i0 + 1) < points.length; i0++) {
            const edgeVector = Point3dVector3d_1.Vector3d.createStartEnd(points[i0], points[i0 + 1]);
            const perp = edgeVector.unitPerpendicularXY();
            perp.z = 0.0;
            const perpNormalized = perp.normalize();
            if (perpNormalized) {
                const clip = ClipPlane_1.ClipPlane.createNormalAndPoint(perp, points[i0], false, false);
                if (clip) {
                    result._planes.push(clip);
                }
            }
        }
        return result;
    }
    clone(result) {
        result = result ? result : new ConvexClipPlaneSet();
        result._planes.length = 0;
        for (const plane of this._planes)
            result._planes.push(plane.clone());
        return result;
    }
    get planes() {
        return this._planes;
    }
    // tNear passed as Float64Array of size 1 to be used as reference
    static testRayIntersections(tNear, origin, direction, planes) {
        tNear[0] = -ConvexClipPlaneSet.hugeVal;
        let tFar = ConvexClipPlaneSet.hugeVal;
        for (const plane of planes._planes) {
            const vD = plane.dotProductVector(direction);
            const vN = plane.evaluatePoint(origin);
            if (vD === 0.0) {
                // Ray is parallel... No need to continue testing if outside halfspace.
                if (vN < 0.0)
                    return false;
            }
            else {
                const rayDistance = -vN / vD;
                if (vD < 0.0) {
                    if (rayDistance < tFar)
                        tFar = rayDistance;
                }
                else {
                    if (rayDistance > tNear[0])
                        tNear[0] = rayDistance;
                }
            }
        }
        return tNear[0] <= tFar;
    }
    multiplyPlanesByMatrix(matrix) {
        for (const plane of this._planes) {
            plane.multiplyPlaneByMatrix(matrix);
        }
    }
    isPointInside(point) {
        for (const plane of this._planes) {
            if (!plane.isPointInside(point)) // Defaults to strict inside check. Other clipping classes may use "on or inside" check for the "on" case
                return false;
        }
        return true;
    }
    isPointOnOrInside(point, tolerance) {
        const interiorTolerance = Math.abs(tolerance); // Interior tolerance should always be positive. (TFS# 246598).
        for (const plane of this._planes) {
            if (!plane.isPointOnOrInside(point, (plane.interior ? interiorTolerance : tolerance)))
                return false;
        }
        return true;
    }
    isSphereInside(point, radius) {
        // Note - The sphere logic differ from "PointOnOrInside" only in the handling of interior planes.
        // For a sphere we don't negate the tolerance on interior planes - we have to look for true containment (TFS# 439212).
        for (const plane of this._planes) {
            if (!plane.isPointOnOrInside(point, radius)) {
                return false;
            }
        }
        return true;
    }
    /** Find the parts of the line segment  (if any) that is within the convex clip volume.
     * * The input fractional interval from fraction0 to fraction1 (increasing!!) is the active part to consider.
     * * To clip to the usual bounded line segment, starts with fractions (0,1).
     * If the clip volume is unbounded, the line interval may also be unbounded.
     * * An unbounded line portion will have fraction coordinates positive or negative Number.MAX_VALUE.
     * @param fraction0 fraction that is the initial lower fraction of the active interval. (e.g. 0.0 for bounded segment)
     * @param fraction1 fraction that is the initial upper fraction of the active interval.  (e.g. 1.0 for bounded segment)
     * @param pointA segment start (fraction 0)
     * @param pointB segment end (fraction 1)
     * @param announce function to be called to announce a fraction interval that is within the convex clip volume.
     * @returns true if a segment was announced, false if entirely outside.
     */
    announceClippedSegmentIntervals(f0, f1, pointA, pointB, announce) {
        let fraction;
        if (f1 < f0)
            return false;
        for (const plane of this._planes) {
            const hA = -plane.evaluatePoint(pointA);
            const hB = -plane.evaluatePoint(pointB);
            fraction = Geometry_1.Geometry.safeDivideFraction(-hA, (hB - hA), 0.0);
            if (fraction === undefined) {
                // LIne parallel to the plane.  If positive, it is all OUT
                if (hA > 0.0)
                    return false;
            }
            else if (hB > hA) { // STRICTLY moving outward
                if (fraction < f0)
                    return false;
                if (fraction < f1)
                    f1 = fraction;
            }
            else if (hA > hB) { // STRICTLY moving inward
                if (fraction > f1)
                    return false;
                if (fraction > f0)
                    f0 = fraction;
            }
            else {
                // Strictly equal evaluations
                if (hA > 0.0)
                    return false;
            }
        }
        if (f1 >= f0) {
            if (announce)
                announce(f0, f1);
            return true;
        }
        return false;
    }
    announceClippedArcIntervals(arc, announce) {
        const breaks = ConvexClipPlaneSet._clipArcFractionArray;
        breaks.clear();
        for (const clipPlane of this.planes) {
            clipPlane.appendIntersectionRadians(arc, breaks);
        }
        arc.sweep.radiansArraytoPositivePeriodicFractions(breaks);
        return ClipUtils_1.ClipUtilities.selectIntervals01(arc, breaks, this, announce);
    }
    /** Find the parts of the (unbounded) line segment  (if any) that is within the convex clip volume.
     * @param pointA segment start (fraction 0)
     * @param pointB segment end (fraction 1)
     * @param announce function to be called to announce a fraction interval that is within the convex clip volume.
     * @returns true if a segment was announced, false if entirely outside.
     */
    clipUnboundedSegment(pointA, pointB, announce) {
        return this.announceClippedSegmentIntervals(-Number.MAX_VALUE, Number.MAX_VALUE, pointA, pointB, announce);
    }
    transformInPlace(transform) {
        for (const plane of this._planes) {
            plane.transformInPlace(transform);
        }
    }
    /** Returns 1, 2, or 3 based on whether point array is strongly inside, ambiguous, or strongly outside respectively.
     * * This has a peculiar expected use case as a very fast pre-filter for more precise clipping.
     * * The expected point set is for a polygon.
     * * Hence any clipping will eventually have to consider the lines between the points.
     * * This method looks for the special case of a single clip plane that has all the points outside.
     * * In this case the whole polygon must be outside.
     * * Note that this does not detect a polygon that is outside but "crosses a corner" -- it is mixed with respect to
     *     multiple planes.
     */
    classifyPointContainment(points, onIsOutside) {
        let allInside = true;
        const onTolerance = onIsOutside ? 1.0e-8 : -1.0e-8;
        const interiorTolerance = 1.0e-8; // Interior tolerance should always be positive
        for (const plane of this._planes) {
            let nOutside = 0;
            for (const point of points) {
                if (plane.evaluatePoint(point) < (plane.interior ? interiorTolerance : onTolerance)) {
                    nOutside++;
                    allInside = false;
                }
            }
            if (nOutside === points.length)
                return 3 /* StronglyOutside */;
        }
        return allInside ? 1 /* StronglyInside */ : 2 /* Ambiguous */;
    }
    /**
     * * Create a convex clip set for a polygon swept with possible tilt angle.
     * * planes are constructed by ClipPlane.createEdgeAndUpVector, using successive points from the array.
     * * If the first and last points match, the polygon area is checked.  If the area is negative, points are used in reverse order.
     * * If first and last points do not match, points are used in order given
     * @param points polygon points. (Closure point optional)
     * @param upVector primary sweep direction, as applied by ClipPlane.createEdgeAndUpVector
     * @param tiltAngle angle to tilt sweep planes away from the sweep direction.
     */
    static createSweptPolyline(points, upVector, tiltAngle) {
        const result = ConvexClipPlaneSet.createEmpty();
        let reverse = false;
        if (points.length > 3 && points[0].isAlmostEqual(points[points.length - 1])) {
            const polygonNormal = PointHelpers_1.PolygonOps.areaNormal(points);
            const normalDot = polygonNormal.dotProduct(upVector);
            if (normalDot > 0.0)
                reverse = true;
        }
        for (let i = 0; (i + 1) < points.length; i++) {
            if (reverse) {
                const toAdd = ClipPlane_1.ClipPlane.createEdgeAndUpVector(points[i + 1], points[i], upVector, tiltAngle);
                if (toAdd) { // Clipplane creation could result in undefined
                    result.addPlaneToConvexSet(toAdd);
                }
                else {
                    return undefined;
                }
            }
            else {
                const toAdd = ClipPlane_1.ClipPlane.createEdgeAndUpVector(points[i], points[i + 1], upVector, tiltAngle);
                if (toAdd) { // Clipplane creation could result in undefined
                    result.addPlaneToConvexSet(toAdd);
                }
                else {
                    return undefined;
                }
            }
        }
        return result;
    }
    addPlaneToConvexSet(plane) {
        if (plane)
            this._planes.push(plane);
    }
    clipPointsOnOrInside(points, inOrOn, out) {
        inOrOn.length = 0;
        out.length = 0;
        for (const xyz of points) {
            if (this.isPointOnOrInside(xyz, 0.0)) {
                inOrOn.push(xyz);
            }
            else {
                out.push(xyz);
            }
        }
    }
    polygonClip(input, output, work) {
        output.length = 0;
        // Copy input array
        for (const i of input)
            output.push(i);
        for (const plane of this._planes) {
            if (output.length === 0)
                break;
            plane.convexPolygonClipInPlace(output, work);
        }
    }
    /**
     * * Define new planes in this ConvexClipPlaneSet so it clips to the inside of a polygon.
     * * always create planes for the swept edges of the polygon
     * * optionally (with nonzero sideSelect) create a cap plane using the polygon normal.
     * @param points Points of a bounding polygon
     * @param sweepDirection direction to sweep.
     * @param sideSelect 0 to have no cap polygon, 1 if the sweep vector side is in, -1 if sweep vector side is out.
     */
    reloadSweptPolygon(points, sweepDirection, sideSelect) {
        this._planes.length = 0;
        const n = points.length;
        if (n <= 2)
            return 0;
        const planeNormal = PointHelpers_1.PolygonOps.areaNormal(points);
        const isCCW = sweepDirection.dotProduct(planeNormal) > 0.0;
        const delta = isCCW ? 1 : n - 1;
        for (let i = 0; i < n; i++) {
            const i1 = (i + delta) % n;
            const xyz0 = points[i];
            const xyz1 = points[i1];
            if (xyz0.isAlmostEqual(xyz1))
                continue;
            const edgeVector = Point3dVector3d_1.Vector3d.createStartEnd(xyz0, xyz1);
            const inwardNormal = Point3dVector3d_1.Vector3d.createCrossProduct(sweepDirection.x, sweepDirection.y, sweepDirection.z, edgeVector.x, edgeVector.y, edgeVector.z);
            const inwardNormalNormalized = inwardNormal.normalize();
            let distance;
            if (inwardNormalNormalized) { // Should never fail... simply a check due to the format of the normalize function return
                distance = inwardNormalNormalized.dotProduct(xyz0);
                const clipToAdd = ClipPlane_1.ClipPlane.createNormalAndDistance(inwardNormalNormalized, distance, false, false);
                if (clipToAdd) {
                    this._planes.push(clipToAdd);
                } // Clipplane creation could result in undefined
            }
        }
        if (sideSelect !== 0.0) {
            let planeNormalNormalized = planeNormal.normalize();
            if (planeNormalNormalized) { // Again.. should never fail
                const a = sweepDirection.dotProduct(planeNormalNormalized) * sideSelect;
                if (a < 0.0)
                    planeNormalNormalized = planeNormalNormalized.negate();
                const xyz0 = points[0];
                const distance = planeNormalNormalized.dotProduct(xyz0);
                const clipToAdd = ClipPlane_1.ClipPlane.createNormalAndDistance(planeNormalNormalized, distance, false, false);
                if (clipToAdd) {
                    this._planes.push(clipToAdd);
                } // Clipplane creation could result in undefined
            }
        }
        return isCCW ? 1 : -1;
    }
    /**
     * Returns range if result does not cover a space of infinity, otherwise undefined.
     * Note: If given a range for output, this will overwrite it, NOT extend it.
     */
    getRangeOfAlignedPlanes(transform, result) {
        const idMatrix = Matrix3d_1.Matrix3d.createIdentity();
        const bigRange = Range_1.Range3d.createXYZXYZ(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        const range = bigRange.clone(result);
        for (const clipPlane of this._planes) {
            if (transform)
                clipPlane.transformInPlace(transform);
            // Array of 1-d ranges that will be pieced back together into a Range3d after making adjustments
            const rangePieces = [
                Range_1.Range1d.createXX(range.low.x, range.high.x),
                Range_1.Range1d.createXX(range.low.y, range.high.y),
                Range_1.Range1d.createXX(range.low.z, range.high.z)
            ];
            for (let i = 0; i < 3; i++) {
                // Set values of minP and maxP based on i (we are compensating for pointer arithmetic in native code)
                let minP;
                let maxP;
                minP = rangePieces[i].low;
                maxP = rangePieces[i].high;
                const direction = idMatrix.getColumn(i);
                if (clipPlane.inwardNormalRef.isParallelTo(direction, true)) {
                    if (clipPlane.inwardNormalRef.dotProduct(direction) > 0.0) {
                        if (clipPlane.distance > minP)
                            rangePieces[i].low = clipPlane.distance;
                    }
                    else {
                        if (-clipPlane.distance < maxP)
                            rangePieces[i].high = -clipPlane.distance;
                    }
                }
            }
            // Reassign to Range3d
            range.low.x = rangePieces[0].low;
            range.high.x = rangePieces[0].high;
            range.low.y = rangePieces[1].low;
            range.high.y = rangePieces[1].high;
            range.low.z = rangePieces[2].low;
            range.high.z = rangePieces[2].high;
        }
        if (range.isAlmostEqual(bigRange))
            return undefined;
        else
            return range;
    }
    setInvisible(invisible) {
        for (const plane of this._planes) {
            plane.setInvisible(invisible);
        }
    }
    addZClipPlanes(invisible, zLow, zHigh) {
        if (zLow !== undefined)
            this._planes.push(ClipPlane_1.ClipPlane.createNormalAndDistance(Point3dVector3d_1.Vector3d.create(0, 0, 1), zLow, invisible));
        if (zHigh !== undefined)
            this._planes.push(ClipPlane_1.ClipPlane.createNormalAndDistance(Point3dVector3d_1.Vector3d.create(0, 0, -1), -zHigh, invisible));
    }
}
ConvexClipPlaneSet.hugeVal = 1e37;
ConvexClipPlaneSet._clipArcFractionArray = new GrowableFloat64Array_1.GrowableFloat64Array();
exports.ConvexClipPlaneSet = ConvexClipPlaneSet;


/***/ }),

/***/ "./lib/clipping/UnionOfConvexClipPlaneSets.js":
/*!****************************************************!*\
  !*** ./lib/clipping/UnionOfConvexClipPlaneSets.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module CartesianGeometry */
Object.defineProperty(exports, "__esModule", { value: true });
const Segment1d_1 = __webpack_require__(/*! ../geometry3d/Segment1d */ "./lib/geometry3d/Segment1d.js");
const Range_1 = __webpack_require__(/*! ../geometry3d/Range */ "./lib/geometry3d/Range.js");
const GrowableFloat64Array_1 = __webpack_require__(/*! ../geometry3d/GrowableFloat64Array */ "./lib/geometry3d/GrowableFloat64Array.js");
const ClipUtils_1 = __webpack_require__(/*! ./ClipUtils */ "./lib/clipping/ClipUtils.js");
const ConvexClipPlaneSet_1 = __webpack_require__(/*! ./ConvexClipPlaneSet */ "./lib/clipping/ConvexClipPlaneSet.js");
/**
 * A collection of ConvexClipPlaneSets.
 * * A point is "in" the clip plane set if it is "in" one or more of  the ConvexClipPlaneSet
 * * Hence the boolean logic is that the ClipPlaneSet is a UNION of its constituents.
 */
class UnionOfConvexClipPlaneSets {
    constructor() {
        this._convexSets = [];
    }
    get convexSets() { return this._convexSets; }
    toJSON() {
        const val = [];
        for (const convex of this._convexSets) {
            val.push(convex.toJSON());
        }
        return val;
    }
    static fromJSON(json, result) {
        result = result ? result : new UnionOfConvexClipPlaneSets();
        result._convexSets.length = 0;
        if (!Array.isArray(json))
            return result;
        for (const thisJson of json) {
            result._convexSets.push(ConvexClipPlaneSet_1.ConvexClipPlaneSet.fromJSON(thisJson));
        }
        return result;
    }
    static createEmpty(result) {
        if (result) {
            result._convexSets.length = 0;
            return result;
        }
        return new UnionOfConvexClipPlaneSets();
    }
    /**
     * @returns Return true if all member convex sets are almostEqual to corresponding members of other.  This includes identical order in array.
     * @param other clip plane to compare
     */
    isAlmostEqual(other) {
        if (this._convexSets.length !== other._convexSets.length)
            return false;
        for (let i = 0; i < this._convexSets.length; i++)
            if (!this._convexSets[i].isAlmostEqual(other._convexSets[i]))
                return false;
        return true;
    }
    static createConvexSets(convexSets, result) {
        result = result ? result : new UnionOfConvexClipPlaneSets();
        for (const set of convexSets)
            result._convexSets.push(set);
        return result;
    }
    clone(result) {
        result = result ? result : new UnionOfConvexClipPlaneSets();
        result._convexSets.length = 0;
        for (const convexSet of this._convexSets)
            result._convexSets.push(convexSet.clone());
        return result;
    }
    addConvexSet(toAdd) {
        this._convexSets.push(toAdd);
    }
    testRayIntersect(point, direction) {
        const tNear = new Float64Array(1);
        for (const planeSet of this._convexSets) {
            if (ConvexClipPlaneSet_1.ConvexClipPlaneSet.testRayIntersections(tNear, point, direction, planeSet))
                return true;
        }
        return false;
    }
    getRayIntersection(point, direction) {
        let nearest = -ConvexClipPlaneSet_1.ConvexClipPlaneSet.hugeVal;
        for (const planeSet of this._convexSets) {
            if (planeSet.isPointInside(point)) {
                return 0.0;
            }
            else {
                const tNear = new Float64Array(1);
                if (ConvexClipPlaneSet_1.ConvexClipPlaneSet.testRayIntersections(tNear, point, direction, planeSet) && tNear[0] > nearest) {
                    nearest = tNear[0];
                }
            }
        }
        if (nearest > -ConvexClipPlaneSet_1.ConvexClipPlaneSet.hugeVal)
            return nearest;
        else
            return undefined;
    }
    isPointInside(point) {
        for (const convexSet of this._convexSets) {
            if (convexSet.isPointInside(point)) {
                return true;
            }
        }
        return false;
    }
    isPointOnOrInside(point, tolerance) {
        for (const convexSet of this._convexSets) {
            if (convexSet.isPointOnOrInside(point, tolerance))
                return true;
        }
        return false;
    }
    isSphereInside(point, radius) {
        for (const convexSet of this._convexSets) {
            if (convexSet.isSphereInside(point, radius))
                return true;
        }
        return false;
    }
    /** test if any part of a line segment is within the volume */
    isAnyPointInOrOnFromSegment(segment) {
        for (const convexSet of this._convexSets) {
            if (convexSet.announceClippedSegmentIntervals(0.0, 1.0, segment.point0Ref, segment.point1Ref))
                return true;
        }
        return false;
    }
    // Intervals must be Segment1d array, as there may be multiple intervals along segment that pass through set regions,
    // and so splitting the intervals into segments aids in better organization
    /** Returns the fractions of the segment that pass through the set region, as 1 dimensional pieces */
    appendIntervalsFromSegment(segment, intervals) {
        for (const convexSet of this._convexSets) {
            convexSet.announceClippedSegmentIntervals(0.0, 1.0, segment.point0Ref, segment.point1Ref, (fraction0, fraction1) => intervals.push(Segment1d_1.Segment1d.create(fraction0, fraction1)));
        }
    }
    transformInPlace(transform) {
        for (const convexSet of this._convexSets) {
            convexSet.transformInPlace(transform);
        }
    }
    /** Returns 1, 2, or 3 based on whether point is strongly inside, ambiguous, or strongly outside respectively */
    classifyPointContainment(points, onIsOutside) {
        for (const convexSet of this._convexSets) {
            const thisStatus = convexSet.classifyPointContainment(points, onIsOutside);
            if (thisStatus !== 3 /* StronglyOutside */)
                return thisStatus;
        }
        return 3 /* StronglyOutside */;
    }
    /** Clip a polygon using this ClipPlaneSet, returning new polygon boundaries. Note that each polygon may lie next to the previous, or be disconnected. */
    polygonClip(input, output) {
        output.length = 0;
        for (const convexSet of this._convexSets) {
            const convexSetOutput = [];
            convexSet.polygonClip(input, convexSetOutput, []);
            if (convexSetOutput.length !== 0)
                output.push(convexSetOutput);
        }
    }
    /**
     * * announce clipSegment() for each convexSet in this ClipPlaneSet.
     * * all clipPlaneSets are inspected
     * * announced intervals are for each individual clipPlaneSet -- adjacent intervals are not consolidated.
     * @param f0 active interval start.
     * @param f1 active interval end
     * @param pointA line segment start
     * @param pointB line segment end
     * @param announce function to announce interval.
     * @returns Return true if any announcements are made.
     */
    announceClippedSegmentIntervals(f0, f1, pointA, pointB, announce) {
        let numAnnounce = 0;
        for (const convexSet of this._convexSets) {
            if (convexSet.announceClippedSegmentIntervals(f0, f1, pointA, pointB, announce))
                numAnnounce++;
        }
        return numAnnounce > 0;
    }
    announceClippedArcIntervals(arc, announce) {
        const breaks = UnionOfConvexClipPlaneSets._clipArcFractionArray;
        breaks.clear();
        for (const convexSet of this._convexSets) {
            for (const clipPlane of convexSet.planes) {
                clipPlane.appendIntersectionRadians(arc, breaks);
            }
        }
        arc.sweep.radiansArraytoPositivePeriodicFractions(breaks);
        return ClipUtils_1.ClipUtilities.selectIntervals01(arc, breaks, this, announce);
    }
    /**
     * Returns range if result does not cover a space of infinity, otherwise undefined.
     * Note: If given a range for output, overwrites it, rather than extending it.
     */
    getRangeOfAlignedPlanes(transform, result) {
        const range = Range_1.Range3d.createNull(result);
        for (const convexSet of this._convexSets) {
            const thisRange = Range_1.Range3d.createNull();
            if (convexSet.getRangeOfAlignedPlanes(transform, thisRange))
                range.extendRange(thisRange);
        }
        if (range.isNull)
            return undefined;
        else
            return range;
    }
    multiplyPlanesByMatrix(matrix) {
        for (const convexSet of this._convexSets) {
            convexSet.multiplyPlanesByMatrix(matrix);
        }
    }
    setInvisible(invisible) {
        for (const convexSet of this._convexSets) {
            convexSet.setInvisible(invisible);
        }
    }
    addOutsideZClipSets(invisible, zLow, zHigh) {
        if (zLow) {
            const convexSet = ConvexClipPlaneSet_1.ConvexClipPlaneSet.createEmpty();
            convexSet.addZClipPlanes(invisible, zLow);
            this._convexSets.push(convexSet);
        }
        if (zHigh) {
            const convexSet = ConvexClipPlaneSet_1.ConvexClipPlaneSet.createEmpty();
            convexSet.addZClipPlanes(invisible, undefined, zHigh);
            this._convexSets.push(convexSet);
        }
    }
}
UnionOfConvexClipPlaneSets._clipArcFractionArray = new GrowableFloat64Array_1.GrowableFloat64Array();
exports.UnionOfConvexClipPlaneSets = UnionOfConvexClipPlaneSets;


/***/ }),

/***/ "./lib/curve/Arc3d.js":
/*!****************************!*\
  !*** ./lib/curve/Arc3d.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Curve */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const AngleSweep_1 = __webpack_require__(/*! ../geometry3d/AngleSweep */ "./lib/geometry3d/AngleSweep.js");
const Angle_1 = __webpack_require__(/*! ../geometry3d/Angle */ "./lib/geometry3d/Angle.js");
const Polynomials_1 = __webpack_require__(/*! ../numerics/Polynomials */ "./lib/numerics/Polynomials.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Matrix3d_1 = __webpack_require__(/*! ../geometry3d/Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const Ray3d_1 = __webpack_require__(/*! ../geometry3d/Ray3d */ "./lib/geometry3d/Ray3d.js");
const Plane3dByOriginAndVectors_1 = __webpack_require__(/*! ../geometry3d/Plane3dByOriginAndVectors */ "./lib/geometry3d/Plane3dByOriginAndVectors.js");
const CurvePrimitive_1 = __webpack_require__(/*! ./CurvePrimitive */ "./lib/curve/CurvePrimitive.js");
const CurveLocationDetail_1 = __webpack_require__(/*! ./CurveLocationDetail */ "./lib/curve/CurveLocationDetail.js");
const StrokeOptions_1 = __webpack_require__(/*! ./StrokeOptions */ "./lib/curve/StrokeOptions.js");
const LineString3d_1 = __webpack_require__(/*! ./LineString3d */ "./lib/curve/LineString3d.js");
/* tslint:disable:variable-name no-empty*/
/**
 * Circular or elliptic arc.
 *
 * * The angle to point equation is:
 *
 * **  `X = center + cos(theta) * vector0 + sin(theta) * vector90`
 * * When the two vectors are perpendicular and have equal length, it is a true circle.
 * * Non-perpendicular vectors are always elliptic.
 * *  vectors of unequal length are always elliptic.
 * * To create an ellipse in the common "major and minor axis" form of an ellipse:
 * ** vector0 is the vector from the center to the major axis extreme.
 * ** vector90 is the vector from the center to the minor axis extreme.
 * ** note the constructing the vectors to the extreme points makes them perpendicular.
 * *  The method toScaledMatrix3d () can be called to convert the unrestricted vector0,vector90 to perpendicular form.
 * * The unrestricted form is much easier to work with for common calculations -- stroking, projection to 2d, intersection with plane.
 */
class Arc3d extends CurvePrimitive_1.CurvePrimitive {
    // constructor copies the pointers !!!
    constructor(center, matrix, sweep) {
        super();
        this._center = center;
        this._matrix = matrix;
        this._sweep = sweep;
    }
    isSameGeometryClass(other) { return other instanceof Arc3d; }
    /**
     * read property for (clone of) center
     */
    get center() { return this._center.clone(); }
    /**
     * read property for (clone of) vector0
     */
    get vector0() { return this._matrix.columnX(); }
    /**
     * read property for (clone of) vector90
     */
    get vector90() { return this._matrix.columnY(); }
    /**
     * read property for (clone of) matrix of vector0, vector90, unit normal
     */
    get matrix() { return this._matrix.clone(); }
    get sweep() { return this._sweep; }
    set sweep(value) { this._sweep.setFrom(value); }
    /**
     * An Arc3d extends along its complete elliptic arc
     */
    get isExtensibleFractionSpace() { return true; }
    cloneTransformed(transform) {
        const c = this.clone();
        c.tryTransformInPlace(transform);
        return c;
    }
    setRefs(center, matrix, sweep) {
        this._center = center;
        this._matrix = matrix;
        this._sweep = sweep;
    }
    set(center, matrix, sweep) {
        this.setRefs(center.clone(), matrix.clone(), sweep ? sweep.clone() : AngleSweep_1.AngleSweep.create360());
    }
    setFrom(other) {
        this._center.setFrom(other._center);
        this._matrix.setFrom(other._matrix);
        this._sweep.setFrom(other._sweep);
    }
    clone() {
        return new Arc3d(this._center.clone(), this._matrix.clone(), this._sweep.clone());
    }
    static createRefs(center, matrix, sweep, result) {
        if (result) {
            result.setRefs(center, matrix, sweep);
            return result;
        }
        return new Arc3d(center, matrix, sweep);
    }
    static createScaledXYColumns(center, matrix, radius0, radius90, sweep, result) {
        const vector0 = matrix.columnX();
        const vector90 = matrix.columnY();
        return Arc3d.create(center, vector0.scale(radius0, vector0), vector90.scale(radius90, vector90), sweep, result);
    }
    static create(center, vector0, vector90, sweep, result) {
        const normal = vector0.unitCrossProductWithDefault(vector90, 0, 0, 0); // normal will be 000 for degenerate case ! !!
        const matrix = Matrix3d_1.Matrix3d.createColumns(vector0, vector90, normal);
        if (result) {
            result.setRefs(center.clone(), matrix, sweep ? sweep.clone() : AngleSweep_1.AngleSweep.create360());
            return result;
        }
        return new Arc3d(center.clone(), matrix, sweep ? sweep.clone() : AngleSweep_1.AngleSweep.create360());
    }
    /**
     * Return a quick estimate of the eccentricity of the ellipse.
     * * The estimator is the cross magnitude of the product of vectors U and V, divided by square of the larger magnitude
     * * for typical Arc3d with perpendicular UV, this is exactly the small axis divided by large.
     * * note that the eccentricity is AT MOST ONE.
     */
    quickEccentricity() {
        const magX = this._matrix.columnXMagnitude();
        const magY = this._matrix.columnYMagnitude();
        const jacobian = this._matrix.columnXYCrossProductMagnitude();
        const largeAxis = Geometry_1.Geometry.maxXY(magX, magY);
        return jacobian / (largeAxis * largeAxis);
    }
    /** Create a circular arc defined by start point, any intermediate point, and end point.
     * If the points are colinear, assemble them into a linestring.
     */
    static createCircularStartMiddleEnd(pointA, pointB, pointC, result) {
        const vectorAB = Point3dVector3d_1.Vector3d.createStartEnd(pointA, pointB);
        const vectorAC = Point3dVector3d_1.Vector3d.createStartEnd(pointA, pointC);
        const ab = vectorAB.magnitude();
        const bc = vectorAC.magnitude();
        const normal = vectorAB.sizedCrossProduct(vectorAC, Math.sqrt(ab * bc));
        if (normal) {
            const vectorToCenter = Polynomials_1.SmallSystem.linearSystem3d(normal.x, normal.y, normal.z, vectorAB.x, vectorAB.y, vectorAB.z, vectorAC.x, vectorAC.y, vectorAC.z, 0, // vectorToCenter DOT normal = 0
            0.5 * ab * ab, // vectorToCenter DOT vectorBA = 0.5 * vectorBA DOT vectorBA  (Rayleigh quotient)
            0.5 * bc * bc); // vectorToCenter DOT vectorBC = 0.5 * vectorBC DOT vectorBC  (Rayleigh quotient)
            if (vectorToCenter) {
                const center = Point3dVector3d_1.Point3d.create(pointA.x, pointA.y, pointA.z).plus(vectorToCenter);
                const vectorX = Point3dVector3d_1.Vector3d.createStartEnd(center, pointA);
                const vectorY = Point3dVector3d_1.Vector3d.createRotateVectorAroundVector(vectorX, normal, Angle_1.Angle.createDegrees(90));
                if (vectorY) {
                    const vectorCenterToC = Point3dVector3d_1.Vector3d.createStartEnd(center, pointC);
                    const sweepAngle = vectorX.signedAngleTo(vectorCenterToC, normal);
                    return Arc3d.create(center, vectorX, vectorY, AngleSweep_1.AngleSweep.createStartEndRadians(0.0, sweepAngle.radians), result);
                }
            }
        }
        return LineString3d_1.LineString3d.create(pointA, pointB, pointC);
    }
    /** The arc has simple proportional arc length if and only if it is a circular arc. */
    getFractionToDistanceScale() {
        const radius = this.circularRadius();
        if (radius !== undefined)
            return Math.abs(radius * this._sweep.sweepRadians);
        return undefined;
    }
    fractionToPoint(fraction, result) {
        const radians = this._sweep.fractionToRadians(fraction);
        return this._matrix.originPlusMatrixTimesXY(this._center, Math.cos(radians), Math.sin(radians), result);
    }
    fractionToPointAndDerivative(fraction, result) {
        result = this.radiansToPointAndDerivative(this._sweep.fractionToRadians(fraction), result);
        result.direction.scaleInPlace(this._sweep.sweepRadians);
        return result;
    }
    /** Construct a plane with
     * * origin at the fractional position along the arc
     * * x axis is the first derivative, i.e. tangent along the arc
     * * y axis is the second derivative, i.e. in the plane and on the center side of the tangent.
     * If the arc is circular, the second derivative is directly towards the center
     */
    fractionToPointAnd2Derivatives(fraction, result) {
        const radians = this._sweep.fractionToRadians(fraction);
        if (!result)
            result = Plane3dByOriginAndVectors_1.Plane3dByOriginAndVectors.createXYPlane();
        const c = Math.cos(radians);
        const s = Math.sin(radians);
        this._matrix.originPlusMatrixTimesXY(this._center, c, s, result.origin);
        const a = this._sweep.sweepRadians;
        this._matrix.multiplyXY(-a * s, a * c, result.vectorU);
        const aa = a * a;
        this._matrix.multiplyXY(-aa * c, -aa * s, result.vectorV);
        return result;
    }
    radiansToPointAndDerivative(radians, result) {
        result = result ? result : Ray3d_1.Ray3d.createZero();
        const c = Math.cos(radians);
        const s = Math.sin(radians);
        this._matrix.originPlusMatrixTimesXY(this._center, c, s, result.origin);
        this._matrix.multiplyXY(-s, c, result.direction);
        return result;
    }
    angleToPointAndDerivative(theta, result) {
        result = result ? result : Ray3d_1.Ray3d.createZero();
        const c = theta.cos();
        const s = theta.sin();
        this._matrix.originPlusMatrixTimesXY(this._center, c, s, result.origin);
        this._matrix.multiplyXY(-s, c, result.direction);
        return result;
    }
    startPoint(result) { return this.fractionToPoint(0.0, result); }
    endPoint(result) { return this.fractionToPoint(1.0, result); }
    /** * If this is a circular arc, return the simple length derived from radius and sweep.
     * * Otherwise (i.e. if this elliptical) fall through to CurvePrimitive base implementation which
     *     Uses quadrature.
     */
    curveLength() {
        return this.curveLengthBetweenFractions(0, 1);
    }
    /** * If this is a circular arc, return the simple length derived from radius and sweep.
     * * Otherwise (i.e. if this elliptical) fall through CurvePrimitive integrator.
     */
    curveLengthBetweenFractions(fraction0, fraction1) {
        const simpleLength = this.getFractionToDistanceScale();
        if (simpleLength !== undefined)
            return simpleLength * Math.abs(fraction1 - fraction0);
        // fall through for true ellipse . .. stroke and accumulate quadrature with typical count .  ..
        let f0 = fraction0;
        let f1 = fraction1;
        if (fraction0 > fraction1) {
            f0 = fraction1;
            f1 = fraction0;
        }
        const sweepDegrees = (f1 - f0) * this._sweep.sweepDegrees;
        let eccentricity = this.quickEccentricity();
        if (eccentricity < 0.00001)
            eccentricity = 0.00001;
        let numInterval = Math.ceil(sweepDegrees / (eccentricity * Arc3d.quadratureIntervalAngleDegrees));
        if (numInterval > 400)
            numInterval = 400;
        if (numInterval < 1)
            numInterval = 1;
        return super.curveLengthWithFixedIntervalCountQuadrature(f0, f1, numInterval, Arc3d.quadratureGuassCount);
    }
    /**
     * Return an approximate (but easy to compute) arc length.
     * The estimate is:
     * * Form 8 chords on full circle, proportionally fewer for partials.  (But 2 extras if less than half circle.)
     * * sum the chord lengths
     * * For a circle, we know this crude approximation has to be increased by a factor (theta/(2 sin (theta/2)))
     * * Apply that factor.
     * * Experiments confirm that this is within 3 percent for a variety of eccentricities and arc sweeps.
     */
    quickLength() {
        const totalSweep = Math.abs(this._sweep.sweepRadians);
        let numInterval = Math.ceil(4 * totalSweep / Math.PI);
        if (numInterval < 1)
            numInterval = 1;
        if (numInterval < 4)
            numInterval += 3;
        else if (numInterval < 6)
            numInterval += 2; // force extras for short arcs
        const pointA = Arc3d._workPointA;
        const pointB = Arc3d._workPointB;
        let chordSum = 0.0;
        this.fractionToPoint(0.0, pointA);
        for (let i = 1; i <= numInterval; i++) {
            this.fractionToPoint(i / numInterval, pointB);
            chordSum += pointA.distance(pointB);
            pointA.setFromPoint3d(pointB);
        }
        // The chord sum is always shorter.
        // if it is a true circular arc, the ratio of correct over sum is easy ...
        const dTheta = totalSweep / numInterval;
        const factor = dTheta / (2.0 * Math.sin(0.5 * dTheta));
        return chordSum * factor;
    }
    /**
     * * See extended comments on `CurvePrimitive.moveSignedDistanceFromFraction`
     * * A zero length line generates `CurveSearchStatus.error`
     * * Nonzero length line generates `CurveSearchStatus.success` or `CurveSearchStatus.stoppedAtBoundary`
     */
    moveSignedDistanceFromFraction(startFraction, signedDistance, allowExtension, result) {
        if (!this.isCircular) // suppress extension !!!
            return super.moveSignedDistanceFromFractionGeneric(startFraction, signedDistance, allowExtension, result);
        const totalLength = this.curveLength();
        const signedFractionMove = Geometry_1.Geometry.conditionalDivideFraction(signedDistance, totalLength);
        if (signedFractionMove === undefined) {
            return CurveLocationDetail_1.CurveLocationDetail.createCurveFractionPointDistanceCurveSearchStatus(this, startFraction, this.fractionToPoint(startFraction), 0.0, CurveLocationDetail_1.CurveSearchStatus.error);
        }
        return CurveLocationDetail_1.CurveLocationDetail.createConditionalMoveSignedDistance(allowExtension, this, startFraction, startFraction + signedFractionMove, signedDistance, result);
    }
    allPerpendicularAngles(spacePoint, _extend = false, _endpoints = false) {
        const radians = [];
        const vectorQ = spacePoint.vectorTo(this.center);
        const uu = this.matrix.columnXMagnitudeSquared();
        const uv = this._matrix.columnXDotColumnY();
        const vv = this._matrix.columnYMagnitudeSquared();
        Polynomials_1.TrigPolynomial.SolveUnitCircleImplicitQuadricIntersection(uv, vv - uu, -uv, this.matrix.dotColumnY(vectorQ), -this.matrix.dotColumnX(vectorQ), 0.0, radians);
        return radians;
    }
    closestPoint(spacePoint, extend, result) {
        result = CurveLocationDetail_1.CurveLocationDetail.create(this, result);
        const allRadians = this.allPerpendicularAngles(spacePoint);
        if (!extend && !this._sweep.isFullCircle) {
            allRadians.push(this._sweep.startRadians);
            allRadians.push(this._sweep.endRadians);
        }
        // hm... logically there must at least two angles there ...  but if it happens return the start point ...
        const workRay = Ray3d_1.Ray3d.createZero();
        if (allRadians.length === 0) {
            result.setFR(0.0, this.radiansToPointAndDerivative(this._sweep.startRadians, workRay));
            result.a = spacePoint.distance(result.point);
        }
        else {
            let dMin = Number.MAX_VALUE;
            let d = 0;
            for (const radians of allRadians) {
                if (extend || this._sweep.isRadiansInSweep(radians)) {
                    this.radiansToPointAndDerivative(radians, workRay);
                    d = spacePoint.distance(workRay.origin);
                    if (d < dMin) {
                        dMin = d;
                        result.setFR(this._sweep.radiansToSignedPeriodicFraction(radians), workRay);
                        result.a = d;
                    }
                }
            }
        }
        return result;
    }
    reverseInPlace() { this._sweep.reverseInPlace(); }
    tryTransformInPlace(transform) {
        this._center = transform.multiplyPoint3d(this._center, this._center);
        this._matrix = transform.matrix.multiplyMatrixMatrix(this._matrix, this._matrix);
        // force re-normalization of columnZ.
        this.setVector0Vector90(this._matrix.columnX(), this._matrix.columnY());
        return true;
    }
    isInPlane(plane) {
        const normal = plane.getNormalRef();
        // The ellipse vectors are full-length  -- true distance comparisons say things.
        return Geometry_1.Geometry.isSmallMetricDistance(plane.altitude(this._center))
            && Geometry_1.Geometry.isSmallMetricDistance(this._matrix.dotColumnX(normal))
            && Geometry_1.Geometry.isSmallMetricDistance(this._matrix.dotColumnY(normal));
    }
    get isCircular() {
        const axx = this._matrix.columnXMagnitudeSquared();
        const ayy = this._matrix.columnYMagnitudeSquared();
        const axy = this._matrix.columnXDotColumnY();
        return Angle_1.Angle.isPerpendicularDotSet(axx, ayy, axy) && Geometry_1.Geometry.isSameCoordinateSquared(axx, ayy);
    }
    /** If the arc is circular, return its radius.  Otherwise return undefined */
    circularRadius() {
        return this.isCircular ? this._matrix.columnXMagnitude() : undefined;
    }
    /** Return the larger of the two defining vectors. */
    maxVectorLength() { return Math.max(this._matrix.columnXMagnitude(), this._matrix.columnYMagnitude()); }
    appendPlaneIntersectionPoints(plane, result) {
        const constCoff = plane.altitude(this._center);
        const coffs = this._matrix.coffs;
        const cosCoff = plane.velocityXYZ(coffs[0], coffs[3], coffs[6]);
        const sinCoff = plane.velocityXYZ(coffs[1], coffs[4], coffs[7]);
        const trigPoints = Geometry_1.Geometry.solveTrigForm(constCoff, cosCoff, sinCoff);
        let numIntersection = 0;
        if (trigPoints !== undefined) {
            numIntersection = trigPoints.length;
            let xy;
            for (xy of trigPoints) {
                const radians = Math.atan2(xy.y, xy.x);
                const fraction = this._sweep.radiansToPositivePeriodicFraction(radians);
                result.push(CurveLocationDetail_1.CurveLocationDetail.createCurveFractionPoint(this, fraction, this.fractionToPoint(fraction)));
            }
        }
        return numIntersection;
    }
    extendRange(range) {
        const df = 1.0 / 32;
        // KLUDGE --- evaluate lots of points ...
        let point = Point3dVector3d_1.Point3d.create();
        for (let fraction = 0; fraction <= 1.001; fraction += df) {
            point = this.fractionToPoint(fraction, point);
            range.extendPoint(point);
        }
    }
    static createUnitCircle() {
        return Arc3d.createRefs(Point3dVector3d_1.Point3d.create(0, 0, 0), Matrix3d_1.Matrix3d.createIdentity(), AngleSweep_1.AngleSweep.create360());
    }
    /**
     * @param center center of arc
     * @param radius radius of arc
     * @param sweep sweep limits.  defaults to full circle.
     */
    static createXY(center, radius, sweep = AngleSweep_1.AngleSweep.create360()) {
        return new Arc3d(center.clone(), Matrix3d_1.Matrix3d.createScale(radius, radius, 1.0), sweep);
    }
    static createXYEllipse(center, radiusA, radiusB, sweep = AngleSweep_1.AngleSweep.create360()) {
        return new Arc3d(center.clone(), Matrix3d_1.Matrix3d.createScale(radiusA, radiusB, 1.0), sweep);
    }
    setVector0Vector90(vector0, vector90) {
        this._matrix.setColumns(vector0, vector90, vector0.unitCrossProductWithDefault(vector90, 0, 0, 0));
    }
    toScaledMatrix3d() {
        const angleData = Angle_1.Angle.dotProductsToHalfAngleTrigValues(this._matrix.columnXMagnitudeSquared(), this._matrix.columnYMagnitudeSquared(), this._matrix.columnXDotColumnY(), true);
        const vector0A = this._matrix.multiplyXY(angleData.c, angleData.s);
        const vector90A = this._matrix.multiplyXY(-angleData.s, angleData.c);
        const axes = Matrix3d_1.Matrix3d.createRigidFromColumns(vector0A, vector90A, 0 /* XYZ */);
        return {
            axes: (axes ? axes : Matrix3d_1.Matrix3d.createIdentity()),
            center: this._center,
            r0: vector0A.magnitude(),
            r90: vector90A.magnitude(),
            sweep: this.sweep.cloneMinusRadians(angleData.radians),
        };
    }
    /** Return the arc definition with center, two vectors, and angle sweep;
     */
    toVectors() {
        return {
            center: this.center,
            vector0: this.matrix.columnX(),
            vector90: this.matrix.columnY(),
            sweep: this.sweep,
        };
    }
    /** Return the arc definition with center, two vectors, and angle sweep, optionally transformed.
     */
    toTransformedVectors(transform) {
        return transform ? {
            center: transform.multiplyPoint3d(this._center),
            vector0: transform.multiplyVector(this._matrix.columnX()),
            vector90: transform.multiplyVector(this._matrix.columnY()),
            sweep: this.sweep,
        }
            : {
                center: this._center.clone(),
                vector0: this._matrix.columnX(),
                vector90: this._matrix.columnY(),
                sweep: this.sweep,
            };
    }
    /** Return the arc definition with center, two vectors, and angle sweep, transformed to 4d points.
     */
    toTransformedPoint4d(matrix) {
        return {
            center: matrix.multiplyPoint3d(this._center, 1.0),
            vector0: matrix.multiplyPoint3d(this._matrix.columnX(), 0.0),
            vector90: matrix.multiplyPoint3d(this._matrix.columnY(), 0.0),
            sweep: this.sweep,
        };
    }
    setFromJSON(json) {
        if (json && json.center && json.vector0 && json.vector90 && json.sweep) {
            this._center.setFromJSON(json.center);
            const vector0 = Point3dVector3d_1.Vector3d.create();
            const vector90 = Point3dVector3d_1.Vector3d.create();
            vector0.setFromJSON(json.vector0);
            vector90.setFromJSON(json.vector90);
            this.setVector0Vector90(vector0, vector90);
            this._sweep.setFromJSON(json.sweep);
        }
        else {
            this._center.set(0, 0, 0);
            this._matrix.setFrom(Matrix3d_1.Matrix3d.identity);
            this._sweep.setStartEndRadians();
        }
    }
    /**
     * Convert to a JSON object.
     * @return {*} [center:  [], vector0:[], vector90:[], sweep []}
     */
    toJSON() {
        return {
            center: this._center.toJSON(),
            sweep: this._sweep.toJSON(),
            vector0: this._matrix.columnX().toJSON(),
            vector90: this._matrix.columnY().toJSON(),
        };
    }
    isAlmostEqual(otherGeometry) {
        if (otherGeometry instanceof Arc3d) {
            const other = otherGeometry;
            return this._center.isAlmostEqual(other._center)
                && this._matrix.isAlmostEqual(other._matrix)
                && this._sweep.isAlmostEqualAllowPeriodShift(other._sweep);
        }
        return false;
    }
    /** Emit strokes to caller-supplied linestring */
    emitStrokes(dest, options) {
        let numStrokes = 1;
        if (options) {
            const rMax = this.maxVectorLength();
            numStrokes = options.applyTolerancesToArc(rMax, this._sweep.sweepRadians);
        }
        else {
            numStrokes = StrokeOptions_1.StrokeOptions.applyAngleTol(undefined, 1, this._sweep.sweepRadians);
        }
        dest.appendFractionalStrokePoints(this, numStrokes, 0.0, 1.0, true);
    }
    /** Emit strokes to caller-supplied handler */
    emitStrokableParts(handler, options) {
        let numStrokes = 1;
        if (options) {
            const rMax = this.maxVectorLength();
            numStrokes = options.applyTolerancesToArc(rMax, this._sweep.sweepRadians);
        }
        else {
            numStrokes = StrokeOptions_1.StrokeOptions.applyAngleTol(undefined, 1, this._sweep.sweepRadians);
        }
        handler.startCurvePrimitive(this);
        handler.announceIntervalForUniformStepStrokes(this, numStrokes, 0.0, 1.0);
        handler.endCurvePrimitive(this);
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleArc3d(this);
    }
    /** Return (if possible) an arc which is a portion of this curve.
     * @param fractionA [in] start fraction
     * @param fractionB [in] end fraction
     */
    clonePartialCurve(fractionA, fractionB) {
        if (fractionB < fractionA) {
            const arcA = this.clonePartialCurve(fractionB, fractionA);
            if (arcA)
                arcA.reverseInPlace();
            return arcA;
        }
        const arcB = this.clone();
        arcB.sweep.setStartEndRadians(this.sweep.fractionToRadians(fractionA), this.sweep.fractionToRadians(fractionB));
        return arcB;
    }
    /**
     * Find intervals of this curveprimitve that are interior to a clipper
     * @param clipper clip structure (e.g.clip planes)
     * @param announce(optional) function to be called announcing fractional intervals"  ` announce(fraction0, fraction1, curvePrimitive)`
     * @returns true if any "in" segments are announced.
     */
    announceClipIntervals(clipper, announce) {
        return clipper.announceClippedArcIntervals(this, announce);
    }
}
Arc3d._workPointA = Point3dVector3d_1.Point3d.create();
Arc3d._workPointB = Point3dVector3d_1.Point3d.create();
Arc3d.quadratureGuassCount = 5;
/** In quadrature for arc length, use this interval (divided by quickEccentricity) */
Arc3d.quadratureIntervalAngleDegrees = 10.0;
exports.Arc3d = Arc3d;


/***/ }),

/***/ "./lib/curve/ConstructCurveBetweenCurves.js":
/*!**************************************************!*\
  !*** ./lib/curve/ConstructCurveBetweenCurves.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const GeometryHandler_1 = __webpack_require__(/*! ../geometry3d/GeometryHandler */ "./lib/geometry3d/GeometryHandler.js");
const LineSegment3d_1 = __webpack_require__(/*! ./LineSegment3d */ "./lib/curve/LineSegment3d.js");
const Arc3d_1 = __webpack_require__(/*! ./Arc3d */ "./lib/curve/Arc3d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const LineString3d_1 = __webpack_require__(/*! ./LineString3d */ "./lib/curve/LineString3d.js");
/**
 * Context for constructing a curve that is interpolated between two other curves.
 * * The only callable method is the static `InterpolateBetween`.
 * * Other methods are called only by `dispatchToGeometryHandler`
 */
class ConstructCurveBetweenCurves extends GeometryHandler_1.NullGeometryHandler {
    constructor(_geometry0, _fraction, _geometry1) {
        super();
        // this.geometry0 = _geometry0;   <-- Never used
        this._geometry1 = _geometry1;
        this._fraction = _fraction;
    }
    /**
     * * To be directly called only by double displatcher
     * * Assumes this.geometry1 was set by calling context.
     * * Construct the interpoalted curve between this.geomtry1 and the supplied segment0.
     */
    handleLineSegment3d(segment0) {
        if (this._geometry1 instanceof LineSegment3d_1.LineSegment3d) {
            const segment1 = this._geometry1;
            return LineSegment3d_1.LineSegment3d.create(segment0.startPoint().interpolate(this._fraction, segment1.startPoint()), segment0.endPoint().interpolate(this._fraction, segment1.endPoint()));
        }
        return undefined;
    }
    /**
     * * To be directly called only by double displatcher
     * * Assumes this.geometry1 was set by calling context.
     * * Construct the interpoalted curve between this.geomtry1 and the supplied ls0.
     */
    handleLineString3d(ls0) {
        if (this._geometry1 instanceof LineString3d_1.LineString3d) {
            const ls1 = this._geometry1;
            if (ls0.numPoints() === ls1.numPoints()) {
                const ls = LineString3d_1.LineString3d.create();
                const workPoint = Point3dVector3d_1.Point3d.create();
                const workPoint0 = Point3dVector3d_1.Point3d.create();
                const workPoint1 = Point3dVector3d_1.Point3d.create();
                for (let i = 0; i < ls0.numPoints(); i++) {
                    ls0.pointAt(i, workPoint0);
                    ls1.pointAt(i, workPoint1);
                    workPoint0.interpolate(this._fraction, workPoint1, workPoint);
                    ls.addPoint(workPoint);
                }
                return ls;
            }
        }
        return undefined;
    }
    /**
     * * To be directly called only by double displatcher
     * * Assumes this.geometry1 was set by calling context.
     * * Construct the interpoalted curve between this.geomtry1 and the supplied arc0.
     */
    handleArc3d(arc0) {
        if (this._geometry1 instanceof Arc3d_1.Arc3d) {
            const arc1 = this._geometry1;
            return Arc3d_1.Arc3d.create(arc0.center.interpolate(this._fraction, arc1.center), arc0.vector0.interpolate(this._fraction, arc1.vector0), arc0.vector90.interpolate(this._fraction, arc1.vector90), arc0.sweep.interpolate(this._fraction, arc1.sweep));
        }
        return undefined;
    }
    /**
     * Construct a geometry item which is fractionally interpolated btween two others.
     * * The construction is only supported between certain types:
     * * * LineSegment3d+LineSegment3d -- endpoints are interpolated
     * * * LineString3d+LineString3d with matching counts.  Each point is interpolated.
     * * * Arc3d+Arc3d -- center, vector0, vector90, and limit angles of the sweep are interpolated.
     * @param geometry0 geometry "at fraction 0"
     * @param fraction  fractional positon
     * @param geometry1 geometry "at fraction 1"
     */
    static InterpolateBetween(geometry0, fraction, geometry1) {
        const handler = new ConstructCurveBetweenCurves(geometry0, fraction, geometry1);
        return geometry0.dispatchToGeometryHandler(handler);
    }
}
exports.ConstructCurveBetweenCurves = ConstructCurveBetweenCurves;


/***/ }),

/***/ "./lib/curve/CoordinateXYZ.js":
/*!************************************!*\
  !*** ./lib/curve/CoordinateXYZ.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Range_1 = __webpack_require__(/*! ../geometry3d/Range */ "./lib/geometry3d/Range.js");
const GeometryQuery_1 = __webpack_require__(/*! ./GeometryQuery */ "./lib/curve/GeometryQuery.js");
/** A Coordinate is a persistable Point3d */
class CoordinateXYZ extends GeometryQuery_1.GeometryQuery {
    get point() { return this._xyz; }
    /**
     * @param xyz point to be CAPTURED.
     */
    constructor(xyz) {
        super();
        this._xyz = xyz;
    }
    static create(point) {
        return new CoordinateXYZ(point.clone());
    }
    /** return the range of the point */
    range() { return Range_1.Range3d.create(this._xyz); }
    extendRange(rangeToExtend, transform) {
        if (transform)
            rangeToExtend.extendTransformedXYZ(transform, this._xyz.x, this._xyz.y, this._xyz.z);
        else
            rangeToExtend.extend(this._xyz);
    }
    /** Apply transform to the Coordinate's point. */
    tryTransformInPlace(transform) {
        transform.multiplyPoint3d(this._xyz, this._xyz);
        return true;
    }
    /** return a transformed clone.
     */
    cloneTransformed(transform) {
        const result = new CoordinateXYZ(this._xyz.clone());
        result.tryTransformInPlace(transform);
        return result;
    }
    /** return a clone */
    clone() {
        return new CoordinateXYZ(this._xyz.clone());
    }
    /** return GeometryQuery children for recursive queries.
     *
     * * leaf classes do not need to implement.
     */
    /** test if (other instanceof Coordinate).  */
    isSameGeometryClass(other) {
        return other instanceof CoordinateXYZ;
    }
    /** test for exact structure and nearly identical geometry.
     *
     * *  Leaf classes must implement !!!
     * *  base class implementation recurses through children.
     * *  base implementation is complete for classes with children and no properties.
     * *  classes with both children and properties must implement for properties, call super for children.
     */
    isAlmostEqual(other) {
        return (other instanceof CoordinateXYZ) && this._xyz.isAlmostEqual(other._xyz);
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleCoordinateXYZ(this);
    }
}
exports.CoordinateXYZ = CoordinateXYZ;


/***/ }),

/***/ "./lib/curve/CurveCollection.js":
/*!**************************************!*\
  !*** ./lib/curve/CurveCollection.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const GeometryQuery_1 = __webpack_require__(/*! ./GeometryQuery */ "./lib/curve/GeometryQuery.js");
const CurveProcessor_1 = __webpack_require__(/*! ./CurveProcessor */ "./lib/curve/CurveProcessor.js");
const CurvePrimitive_1 = __webpack_require__(/*! ./CurvePrimitive */ "./lib/curve/CurvePrimitive.js");
const LineSegment3d_1 = __webpack_require__(/*! ./LineSegment3d */ "./lib/curve/LineSegment3d.js");
const LineString3d_1 = __webpack_require__(/*! ./LineString3d */ "./lib/curve/LineString3d.js");
// import { SumLengthsContext, GapSearchContext, CountLinearPartsSearchContext, CloneCurvesContext, TransformInPlaceContext } from "./CurveSearches";
/** Algorithmic class: Accumulate maximum gap between adjacent primitives of CurveChain.
 */
class GapSearchContext extends CurveProcessor_1.RecursiveCurveProcessorWithStack {
    constructor() { super(); this.maxGap = 0.0; }
    static maxGap(target) {
        const context = new GapSearchContext();
        target.announceToCurveProcessor(context);
        return context.maxGap;
    }
    announceCurvePrimitive(curve, _indexInParent) {
        if (this._stack.length > 0) {
            const parent = this._stack[this._stack.length - 1];
            if (parent instanceof CurveChain) {
                const chain = parent;
                const nextCurve = chain.cyclicCurvePrimitive(_indexInParent + 1);
                if (curve !== undefined && nextCurve !== undefined) {
                    this.maxGap = Math.max(this.maxGap, curve.endPoint().distance(nextCurve.startPoint()));
                }
            }
        }
    }
}
/** Algorithmic class: Count LineSegment3d and LineString3d primitives.
 */
class CountLinearPartsSearchContext extends CurveProcessor_1.RecursiveCurveProcessorWithStack {
    constructor() {
        super();
        this.numLineSegment = 0;
        this.numLineString = 0;
        this.numOther = 0;
    }
    static hasNonLinearPrimitives(target) {
        const context = new CountLinearPartsSearchContext();
        target.announceToCurveProcessor(context);
        return context.numOther > 0;
    }
    announceCurvePrimitive(curve, _indexInParent) {
        if (curve instanceof LineSegment3d_1.LineSegment3d)
            this.numLineSegment++;
        else if (curve instanceof LineString3d_1.LineString3d)
            this.numLineString++;
        else
            this.numOther++;
    }
}
/** Algorithmic class: Transform curves in place.
 */
class TransformInPlaceContext extends CurveProcessor_1.RecursiveCurveProcessor {
    constructor(transform) { super(); this.numFail = 0; this.numOK = 0; this.transform = transform; }
    static tryTransformInPlace(target, transform) {
        const context = new TransformInPlaceContext(transform);
        target.announceToCurveProcessor(context);
        return context.numFail === 0;
    }
    announceCurvePrimitive(curvePrimitive, _indexInParent) {
        if (!curvePrimitive.tryTransformInPlace(this.transform))
            this.numFail++;
        else
            this.numOK++;
    }
}
/** Algorithmic class: Sum lengths of curves */
class SumLengthsContext extends CurveProcessor_1.RecursiveCurveProcessor {
    constructor() { super(); this._sum = 0.0; }
    static sumLengths(target) {
        const context = new SumLengthsContext();
        target.announceToCurveProcessor(context);
        return context._sum;
    }
    announceCurvePrimitive(curvePrimitive, _indexInParent) {
        this._sum += curvePrimitive.curveLength();
    }
}
/**
 * Algorithmic class for cloning curve collections.
 * * recurse through collection nodes, building image nodes as needed and inserting clones of children.
 * * for individual primitive, invoke doClone (protected) for direct clone; insert into parent
 */
class CloneCurvesContext extends CurveProcessor_1.RecursiveCurveProcessorWithStack {
    constructor(transform) {
        super();
        this._transform = transform;
        this._result = undefined;
    }
    static clone(target, transform) {
        const context = new CloneCurvesContext(transform);
        target.announceToCurveProcessor(context);
        return context._result;
    }
    enter(c) {
        if (c instanceof CurveCollection)
            super.enter(c.cloneEmptyPeer());
    }
    leave() {
        const result = super.leave();
        if (result) {
            if (this._stack.length === 0) // this should only happen once !!!
                this._result = result;
            else // push this result to top of stack.
                this._stack[this._stack.length - 1].tryAddChild(result);
        }
        return result;
    }
    // specialized cloners override this (and allow announceCurvePrimitive to insert to parent)
    doClone(primitive) {
        if (this._transform)
            return primitive.cloneTransformed(this._transform);
        return primitive.clone();
    }
    announceCurvePrimitive(primitive, _indexInParent) {
        const c = this.doClone(primitive);
        if (c && this._stack.length > 0) {
            const parent = this._stack[this._stack.length - 1];
            if (parent instanceof CurveChain) {
                parent.tryAddChild(c);
            }
            else if (parent instanceof BagOfCurves) {
                parent.tryAddChild(c);
            }
        }
    }
}
/**
 * * A `CurveCollection` is an abstract (non-instantiable) class for various sets of curves with particular structures:
 * * * `Path` - a sequence of `CurvePrimitive` joining head-to-tail (but not required to close, and not enclosing a planar area)
 * * * `Loop` - a sequence of coplanar `CurvePrimitive` joining head-to-tail, and closing from last to first so that they enclose a planar area.
 * * * `ParityRegion` -- a colletion of coplanar `Loop`s, with "in/out" classification by parity rules
 * * * `UnionRegion` -- a colletion of coplanar `Loop`s, with "in/out" classification by union rules
 * * * `BagOfCurves` -- a collection of `AnyCurve` with no implied structure.
 */
class CurveCollection extends GeometryQuery_1.GeometryQuery {
    constructor() {
        super(...arguments);
        /* tslint:disable:variable-name no-empty*/
        // Only used by the Loop class, which is needed during a check in DGNJS writing
        this.isInner = false;
    }
    /** Return the sum of the lengths of all contained curves. */
    sumLengths() { return SumLengthsContext.sumLengths(this); }
    /** return the max gap between adjacent primitives in Path and Loop collctions.
     *
     * * In a Path, gaps are computed between consecutive primitives.
     * * In a Loop, gaps are comptued between consecutvie primtives and between last and first.
     * * gaps are NOT computed between consecutive CurvePrimitives in "unstructured" collections.  The type is "unstructured" so gaps should not be semantically meaningful.
     */
    maxGap() { return GapSearchContext.maxGap(this); }
    /** return true if the curve collection has any primitives other than LineSegment3d and LineString3d  */
    checkForNonLinearPrimitives() { return CountLinearPartsSearchContext.hasNonLinearPrimitives(this); }
    tryTransformInPlace(transform) { return TransformInPlaceContext.tryTransformInPlace(this, transform); }
    clone() {
        return CloneCurvesContext.clone(this);
    }
    cloneTransformed(transform) {
        return CloneCurvesContext.clone(this, transform);
    }
    /** Return true for planar region types:
     * * `Loop`
     * * `ParityRegion`
     * * `UnionRegion`
     */
    get isAnyRegionType() {
        return this.dgnBoundaryType() === 2 || this.dgnBoundaryType() === 5 || this.dgnBoundaryType() === 4;
    }
    /** Return true for a `Path`, i.e. a chain of curves joined head-to-tail
     */
    get isOpenPath() {
        return this.dgnBoundaryType() === 1;
    }
    /** Return true for a single-loop planar region type, i.e. `Loop`.
     * * This is _not- a test for physical closure of a `Path`
     */
    get isClosedPath() {
        return this.dgnBoundaryType() === 2;
    }
    /** Extend (increase) `rangeToExtend` as needed to include these curves (optionally transformed)
     */
    extendRange(rangeToExtend, transform) {
        const children = this.children;
        if (children) {
            for (const c of children) {
                c.extendRange(rangeToExtend, transform);
            }
        }
    }
}
exports.CurveCollection = CurveCollection;
/** Shared base class for use by both open and closed paths.
 * A curveChain contains only curvePrimitives.  No other paths, loops, or regions allowed.
 */
class CurveChain extends CurveCollection {
    constructor() { super(); this._curves = []; }
    // _curves should be initialized in ctor.  But it doesn't happen.
    get children() {
        if (this._curves === undefined)
            this._curves = [];
        return this._curves;
    }
    getPackedStrokes(options) {
        const tree = this.cloneStroked(options);
        if (tree instanceof CurveChain) {
            const children = tree.children;
            if (children.length === 1) {
                const ls = children[0];
                if (ls instanceof LineString3d_1.LineString3d)
                    return ls.packedPoints;
            }
        }
        return undefined;
    }
    cloneStroked(options) {
        const strokes = LineString3d_1.LineString3d.create();
        for (const curve of this.children)
            curve.emitStrokes(strokes, options);
        return strokes;
    }
    tryAddChild(child) {
        if (child instanceof CurvePrimitive_1.CurvePrimitive) {
            this._curves.push(child);
            return true;
        }
        return false;
    }
    getChild(i) {
        if (i < this._curves.length)
            return this._curves[i];
        return undefined;
    }
    extendRange(range, transform) {
        for (const curve of this._curves)
            curve.extendRange(range, transform);
    }
    /**
     * Reverse each child curve (in place)
     * Reverse the order of the children in the CurveChain array.
     */
    reverseChildrenInPlace() {
        for (const curve of this._curves)
            curve.reverseInPlace();
        this._curves.reverse();
    }
}
exports.CurveChain = CurveChain;
/**
 * * A `BagOfCurves` object is a collection of `AnyCurve` objects.
 * * A `BagOfCurves` is not a planar region.
 */
class BagOfCurves extends CurveCollection {
    isSameGeometryClass(other) { return other instanceof BagOfCurves; }
    constructor() { super(); this._children = []; }
    get children() { return this._children; }
    static create(...data) {
        const result = new BagOfCurves();
        for (const child of data) {
            result.tryAddChild(child);
        }
        return result;
    }
    dgnBoundaryType() { return 0; }
    announceToCurveProcessor(processor, indexInParent = -1) {
        return processor.announceBagOfCurves(this, indexInParent);
    }
    cloneStroked(options) {
        const clone = new BagOfCurves();
        let child;
        for (child of this.children) {
            if (child instanceof CurvePrimitive_1.CurvePrimitive) {
                const ls = LineString3d_1.LineString3d.create();
                child.emitStrokes(ls, options);
                if (ls)
                    clone.children.push(ls);
            }
            else if (child instanceof CurveCollection) {
                const childStrokes = child.cloneStroked(options);
                if (childStrokes)
                    clone.children.push(childStrokes);
            }
        }
        return clone;
    }
    cloneEmptyPeer() { return new BagOfCurves(); }
    tryAddChild(child) {
        this._children.push(child);
        return true;
    }
    getChild(i) {
        if (i < this._children.length)
            return this._children[i];
        return undefined;
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleBagOfCurves(this);
    }
}
exports.BagOfCurves = BagOfCurves;


/***/ }),

/***/ "./lib/curve/CurveCurveIntersectXY.js":
/*!********************************************!*\
  !*** ./lib/curve/CurveCurveIntersectXY.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Curve */
const GeometryHandler_1 = __webpack_require__(/*! ../geometry3d/GeometryHandler */ "./lib/geometry3d/GeometryHandler.js");
const CurveLocationDetail_1 = __webpack_require__(/*! ./CurveLocationDetail */ "./lib/curve/CurveLocationDetail.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const LineSegment3d_1 = __webpack_require__(/*! ./LineSegment3d */ "./lib/curve/LineSegment3d.js");
const LineString3d_1 = __webpack_require__(/*! ./LineString3d */ "./lib/curve/LineString3d.js");
// import { Arc3d } from "./Arc3d";
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
// import { LineString3d } from "./LineString3d";
const Polynomials_1 = __webpack_require__(/*! ../numerics/Polynomials */ "./lib/numerics/Polynomials.js");
const Point4d_1 = __webpack_require__(/*! ../geometry4d/Point4d */ "./lib/geometry4d/Point4d.js");
const Matrix3d_1 = __webpack_require__(/*! ../geometry3d/Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const Arc3d_1 = __webpack_require__(/*! ./Arc3d */ "./lib/curve/Arc3d.js");
const GrowableFloat64Array_1 = __webpack_require__(/*! ../geometry3d/GrowableFloat64Array */ "./lib/geometry3d/GrowableFloat64Array.js");
const BSplineCurve_1 = __webpack_require__(/*! ../bspline/BSplineCurve */ "./lib/bspline/BSplineCurve.js");
const BezierPolynomials_1 = __webpack_require__(/*! ../numerics/BezierPolynomials */ "./lib/numerics/BezierPolynomials.js");
const Newton_1 = __webpack_require__(/*! ../numerics/Newton */ "./lib/numerics/Newton.js");
const Ray3d_1 = __webpack_require__(/*! ../geometry3d/Ray3d */ "./lib/geometry3d/Ray3d.js");
/**
 * * Private class for refining bezier-bezier intersections.
 * * The inputs are assumed pre-transoformed so that the target condition is to match x and y coordinates.
 */
class BezierBezierIntersectionXYRRToRRD extends Newton_1.NewtonEvaluatorRRtoRRD {
    constructor(curveA, curveB) {
        super();
        this._curveA = curveA;
        this._curveB = curveB;
        this._rayA = Ray3d_1.Ray3d.createZero();
        this._rayB = Ray3d_1.Ray3d.createZero();
    }
    evaluate(fractionA, fractionB) {
        this._curveA.fractionToPointAndDerivative(fractionA, this._rayA);
        this._curveB.fractionToPointAndDerivative(fractionB, this._rayB);
        this.currentF.setOriginAndVectorsXYZ(this._rayB.origin.x - this._rayA.origin.x, this._rayB.origin.y - this._rayA.origin.y, 0.0, -this._rayA.direction.x, -this._rayA.direction.y, 0.0, this._rayB.direction.x, this._rayB.direction.y, 0.0);
        return true;
    }
}
/**
 * Data bundle for a pair of arrays of CurveLocationDetail structures such as produced by CurveCurve,IntersectXY and
 * CurveCurve.ClosestApproach
 */
class CurveLocationDetailArrayPair {
    constructor() {
        this.dataA = [];
        this.dataB = [];
    }
}
exports.CurveLocationDetailArrayPair = CurveLocationDetailArrayPair;
/*
 * * Handler class for XY intersections.
 * * This is local to the file (not exported)
 * * Instances are initialized and called from CurveCurve.
 */
class CurveCurveIntersectXY extends GeometryHandler_1.NullGeometryHandler {
    constructor(worldToLocal, _geometryA, extendA, geometryB, extendB) {
        super();
        // this.geometryA = _geometryA;
        this._extendA = extendA;
        this._geometryB = geometryB;
        this._extendB = extendB;
        this._worldToLocalPerspective = undefined;
        this._worldToLocalAffine = undefined;
        if (worldToLocal !== undefined && !worldToLocal.isIdentity()) {
            this._worldToLocalAffine = worldToLocal.asTransform;
            if (!this._worldToLocalAffine)
                this._worldToLocalPerspective = worldToLocal.clone();
        }
        this.reinitialize();
    }
    reinitialize() {
        this._results = new CurveLocationDetailArrayPair();
    }
    /**
     * @param reinitialize if true, a new results structure is created for use by later calls.
     * @returns Return the results structure for the intersection calculation.
     *
     */
    grabResults(reinitialize = false) {
        const result = this._results;
        if (reinitialize)
            this.reinitialize();
        return result;
    }
    acceptFraction(extend0, fraction, extend1) {
        if (!extend0 && fraction < 0.0)
            return false;
        if (!extend1 && fraction > 1.0)
            return false;
        return true;
    }
    /** compute intersection of two line segments.
     * filter by extension rules.
     * record with fraction mapping.
     */
    recordPointWithLocalFractions(localFractionA, cpA, fractionA0, fractionA1, localFractionB, // Computed intersection fraction
    cpB, fractionB0, fractionB1, reversed) {
        const globalFractionA = Geometry_1.Geometry.interpolate(fractionA0, localFractionA, fractionA1);
        const globalFractionB = Geometry_1.Geometry.interpolate(fractionB0, localFractionB, fractionB1);
        // ignore duplicate of most recent point .  ..
        const numPrevious = this._results.dataA.length;
        if (numPrevious > 0) {
            const topFractionA = this._results.dataA[numPrevious - 1].fraction;
            const topFractionB = this._results.dataB[numPrevious - 1].fraction;
            if (reversed) {
                if (Geometry_1.Geometry.isAlmostEqualNumber(topFractionA, globalFractionB) && Geometry_1.Geometry.isAlmostEqualNumber(topFractionB, globalFractionA))
                    return;
            }
            else {
                if (Geometry_1.Geometry.isAlmostEqualNumber(topFractionA, globalFractionA) && Geometry_1.Geometry.isAlmostEqualNumber(topFractionB, globalFractionB))
                    return;
            }
        }
        const detailA = CurveLocationDetail_1.CurveLocationDetail.createCurveFractionPoint(cpA, globalFractionA, cpA.fractionToPoint(globalFractionA));
        detailA.setIntervalRole(CurveLocationDetail_1.CurveIntervalRole.isolated);
        const detailB = CurveLocationDetail_1.CurveLocationDetail.createCurveFractionPoint(cpB, globalFractionB, cpB.fractionToPoint(globalFractionB));
        detailB.setIntervalRole(CurveLocationDetail_1.CurveIntervalRole.isolated);
        if (reversed) {
            this._results.dataA.push(detailB);
            this._results.dataB.push(detailA);
        }
        else {
            this._results.dataA.push(detailA);
            this._results.dataB.push(detailB);
        }
    }
    /** compute intersection of two line segments.
     * filter by extension rules.
     * record with fraction mapping.
     */
    computeSegmentSegment3D(cpA, extendA0, pointA0, fractionA0, pointA1, fractionA1, extendA1, cpB, extendB0, pointB0, fractionB0, pointB1, fractionB1, extendB1, reversed) {
        const uv = CurveCurveIntersectXY._workVector2dA;
        if (Polynomials_1.SmallSystem.lineSegment3dXYTransverseIntersectionUnbounded(pointA0, pointA1, pointB0, pointB1, uv)
            && this.acceptFraction(extendA0, uv.x, extendA1)
            && this.acceptFraction(extendB0, uv.y, extendB1)) {
            this.recordPointWithLocalFractions(uv.x, cpA, fractionA0, fractionA1, uv.y, cpB, fractionB0, fractionB1, reversed);
        }
    }
    // intersection of PROJECTED homogeneous segments ...  assumes caller knows the _worldToLocal is present
    computeSegmentSegment3DH(cpA, extendA0, pointA0, fractionA0, pointA1, fractionA1, extendA1, cpB, extendB0, pointB0, fractionB0, pointB1, fractionB1, extendB1, reversed) {
        const hA0 = CurveCurveIntersectXY._workPointA0H;
        const hA1 = CurveCurveIntersectXY._workPointA1H;
        const hB0 = CurveCurveIntersectXY._workPointB0H;
        const hB1 = CurveCurveIntersectXY._workPointB1H;
        this._worldToLocalPerspective.multiplyPoint3d(pointA0, 1, hA0);
        this._worldToLocalPerspective.multiplyPoint3d(pointA1, 1, hA1);
        this._worldToLocalPerspective.multiplyPoint3d(pointB0, 1, hB0);
        this._worldToLocalPerspective.multiplyPoint3d(pointB1, 1, hB1);
        const fractionAB = Polynomials_1.SmallSystem.lineSegment3dHXYTransverseIntersectionUnbounded(hA0, hA1, hB0, hB1);
        if (fractionAB !== undefined) {
            const fractionA = fractionAB.x;
            const fractionB = fractionAB.y;
            if (this.acceptFraction(extendA0, fractionA, extendA1) && this.acceptFraction(extendB0, fractionB, extendB1)) {
                // final fraction acceptance uses original world points, with perspective-aware fractions
                this.recordPointWithLocalFractions(fractionA, cpA, fractionA0, fractionA1, fractionB, cpB, fractionB0, fractionB1, reversed);
            }
        }
    }
    // Caller accesses data from a linesegment and passes to here.
    // (The linesegment in question might be (a) a full linesegment or (b) a fragment within a linestring.  The fraction and extend parameters
    // allow all combinations to be passed in)
    // This method applies transform.
    dispatchSegmentSegment(cpA, extendA0, pointA0, fractionA0, pointA1, fractionA1, extendA1, cpB, extendB0, pointB0, fractionB0, pointB1, fractionB1, extendB1, reversed) {
        if (this._worldToLocalAffine) {
            // non-perspective projection
            CurveCurveIntersectXY.setTransformedWorkPoints(this._worldToLocalAffine, pointA0, pointA1, pointB0, pointB1);
            this.computeSegmentSegment3D(cpA, extendA0, CurveCurveIntersectXY._workPointA0, fractionA0, CurveCurveIntersectXY._workPointA1, fractionA1, extendA1, cpB, extendB0, CurveCurveIntersectXY._workPointB0, fractionB0, CurveCurveIntersectXY._workPointB1, fractionB1, extendB1, reversed);
        }
        else if (this._worldToLocalPerspective) {
            this.computeSegmentSegment3DH(cpA, extendA0, pointA0, fractionA0, pointA1, fractionA1, extendA1, cpB, extendB0, pointB0, fractionB0, pointB1, fractionB1, extendB1, reversed);
        }
        else {
            this.computeSegmentSegment3D(cpA, extendA0, pointA0, fractionA0, pointA1, fractionA1, extendA1, cpB, extendB0, pointB0, fractionB0, pointB1, fractionB1, extendB1, reversed);
        }
    }
    // Caller accesses data from a linestring or segment and passes it here.
    // (The linesegment in question might be (a) a full linesegment or (b) a fragment within a linestring.  The fraction and extend parameters
    // allow all combinations to be passed in)
    dispatchSegmentArc(cpA, extendA0, pointA0, fractionA0, pointA1, fractionA1, extendA1, arc, extendB0, extendB1, reversed) {
        // Arc: X = C + cU + sV
        // Line:  contains points A0,A1
        // Arc point colinear with line if det (A0, A1, X) = 0
        // with homogeneous xyw points and vectors.
        // With equational X:   det (A0, A1, C) + c det (A0, A1,U) + s det (A0, A1, V) = 0.
        // solve for theta.
        // evaluate points.
        // project back to line.
        if (this._worldToLocalPerspective) {
            const data = arc.toTransformedPoint4d(this._worldToLocalPerspective);
            const pointA0H = this._worldToLocalPerspective.multiplyPoint3d(pointA0, 1);
            const pointA1H = this._worldToLocalPerspective.multiplyPoint3d(pointA1, 1);
            const alpha = Geometry_1.Geometry.tripleProductPoint4dXYW(pointA0H, pointA1H, data.center);
            const beta = Geometry_1.Geometry.tripleProductPoint4dXYW(pointA0H, pointA1H, data.vector0);
            const gamma = Geometry_1.Geometry.tripleProductPoint4dXYW(pointA0H, pointA1H, data.vector90);
            const cosines = new GrowableFloat64Array_1.GrowableFloat64Array(2);
            const sines = new GrowableFloat64Array_1.GrowableFloat64Array(2);
            const radians = new GrowableFloat64Array_1.GrowableFloat64Array(2);
            const numRoots = Polynomials_1.AnalyticRoots.appendImplicitLineUnitCircleIntersections(alpha, beta, gamma, cosines, sines, radians);
            for (let i = 0; i < numRoots; i++) {
                const arcPoint = data.center.plus2Scaled(data.vector0, cosines.at(i), data.vector90, sines.at(i));
                const arcFraction = data.sweep.radiansToSignedPeriodicFraction(radians.at(i));
                const lineFraction = Polynomials_1.SmallSystem.lineSegment3dHXYClosestPointUnbounded(pointA0H, pointA1H, arcPoint);
                if (lineFraction !== undefined && this.acceptFraction(extendA0, lineFraction, extendA1) && this.acceptFraction(extendB0, arcFraction, extendB1)) {
                    this.recordPointWithLocalFractions(lineFraction, cpA, fractionA0, fractionA1, arcFraction, arc, 0, 1, reversed);
                }
            }
        }
        else {
            const data = arc.toTransformedVectors(this._worldToLocalAffine);
            let pointA0Local = pointA0;
            let pointA1Local = pointA1;
            if (this._worldToLocalAffine) {
                pointA0Local = this._worldToLocalAffine.multiplyPoint3d(pointA0);
                pointA1Local = this._worldToLocalAffine.multiplyPoint3d(pointA1);
            }
            const alpha = Geometry_1.Geometry.tripleProductXYW(pointA0Local, 1, pointA1Local, 1, data.center, 1);
            const beta = Geometry_1.Geometry.tripleProductXYW(pointA0Local, 1, pointA1Local, 1, data.vector0, 0);
            const gamma = Geometry_1.Geometry.tripleProductXYW(pointA0Local, 1, pointA1Local, 1, data.vector90, 0);
            const cosines = new GrowableFloat64Array_1.GrowableFloat64Array(2);
            const sines = new GrowableFloat64Array_1.GrowableFloat64Array(2);
            const radians = new GrowableFloat64Array_1.GrowableFloat64Array(2);
            const numRoots = Polynomials_1.AnalyticRoots.appendImplicitLineUnitCircleIntersections(alpha, beta, gamma, cosines, sines, radians);
            for (let i = 0; i < numRoots; i++) {
                const arcPoint = data.center.plus2Scaled(data.vector0, cosines.at(i), data.vector90, sines.at(i));
                const arcFraction = data.sweep.radiansToSignedPeriodicFraction(radians.at(i));
                const lineFraction = Polynomials_1.SmallSystem.lineSegment3dXYClosestPointUnbounded(pointA0Local, pointA1Local, arcPoint);
                if (lineFraction !== undefined && this.acceptFraction(extendA0, lineFraction, extendA1) && this.acceptFraction(extendB0, arcFraction, extendB1)) {
                    this.recordPointWithLocalFractions(lineFraction, cpA, fractionA0, fractionA1, arcFraction, arc, 0, 1, reversed);
                }
            }
        }
    }
    // Caller accesses data from two arcs.
    // each matrix has [U V C] in (x,y,w) form from projection.
    // invert the projection matrix matrixA.
    // apply the inverse to matrixB. Then arcb is an ellipse in the circular space of A
    dispatchArcArc_thisOrder(cpA, matrixA, // homogeneous xyw projection !!!
    extendA, cpB, matrixB, // homogeneous xyw projection !!!
    extendB, reversed) {
        const inverseA = matrixA.inverse();
        if (inverseA) {
            const localB = inverseA.multiplyMatrixMatrix(matrixB);
            const ellipseRadians = [];
            const circleRadians = [];
            Polynomials_1.TrigPolynomial.SolveUnitCircleHomogeneousEllipseIntersection(localB.coffs[2], localB.coffs[5], localB.coffs[8], // center xyw
            localB.coffs[0], localB.coffs[3], localB.coffs[6], // center xyw
            localB.coffs[1], localB.coffs[4], localB.coffs[7], // center xyw
            ellipseRadians, circleRadians);
            for (let i = 0; i < ellipseRadians.length; i++) {
                const fractionA = cpA.sweep.radiansToSignedPeriodicFraction(circleRadians[i]);
                const fractionB = cpA.sweep.radiansToSignedPeriodicFraction(ellipseRadians[i]);
                // hm .. do we really need to check the fractions?  We know they are internal to the beziers
                if (this.acceptFraction(extendA, fractionA, extendA) && this.acceptFraction(extendB, fractionB, extendB)) {
                    this.recordPointWithLocalFractions(fractionA, cpA, 0, 1, fractionB, cpB, 0, 1, reversed);
                }
            }
        }
    }
    // Caller accesses data from two arcs.
    // Selects the best conditioned arc (in xy parts) as "circle after inversion"
    // Solves the arc-arc equations
    dispatchArcArc(cpA, extendA, cpB, extendB, reversed) {
        // Arc: X = C + cU + sV
        // Line:  contains points A0,A1
        // Arc point colinear with line if det (A0, A1, X) = 0
        // with homogeneous xyw points and vectors.
        // With equational X:   det (A0, A1, C) + c det (A0, A1,U) + s det (A0, A1, V) = 0.
        // solve for theta.
        // evaluate points.
        // project back to line.
        let matrixA;
        let matrixB;
        if (this._worldToLocalPerspective) {
            const dataA = cpA.toTransformedPoint4d(this._worldToLocalPerspective);
            const dataB = cpB.toTransformedPoint4d(this._worldToLocalPerspective);
            matrixA = Matrix3d_1.Matrix3d.createColumnsXYW(dataA.vector0, dataA.vector0.w, dataA.vector90, dataA.vector90.w, dataA.center, dataA.center.w);
            matrixB = Matrix3d_1.Matrix3d.createColumnsXYW(dataB.vector0, dataB.vector0.w, dataB.vector90, dataA.vector90.w, dataB.center, dataB.center.w);
        }
        else {
            const dataA = cpA.toTransformedVectors(this._worldToLocalAffine);
            const dataB = cpB.toTransformedVectors(this._worldToLocalAffine);
            matrixA = Matrix3d_1.Matrix3d.createColumnsXYW(dataA.vector0, 0, dataA.vector90, 0, dataA.center, 1);
            matrixB = Matrix3d_1.Matrix3d.createColumnsXYW(dataB.vector0, 0, dataB.vector90, 0, dataB.center, 1);
        }
        const conditionA = matrixA.conditionNumber();
        const conditionB = matrixB.conditionNumber();
        if (conditionA > conditionB)
            this.dispatchArcArc_thisOrder(cpA, matrixA, extendA, cpB, matrixB, extendB, reversed);
        else
            this.dispatchArcArc_thisOrder(cpB, matrixB, extendB, cpA, matrixA, extendA, !reversed);
    }
    // Caller accesses data from two arcs.
    // Selects the best conditioned arc (in xy parts) as "circle after inversion"
    // Solves the arc-arc equations
    dispatchArcBsplineCurve3d(cpA, extendA, cpB, extendB, reversed) {
        // Arc: X = C + cU + sV
        // implicitize the arc as viewed.  This "3d" matrix is homogeneous "XYW" not "xyz"
        let matrixA;
        if (this._worldToLocalPerspective) {
            const dataA = cpA.toTransformedPoint4d(this._worldToLocalPerspective);
            matrixA = Matrix3d_1.Matrix3d.createColumnsXYW(dataA.vector0, dataA.vector0.w, dataA.vector90, dataA.vector90.w, dataA.center, dataA.center.w);
        }
        else {
            const dataA = cpA.toTransformedVectors(this._worldToLocalAffine);
            matrixA = Matrix3d_1.Matrix3d.createColumnsXYW(dataA.vector0, 0, dataA.vector90, 0, dataA.center, 1);
        }
        // The worldToLocal has moved the arc vectors into screen space.
        // matrixA captures the xyw parts (ignoring z)
        // for any point in world space,
        // THIS CODE ONLY WORKS FOR
        const matrixAinverse = matrixA.inverse();
        if (matrixAinverse) {
            const orderF = cpB.order; // order of the beziers for simple coordinates
            const orderG = 2 * orderF - 1; // order of the (single) bezier for squared coordinates.
            const coffF = new Float64Array(orderF);
            const univariateBezierG = new BezierPolynomials_1.UnivariateBezier(orderG);
            const axx = matrixAinverse.at(0, 0);
            const axy = matrixAinverse.at(0, 1);
            const axz = 0.0;
            const axw = matrixAinverse.at(0, 2);
            const ayx = matrixAinverse.at(1, 0);
            const ayy = matrixAinverse.at(1, 1);
            const ayz = 0.0;
            const ayw = matrixAinverse.at(1, 2);
            const awx = matrixAinverse.at(2, 0);
            const awy = matrixAinverse.at(2, 1);
            const awz = 0.0;
            const aww = matrixAinverse.at(2, 2);
            if (matrixAinverse) {
                let bezier;
                for (let spanIndex = 0;; spanIndex++) {
                    bezier = cpB.getSaturatedBezierSpan3dH(spanIndex, bezier);
                    if (!bezier)
                        break;
                    if (this._worldToLocalPerspective)
                        bezier.tryMultiplyMatrix4dInPlace(this._worldToLocalPerspective);
                    else if (this._worldToLocalAffine)
                        bezier.tryTransformInPlace(this._worldToLocalAffine);
                    univariateBezierG.zero();
                    bezier.poleProductsXYZW(coffF, axx, axy, axz, axw);
                    univariateBezierG.addSquaredSquaredBezier(coffF, 1.0);
                    bezier.poleProductsXYZW(coffF, ayx, ayy, ayz, ayw);
                    univariateBezierG.addSquaredSquaredBezier(coffF, 1.0);
                    bezier.poleProductsXYZW(coffF, awx, awy, awz, aww);
                    univariateBezierG.addSquaredSquaredBezier(coffF, -1.0);
                    const roots = univariateBezierG.roots(0.0, true);
                    if (roots) {
                        for (const root of roots) {
                            const fractionB = bezier.fractionToParentFraction(root);
                            // The univariate bezier (which has been transformed by the view transform) evaluates into xyw space
                            const bcurvePoint4d = bezier.fractionToPoint4d(root);
                            const c = bcurvePoint4d.dotProductXYZW(axx, axy, axz, axw);
                            const s = bcurvePoint4d.dotProductXYZW(ayx, ayy, ayz, ayw);
                            const arcFraction = cpA.sweep.radiansToSignedPeriodicFraction(Math.atan2(s, c));
                            if (this.acceptFraction(extendA, arcFraction, extendA) && this.acceptFraction(extendB, fractionB, extendB)) {
                                this.recordPointWithLocalFractions(arcFraction, cpA, 0, 1, fractionB, cpB, 0, 1, reversed);
                            }
                        }
                    }
                }
            }
        }
    }
    /** apply the transformation to bezier curves. optionally construct ranges.
     *
     */
    transformBeziers(beziers) {
        if (this._worldToLocalAffine) {
            for (const bezier of beziers)
                bezier.tryTransformInPlace(this._worldToLocalAffine);
        }
        else if (this._worldToLocalPerspective) {
            for (const bezier of beziers)
                bezier.tryMultiplyMatrix4dInPlace(this._worldToLocalPerspective);
        }
    }
    getRanges(beziers) {
        const ranges = [];
        ranges.length = 0;
        for (const b of beziers) {
            ranges.push(b.range());
        }
        return ranges;
    }
    dispatchBezierBezierStrokeFirst(bezierA, bcurveA, strokeCountA, bezierB, bcurveB, _strokeCOuntB, univariateBezierB, // caller-allocated for univariate coefficients.
    reversed) {
        if (!this._xyzwA0)
            this._xyzwA0 = Point4d_1.Point4d.create();
        if (!this._xyzwA1)
            this._xyzwA1 = Point4d_1.Point4d.create();
        if (!this._xyzwPlane)
            this._xyzwPlane = Point4d_1.Point4d.create();
        if (!this._xyzwB)
            this._xyzwB = Point4d_1.Point4d.create();
        /*
    
                  const roots = univariateBezierG.roots(0.0, true);
                  if (roots) {
                    for (const root of roots) {
                      const fractionB = bezier.fractionToParentFraction(root);
                      // The univariate bezier (which has been transformed by the view transform) evaluates into xyw space
                      const bcurvePoint4d = bezier.fractionToPoint4d(root);
                      const c = bcurvePoint4d.dotProductXYZW(axx, axy, axz, axw);
                      const s = bcurvePoint4d.dotProductXYZW(ayx, ayy, ayz, ayw);
                      const arcFraction = cpA.sweep.radiansToSignedPeriodicFraction(Math.atan2(s, c));
                      if (this.acceptFraction(extendA, arcFraction, extendA) && this.acceptFraction(extendB, fractionB, extendB)) {
                        this.recordPointWithLocalFractions(arcFraction, cpA, 0, 1,
                          fractionB, cpB, 0, 1, reversed);
                      }
                    }
        */
        bezierA.fractionToPoint4d(0.0, this._xyzwA0);
        let f0 = 0.0;
        let f1 = 1.0;
        const intervalTolerance = 1.0e-5;
        const df = 1.0 / strokeCountA;
        for (let i = 1; i <= strokeCountA; i++, f0 = f1, this._xyzwA0.setFrom(this._xyzwA1)) {
            f1 = i * df;
            bezierA.fractionToPoint4d(f1, this._xyzwA1);
            Point4d_1.Point4d.createPlanePointPointZ(this._xyzwA0, this._xyzwA1, this._xyzwPlane);
            bezierB.poleProductsXYZW(univariateBezierB.coffs, this._xyzwPlane.x, this._xyzwPlane.y, this._xyzwPlane.z, this._xyzwPlane.w);
            let errors = 0;
            const roots = univariateBezierB.roots(0.0, true);
            if (roots)
                for (const r of roots) {
                    let bezierBFraction = r;
                    bezierB.fractionToPoint4d(bezierBFraction, this._xyzwB);
                    const segmentAFraction = Polynomials_1.SmallSystem.lineSegment3dHXYClosestPointUnbounded(this._xyzwA0, this._xyzwA1, this._xyzwB);
                    if (segmentAFraction && Geometry_1.Geometry.isIn01WithTolerance(segmentAFraction, intervalTolerance)) {
                        let bezierAFraction = Geometry_1.Geometry.interpolate(f0, segmentAFraction, f1);
                        const xyMatchingFunction = new BezierBezierIntersectionXYRRToRRD(bezierA, bezierB);
                        const newtonSearcher = new Newton_1.Newton2dUnboundedWithDerivative(xyMatchingFunction);
                        newtonSearcher.setUV(bezierAFraction, bezierBFraction);
                        if (newtonSearcher.runIterations()) {
                            bezierAFraction = newtonSearcher.getU();
                            bezierBFraction = newtonSearcher.getV();
                        }
                        // We have a near intersection at fractions on the two beziers !!!
                        // Iterate on the curves for a true intersection ....
                        // NEEDS WORK -- just accept . . .
                        const bcurveAFraction = bezierA.fractionToParentFraction(bezierAFraction);
                        const bcurveBFraction = bezierB.fractionToParentFraction(bezierBFraction);
                        const xyzA0 = bezierA.fractionToPoint(bezierAFraction);
                        const xyzA1 = bcurveA.fractionToPoint(bcurveAFraction);
                        const xyzB0 = bezierB.fractionToPoint(bezierBFraction);
                        const xyzB1 = bcurveB.fractionToPoint(bcurveBFraction);
                        if (!xyzA0.isAlmostEqualXY(xyzA1))
                            errors++;
                        if (!xyzB0.isAlmostEqualXY(xyzB1))
                            errors++;
                        if (errors > 0 && !xyzA0.isAlmostEqual(xyzB0))
                            errors++;
                        if (errors > 0 && !xyzA1.isAlmostEqual(xyzB1))
                            errors++;
                        if (this.acceptFraction(false, bcurveAFraction, false) && this.acceptFraction(false, bcurveBFraction, false)) {
                            this.recordPointWithLocalFractions(bcurveAFraction, bcurveA, 0, 1, bcurveBFraction, bcurveB, 0, 1, reversed);
                        }
                    }
                }
        }
    }
    // Caller accesses data from two arcs.
    // Selects the best conditioned arc (in xy parts) as "circle after inversion"
    // Solves the arc-arc equations
    dispatchBSplineCurve3dBSplineCurve3d(bcurveA, bcurveB, _reversed) {
        const bezierSpanA = bcurveA.collectBezierSpans(true);
        const bezierSpanB = bcurveB.collectBezierSpans(true);
        const numA = bezierSpanA.length;
        const numB = bezierSpanB.length;
        this.transformBeziers(bezierSpanA);
        this.transformBeziers(bezierSpanB);
        const rangeA = this.getRanges(bezierSpanA);
        const rangeB = this.getRanges(bezierSpanB);
        const orderA = bcurveA.order;
        const orderB = bcurveB.order;
        const univariateCoffsA = new BezierPolynomials_1.UnivariateBezier(orderA);
        const univairateCoffsB = new BezierPolynomials_1.UnivariateBezier(orderB);
        for (let a = 0; a < numA; a++) {
            for (let b = 0; b < numB; b++) {
                if (rangeA[a].intersectsRangeXY(rangeB[b])) {
                    const strokeCountA = bezierSpanA[a].strokeCount();
                    const strokeCountB = bezierSpanB[b].strokeCount();
                    if (strokeCountA < strokeCountB)
                        this.dispatchBezierBezierStrokeFirst(bezierSpanA[a], bcurveA, strokeCountA, bezierSpanB[b], bcurveB, strokeCountB, univairateCoffsB, !_reversed);
                    else
                        this.dispatchBezierBezierStrokeFirst(bezierSpanB[b], bcurveB, strokeCountB, bezierSpanA[a], bcurveA, strokeCountA, univariateCoffsA, _reversed);
                }
            }
        }
    }
    /**
     * Apply the projection transform (if any) to (xyz, w)
     * @param xyz xyz parts of input point.
     * @param w   weight to use for homogeneous effects
     */
    projectPoint(xyz, w = 1.0) {
        if (this._worldToLocalPerspective)
            return this._worldToLocalPerspective.multiplyPoint3d(xyz, w);
        if (this._worldToLocalAffine)
            return this._worldToLocalAffine.multiplyXYZW(xyz.x, xyz.y, xyz.z, w);
        return Point4d_1.Point4d.createFromPointAndWeight(xyz, w);
    }
    mapNPCPlaneToWorld(npcPlane, worldPlane) {
        // for NPC pointY, Y^ * H = 0 is "on" plane H.  (Hat is tranpose)
        // NPC Y is A*X for our transform A and worldPointX.
        // hence (A X)^ * H = 0
        // hence X^ * A^ * H = 0
        // hence K = A^ * H
        if (this._worldToLocalAffine) {
            this._worldToLocalAffine.multiplyTransposeXYZW(npcPlane.x, npcPlane.y, npcPlane.z, npcPlane.w, worldPlane);
        }
        else if (this._worldToLocalPerspective) {
            this._worldToLocalPerspective.multiplyTransposePoint4d(npcPlane, worldPlane);
        }
        else {
            npcPlane.clone(worldPlane);
        }
    }
    // Caller accesses data from segment and bsplineCurve
    // Selects the best conditioned arc (in xy parts) as "circle after inversion"
    // Solves the arc-arc equations
    dispatchSegmentBsplineCurve(cpA, extendA0, pointA0, fractionA0, pointA1, fractionA1, extendA1, bcurve, extendB, reversed) {
        const pointA0H = this.projectPoint(pointA0);
        const pointA1H = this.projectPoint(pointA1);
        const planeCoffs = Point4d_1.Point4d.createPlanePointPointZ(pointA0H, pointA1H);
        this.mapNPCPlaneToWorld(planeCoffs, planeCoffs);
        // NOW .. we have a plane in world space.  Intersect it with the bspline:
        const intersections = [];
        bcurve.appendPlaneIntersectionPoints(planeCoffs, intersections);
        // intersections has WORLD points with bspline fractions.   (The bspline fractions are all good 0..1 fractions within the spline.)
        // accept those that are within the segment range.
        for (const detail of intersections) {
            const fractionB = detail.fraction;
            const curvePoint = detail.point;
            const curvePointH = this.projectPoint(curvePoint);
            const lineFraction = Polynomials_1.SmallSystem.lineSegment3dHXYClosestPointUnbounded(pointA0H, pointA1H, curvePointH);
            if (lineFraction !== undefined && this.acceptFraction(extendA0, lineFraction, extendA1) && this.acceptFraction(extendB, fractionB, extendB)) {
                this.recordPointWithLocalFractions(lineFraction, cpA, fractionA0, fractionA1, fractionB, bcurve, 0, 1, reversed);
            }
        }
    }
    dispatchLineStringBSplineCurve(lsA, extendA, curveB, extendB, reversed) {
        const numA = lsA.numPoints();
        if (numA > 1) {
            const dfA = 1.0 / (numA - 1);
            let fA0;
            let fA1;
            fA0 = 0.0;
            const pointA0 = CurveCurveIntersectXY._workPointA0;
            const pointA1 = CurveCurveIntersectXY._workPointA1;
            lsA.pointAt(0, pointA0);
            for (let iA = 1; iA < numA; iA++, pointA0.setFrom(pointA1), fA0 = fA1) {
                lsA.pointAt(iA, pointA1);
                fA1 = iA * dfA;
                this.dispatchSegmentBsplineCurve(lsA, iA === 1 && extendA, pointA0, fA0, pointA1, fA1, (iA + 1) === numA && extendA, curveB, extendB, reversed);
            }
        }
        return undefined;
    }
    computeSegmentLineString(lsA, extendA, lsB, extendB, reversed) {
        const pointA0 = lsA.point0Ref;
        const pointA1 = lsA.point1Ref;
        const pointB0 = CurveCurveIntersectXY._workPointBB0;
        const pointB1 = CurveCurveIntersectXY._workPointBB1;
        const numB = lsB.numPoints();
        if (numB > 1) {
            const dfB = 1.0 / (numB - 1);
            let fB0;
            let fB1;
            fB0 = 0.0;
            lsB.pointAt(0, pointB0);
            for (let ib = 1; ib < numB; ib++, pointB0.setFrom(pointB1), fB0 = fB1) {
                lsB.pointAt(ib, pointB1);
                fB1 = ib * dfB;
                this.dispatchSegmentSegment(lsA, extendA, pointA0, 0.0, pointA1, 1.0, extendA, lsB, ib === 1 && extendB, pointB0, fB0, pointB1, fB1, (ib + 1) === numB && extendB, reversed);
            }
        }
        return undefined;
    }
    computeArcLineString(arcA, extendA, lsB, extendB, reversed) {
        const pointB0 = CurveCurveIntersectXY._workPointBB0;
        const pointB1 = CurveCurveIntersectXY._workPointBB1;
        const numB = lsB.numPoints();
        if (numB > 1) {
            const dfB = 1.0 / (numB - 1);
            let fB0;
            let fB1;
            fB0 = 0.0;
            lsB.pointAt(0, pointB0);
            for (let ib = 1; ib < numB; ib++, pointB0.setFrom(pointB1), fB0 = fB1) {
                lsB.pointAt(ib, pointB1);
                fB1 = ib * dfB;
                this.dispatchSegmentArc(lsB, ib === 1 && extendB, pointB0, fB0, pointB1, fB1, (ib + 1) === numB && extendB, arcA, extendA, extendA, !reversed);
            }
        }
        return undefined;
    }
    static setTransformedWorkPoints(transform, pointA0, pointA1, pointB0, pointB1) {
        transform.multiplyPoint3d(pointA0, this._workPointA0);
        transform.multiplyPoint3d(pointA1, this._workPointA1);
        transform.multiplyPoint3d(pointB0, this._workPointB0);
        transform.multiplyPoint3d(pointB1, this._workPointB1);
    }
    handleLineSegment3d(segmentA) {
        if (this._geometryB instanceof LineSegment3d_1.LineSegment3d) {
            const segmentB = this._geometryB;
            this.dispatchSegmentSegment(segmentA, this._extendA, segmentA.point0Ref, 0.0, segmentA.point1Ref, 1.0, this._extendA, segmentB, this._extendB, segmentB.point0Ref, 0.0, segmentB.point1Ref, 1.0, this._extendB, false);
        }
        else if (this._geometryB instanceof LineString3d_1.LineString3d) {
            this.computeSegmentLineString(segmentA, this._extendA, this._geometryB, this._extendB, false);
        }
        else if (this._geometryB instanceof Arc3d_1.Arc3d) {
            this.dispatchSegmentArc(segmentA, this._extendA, segmentA.point0Ref, 0.0, segmentA.point1Ref, 1.0, this._extendA, this._geometryB, this._extendB, this._extendB, false);
        }
        else if (this._geometryB instanceof BSplineCurve_1.BSplineCurve3d) {
            this.dispatchSegmentBsplineCurve(segmentA, this._extendA, segmentA.point0Ref, 0.0, segmentA.point1Ref, 1.0, this._extendA, this._geometryB, this._extendB, false);
        }
    }
    handleLineString3d(lsA) {
        if (this._geometryB instanceof LineString3d_1.LineString3d) {
            const lsB = this._geometryB;
            const pointA0 = CurveCurveIntersectXY._workPointAA0;
            const pointA1 = CurveCurveIntersectXY._workPointAA1;
            const pointB0 = CurveCurveIntersectXY._workPointBB0;
            const pointB1 = CurveCurveIntersectXY._workPointBB1;
            const numA = lsA.numPoints();
            const numB = lsB.numPoints();
            if (numA > 1 && numB > 1) {
                lsA.pointAt(0, pointA0);
                const dfA = 1.0 / (numA - 1);
                const dfB = 1.0 / (numB - 1);
                let fA0 = 0.0;
                let fB0;
                let fA1;
                let fB1;
                const extendA = this._extendA;
                const extendB = this._extendB;
                lsA.pointAt(0, pointA0);
                for (let ia = 1; ia < numA; ia++, pointA0.setFrom(pointA1), fA0 = fA1) {
                    fA1 = ia * dfA;
                    fB0 = 0.0;
                    lsA.pointAt(ia, pointA1);
                    lsB.pointAt(0, pointB0);
                    for (let ib = 1; ib < numB; ib++, pointB0.setFrom(pointB1), fB0 = fB1) {
                        lsB.pointAt(ib, pointB1);
                        fB1 = ib * dfB;
                        this.dispatchSegmentSegment(lsA, ia === 1 && extendA, pointA0, fA0, pointA1, fA1, (ia + 1) === numA && extendA, lsB, ib === 1 && extendB, pointB0, fB0, pointB1, fB1, (ib + 1) === numB && extendB, false);
                    }
                }
            }
        }
        else if (this._geometryB instanceof LineSegment3d_1.LineSegment3d) {
            this.computeSegmentLineString(this._geometryB, this._extendB, lsA, this._extendA, true);
        }
        else if (this._geometryB instanceof Arc3d_1.Arc3d) {
            this.computeArcLineString(this._geometryB, this._extendB, lsA, this._extendA, true);
        }
        else if (this._geometryB instanceof BSplineCurve_1.BSplineCurve3d) {
            this.dispatchLineStringBSplineCurve(lsA, this._extendA, this._geometryB, this._extendB, false);
        }
        return undefined;
    }
    handleArc3d(arc0) {
        if (this._geometryB instanceof LineSegment3d_1.LineSegment3d) {
            this.dispatchSegmentArc(this._geometryB, this._extendB, this._geometryB.point0Ref, 0.0, this._geometryB.point1Ref, 1.0, this._extendB, arc0, this._extendA, this._extendA, true);
        }
        else if (this._geometryB instanceof LineString3d_1.LineString3d) {
            this.computeArcLineString(arc0, this._extendA, this._geometryB, this._extendB, false);
        }
        else if (this._geometryB instanceof Arc3d_1.Arc3d) {
            this.dispatchArcArc(arc0, this._extendA, this._geometryB, this._extendB, false);
        }
        else if (this._geometryB instanceof BSplineCurve_1.BSplineCurve3d) {
            this.dispatchArcBsplineCurve3d(arc0, this._extendA, this._geometryB, this._extendB, false);
        }
        return undefined;
    }
    handleBSplineCurve3d(curve) {
        if (this._geometryB instanceof LineSegment3d_1.LineSegment3d) {
            this.dispatchSegmentBsplineCurve(this._geometryB, this._extendB, this._geometryB.point0Ref, 0.0, this._geometryB.point1Ref, 1.0, this._extendB, curve, this._extendA, true);
        }
        else if (this._geometryB instanceof LineString3d_1.LineString3d) {
            this.dispatchLineStringBSplineCurve(this._geometryB, this._extendB, curve, this._extendA, true);
        }
        else if (this._geometryB instanceof Arc3d_1.Arc3d) {
            this.dispatchArcBsplineCurve3d(this._geometryB, this._extendB, curve, this._extendA, true);
        }
        else if (this._geometryB instanceof BSplineCurve_1.BSplineCurve3dBase) {
            this.dispatchBSplineCurve3dBSplineCurve3d(curve, this._geometryB, false);
        }
        return undefined;
    }
    handleBSplineCurve3dH(_curve) {
        /* NEEDS WORK -- make "dispatch" methods tolerant of both 3d and 3dH ..."easy" if both present BezierCurve3dH span loaders
        if (this._geometryB instanceof LineSegment3d) {
          this.dispatchSegmentBsplineCurve(
            this._geometryB, this._extendB, this._geometryB.point0Ref, 0.0, this._geometryB.point1Ref, 1.0, this._extendB,
            curve, this._extendA, true);
        } else if (this._geometryB instanceof LineString3d) {
          this.dispatchLineStringBSplineCurve(this._geometryB, this._extendB, curve, this._extendA, true);
        } else if (this._geometryB instanceof Arc3d) {
          this.dispatchArcBsplineCurve3d(this._geometryB, this._extendB, curve, this._extendA, true);
        }
        */
        return undefined;
    }
}
CurveCurveIntersectXY._workVector2dA = Point2dVector2d_1.Vector2d.create();
CurveCurveIntersectXY._workPointA0H = Point4d_1.Point4d.create();
CurveCurveIntersectXY._workPointA1H = Point4d_1.Point4d.create();
CurveCurveIntersectXY._workPointB0H = Point4d_1.Point4d.create();
CurveCurveIntersectXY._workPointB1H = Point4d_1.Point4d.create();
CurveCurveIntersectXY._workPointAA0 = Point3dVector3d_1.Point3d.create();
CurveCurveIntersectXY._workPointAA1 = Point3dVector3d_1.Point3d.create();
CurveCurveIntersectXY._workPointBB0 = Point3dVector3d_1.Point3d.create();
CurveCurveIntersectXY._workPointBB1 = Point3dVector3d_1.Point3d.create();
CurveCurveIntersectXY._workPointA0 = Point3dVector3d_1.Point3d.create();
CurveCurveIntersectXY._workPointA1 = Point3dVector3d_1.Point3d.create();
CurveCurveIntersectXY._workPointB0 = Point3dVector3d_1.Point3d.create();
CurveCurveIntersectXY._workPointB1 = Point3dVector3d_1.Point3d.create();
class CurveCurve {
    /**
     * Return xy intersections of 2 curves.
     * @param geometryA second geometry
     * @param extendA true to allow geometryA to extend
     * @param geometryB second geometry
     * @param extendB true to allow geometryB to extend
     */
    static IntersectionXY(geometryA, extendA, geometryB, extendB) {
        const handler = new CurveCurveIntersectXY(undefined, geometryA, extendA, geometryB, extendB);
        geometryA.dispatchToGeometryHandler(handler);
        return handler.grabResults();
    }
    /**
     * Return xy intersections of 2 projected curves
     * @param geometryA second geometry
     * @param extendA true to allow geometryA to extend
     * @param geometryB second geometry
     * @param extendB true to allow geometryB to extend
     */
    static IntersectionProjectedXY(worldToLocal, geometryA, extendA, geometryB, extendB) {
        const handler = new CurveCurveIntersectXY(worldToLocal, geometryA, extendA, geometryB, extendB);
        geometryA.dispatchToGeometryHandler(handler);
        return handler.grabResults();
    }
}
exports.CurveCurve = CurveCurve;


/***/ }),

/***/ "./lib/curve/CurveLocationDetail.js":
/*!******************************************!*\
  !*** ./lib/curve/CurveLocationDetail.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Curve */
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
/**
 * An enumeration of special conditions being described by a CurveLocationDetail.
 */
var CurveIntervalRole;
(function (CurveIntervalRole) {
    /** This point is an isolated point NOT at a primary vertex. */
    CurveIntervalRole[CurveIntervalRole["isolated"] = 0] = "isolated";
    /**  This point is an isolated vertex hit */
    CurveIntervalRole[CurveIntervalRole["isolatedAtVertex"] = 1] = "isolatedAtVertex";
    /** This is the beginning of an interval */
    CurveIntervalRole[CurveIntervalRole["intervalStart"] = 10] = "intervalStart";
    /** This is an interior point of an interval. */
    CurveIntervalRole[CurveIntervalRole["intervalInterior"] = 11] = "intervalInterior";
    /** This is the end of an interval */
    CurveIntervalRole[CurveIntervalRole["intervalEnd"] = 12] = "intervalEnd";
})(CurveIntervalRole = exports.CurveIntervalRole || (exports.CurveIntervalRole = {}));
/**
 * Return code for CurvePrimitive method `moveSignedDistanceFromFraction`
 */
var CurveSearchStatus;
(function (CurveSearchStatus) {
    /** unimplemented or zero length curve  */
    CurveSearchStatus[CurveSearchStatus["error"] = 0] = "error";
    /** complete success of search */
    CurveSearchStatus[CurveSearchStatus["success"] = 1] = "success";
    /** search ended prematurely (e.g. at incomplete distance moved) at start or end of curve */
    CurveSearchStatus[CurveSearchStatus["stoppedAtBoundary"] = 2] = "stoppedAtBoundary";
})(CurveSearchStatus = exports.CurveSearchStatus || (exports.CurveSearchStatus = {}));
/**
 * use to update a vector in case where source and prior result are both possibly undefined.
 * * Any undefined source returns undefined.
 * * For defined source, reuse optional result if available.
 * @param source optional source
 * @param result optional result
 */
function optionalVectorUpdate(source, result) {
    if (source) {
        return source.clone(result);
    }
    return undefined;
}
/**
 * CurveLocationDetail carries point and paramter data about a point evaluated on a curve.
 */
class CurveLocationDetail {
    constructor() {
        this.pointQ = Point3dVector3d_1.Point3d.createZero();
        this.fraction = 0;
        this.point = Point3dVector3d_1.Point3d.createZero();
        this.a = 0.0;
    }
    /** Set the (optional) intervalRole field */
    setIntervalRole(value) {
        this.intervalRole = value;
    }
    /** test if this is an isolated point. This is true if intervalRole is any of (undefined, isolated, isolatedAtVertex) */
    get isIsolated() {
        return this.intervalRole === undefined
            || this.intervalRole === CurveIntervalRole.isolated
            || this.intervalRole === CurveIntervalRole.isolatedAtVertex;
    }
    /** Return a complete copy, WITH CAVEATS . . .
     * * curve member is copied as a reference.
     * * point and vector members are cloned.
     */
    clone(result) {
        if (result === this)
            return result;
        result = result ? result : new CurveLocationDetail();
        result.curve = this.curve;
        result.fraction = this.fraction;
        result.point.setFromPoint3d(this.point);
        result.vectorInCurveLocationDetail = optionalVectorUpdate(this.vectorInCurveLocationDetail, result.vectorInCurveLocationDetail);
        result.a = this.a;
        result.curveSearchStatus = this.curveSearchStatus;
        return result;
    }
    /**
     * Updated in this instance.
     * * Note that if caller omits `vector` and `a`, those fields are updated to the call-list defaults (NOT left as-is)
     * * point and vector updates are by data copy (not capture of arglist pointers)
     * @param fraction (required) fraction to install
     * @param point  (required) point to install
     * @param vector (optional) vector to install.
     * @param a (optional) numeric value to install.
     */
    setFP(fraction, point, vector, a = 0.0) {
        this.fraction = fraction;
        this.point.setFrom(point);
        this.vectorInCurveLocationDetail = optionalVectorUpdate(vector, this.vectorInCurveLocationDetail);
        this.a = a;
    }
    /**
     * Updated in this instance.
     * * Note that if caller omits a`, that field is updated to the call-list default (NOT left as-is)
     * * point and vector updates are by data copy (not capture of arglist data.
     * @param fraction (required) fraction to install
     * @param ray  (required) point and vector to install
     * @param a (optional) numeric value to install.
     */
    setFR(fraction, ray, a = 0) {
        return this.setFP(fraction, ray.origin, ray.direction, a);
    }
    /** Set the CurvePrimitive pointer, leaving all other properties untouched.
     */
    setCurve(curve) { this.curve = curve; }
    /** record the distance from the CurveLocationDetail's point to the parameter point. */
    setDistanceTo(point) {
        this.a = this.point.distance(point);
    }
    /** create with a CurvePrimitive pointer but no coordinate data.
     */
    static create(curve, result) {
        result = result ? result : new CurveLocationDetail();
        result.curve = curve;
        return result;
    }
    /** create with CurvePrimitive pointer, fraction, and point coordinates.
     */
    static createCurveFractionPoint(curve, fraction, point, result) {
        result = result ? result : new CurveLocationDetail();
        result.curve = curve;
        result.fraction = fraction;
        result.point.setFromPoint3d(point);
        result.vectorInCurveLocationDetail = undefined;
        result.a = 0.0;
        result.curveSearchStatus = undefined;
        return result;
    }
    /** create with CurvePrimitive pointer, fraction, and point coordinates
     */
    static createCurveFractionPointDistanceCurveSearchStatus(curve, fraction, point, distance, status, result) {
        result = result ? result : new CurveLocationDetail();
        result.curve = curve;
        result.fraction = fraction;
        result.point.setFromPoint3d(point);
        result.vectorInCurveLocationDetail = undefined;
        result.a = distance;
        result.curveSearchStatus = status;
        return result;
    }
    /** create with curveSearchStatus affected by allowExtension.
     * *
     */
    static createConditionalMoveSignedDistance(allowExtension, curve, startFraction, endFraction, requestedSignedDistance, result) {
        let a = requestedSignedDistance;
        let status = CurveSearchStatus.success;
        if (!allowExtension && !Geometry_1.Geometry.isIn01(endFraction)) {
            // cap the movement at the endponit
            if (endFraction < 0.0) {
                a = -curve.curveLengthBetweenFractions(startFraction, 0.0);
                endFraction = 0.0;
                status = CurveSearchStatus.stoppedAtBoundary;
            }
            else if (endFraction > 1.0) {
                endFraction = 1.0;
                a = curve.curveLengthBetweenFractions(startFraction, 1.0);
                status = CurveSearchStatus.stoppedAtBoundary;
            }
        }
        result = result ? result : new CurveLocationDetail();
        result.curve = curve;
        result.fraction = endFraction;
        result.point = curve.fractionToPoint(endFraction, result.point);
        result.vectorInCurveLocationDetail = undefined;
        result.a = a;
        result.curveSearchStatus = status;
        return result;
    }
    /** create with CurvePrimitive pointer, fraction, and point coordinates.
     */
    static createCurveEvaluatedFraction(curve, fraction, result) {
        result = result ? result : new CurveLocationDetail();
        result.curve = curve;
        result.fraction = fraction;
        result.point = curve.fractionToPoint(fraction);
        result.vectorInCurveLocationDetail = undefined;
        result.curveSearchStatus = undefined;
        result.a = 0.0;
        return result;
    }
    /** create with CurvePrimitive pointer, fraction, and point coordinates.
     */
    static createCurveFractionPointDistance(curve, fraction, point, a, result) {
        result = result ? result : new CurveLocationDetail();
        result.curve = curve;
        result.fraction = fraction;
        result.point.setFromPoint3d(point);
        result.vectorInCurveLocationDetail = undefined;
        result.a = a;
        result.curveSearchStatus = undefined;
        return result;
    }
    /** update or create if closer than current contents.
     * @param curve candidate curve
     * @param fraction candidate fraction
     * @param point candidate point
     * @param a candidate distance
     * @returns true if the given distance is smaller (and hence this detail was updated.)
     */
    updateIfCloserCurveFractionPointDistance(curve, fraction, point, a) {
        if (this.a < a)
            return false;
        CurveLocationDetail.createCurveFractionPointDistance(curve, fraction, point, a, this);
        return true;
    }
}
exports.CurveLocationDetail = CurveLocationDetail;
/** A pair of CurveLocationDetail. */
class CurveLocationDetailPair {
    constructor() {
        this.detailA = new CurveLocationDetail();
        this.detailB = new CurveLocationDetail();
    }
    /** Create a curve detail pair using references to two CurveLocationDetails */
    static createDetailRef(detailA, detailB, result) {
        result = result ? result : new CurveLocationDetailPair();
        result.detailA = detailA;
        result.detailB = detailB;
        return result;
    }
    /** Make a deep copy of this CurveLocationDetailPair */
    clone(result) {
        result = result ? result : new CurveLocationDetailPair();
        result.detailA = this.detailA.clone();
        result.detailB = this.detailB.clone();
        return result;
    }
}
exports.CurveLocationDetailPair = CurveLocationDetailPair;


/***/ }),

/***/ "./lib/curve/CurvePrimitive.js":
/*!*************************************!*\
  !*** ./lib/curve/CurvePrimitive.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Curve */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const BezierPolynomials_1 = __webpack_require__(/*! ../numerics/BezierPolynomials */ "./lib/numerics/BezierPolynomials.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const Matrix3d_1 = __webpack_require__(/*! ../geometry3d/Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const Ray3d_1 = __webpack_require__(/*! ../geometry3d/Ray3d */ "./lib/geometry3d/Ray3d.js");
const Newton_1 = __webpack_require__(/*! ../numerics/Newton */ "./lib/numerics/Newton.js");
const Quadrature_1 = __webpack_require__(/*! ../numerics/Quadrature */ "./lib/numerics/Quadrature.js");
const CurveLocationDetail_1 = __webpack_require__(/*! ./CurveLocationDetail */ "./lib/curve/CurveLocationDetail.js");
const GeometryQuery_1 = __webpack_require__(/*! ./GeometryQuery */ "./lib/curve/GeometryQuery.js");
/**
 * A curve primitive is bounded
 * A curve primitive maps fractions in 0..1 to points in space.
 * As the fraction proceeds from 0 towards 1, the point moves "forward" along the curve.
 * True distance along the curve is not always strictly proportional to fraction.
 * * LineSegment3d always has proportional fraction and distance
 * * an Arc3d which is true circular has proportional fraction and distance
 * *  A LineString3d is not proportional (except for special case of all segments of equal length)
 * * A Spiral3d is proportional
 * * A BsplineCurve3d is only proportional for special cases.
 *
 * For fractions outside 0..1, the curve primitive class may either (a) return the near endpoint or (b) evaluate an extended curve.
 */
class CurvePrimitive extends GeometryQuery_1.GeometryQuery {
    constructor() { super(); }
    /**
     *
     * @param fraction fractional position on the curve
     * @param result optional receiver for the result.
     * @returns Returns a ray whose origin is the curve point and direction is the unit tangent.
     */
    fractionToPointAndUnitTangent(fraction, result) {
        const ray = this.fractionToPointAndDerivative(fraction, result);
        ray.trySetDirectionMagnitudeInPlace(1.0);
        return ray;
    }
    /** Construct a frenet frame:
     * * origin at the point on the curve
     * * x axis is unit vector along the curve (tangent)
     * * y axis is perpendicular and in the plane of the osculating circle.
     * * z axis perpendicular to those.
     */
    fractionToFrenetFrame(fraction, result) {
        const plane = this.fractionToPointAnd2Derivatives(fraction);
        if (!plane)
            return undefined;
        let axes = Matrix3d_1.Matrix3d.createRigidFromColumns(plane.vectorU, plane.vectorV, 0 /* XYZ */);
        if (axes)
            return Transform_1.Transform.createRefs(plane.origin, axes, result);
        // 2nd derivative not distinct -- do arbitrary headsup ...
        const perpVector = Matrix3d_1.Matrix3d.createPerpendicularVectorFavorXYPlane(plane.vectorU, plane.vectorV);
        axes = Matrix3d_1.Matrix3d.createRigidFromColumns(plane.vectorU, perpVector, 0 /* XYZ */);
        if (axes)
            return Transform_1.Transform.createRefs(plane.origin, axes, result);
        return undefined;
    }
    /**
     *
     * * Curve length is always positive.
     * @returns Returns a (high accuracy) length of the curve.
     * @returns Returns the length of the curve.
     */
    curveLength() {
        const context = new CurveLengthContext();
        this.emitStrokableParts(context);
        return context.getSum();
    }
    /**
     *
     * * Curve length is always positive.
     * @returns Returns a (high accuracy) length of the curve between fractional positions
     */
    curveLengthBetweenFractions(fraction0, fraction1) {
        if (fraction0 === fraction1)
            return 0.0;
        const scale = this.getFractionToDistanceScale();
        if (scale !== undefined) {
            // We are in luck! simple proportions determine it all  !!!
            // (for example, a LineSegment3d or a circular arc)
            const totalLength = this.curveLength();
            return Math.abs((fraction1 - fraction0) * totalLength);
        }
        const context = new CurveLengthContext(fraction0, fraction1);
        this.emitStrokableParts(context);
        return Math.abs(context.getSum());
    }
    /**
     *
     * * Run an integration (with a default gaussian quadrature) with a fixed fractional step
     * * This is typically called by specific curve type implementations of curveLengthBetweenFrations.
     *   * For example, in Arc3d implementation of curveLengthBetweenFrations:
     *     * If the Arc3d is true circular, it the arc is true circular, use the direct `arcLength = radius * sweepRadians`
     *     * If the Arc3d is not true circular, call this method with an interval count appropriate to eccentricity and sweepRadians.
     * @returns Returns an integral estimated by numerical quadrature between the fractional positions.
     * @param fraction0 start fraction for integration
     * @param fraction1 end fraction for integration
     * @param numInterval number of quadrature intervals
     */
    curveLengthWithFixedIntervalCountQuadrature(fraction0, fraction1, numInterval, numGauss = 5) {
        if (fraction0 > fraction1) {
            const fSave = fraction0;
            fraction0 = fraction1;
            fraction1 = fSave;
        }
        const context = new CurveLengthContext(fraction0, fraction1, numGauss);
        context.announceIntervalForUniformStepStrokes(this, numInterval, fraction0, fraction1);
        return Math.abs(context.getSum());
    }
    /**
     *
     * * (Attempt to) find a position on the curve at a signed distance from start fraction.
     * * Return the postion as a CurveLocationDetail.
     * * In the `CurveLocationDetail`, record:
     *   * `fractional` position
     *   * `fraction` = coordinates of the point
     *   * `search
     *   * `a` = (signed!) distance moved.   If `allowExtension` is false and the move reached the start or end of the curve, this distance is smaller than the requested signedDistance.
     *   * `curveSearchStatus` indicates one of:
     *     * `error` (unusual) computation failed not supported for this curve.
     *     * `success` full movement completed
     *     * `stoppedAtBoundary` partial movement completed. This can be due to either
     *        * `allowExtendsion` parameter sent as `false`
     *        * the curve type (e.g. bspline) does not support extended range.
     * * if `allowExtension` is true, movement may still end at the startpoint or endpoint for curves that do not support extended geometry (specifically bsplines)
     * * if the curve returns a value (i.e. not `undefined`) for `curve.getFractionToDistanceScale()`, the base class carries out the computation
     *    and returns a final location.
     *   * LineSegment3d relies on this.
     * * If the curve does not implement the computation or the curve has zero length, the returned `CurveLocationDetail` has
     *    * `fraction` = the value of `startFraction`
     *    * `point` = result of `curve.fractionToPoint(startFraction)`
     *    * `a` = 0
     *    * `curveStartState` = `CurveSearchStatus.error`
     * @param startFraction fractional position where the move starts
     * @param signedDistance distance to move.   Negative distance is backwards in the fraction space
     * @param allowExtension if true, all the move to go beyond the startpoint or endpoint of the curve.  If false, do not allow movement beyond the startpoint or endpoint
     * @param result optional result.
     * @returns A CurveLocationDetail annotated as above.  Note that if the curve does not support the calculation, there is still a result which contains the point at the input startFraction, with failure indicated in the `curveStartState` member
     */
    moveSignedDistanceFromFraction(startFraction, signedDistance, allowExtension, result) {
        const scale = this.getFractionToDistanceScale();
        if (scale !== undefined) {
            // We are in luck! simple proportions determine it all  !!!
            // (for example, a LineSegment3d or a circular arc)
            const totalLength = this.curveLength();
            const signedFractionMove = Geometry_1.Geometry.conditionalDivideFraction(signedDistance, totalLength);
            if (signedFractionMove === undefined) {
                return CurveLocationDetail_1.CurveLocationDetail.createCurveFractionPointDistanceCurveSearchStatus(this, startFraction, this.fractionToPoint(startFraction), 0.0, CurveLocationDetail_1.CurveSearchStatus.error);
            }
            return CurveLocationDetail_1.CurveLocationDetail.createConditionalMoveSignedDistance(allowExtension, this, startFraction, startFraction + signedFractionMove, signedDistance, result);
        }
        return this.moveSignedDistanceFromFractionGeneric(startFraction, signedDistance, allowExtension, result);
    }
    /**
     * Generic algorithm to search for point at signed distance from a fractional start point.
     * * This will work for well for smooth curves.
     * * Curves with tangent or other low-order-derivative discontinuities may need to implement specialized algorithms.
     * * We need to find an endFraction which is the end-of-interval (usually upper) limit of integration of the tangent magnitude from startFraction to endFraction
     * * That integral is a function of endFraction.
     * * The derivative of that integral with respect to end fraction is the tangent magnitude at end fraction.
     * * Use that function and (easily evaluated!) derivative for a Newton iteration
     * * TO ALL WHO HAVE FUZZY MEMORIES OF CALCULUS CLASS: "The derivative of the integral wrt upper limit is the value of the integrand there" is the
     *       fundamental theorem of integral calculus !!! The fundeamental theorem is not just an abstraction !!! It is being used
     *       here in its barest possible form !!!
     * * See https://en.wikipedia.org/wiki/Fundamental_theorem_of_calculus
     * @param startFraction
     * @param signedDistance
     * @param _allowExtension
     * @param result
     */
    moveSignedDistanceFromFractionGeneric(startFraction, signedDistance, allowExtension, result) {
        const limitFraction = signedDistance > 0.0 ? 1.0 : 0.0;
        const absDistance = Math.abs(signedDistance);
        const directionFactor = signedDistance < 0.0 ? -1.0 : 1.0;
        const availableLength = this.curveLengthBetweenFractions(startFraction, limitFraction); // that is always positive
        if (availableLength < absDistance && !allowExtension)
            return CurveLocationDetail_1.CurveLocationDetail.createConditionalMoveSignedDistance(allowExtension, this, startFraction, limitFraction, signedDistance, result);
        const fractionStep = absDistance / availableLength;
        let fractionB = Geometry_1.Geometry.interpolate(startFraction, fractionStep, limitFraction);
        let fractionA = startFraction;
        let distanceA = 0.0;
        const tol = 1.0e-12 * availableLength;
        let numConverged = 0;
        const tangent = Ray3d_1.Ray3d.createXAxis();
        // on each loop entry:
        // fractionA is the most recent endOfInterval.  (It may have been reached by a mixtrueo forward and backward step.)
        // distanceA is the distance to (the point at) fractionA
        // fractionB is the next end fraction
        for (let iterations = 0; iterations < 10; iterations++) {
            const distanceAB = this.curveLengthBetweenFractions(fractionA, fractionB);
            const directionAB = fractionB > fractionA ? directionFactor : -directionFactor;
            const distance0B = distanceA + directionAB * distanceAB;
            const distanceError = absDistance - distance0B;
            if (Math.abs(distanceError) < tol) {
                numConverged++;
                if (numConverged > 1)
                    break;
            }
            else {
                numConverged = 0;
            }
            this.fractionToPointAndDerivative(fractionB, tangent);
            const tangentMagnitude = tangent.direction.magnitude();
            fractionA = fractionB;
            fractionB = fractionA + directionFactor * distanceError / tangentMagnitude;
            if (fractionA === fractionB) { // YES -- that is an exact equality test.   When it happens, there's no need for confirming with another iteration.
                numConverged = 100;
                break;
            }
            distanceA = distance0B;
        }
        if (numConverged > 1)
            return CurveLocationDetail_1.CurveLocationDetail.createConditionalMoveSignedDistance(false, this, startFraction, fractionB, signedDistance, result);
        result = CurveLocationDetail_1.CurveLocationDetail.createCurveEvaluatedFraction(this, startFraction, result);
        result.a = 0.0;
        result.curveSearchStatus = CurveLocationDetail_1.CurveSearchStatus.error;
        return result;
    }
    /**
     * * Returns true if the curve's fraction queries extend beyond 0..1.
     * * Base class default implementation returns false.
     * * These class (and perhaps others in the future) will return true:
     *   * LineSegment3d
     *   * LineString3d
     *   * Arc3d
     */
    get isExtensibleFractionSpace() { return false; }
    /** Search for the curve point that is closest to the spacePoint.
     *
     * * If the space point is exactly on the curve, this is the reverse of fractionToPoint.
     * * Since CurvePrimitive should always have start and end available as candidate points, this method should always succeed
     * @param spacePoint point in space
     * @param extend true to extend the curve (if possible)
     * @returns Returns a CurveLocationDetail structure that holds the details of the close point.
     */
    closestPoint(spacePoint, extend) {
        const strokeHandler = new ClosestPointStrokeHandler(spacePoint, extend);
        this.emitStrokableParts(strokeHandler);
        return strokeHandler.claimResult();
    }
    /**
     * Find intervals of this curvePrimitive that are interior to a clipper
     * @param clipper clip structure (e.g. clip planes)
     * @param announce (optional) function to be called announcing fractional intervals"  ` announce(fraction0, fraction1, curvePrimitive)`
     * @returns true if any "in" segments are announced.
     */
    announceClipIntervals(_clipper, _announce) {
        // DEFAULT IMPLEMENTATION -- no interior parts
        return false;
    }
    /** Return (if possible) a curve primitive which is a portion of this curve.
     * @param _fractionA [in] start fraction
     * @param _fractionB [in] end fraction
     */
    clonePartialCurve(_fractionA, _fractionB) {
        return undefined;
    }
    /**
     * * If the curve primitive has distance-along-curve strictly proportional to curve fraction, return true
     * * If distance-along-the-curve is not proportional, return undefined.
     * * When defined, the scale factor is alwyas the length of the curve.
     * * This scale factor is typically available for these curve types:
     * * * All `LineSegment3d`
     * * * Arc3d which is a true circular arc (axes perpendicular and of equal length).
     * * * CurveChainWithDistanceIndex
     * * This scale factor is undefined for these curve types:
     * * * Arc3d which is a true ellipse, i.e. unequal lengths of defining vectors or non-perpendicular defining vectors.
     * * * bspline and bezier curves
     * @returns scale factor or undefined
     */
    getFractionToDistanceScale() { return undefined; }
    /**
     * Compute intersections with a plane.
     * The intersections are appended to the result array.
     * The base class implementation emits strokes to an AppendPlaneIntersectionStrokeHandler object, which uses a Newton iteration to get
     * high-accuracy intersection points within strokes.
     * Derived classes should override this default implementation if there are easy analytic solutions.
     * @param plane The plane to be intersected.
     * @param result Array to receive intersections
     * @returns Return the number of CurveLocationDetail's added to the result array.
     */
    appendPlaneIntersectionPoints(plane, result) {
        const strokeHandler = new AppendPlaneIntersectionStrokeHandler(plane, result);
        const n0 = result.length;
        this.emitStrokableParts(strokeHandler);
        return result.length - n0;
    }
    /** return the start point of the primitive.  The default implementation returns fractionToPoint (0.0) */
    startPoint(result) { return this.fractionToPoint(0.0, result); }
    /** @returns return the end point of the primitive. The default implementation returns fractionToPoint(1.0) */
    endPoint(result) { return this.fractionToPoint(1.0, result); }
}
exports.CurvePrimitive = CurvePrimitive;
/** Intermediate class for managing the parentCurve announcements from an IStrokeHandler */
class NewtonRotRStrokeHandler extends Newton_1.NewtonEvaluatorRtoR {
    constructor() {
        super();
        this._parentCurvePrimitive = undefined;
    }
    /** retain the parentCurvePrimitive.
     * * Calling this method tells the handler that the parent curve is to be used for detail searches.
     * * Example: Transition spiral search is based on linestring first, then the exact spiral.
     * * Example: CurveChainWithDistanceIndex does NOT do this announcement -- the constituents act independently.
     */
    startParentCurvePrimitive(curve) { this._parentCurvePrimitive = curve; }
    /** Forget the parentCurvePrimitive */
    endParentCurvePrimitive(_curve) { this._parentCurvePrimitive = undefined; }
}
class AppendPlaneIntersectionStrokeHandler extends NewtonRotRStrokeHandler {
    constructor(plane, intersections) {
        super();
        this._fractionA = 0;
        this._functionA = 0;
        // private derivativeA: number;   <---- Not currently used
        this._functionB = 0;
        this._fractionB = 0;
        this._derivativeB = 0;
        this._numThisCurve = 0;
        this._plane = plane;
        this._intersections = intersections;
        this.startCurvePrimitive(undefined);
        this._ray = Ray3d_1.Ray3d.createZero();
        this._newtonSolver = new Newton_1.Newton1dUnboundedApproximateDerivative(this);
    }
    // Return the first defined curve among: this.parentCurvePrimitive, this.curve;
    effectiveCurve() {
        if (this._parentCurvePrimitive)
            return this._parentCurvePrimitive;
        return this._curve;
    }
    get getDerivativeB() { return this._derivativeB; } // <--- DerivativeB is not currently used anywhere. Provided getter to suppress tslint error
    startCurvePrimitive(curve) {
        this._curve = curve;
        this._fractionA = 0.0;
        this._numThisCurve = 0;
        this._functionA = 0.0;
        // this.derivativeA = 0.0;
    }
    endCurvePrimitive() { }
    announceIntervalForUniformStepStrokes(cp, numStrokes, fraction0, fraction1) {
        this.startCurvePrimitive(cp);
        if (numStrokes < 1)
            numStrokes = 1;
        const df = 1.0 / numStrokes;
        for (let i = 0; i <= numStrokes; i++) {
            const fraction = Geometry_1.Geometry.interpolate(fraction0, i * df, fraction1);
            cp.fractionToPointAndDerivative(fraction, this._ray);
            this.announcePointTangent(this._ray.origin, fraction, this._ray.direction);
        }
    }
    announceSegmentInterval(_cp, point0, point1, _numStrokes, fraction0, fraction1) {
        const h0 = this._plane.altitude(point0);
        const h1 = this._plane.altitude(point1);
        if (h0 * h1 > 0.0)
            return;
        const fraction01 = BezierPolynomials_1.Order2Bezier.solveCoffs(h0, h1);
        // let numIntersection = 0;
        if (fraction01 !== undefined) {
            // numIntersection++;
            const fraction = Geometry_1.Geometry.interpolate(fraction0, fraction01, fraction1);
            this._newtonSolver.setX(fraction);
            if (this._newtonSolver.runIterations()) {
                this.announceSolutionFraction(this._newtonSolver.getX());
            }
            // this.intersections.push(CurveLocationDetail.createCurveFractionPoint(cp, fraction, cp.fractionToPoint(fraction)));
        }
    }
    announceSolutionFraction(fraction) {
        const curve = this.effectiveCurve();
        if (curve) {
            this._ray = curve.fractionToPointAndDerivative(fraction, this._ray);
            this._intersections.push(CurveLocationDetail_1.CurveLocationDetail.createCurveFractionPoint(curve, fraction, this._ray.origin));
        }
    }
    evaluate(fraction) {
        const curve = this.effectiveCurve();
        if (!curve)
            return false;
        this.currentF = this._plane.altitude(curve.fractionToPoint(fraction));
        return true;
    }
    /**
     * * ASSUME both the "A" and "B"  evaluations (fraction, function, and derivative) are known.
     * * If function value changed sign between, interpolate an approximate root and improve it with
     *     the newton solver.
     */
    searchInterval() {
        if (this._functionA * this._functionB > 0)
            return;
        if (this._functionA === 0)
            this.announceSolutionFraction(this._fractionA);
        if (this._functionB === 0)
            this.announceSolutionFraction(this._fractionB);
        if (this._functionA * this._functionB < 0) {
            const fraction = Geometry_1.Geometry.inverseInterpolate(this._fractionA, this._functionA, this._fractionB, this._functionB);
            if (fraction) {
                this._newtonSolver.setX(fraction);
                if (this._newtonSolver.runIterations())
                    this.announceSolutionFraction(this._newtonSolver.getX());
            }
        }
    }
    /** Evaluate and save _functionB, _derivativeB, and _fractionB. */
    evaluateB(xyz, fraction, tangent) {
        this._functionB = this._plane.altitude(xyz);
        this._derivativeB = this._plane.velocity(tangent);
        this._fractionB = fraction;
    }
    /**
     * Announce point and tangent for evaluations.
     * * The function evaluation is saved as the "B" function point.
     * * The function point count is incremented
     * * If function point count is greater than 1, the current interval is searched.
     * * The just-evaluated point ("B") is saved as the "old" ("A") evaluation point.
     * @param xyz
     * @param fraction
     * @param tangent
     */
    announcePointTangent(xyz, fraction, tangent) {
        this.evaluateB(xyz, fraction, tangent);
        if (this._numThisCurve++ > 0)
            this.searchInterval();
        this._functionA = this._functionB;
        this._fractionA = this._fractionB;
        this._fractionA = this._fractionB;
    }
}
class CurveLengthContext {
    tangentMagnitude(fraction) {
        this._ray = this._curve.fractionToPointAndDerivative(fraction, this._ray);
        return this._ray.direction.magnitude();
    }
    getSum() { return this._summedLength; }
    constructor(fraction0 = 0.0, fraction1 = 1.0, numGaussPoints = 5) {
        this.startCurvePrimitive(undefined);
        this._summedLength = 0.0;
        this._ray = Ray3d_1.Ray3d.createZero();
        if (fraction0 < fraction1) {
            this._fraction0 = fraction0;
            this._fraction1 = fraction1;
        }
        else {
            this._fraction0 = fraction1;
            this._fraction1 = fraction0;
        }
        const maxGauss = 7; // (As of Nov 2 2018, 7 is a fluffy overallocation-- the quadrature class only handles up to 5.)
        this._gaussX = new Float64Array(maxGauss);
        this._gaussW = new Float64Array(maxGauss);
        // This sets the number of gauss points.  This intgetes exactly for polynomials of (degree 2*numGauss - 1).
        if (numGaussPoints > 5 || numGaussPoints < 1)
            numGaussPoints = 5;
        switch (numGaussPoints) {
            case 1:
                this._gaussMapper = Quadrature_1.Quadrature.setupGauss1;
                break;
            case 2:
                this._gaussMapper = Quadrature_1.Quadrature.setupGauss2;
                break;
            case 3:
                this._gaussMapper = Quadrature_1.Quadrature.setupGauss3;
                break;
            case 4:
                this._gaussMapper = Quadrature_1.Quadrature.setupGauss4;
                break;
            default:
                this._gaussMapper = Quadrature_1.Quadrature.setupGauss5;
                break;
        }
    }
    startCurvePrimitive(curve) {
        this._curve = curve;
    }
    startParentCurvePrimitive(_curve) { }
    endParentCurvePrimitive(_curve) { }
    endCurvePrimitive() { }
    announceIntervalForUniformStepStrokes(cp, numStrokes, fraction0, fraction1) {
        if (fraction0 < this._fraction0)
            fraction0 = this._fraction0;
        if (fraction1 > this._fraction1)
            fraction1 = this._fraction1;
        if (fraction1 > fraction0) {
            this.startCurvePrimitive(cp);
            if (numStrokes < 1)
                numStrokes = 1;
            const df = 1.0 / numStrokes;
            for (let i = 1; i <= numStrokes; i++) {
                const fractionA = Geometry_1.Geometry.interpolate(fraction0, (i - 1) * df, fraction1);
                const fractionB = i === numStrokes ? fraction1 : Geometry_1.Geometry.interpolate(fraction0, (i) * df, fraction1);
                const numGauss = this._gaussMapper(fractionA, fractionB, this._gaussX, this._gaussW);
                for (let k = 0; k < numGauss; k++) {
                    this._summedLength += this._gaussW[k] * this.tangentMagnitude(this._gaussX[k]);
                }
            }
        }
    }
    announceSegmentInterval(_cp, point0, point1, _numStrokes, fraction0, fraction1) {
        const segmentLength = point0.distance(point1);
        if (this._fraction0 <= fraction0 && fraction1 <= this._fraction1)
            this._summedLength += segmentLength;
        else {
            let g0 = fraction0;
            let g1 = fraction1;
            if (g0 < this._fraction0)
                g0 = this._fraction0;
            if (g1 > this._fraction1)
                g1 = this._fraction1;
            if (g1 > g0) {
                this._summedLength += segmentLength * (g1 - g0) / (fraction1 - fraction0);
            }
        }
    }
    announcePointTangent(_xyz, _fraction, _tangent) {
        // uh oh -- need to retain point for next interval
    }
}
// context for searching for closest point .. .
class ClosestPointStrokeHandler extends NewtonRotRStrokeHandler {
    constructor(spacePoint, extend) {
        super();
        this._fractionA = 0;
        this._functionA = 0;
        this._functionB = 0;
        this._fractionB = 0;
        this._numThisCurve = 0;
        this._spacePoint = spacePoint;
        this._workPoint = Point3dVector3d_1.Point3d.create();
        this._workRay = Ray3d_1.Ray3d.createZero();
        this._closestPoint = undefined;
        this._extend = extend;
        this.startCurvePrimitive(undefined);
        this._newtonSolver = new Newton_1.Newton1dUnboundedApproximateDerivative(this);
    }
    claimResult() {
        if (this._closestPoint) {
            this._newtonSolver.setX(this._closestPoint.fraction);
            this._curve = this._closestPoint.curve;
            if (this._newtonSolver.runIterations())
                this.announceSolutionFraction(this._newtonSolver.getX());
        }
        return this._closestPoint;
    }
    startCurvePrimitive(curve) {
        this._curve = curve;
        this._fractionA = 0.0;
        this._numThisCurve = 0;
        this._functionA = 0.0;
    }
    endCurvePrimitive() { }
    announceIntervalForUniformStepStrokes(cp, numStrokes, fraction0, fraction1) {
        this.startCurvePrimitive(cp);
        if (numStrokes < 1)
            numStrokes = 1;
        const df = 1.0 / numStrokes;
        for (let i = 0; i <= numStrokes; i++) {
            const fraction = Geometry_1.Geometry.interpolate(fraction0, i * df, fraction1);
            cp.fractionToPointAndDerivative(fraction, this._workRay);
            this.announceRay(fraction, this._workRay);
        }
    }
    announceCandidate(cp, fraction, point) {
        const distance = this._spacePoint.distance(point);
        if (this._closestPoint && distance > this._closestPoint.a)
            return;
        this._closestPoint = CurveLocationDetail_1.CurveLocationDetail.createCurveFractionPoint(cp, fraction, point, this._closestPoint);
        this._closestPoint.a = distance;
        if (this._parentCurvePrimitive !== undefined)
            this._closestPoint.curve = this._parentCurvePrimitive;
    }
    announceSegmentInterval(cp, point0, point1, _numStrokes, fraction0, fraction1) {
        let localFraction = this._spacePoint.fractionOfProjectionToLine(point0, point1, 0.0);
        // only consider extending the segment if the immediate caller says we are at endpoints ...
        if (!this._extend)
            localFraction = Geometry_1.Geometry.clampToStartEnd(localFraction, 0.0, 1.0);
        else {
            if (fraction0 !== 0.0)
                localFraction = Math.max(localFraction, 0.0);
            if (fraction1 !== 1.0)
                localFraction = Math.min(localFraction, 1.0);
        }
        this._workPoint = point0.interpolate(localFraction, point1);
        const globalFraction = Geometry_1.Geometry.interpolate(fraction0, localFraction, fraction1);
        this.announceCandidate(cp, globalFraction, this._workPoint);
    }
    searchInterval() {
        if (this._functionA * this._functionB > 0)
            return;
        if (this._functionA === 0)
            this.announceSolutionFraction(this._fractionA);
        if (this._functionB === 0)
            this.announceSolutionFraction(this._fractionB);
        if (this._functionA * this._functionB < 0) {
            const fraction = Geometry_1.Geometry.inverseInterpolate(this._fractionA, this._functionA, this._fractionB, this._functionB);
            if (fraction) {
                this._newtonSolver.setX(fraction);
                if (this._newtonSolver.runIterations())
                    this.announceSolutionFraction(this._newtonSolver.getX());
            }
        }
    }
    evaluateB(fractionB, dataB) {
        this._functionB = dataB.dotProductToPoint(this._spacePoint);
        this._fractionB = fractionB;
    }
    announceSolutionFraction(fraction) {
        if (this._curve)
            this.announceCandidate(this._curve, fraction, this._curve.fractionToPoint(fraction));
    }
    evaluate(fraction) {
        let curve = this._curve;
        if (this._parentCurvePrimitive)
            curve = this._parentCurvePrimitive;
        if (curve) {
            this._workRay = curve.fractionToPointAndDerivative(fraction, this._workRay);
            this.currentF = this._workRay.dotProductToPoint(this._spacePoint);
            return true;
        }
        return false;
    }
    announceRay(fraction, data) {
        this.evaluateB(fraction, data);
        if (this._numThisCurve++ > 0)
            this.searchInterval();
        this._functionA = this._functionB;
        this._fractionA = this._fractionB;
        this._fractionA = this._fractionB;
    }
    announcePointTangent(point, fraction, tangent) {
        this._workRay.set(point, tangent);
        this.announceRay(fraction, this._workRay);
    }
}


/***/ }),

/***/ "./lib/curve/CurveProcessor.js":
/*!*************************************!*\
  !*** ./lib/curve/CurveProcessor.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Curve */
const CurvePrimitive_1 = __webpack_require__(/*! ./CurvePrimitive */ "./lib/curve/CurvePrimitive.js");
/* tslint:disable:variable-name no-empty*/
/** base class for detailed traversal of curve artifacts.  This recurses to children in the quickest way (no records of path)
 * Use the RecursiveCurveProcessorWithStack to record the path along the visit.
 */
class RecursiveCurveProcessor {
    constructor() {
    }
    /** process error content */
    announceUnexpected(_data, _indexInParent) { }
    /** process a leaf primitive. */
    announceCurvePrimitive(_data, _indexInParent = -1) { }
    /** announce a path (recurse to children) */
    announcePath(data, _indexInParent = -1) {
        let i = 0;
        for (const curve of data.children)
            this.announceCurvePrimitive(curve, i++);
    }
    /** announce a loop (recurse to children) */
    announceLoop(data, _indexInParent = -1) {
        let i = 0;
        for (const curve of data.children)
            this.announceCurvePrimitive(curve, i++);
    }
    /** annouce beginning or end of loops in a parity region */
    announceParityRegion(data, _indexInParent = -1) {
        let i = 0;
        for (const loop of data.children)
            this.announceLoop(loop, i++);
    }
    /** annouce beginning or end of a parity region */
    announceUnionRegion(data, _indexInParent = -1) {
        let i = 0;
        for (const child of data.children) {
            child.announceToCurveProcessor(this, i++);
        }
    }
    announceBagOfCurves(data, _indexInParent = -1) {
        for (const child of data.children) {
            if (child instanceof CurvePrimitive_1.CurvePrimitive)
                this.announceCurvePrimitive(child);
            else
                child.announceToCurveProcessor(this);
        }
    }
}
exports.RecursiveCurveProcessor = RecursiveCurveProcessor;
/** base class for detailed traversal of curve artifacts, maintaining a stack that shows complete path to each artifact.
 * Use the QuickRecursiveCurveProcessor to visit without recording the path.
 */
class RecursiveCurveProcessorWithStack extends RecursiveCurveProcessor {
    constructor() {
        super();
        this._stack = [];
    }
    enter(data) { this._stack.push(data); }
    leave() { return this._stack.pop(); }
    /** process error content */
    announceUnexpected(_data, _indexInParent) { }
    /** process a leaf primitive. */
    announceCurvePrimitive(_data, _indexInParent = -1) { }
    /** announce a path (recurse to children) */
    announcePath(data, indexInParent = -1) {
        this.enter(data);
        super.announcePath(data, indexInParent);
        this.leave();
    }
    /** announce a loop (recurse to children) */
    announceLoop(data, indexInParent = -1) {
        this.enter(data);
        super.announceLoop(data, indexInParent);
        this.leave();
    }
    /** annouce beginning or end of loops in a parity region */
    announceParityRegion(data, _indexInParent = -1) {
        this.enter(data);
        let i = 0;
        for (const loop of data.children)
            this.announceLoop(loop, i++);
        this.leave();
    }
    /** annouce beginning or end of a parity region */
    announceUnionRegion(data, indexInParent = -1) {
        this.enter(data);
        super.announceUnionRegion(data, indexInParent);
        this.leave();
    }
    announceBagOfCurves(data, _indexInParent = -1) {
        this.enter(data);
        let i = 0;
        for (const child of data.children) {
            if (child instanceof CurvePrimitive_1.CurvePrimitive)
                this.announceCurvePrimitive(child, i++);
            else
                child.announceToCurveProcessor(this);
        }
        this.leave();
    }
}
exports.RecursiveCurveProcessorWithStack = RecursiveCurveProcessorWithStack;


/***/ }),

/***/ "./lib/curve/GeometryQuery.js":
/*!************************************!*\
  !*** ./lib/curve/GeometryQuery.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Curve */
const Range_1 = __webpack_require__(/*! ../geometry3d/Range */ "./lib/geometry3d/Range.js");
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
/** Queries to be supported by Curve, Surface, and Solid objects */
class GeometryQuery {
    /** return the range of the entire (tree) GeometryQuery */
    range(transform, result) {
        if (result)
            result.setNull();
        const range = result ? result : Range_1.Range3d.createNull();
        this.extendRange(range, transform);
        return range;
    }
    /** try to move the geometry by dx,dy,dz */
    tryTranslateInPlace(dx, dy = 0.0, dz = 0.0) {
        return this.tryTransformInPlace(Transform_1.Transform.createTranslationXYZ(dx, dy, dz));
    }
    /** return GeometryQuery children for recursive queries.
     *
     * * leaf classes do not need to implement.
     */
    get children() { return undefined; }
    /** test for exact structure and nearly identical geometry.
     *
     * *  Leaf classes must implement !!!
     * *  base class implementation recurses through children.
     * *  base implementation is complete for classes with children and no properties.
     * *  classes with both children and properties must implement for properties, call super for children.
     */
    isAlmostEqual(other) {
        if (this.isSameGeometryClass(other)) {
            const childrenA = this.children;
            const childrenB = other.children;
            if (childrenA && childrenB) {
                if (childrenA.length !== childrenB.length)
                    return false;
                for (let i = 0; i < childrenA.length; i++) {
                    if (!childrenA[i].isAlmostEqual(childrenB[i]))
                        return false;
                }
                return true;
            }
            else if (childrenA || childrenB) {
                return false; // plainly different .
            }
            else {
                // both children null. call it equal?   This class should probably have implemented.
                return true;
            }
        }
        return false;
    }
}
exports.GeometryQuery = GeometryQuery;


/***/ }),

/***/ "./lib/curve/LineSegment3d.js":
/*!************************************!*\
  !*** ./lib/curve/LineSegment3d.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Curve */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const BezierPolynomials_1 = __webpack_require__(/*! ../numerics/BezierPolynomials */ "./lib/numerics/BezierPolynomials.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Ray3d_1 = __webpack_require__(/*! ../geometry3d/Ray3d */ "./lib/geometry3d/Ray3d.js");
const Plane3dByOriginAndVectors_1 = __webpack_require__(/*! ../geometry3d/Plane3dByOriginAndVectors */ "./lib/geometry3d/Plane3dByOriginAndVectors.js");
const CurvePrimitive_1 = __webpack_require__(/*! ./CurvePrimitive */ "./lib/curve/CurvePrimitive.js");
const CurveLocationDetail_1 = __webpack_require__(/*! ./CurveLocationDetail */ "./lib/curve/CurveLocationDetail.js");
const LineString3d_1 = __webpack_require__(/*! ./LineString3d */ "./lib/curve/LineString3d.js");
/* tslint:disable:variable-name no-empty*/
/**
 * A LineSegment3d is:
 *
 * * A 3d line segment represented by
 *
 * ** startPoint
 * ** endPoint
 * parameterized with fraction 0 at the start and fraction 1 at the end, i.e. either of these equivalent forms:
 *
 * **  `X(f) = startPoint + f * (endPoint - startPoint)`
 * ** `X(f) = (1-f)*startPoint  + f * endPoint`
 */
class LineSegment3d extends CurvePrimitive_1.CurvePrimitive {
    isSameGeometryClass(other) { return other instanceof LineSegment3d; }
    get point0Ref() { return this._point0; }
    get point1Ref() { return this._point1; }
    /**
     * A LineSegment3d extends along its infinite line.
     */
    get isExtensibleFractionSpace() { return true; }
    /**
     * CAPTURE point references as a `LineSegment3d`
     * @param point0
     * @param point1
     */
    constructor(point0, point1) { super(); this._point0 = point0; this._point1 = point1; }
    /** Set the start and endpoints by capturing input references. */
    setRefs(point0, point1) { this._point0 = point0; this._point1 = point1; }
    /** Set the start and endponits by cloning the input parameters. */
    set(point0, point1) { this._point0 = point0.clone(); this._point1 = point1.clone(); }
    /** copy (clone) data from other */
    setFrom(other) { this._point0.setFrom(other._point0); this._point1.setFrom(other._point1); }
    /** @returns Return a (clone of) the start point. */
    startPoint(result) {
        if (result) {
            result.setFrom(this._point0);
            return result;
        }
        return this._point0.clone();
    }
    /** @returns Return a (clone of) the end point. */
    endPoint(result) {
        if (result) {
            result.setFrom(this._point1);
            return result;
        }
        return this._point1.clone();
    }
    /** @returns Return the point at fractional position along the line segment. */
    fractionToPointAndDerivative(fraction, result) {
        result = result ? result : Ray3d_1.Ray3d.createZero();
        result.direction.setStartEnd(this._point0, this._point1);
        this._point0.interpolate(fraction, this._point1, result.origin);
        return result;
    }
    /** Construct a plane with
     * * origin at the fractional position along the line segment
     * * x axis is the first derivative, i.e. along the line segment
     * * y axis is the second derivative, i.e. 000
     */
    fractionToPointAnd2Derivatives(fraction, result) {
        result = result ? result : Plane3dByOriginAndVectors_1.Plane3dByOriginAndVectors.createXYPlane();
        result.vectorU.setStartEnd(this._point0, this._point1);
        result.vectorV.set(0, 0, 0);
        this._point0.interpolate(fraction, this._point1, result.origin);
        return result;
    }
    /** Clone the LineSegment3d */
    clone() { return LineSegment3d.create(this._point0, this._point1); }
    /** Clone and apply transform to the clone. */
    cloneTransformed(transform) {
        const c = this.clone();
        c.tryTransformInPlace(transform);
        return c;
    }
    /** Create with start and end points.  The ponit contents are cloned into the LineSegment3d. */
    static create(point0, point1, result) {
        if (result) {
            result.set(point0, point1); // and this will clone them !!
            return result;
        }
        return new LineSegment3d(point0.clone(), point1.clone());
    }
    /** create a LineSegment3d from xy coordinates of start and end, with common z.
     * @param x0 start point x coordinate.
     * @param y0 start point y coordinate.
     * @param x1 end point x coordinate.
     * @param y1 end point y coordinate.
     * @param z z coordinate to use for both points.
     * @param result optional existing LineSegment to be reinitiazlized.
     */
    static createXYXY(x0, y0, x1, y1, z = 0, result) {
        if (result) {
            result._point0.set(x0, y0, z);
            result._point1.set(x1, y1, z);
            return result;
        }
        return new LineSegment3d(Point3dVector3d_1.Point3d.create(x0, y0, z), Point3dVector3d_1.Point3d.create(x1, y1, z));
    }
    /** create a LineSegment3d from xy coordinates of start and end, with common z.
     * @param x0 start point x coordinate.
     * @param y0 start point y coordinate.
     * @param x1 end point x coordinate.
     * @param y1 end point y coordinate.
     * @param z z coordinate to use for both points.
     * @param result optional existing LineSegment to be reinitiazlized.
     */
    static createXYZXYZ(x0, y0, z0, x1, y1, z1, result) {
        if (result) {
            result._point0.set(x0, y0, z0);
            result._point1.set(x1, y1, z1);
            return result;
        }
        return new LineSegment3d(Point3dVector3d_1.Point3d.create(x0, y0, z0), Point3dVector3d_1.Point3d.create(x1, y1, z1));
    }
    /** @returns Return the point at fractional position along the line segment. */
    fractionToPoint(fraction, result) { return this._point0.interpolate(fraction, this._point1, result); }
    curveLength() { return this._point0.distance(this._point1); }
    curveLengthBetweenFractions(fraction0, fraction1) {
        return Math.abs(fraction1 - fraction0) * this._point0.distance(this._point1);
    }
    quickLength() { return this.curveLength(); }
    /**
     * @param spacePoint point in space
     * @param extend if false, only return points within the bounded line segment. If true, allow the point to be on the unbounded line that contains the bounded segment.
     * @returns Returns a curve location detail with both xyz and fractional coordinates of the closest point.
     */
    closestPoint(spacePoint, extend, result) {
        let fraction = spacePoint.fractionOfProjectionToLine(this._point0, this._point1, 0.0);
        if (!extend) {
            if (fraction > 1.0)
                fraction = 1.0;
            else if (fraction < 0.0)
                fraction = 0.0;
        }
        result = CurveLocationDetail_1.CurveLocationDetail.create(this, result);
        // remark: This can be done by result.setFP (fraction, thePoint, undefined, a)
        //   but that creates a temporary point.
        result.fraction = fraction;
        this._point0.interpolate(fraction, this._point1, result.point);
        result.vectorInCurveLocationDetail = undefined;
        result.a = result.point.distance(spacePoint);
        return result;
    }
    /** swap the endpoint references. */
    reverseInPlace() {
        const a = this._point0;
        this._point0 = this._point1;
        this._point1 = a;
    }
    tryTransformInPlace(transform) {
        this._point0 = transform.multiplyPoint3d(this._point0, this._point0);
        this._point1 = transform.multiplyPoint3d(this._point1, this._point1);
        return true;
    }
    isInPlane(plane) {
        return Geometry_1.Geometry.isSmallMetricDistance(plane.altitude(this._point0))
            && Geometry_1.Geometry.isSmallMetricDistance(plane.altitude(this._point1));
    }
    appendPlaneIntersectionPoints(plane, result) {
        const h0 = plane.altitude(this._point0);
        const h1 = plane.altitude(this._point1);
        const fraction = BezierPolynomials_1.Order2Bezier.solveCoffs(h0, h1);
        let numIntersection = 0;
        if (fraction !== undefined) {
            numIntersection++;
            result.push(CurveLocationDetail_1.CurveLocationDetail.createCurveFractionPoint(this, fraction, this.fractionToPoint(fraction)));
        }
        return numIntersection;
    }
    /**
     * Extend a range to include the (optionally transformed) line segment
     * @param range range to extend
     * @param transform optional transform to apply to the end points
     */
    extendRange(range, transform) {
        if (transform) {
            range.extendTransformedPoint(transform, this._point0);
            range.extendTransformedPoint(transform, this._point1);
        }
        else {
            range.extendPoint(this._point0);
            range.extendPoint(this._point1);
        }
    }
    /**
     * Construct a line from either of these json forms:
     *
     * * object with named start and end:
     * `{startPoint: pointValue, endPoint: pointValue}`
     * * array of two point values:
     * `[pointValue, pointValue]`
     * The point values are any values accepted by the Point3d method setFromJSON.
     * @param json data to parse.
     */
    setFromJSON(json) {
        if (!json) {
            this._point0.set(0, 0, 0);
            this._point1.set(1, 0, 0);
            return;
        }
        else if (json.startPoint && json.endPoint) { // {startPoint:JSONPOINT, endPoint:JSONPOINT}
            this._point0.setFromJSON(json.startPoint);
            this._point1.setFromJSON(json.endPoint);
        }
        else if (Array.isArray(json)
            && json.length > 1) { // [JSONPOINT, JSONPOINT]
            this._point0.setFromJSON(json[0]);
            this._point1.setFromJSON(json[1]);
        }
    }
    /** A simple line segment's fraction and distance are proportional. */
    getFractionToDistanceScale() { return this.curveLength(); }
    /**
     * Place the lineSegment3d start and points in a json object
     * @return {*} [[x,y,z],[x,y,z]]
     */
    toJSON() { return [this._point0.toJSON(), this._point1.toJSON()]; }
    static fromJSON(json) {
        const result = new LineSegment3d(Point3dVector3d_1.Point3d.createZero(), Point3dVector3d_1.Point3d.create());
        result.setFromJSON(json);
        return result;
    }
    isAlmostEqual(other) {
        if (other instanceof LineSegment3d) {
            const ls = other;
            return this._point0.isAlmostEqual(ls._point0) && this._point1.isAlmostEqual(ls._point1);
        }
        return false;
    }
    /** Emit strokes to caller-supplied linestring */
    emitStrokes(dest, options) {
        dest.appendStrokePoint(this._point0);
        if (options) {
            let numStroke = 1;
            if (options.maxEdgeLength)
                numStroke = options.applyMaxEdgeLength(numStroke, this.curveLength());
            numStroke = options.applyMinStrokesPerPrimitive(numStroke);
            dest.appendFractionalStrokePoints(this, numStroke, 0.0, 1.0, false);
        }
        dest.appendStrokePoint(this._point1);
    }
    /** Emit strokes to caller-supplied handler */
    emitStrokableParts(handler, options) {
        handler.startCurvePrimitive(this);
        const tangent = this._point0.vectorTo(this._point1);
        let numStroke = 1;
        if (options) {
            if (options.maxEdgeLength)
                numStroke = options.applyMaxEdgeLength(numStroke, tangent.magnitude());
            numStroke = options.applyMinStrokesPerPrimitive(numStroke);
        }
        handler.announceSegmentInterval(this, this._point0, this._point1, numStroke, 0.0, 1.0);
        handler.endCurvePrimitive(this);
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleLineSegment3d(this);
    }
    /**
     * Find intervals of this curveprimitve that are interior to a clipper
     * @param clipper clip structure (e.g. clip planes)
     * @param announce function to be called announcing fractional intervals"  ` announce(fraction0, fraction1, curvePrimitive)`
     */
    announceClipIntervals(clipper, announce) {
        return clipper.announceClippedSegmentIntervals(0.0, 1.0, this._point0, this._point1, announce ? (fraction0, fraction1) => announce(fraction0, fraction1, this) : undefined);
    }
    /** Return (if possible) a curve primitive which is a portion of this curve.
     * @param fractionA [in] start fraction
     * @param fractionB [in] end fraction
     */
    clonePartialCurve(fractionA, fractionB) {
        return LineString3d_1.LineString3d.create(this.fractionToPoint(fractionA), this.fractionToPoint(fractionB));
    }
}
exports.LineSegment3d = LineSegment3d;


/***/ }),

/***/ "./lib/curve/LineString3d.js":
/*!***********************************!*\
  !*** ./lib/curve/LineString3d.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Curve */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Angle_1 = __webpack_require__(/*! ../geometry3d/Angle */ "./lib/geometry3d/Angle.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const Matrix3d_1 = __webpack_require__(/*! ../geometry3d/Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const Ray3d_1 = __webpack_require__(/*! ../geometry3d/Ray3d */ "./lib/geometry3d/Ray3d.js");
const Plane3dByOriginAndVectors_1 = __webpack_require__(/*! ../geometry3d/Plane3dByOriginAndVectors */ "./lib/geometry3d/Plane3dByOriginAndVectors.js");
const GrowableXYZArray_1 = __webpack_require__(/*! ../geometry3d/GrowableXYZArray */ "./lib/geometry3d/GrowableXYZArray.js");
const CurvePrimitive_1 = __webpack_require__(/*! ./CurvePrimitive */ "./lib/curve/CurvePrimitive.js");
const CurveLocationDetail_1 = __webpack_require__(/*! ./CurveLocationDetail */ "./lib/curve/CurveLocationDetail.js");
const LineSegment3d_1 = __webpack_require__(/*! ./LineSegment3d */ "./lib/curve/LineSegment3d.js");
/* tslint:disable:variable-name no-empty*/
/**
 * context to be called to incrementally accumulate distance along line segments.
 */
class MoveByDistanceContext {
    /** CAPTURE point0, fraction0, targetDistance */
    constructor(point0, fraction0, targetDistance) {
        this.point0 = point0;
        this.distance0 = 0.0;
        this.targetDistance = Math.abs(targetDistance);
        this.fraction0 = fraction0;
    }
    // Return CurveSearchStatus indicating whether the accumulated distance has reached the target.
    distanceStatus() {
        return Geometry_1.Geometry.isSameCoordinate(this.distance0, this.targetDistance) ?
            CurveLocationDetail_1.CurveSearchStatus.success : CurveLocationDetail_1.CurveSearchStatus.stoppedAtBoundary;
    }
    /**
     * Announce next point on the polyline.
     * * if the additional segment does NOT reach the target:
     *   * accumulate the segment length
     *   * update point0 and fraction0
     *   * return false
     *  * if the additional segment DOES reach the target:
     *    * update point0 and fraction0 to the (possibly interpolated) final point and fraction
     *    * return true
     * @param point1 new point
     * @param fraction1 fraction at point1
     * @return true if targetDistance reached.
     */
    announcePoint(point1, fraction1) {
        const a = this.point0.distance(point1);
        const distance1 = this.distance0 + a;
        if (distance1 < this.targetDistance && !Geometry_1.Geometry.isSameCoordinate(distance1, this.targetDistance)) {
            this.point0.setFromPoint3d(point1);
            this.distance0 = distance1;
            this.fraction0 = fraction1;
            return false;
        }
        const b = this.targetDistance - this.distance0;
        const intervalFraction = Geometry_1.Geometry.safeDivideFraction(b, a, 0.0);
        this.point0.interpolate(intervalFraction, point1, this.point0);
        this.fraction0 = Geometry_1.Geometry.interpolate(this.fraction0, intervalFraction, fraction1);
        this.distance0 = this.targetDistance;
        return true;
    }
    /**
     * Update point0, fraction0, and distance0 based on extrapolation of a segment between indices of a point array.
     * @returns true if extraploation succeeded.  (False if indexed points are coincident)
     * @param points
     * @param index0
     * @param index1
     * @param fraction0
     * @param fraction1
     * @param result
     * @param CurveLocationDetail
     */
    announceExtrapolation(points, index0, index1, fraction0, fraction1) {
        const residual = this.targetDistance - this.distance0;
        const d01 = points.distance(index0, index1);
        if (!d01)
            return false;
        const extensionFraction = Geometry_1.Geometry.conditionalDivideFraction(residual, d01);
        if (extensionFraction === undefined)
            return false;
        // (Remark: indices are swapped and extensionFraction negated to prevent incidental precision
        // loss with the alternative call with (index0, 1 + extensionFraction, index1);
        points.interpolate(index1, -extensionFraction, index0, this.point0);
        this.distance0 = this.targetDistance;
        this.fraction0 = Geometry_1.Geometry.interpolate(fraction1, -extensionFraction, fraction0);
        return true;
    }
}
/* Starting wtih baseIndex and moving index by stepDirection:
If the vector from baseIndex to baseIndex +1 crossed with vectorA can be normalized, accumulate it (scaled) to normal.
Return when successful.
(Do nothing if everything is parallel through limits of the array)
*/
function accumulateGoodUnitPerpendicular(points, vectorA, baseIndex, stepDirection, weight, normal, workVector) {
    const n = points.length;
    if (stepDirection > 0) {
        for (let i = baseIndex; i + 1 < n; i++) {
            points.vectorIndexIndex(i, i + 1, workVector);
            vectorA.crossProduct(workVector, workVector);
            if (workVector.normalizeInPlace()) {
                normal.addScaledInPlace(workVector, weight);
                return true;
            }
        }
    }
    else {
        if (baseIndex + 1 >= n)
            baseIndex = n - 2;
        for (let i = baseIndex; i >= 0; i--) {
            points.vectorIndexIndex(i, i + 1, workVector);
            workVector.crossProduct(vectorA, workVector);
            if (workVector.normalizeInPlace()) {
                normal.addScaledInPlace(workVector, weight);
                return true;
            }
        }
    }
    return false;
}
/**
 * * A LineString3d (sometimes called a PolyLine) is a sequence of xyz coordinates that are to be joined by line segments.
 * * The point coordinates are stored in a GrowableXYZArray.
 */
class LineString3d extends CurvePrimitive_1.CurvePrimitive {
    constructor() {
        super();
        this._points = new GrowableXYZArray_1.GrowableXYZArray();
    }
    isSameGeometryClass(other) { return other instanceof LineString3d; }
    /**
     * A LineString3d extends along its first and final segments.
     */
    get isExtensibleFractionSpace() { return true; }
    /** return the points array (cloned). */
    get points() { return this._points.getPoint3dArray(); }
    /** Return (reference to) point data in packed GrowableXYZArray. */
    get packedPoints() { return this._points; }
    cloneTransformed(transform) {
        const c = this.clone();
        c.tryTransformInPlace(transform);
        return c;
    }
    static flattenArray(arr) {
        return arr.reduce((flat, toFlatten) => {
            return flat.concat(Array.isArray(toFlatten) ? LineString3d.flattenArray(toFlatten) : toFlatten);
        }, []);
    }
    static create(...points) {
        const result = new LineString3d();
        result.addPoints(points);
        return result;
    }
    static createXY(points, z, enforceClosure = false) {
        const result = new LineString3d();
        const xyz = result._points;
        for (const xy of points) {
            xyz.pushXYZ(xy.x, xy.y, z);
        }
        if (enforceClosure && points.length > 1) {
            const distance = xyz.distance(0, xyz.length - 1);
            if (distance !== undefined && distance !== 0.0) {
                if (Geometry_1.Geometry.isSameCoordinate(0, distance)) {
                    xyz.pop(); // nonzero but small distance -- to be replaced by point 0 exactly.
                    const xyzA = xyz.front();
                    xyz.push(xyzA);
                }
            }
        }
        return result;
    }
    addPoints(...points) {
        const toAdd = LineString3d.flattenArray(points);
        for (const p of toAdd) {
            if (p instanceof Point3dVector3d_1.Point3d)
                this._points.push(p);
        }
    }
    /**
     * Add a point to the linestring.
     * @param point
     */
    addPoint(point) {
        this._points.push(point);
    }
    /**
     * Add a point to the linestring.
     * @param point
     */
    addPointXYZ(x, y, z = 0) {
        this._points.pushXYZ(x, y, z);
    }
    /**
     * If the linestring is not already closed, add a closure point.
     */
    addClosurePoint() {
        const distance = this._points.distance(0, this._points.length - 1);
        if (distance !== undefined && !Geometry_1.Geometry.isSameCoordinate(distance, 0))
            this._points.pushWrap(1);
    }
    /** Elminate (but do not return!!) the final point of the linestring */
    popPoint() {
        this._points.pop();
    }
    static createRectangleXY(point0, ax, ay, closed = true) {
        const ls = LineString3d.create();
        const x0 = point0.x;
        const x1 = point0.x + ax;
        const y0 = point0.y;
        const y1 = point0.y + ay;
        const z = point0.z;
        ls.addPointXYZ(x0, y0, z);
        ls.addPointXYZ(x1, y0, z);
        ls.addPointXYZ(x1, y1, z);
        ls.addPointXYZ(x0, y1, z);
        if (closed)
            ls.addClosurePoint();
        return ls;
    }
    /**
     * Create a regular polygon centered
     * @param center center of the polygon.
     * @param edgeCount number of edges.
     * @param radius distance to vertex or edge (see `radiusToVertices`)
     * @param radiusToVertices true if polygon is inscribed in circle (radius measured to vertices); false if polygon is outside circle (radius to edges)
     */
    static createRegularPolygonXY(center, edgeCount, radius, radiusToVertices = true) {
        if (edgeCount < 3)
            edgeCount = 3;
        const ls = LineString3d.create();
        const i0 = radiusToVertices ? 0 : -1; // offset to make first vector (radius,0,0)
        const radiansStep = Math.PI / edgeCount;
        let c;
        let s;
        let radians;
        if (!radiusToVertices)
            radius = radius / Math.cos(radiansStep);
        for (let i = 0; i < edgeCount; i++) {
            radians = (i0 + 2 * i) * radiansStep;
            c = Angle_1.Angle.cleanupTrigValue(Math.cos(radians));
            s = Angle_1.Angle.cleanupTrigValue(Math.sin(radians));
            ls.addPointXYZ(center.x + radius * c, center.y + radius * s, center.z);
        }
        ls.addClosurePoint();
        return ls;
    }
    setFrom(other) {
        this._points.clear();
        let i = 0;
        while (other._points.isIndexValid(i)) {
            this._points.push(other._points.getPoint3dAt(i));
            i++;
        }
    }
    static createPoints(points) {
        const ls = new LineString3d();
        let point;
        for (point of points)
            ls._points.push(point);
        return ls;
    }
    /** Create a LineString3d from xyz coordinates packed in a Float64Array */
    static createFloat64Array(xyzData) {
        const ls = new LineString3d();
        for (let i = 0; i + 3 <= xyzData.length; i += 3)
            ls._points.push(Point3dVector3d_1.Point3d.create(xyzData[i], xyzData[i + 1], xyzData[i + 2]));
        return ls;
    }
    clone() {
        const retVal = new LineString3d();
        retVal.setFrom(this);
        return retVal;
    }
    setFromJSON(json) {
        this._points.clear();
        if (Array.isArray(json)) {
            let xyz;
            for (xyz of json)
                this._points.push(Point3dVector3d_1.Point3d.fromJSON(xyz));
        }
    }
    /**
     * Convert an LineString3d to a JSON object.
     * @return {*} [[x,y,z],...[x,y,z]]
     */
    toJSON() {
        const value = [];
        let i = 0;
        while (this._points.isIndexValid(i)) {
            value.push(this._points.getPoint3dAt(i).toJSON());
            i++;
        }
        return value;
    }
    static fromJSON(json) {
        const ls = new LineString3d();
        ls.setFromJSON(json);
        return ls;
    }
    fractionToPoint(fraction, result) {
        const n = this._points.length;
        if (n === 0)
            return Point3dVector3d_1.Point3d.createZero();
        if (n === 1)
            return Point3dVector3d_1.Point3d.createFrom(this._points.getPoint3dAt(0), result);
        const df = 1.0 / (n - 1);
        if (fraction <= df)
            return this._points.interpolate(0, fraction / df, 1, result);
        if (fraction + df >= 1.0)
            return this._points.interpolate(n - 1, (1.0 - fraction) / df, n - 2, result);
        const index0 = Math.floor(fraction / df);
        return this._points.interpolate(index0, (fraction - index0 * df) / df, index0 + 1, result);
    }
    fractionToPointAndDerivative(fraction, result) {
        result = result ? result : Ray3d_1.Ray3d.createZero();
        const n = this._points.length;
        if (n <= 1) {
            result.direction.setZero();
            if (n === 1)
                result.origin.setFrom(this._points.getPoint3dAt(0));
            else
                result.origin.setZero();
            return result;
        }
        const numSegment = n - 1;
        const df = 1.0 / numSegment;
        if (fraction <= df) {
            result = result ? result : Ray3d_1.Ray3d.createZero();
            this._points.interpolate(0, fraction / df, 1, result.origin);
            this._points.vectorIndexIndex(0, 1, result.direction);
            result.direction.scaleInPlace(1.0 / df);
            return result;
        }
        if (fraction + df >= 1.0) {
            result = result ? result : Ray3d_1.Ray3d.createZero();
            this._points.interpolate(n - 2, 1.0 - (1.0 - fraction) / df, n - 1, result.origin);
            this._points.vectorIndexIndex(n - 2, n - 1, result.direction);
            result.direction.scaleInPlace(1.0 / df);
            return result;
        }
        /* true interior point */
        result = result ? result : Ray3d_1.Ray3d.createZero();
        const index0 = Math.floor(fraction / df);
        const localFraction = (fraction - index0 * df) / df;
        this._points.interpolate(index0, localFraction, index0 + 1, result.origin);
        this._points.vectorIndexIndex(index0, index0 + 1, result.direction);
        result.direction.scaleInPlace(1.0 / df);
        return result;
    }
    /** Return point and derivative at fraction, with 000 second derivative. */
    fractionToPointAnd2Derivatives(fraction, result) {
        const ray = this.fractionToPointAndDerivative(fraction);
        result = Plane3dByOriginAndVectors_1.Plane3dByOriginAndVectors.createCapture(ray.origin, ray.direction, Point3dVector3d_1.Vector3d.createZero(), result);
        return result;
    }
    /**
     * Convert a segment index and local fraction to a global fraction.
     * @param index index of segment being evaluated
     * @param localFraction local fraction within that segment
     */
    segmentIndexAndLocalFractionToGlobalFraction(index, localFraction) {
        const numSegment = this._points.length - 1;
        if (numSegment < 1)
            return 0.0;
        return (index + localFraction) / numSegment;
    }
    /** Return a frenet frame, using nearby points to estimate a plane. */
    fractionToFrenetFrame(fraction, result) {
        const n = this._points.length;
        if (n <= 1) {
            if (n === 1)
                return Transform_1.Transform.createTranslation(this._points.getPoint3dAt(0), result);
            return Transform_1.Transform.createIdentity(result);
        }
        if (n === 2)
            return Transform_1.Transform.createRefs(this._points.interpolate(0, fraction, 1), Matrix3d_1.Matrix3d.createRigidHeadsUp(this._points.vectorIndexIndex(0, 1), 0 /* XYZ */));
        /** 3 or more points. */
        const numSegment = n - 1;
        const df = 1.0 / numSegment;
        let baseIndex = 0;
        let localFraction = 0;
        if (fraction <= df) {
            localFraction = fraction / df;
            baseIndex = 0;
        }
        else if (fraction + df >= 1.0) {
            baseIndex = n - 2;
            localFraction = 1.0 - (1.0 - fraction) / df;
        }
        else {
            baseIndex = Math.floor(fraction / df);
            localFraction = fraction * numSegment - baseIndex;
        }
        const origin = this._points.interpolate(baseIndex, localFraction, baseIndex + 1);
        const vectorA = this._points.vectorIndexIndex(baseIndex, baseIndex + 1);
        // tricky stuff to handle colinear points.   But if vectorA is zero it is still a mess . ..
        const normal = Point3dVector3d_1.Vector3d.create();
        const workVector = Point3dVector3d_1.Vector3d.create();
        if (baseIndex === 0) { // only look forward
            accumulateGoodUnitPerpendicular(this._points, vectorA, baseIndex + 1, 1, 1.0, normal, workVector);
        }
        else if (baseIndex + 2 >= n) { // only look back
            accumulateGoodUnitPerpendicular(this._points, vectorA, baseIndex - 1, -1, 1.0, normal, workVector);
        }
        else {
            accumulateGoodUnitPerpendicular(this._points, vectorA, baseIndex - 1, -1, (1.0 - localFraction), normal, workVector);
            accumulateGoodUnitPerpendicular(this._points, vectorA, baseIndex + 1, 1, (localFraction), normal, workVector);
        }
        const matrix = Matrix3d_1.Matrix3d.createRigidFromColumns(normal, vectorA, 2 /* ZXY */);
        if (matrix)
            return Transform_1.Transform.createOriginAndMatrix(origin, matrix, result);
        return Transform_1.Transform.createTranslation(origin, result);
    }
    startPoint() {
        if (this._points.length === 0)
            return Point3dVector3d_1.Point3d.createZero();
        return this._points.getPoint3dAt(0);
    }
    /** If i is a valid index, return that point. */
    pointAt(i, result) {
        if (this._points.isIndexValid(i))
            return this._points.getPoint3dAt(i, result);
        return undefined;
    }
    /** If i and j are both valid indices, return the vector from point i to point j
     */
    vectorBetween(i, j, result) {
        return this._points.vectorIndexIndex(i, j, result);
    }
    numPoints() { return this._points.length; }
    endPoint() {
        if (this._points.length === 0)
            return Point3dVector3d_1.Point3d.createZero();
        return this._points.getPoint3dAt(this._points.length - 1);
    }
    reverseInPlace() {
        if (this._points.length >= 2) {
            let i0 = 0;
            let i1 = this._points.length - 1;
            let a = this._points.getPoint3dAt(0);
            while (i0 < i1) {
                a = this._points.getPoint3dAt(i0);
                this._points.setAt(i0, this._points.getPoint3dAt(i1));
                this._points.setAt(i1, a);
                i0++;
                i1--;
            }
        }
    }
    tryTransformInPlace(transform) {
        this._points.transformInPlace(transform);
        return true;
    }
    curveLength() { return this._points.sumLengths(); }
    curveLengthBetweenFractions(fraction0, fraction1) {
        const numSegments = this._points.length - 1;
        if (fraction1 === fraction0 || numSegments < 1)
            return 0.0;
        if (fraction1 < fraction0)
            return this.curveLengthBetweenFractions(fraction1, fraction0);
        const scaledFraction0 = fraction0 * numSegments;
        const scaledFraction1 = fraction1 * numSegments;
        const index0 = Math.max(1, Math.ceil(scaledFraction0));
        const index1 = Math.min(Math.floor(scaledFraction1), numSegments - 1);
        const localFraction0 = index0 - scaledFraction0;
        const localFraction1 = scaledFraction1 - index1;
        if (index0 > index1) {
            // the interval is entirely within a single segment
            return Math.abs(scaledFraction1 - scaledFraction0) * this._points.distance(index0 - 1, index0);
        }
        else {
            // there is leading partial interval, 0 or more complete segments, and a trailing partial interval.
            // (either or both partial may be zero length)
            let sum = localFraction0 * this._points.distance(index0 - 1, index0)
                + localFraction1 * (this._points.distance(index1, index1 + 1));
            for (let i = index0; i < index1; i++)
                sum += this._points.distance(i, i + 1);
            return sum;
        }
    }
    /**
     * * Implementation of `CurvePrimitive.moveSignedDistanceFromFraction`.  (see comments there!)
     * * Find the segment that contains the start fraction
     * * Move point-by-point from that position to the start or end (respectively for negative or positive signedDistance)
     * * Optionally extrapolate
     * @param startFraction
     * @param signedDistance
     * @param allowExtension
     * @param result
     */
    moveSignedDistanceFromFraction(startFraction, signedDistance, allowExtension, result) {
        const numSegments = this._points.length - 1;
        const scaledFraction = startFraction * numSegments;
        let leftPointIndex = Geometry_1.Geometry.restrictToInterval(Math.floor(scaledFraction), 0, numSegments - 1); // lower point index on active segment.
        const localFraction = scaledFraction - leftPointIndex;
        const point0 = this._points.interpolate(leftPointIndex, localFraction, leftPointIndex + 1, LineString3d._workPointA);
        const point1 = LineString3d._workPointB;
        const context = new MoveByDistanceContext(point0, startFraction, signedDistance);
        if (signedDistance > 0.0) {
            for (; leftPointIndex <= numSegments;) {
                leftPointIndex++;
                this._points.atPoint3dIndex(leftPointIndex, point1);
                if (context.announcePoint(point1, leftPointIndex / numSegments))
                    return CurveLocationDetail_1.CurveLocationDetail.createCurveFractionPointDistanceCurveSearchStatus(this, context.fraction0, context.point0, signedDistance, CurveLocationDetail_1.CurveSearchStatus.success, result);
            }
            // fall through for extrapolation from final segment
            if (allowExtension)
                context.announceExtrapolation(this._points, numSegments - 1, numSegments, (numSegments - 1) / numSegments, 1.0);
            return CurveLocationDetail_1.CurveLocationDetail.createCurveFractionPointDistanceCurveSearchStatus(this, context.fraction0, context.point0, signedDistance, context.distanceStatus(), result);
        }
        else { // (moving backwards)
            if (localFraction <= 0.0)
                leftPointIndex--;
            for (; leftPointIndex >= 0; leftPointIndex--) {
                this._points.atPoint3dIndex(leftPointIndex, point1);
                if (context.announcePoint(point1, leftPointIndex / numSegments))
                    return CurveLocationDetail_1.CurveLocationDetail.createCurveFractionPointDistanceCurveSearchStatus(this, context.fraction0, context.point0, signedDistance, CurveLocationDetail_1.CurveSearchStatus.success, result);
            }
            // fall through for backward extrapolation from initial segment
            if (allowExtension)
                context.announceExtrapolation(this._points, 1, 0, 1.0 / numSegments, 0.0);
            return CurveLocationDetail_1.CurveLocationDetail.createCurveFractionPointDistanceCurveSearchStatus(this, context.fraction0, context.point0, -context.distance0, context.distanceStatus(), result);
        }
    }
    quickLength() { return this.curveLength(); }
    closestPoint(spacePoint, extend, result) {
        result = CurveLocationDetail_1.CurveLocationDetail.create(this, result);
        const numPoints = this._points.length;
        if (numPoints > 0) {
            const lastIndex = numPoints - 1;
            result.setFP(1.0, this._points.getPoint3dAt(lastIndex), undefined);
            result.setDistanceTo(spacePoint);
            if (numPoints > 1) {
                let segmentFraction = 0;
                let d = 0;
                const df = 1.0 / lastIndex;
                for (let i = 1; i < numPoints; i++) {
                    segmentFraction = spacePoint.fractionOfProjectionToLine(this._points.getPoint3dAt(i - 1), this._points.getPoint3dAt(i));
                    if (segmentFraction < 0) {
                        if (!extend || i > 1)
                            segmentFraction = 0.0;
                    }
                    else if (segmentFraction > 1.0) {
                        if (!extend || i < lastIndex)
                            segmentFraction = 1.0;
                    }
                    this._points.getPoint3dAt(i - 1).interpolate(segmentFraction, this._points.getPoint3dAt(i), result.pointQ);
                    d = result.pointQ.distance(spacePoint);
                    if (d < result.a) {
                        result.setFP((i - 1 + segmentFraction) * df, result.pointQ, undefined, d);
                    }
                }
            }
        }
        return result;
    }
    isInPlane(plane) {
        return this._points.isCloseToPlane(plane, Geometry_1.Geometry.smallMetricDistance);
    }
    /** push a hit, fixing up the prior entry if needed.
     * return the incremented counter.
     */
    static pushVertexHit(result, counter, cp, fraction, point) {
        const detail = CurveLocationDetail_1.CurveLocationDetail.createCurveFractionPoint(cp, fraction, point);
        result.push(detail);
        if (counter === 0) {
            detail.setIntervalRole(CurveLocationDetail_1.CurveIntervalRole.isolatedAtVertex);
        }
        else if (counter === 1) { // last entry must be isolatedAtVertex !!!
            result[result.length - 2].setIntervalRole(CurveLocationDetail_1.CurveIntervalRole.intervalStart);
            detail.setIntervalRole(CurveLocationDetail_1.CurveIntervalRole.intervalEnd);
        }
        else {
            result[result.length - 2].setIntervalRole(CurveLocationDetail_1.CurveIntervalRole.intervalInterior);
            detail.setIntervalRole(CurveLocationDetail_1.CurveIntervalRole.intervalEnd);
        }
    }
    /** find intersections with a plane.
     *  Intersections within segments are recorded as CurveIntervalRole.isolated
     *   Intersections at isolated "on" vertex are recoded as CurveIntervalRole.isolatedAtVertex.
     */
    appendPlaneIntersectionPoints(plane, result) {
        if (this._points.length < 1)
            return 0;
        const initialLength = result.length;
        const n = this._points.length;
        const divisor = n === 1 ? 1.0 : n - 1;
        const pointA = LineString3d._workPointA;
        const pointB = LineString3d._workPointB;
        const pointC = LineString3d._workPointC;
        this._points.getPoint3dAt(0, pointA);
        let hB = 0;
        let numConsecutiveZero = 0;
        let hA = 0;
        let segmentFraction = 0;
        for (let i = 0; i < this._points.length; i++, pointA.setFrom(pointB), hA = hB) {
            this._points.getPoint3dAt(i, pointB);
            hB = Geometry_1.Geometry.correctSmallMetricDistance(plane.altitude(pointB));
            if (hB === 0.0)
                LineString3d.pushVertexHit(result, numConsecutiveZero++, this, i / divisor, pointB);
            else {
                if (hA * hB < 0.0) { // at point0, hA=0 will keep us out of here . ..
                    segmentFraction = hA / (hA - hB); // this division is safe because the signs are different.
                    pointA.interpolate(segmentFraction, pointB, pointC);
                    const detail = CurveLocationDetail_1.CurveLocationDetail.createCurveFractionPoint(this, (i - 1 + segmentFraction) / divisor, pointC);
                    detail.setIntervalRole(CurveLocationDetail_1.CurveIntervalRole.isolated);
                    result.push(detail);
                    numConsecutiveZero = 0;
                }
            }
        }
        return result.length - initialLength;
    }
    extendRange(rangeToExtend, transform) { this._points.extendRange(rangeToExtend, transform); }
    isAlmostEqual(other) {
        if (!(other instanceof LineString3d))
            return false;
        if (!GrowableXYZArray_1.GrowableXYZArray.isAlmostEqual(this._points, other._points))
            return false;
        return true;
    }
    /** Append (clone of) one point.
     * BUT ... skip if duplicates the tail of prior points.
     */
    appendStrokePoint(point) {
        const n = this._points.length;
        if (n === 0 || !point.isAlmostEqual(this._points.getPoint3dAt(n - 1)))
            this._points.push(point);
    }
    clear() { this._points.clear(); }
    /** Evaluate a curve at uniform fractions.  Append the evaluations to this linestring.
     * @param curve primitive to evaluate.
     * @param numStrokes number of strokes (edges).
     * @param fraction0 starting fraction coordinate
     * @param fraction1 end fraction coordinate
     * @param include01 if false, points at fraction0 and fraction1 are omitted.
     */
    appendFractionalStrokePoints(curve, numStrokes, fraction0 = 0, fraction1 = 1, include01) {
        if (include01)
            this.appendStrokePoint(curve.fractionToPoint(fraction0));
        if (numStrokes > 1) {
            const df = (fraction1 - fraction0) / numStrokes;
            for (let i = 1; i < numStrokes; i++)
                this.appendStrokePoint(curve.fractionToPoint(fraction0 + i * df));
        }
        if (include01)
            this.appendStrokePoint(curve.fractionToPoint(fraction1));
    }
    appendInterpolatedStrokePoints(numStrokes, point0, point1, include01) {
        if (include01)
            this.appendStrokePoint(point0);
        if (numStrokes > 1) {
            const df = 1.0 / numStrokes;
            for (let i = 1; i < numStrokes; i++)
                this.appendStrokePoint(point0.interpolate(i * df, point1));
        }
        if (include01)
            this.appendStrokePoint(point1);
    }
    /** Emit strokes to caller-supplied linestring */
    emitStrokes(dest, options) {
        const n = this._points.length;
        const pointA = LineString3d._workPointA;
        const pointB = LineString3d._workPointB;
        if (n > 0) {
            // This is a linestring.
            // There is no need for chordTol and angleTol within a segment.
            // Do NOT apply minstrokes per primitive.
            if (options && options.hasMaxEdgeLength) {
                dest.appendStrokePoint(this._points.getPoint3dAt(0));
                for (let i = 1; i < n; i++) {
                    this._points.getPoint3dAt(i - 1, pointA);
                    this._points.getPoint3dAt(i, pointB);
                    const numStroke = options.applyMaxEdgeLength(1, pointA.distance(pointB));
                    if (numStroke > 1)
                        dest.appendInterpolatedStrokePoints(numStroke, pointA, pointB, false);
                    dest.appendStrokePoint(pointB);
                }
            }
            else {
                for (let i = 0; i < n; i++) {
                    dest.appendStrokePoint(this._points.getPoint3dAt(i));
                }
            }
        }
    }
    /** Emit strokable parts of the curve to a caller-supplied handler.
     * If the stroke options does not have a maxEdgeLength, one stroke is emited for each segment of the linestring.
     * If the stroke options has a maxEdgeLength, smaller segments are emitted as needed.
     */
    emitStrokableParts(handler, options) {
        const n = this._points.length;
        handler.startCurvePrimitive(this);
        if (n > 1) {
            const df = 1.0 / (n - 1);
            // This is a linestring.
            // There is no need for chordTol and angleTol within a segment.
            // Do NOT apply minstrokes per primitive.
            if (options && options.hasMaxEdgeLength) {
                for (let i = 1; i < n; i++) {
                    const numStroke = options.applyMaxEdgeLength(1, this._points.getPoint3dAt(i - 1).distance(this._points.getPoint3dAt(i)));
                    handler.announceSegmentInterval(this, this._points.getPoint3dAt(i - 1), this._points.getPoint3dAt(i), numStroke, (i - 1) * df, i * df);
                }
            }
            else {
                for (let i = 1; i < n; i++) {
                    handler.announceSegmentInterval(this, this._points.getPoint3dAt(i - 1), this._points.getPoint3dAt(i), 1, (i - 1) * df, i * df);
                }
            }
        }
        handler.endCurvePrimitive(this);
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleLineString3d(this);
    }
    // HARD TO TEST -- tests that get to announceClipInterval for arc, bspline do NOT get here with
    // linestring because the controller has special case loops through segments?
    /**
     * Find intervals of this curveprimitve that are interior to a clipper
     * @param clipper clip structure (e.g. clip planes)
     * @param announce (optional) function to be called announcing fractional intervals"  ` announce(fraction0, fraction1, curvePrimitive)`
     * @returns true if any "in" segments are announced.
     */
    announceClipIntervals(clipper, announce) {
        const n = this._points.length;
        if (n < 2)
            return false;
        let globalFractionA = 0.0;
        let globalFractionB = 1.0;
        const capture = (localFraction0, localFraction1) => {
            if (announce)
                announce(Geometry_1.Geometry.interpolate(globalFractionA, localFraction0, globalFractionB), Geometry_1.Geometry.interpolate(globalFractionA, localFraction1, globalFractionB), this);
        };
        const pointA = LineString3d._workPointA;
        const pointB = LineString3d._workPointB;
        this._points.getPoint3dAt(0, pointA);
        let status = false;
        for (let i = 1; i < n; i++, pointA.setFrom(pointB), globalFractionA = globalFractionB) {
            this._points.getPoint3dAt(i, pointB);
            globalFractionB = i / (n - 1);
            if (clipper.announceClippedSegmentIntervals(0.0, 1.0, pointA, pointB, capture))
                status = true;
        }
        return status;
    }
    addResolvedPoint(index, fraction, dest) {
        const n = this._points.length;
        if (n === 0)
            return;
        if (n === 1) {
            this._points.getPoint3dAt(0, LineString3d._indexPoint);
            dest.push(LineString3d._indexPoint);
            return;
        }
        if (index < 0)
            index = 0;
        if (index >= n) {
            index = n - 1;
            fraction += 1;
        }
        this._points.interpolate(index, fraction, index + 1, LineString3d._indexPoint);
        dest.push(LineString3d._indexPoint);
    }
    /** Return (if possible) a LineString which is a portion of this curve.
     * @param fractionA [in] start fraction
     * @param fractionB [in] end fraction
     */
    clonePartialCurve(fractionA, fractionB) {
        if (fractionB < fractionA) {
            const linestringA = this.clonePartialCurve(fractionB, fractionA);
            if (linestringA)
                linestringA.reverseInPlace();
            return linestringA;
        }
        const n = this._points.length;
        const numEdge = n - 1;
        if (n < 2 || fractionA >= 1.0 || fractionB <= 0.0)
            return undefined;
        if (fractionA < 0)
            fractionA = 0;
        if (fractionB > 1)
            fractionB = 1;
        const gA = fractionA * numEdge;
        const gB = fractionB * numEdge;
        const indexA = Math.floor(gA);
        const indexB = Math.floor(gB);
        const localFractionA = gA - indexA;
        const localFractionB = gB - indexB;
        const result = LineString3d.create();
        this.addResolvedPoint(indexA, localFractionA, result._points);
        for (let index = indexA + 1; index <= indexB; index++) {
            this._points.getPoint3dAt(index, LineString3d._workPointA);
            result._points.push(LineString3d._workPointA);
        }
        if (!Geometry_1.Geometry.isSmallRelative(localFractionB)) {
            this.addResolvedPoint(indexB, localFractionB, result._points);
        }
        return result;
    }
    /** Return (if possible) a specific segment of the linestring */
    getIndexedSegment(index) {
        if (index >= 0 && index + 1 < this._points.length)
            return LineSegment3d_1.LineSegment3d.create(this._points.atPoint3dIndex(index), this._points.atPoint3dIndex(index + 1));
        return undefined;
    }
}
LineString3d._workPointA = Point3dVector3d_1.Point3d.create();
LineString3d._workPointB = Point3dVector3d_1.Point3d.create();
LineString3d._workPointC = Point3dVector3d_1.Point3d.create();
LineString3d._indexPoint = Point3dVector3d_1.Point3d.create(); // private point for indexAndFractionToPoint.
exports.LineString3d = LineString3d;
/** An AnnotatedLineString3d is a linestring with additional data attached to each point
 * * This is useful in facet construction.
 */
class AnnotatedLineString3d {
}
exports.AnnotatedLineString3d = AnnotatedLineString3d;


/***/ }),

/***/ "./lib/curve/Loop.js":
/*!***************************!*\
  !*** ./lib/curve/Loop.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Curve */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const LineString3d_1 = __webpack_require__(/*! ./LineString3d */ "./lib/curve/LineString3d.js");
const CurveCollection_1 = __webpack_require__(/*! ./CurveCollection */ "./lib/curve/CurveCollection.js");
/**
 * A `Loop` is a curve chain that is the boundary of a closed (planar) loop.
 */
class Loop extends CurveCollection_1.CurveChain {
    constructor() {
        super();
        this.isInner = false;
    }
    isSameGeometryClass(other) { return other instanceof Loop; }
    /**
     * Create a loop from variable length list of CurvePrimtives
     * @param curves array of individual curve primitives
     */
    static create(...curves) {
        const result = new Loop();
        for (const curve of curves) {
            result.children.push(curve);
        }
        return result;
    }
    /**
     * Create a loop from an array of curve primtiives
     * @param curves array of individual curve primitives
     */
    static createArray(curves) {
        const result = new Loop();
        for (const curve of curves) {
            result.children.push(curve);
        }
        return result;
    }
    static createPolygon(points) {
        const linestring = LineString3d_1.LineString3d.create(points);
        linestring.addClosurePoint();
        return Loop.create(linestring);
    }
    cloneStroked(options) {
        const strokes = LineString3d_1.LineString3d.create();
        for (const curve of this.children)
            curve.emitStrokes(strokes, options);
        return Loop.create(strokes);
    }
    dgnBoundaryType() { return 2; } // (2) all "Loop" become "outer"
    announceToCurveProcessor(processor, indexInParent = -1) {
        return processor.announceLoop(this, indexInParent);
    }
    cyclicCurvePrimitive(index) {
        const n = this.children.length;
        if (n >= 1) {
            index = Geometry_1.Geometry.modulo(index, this.children.length);
            return this.children[index];
        }
        return undefined;
    }
    cloneEmptyPeer() { return new Loop(); }
    dispatchToGeometryHandler(handler) {
        return handler.handleLoop(this);
    }
}
exports.Loop = Loop;


/***/ }),

/***/ "./lib/curve/ParityRegion.js":
/*!***********************************!*\
  !*** ./lib/curve/ParityRegion.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const CurveCollection_1 = __webpack_require__(/*! ./CurveCollection */ "./lib/curve/CurveCollection.js");
const Loop_1 = __webpack_require__(/*! ./Loop */ "./lib/curve/Loop.js");
/**
 * * A `ParityRegion` is a collection of `Loop` objects.
 * * The loops collectively define a planar region.
 * * A point is "in" the composite region if it is "in" an odd number of the loops.
 */
class ParityRegion extends CurveCollection_1.CurveCollection {
    isSameGeometryClass(other) { return other instanceof ParityRegion; }
    get children() { return this._children; }
    constructor() { super(); this._children = []; }
    static create(...data) {
        const result = new ParityRegion();
        for (const child of data) {
            result.children.push(child);
        }
        return result;
    }
    dgnBoundaryType() { return 4; }
    announceToCurveProcessor(processor, indexInParent = -1) {
        return processor.announceParityRegion(this, indexInParent);
    }
    clone() {
        const clone = new ParityRegion();
        let child;
        for (child of this.children) {
            const childClone = child.clone();
            if (childClone instanceof Loop_1.Loop)
                clone.children.push(childClone);
        }
        return clone;
    }
    cloneStroked(options) {
        const clone = new ParityRegion();
        let child;
        for (child of this.children) {
            const childStrokes = child.cloneStroked(options);
            if (childStrokes)
                clone.children.push(childStrokes);
        }
        return clone;
    }
    cloneEmptyPeer() { return new ParityRegion(); }
    tryAddChild(child) {
        if (child instanceof Loop_1.Loop) {
            this._children.push(child);
            return true;
        }
        return false;
    }
    getChild(i) {
        if (i < this._children.length)
            return this._children[i];
        return undefined;
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleParityRegion(this);
    }
}
exports.ParityRegion = ParityRegion;


/***/ }),

/***/ "./lib/curve/Path.js":
/*!***************************!*\
  !*** ./lib/curve/Path.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const LineString3d_1 = __webpack_require__(/*! ./LineString3d */ "./lib/curve/LineString3d.js");
const CurveCollection_1 = __webpack_require__(/*! ./CurveCollection */ "./lib/curve/CurveCollection.js");
/**
 * * A `Path` object is a collection of curves that join head-to-tail to form a path.
 * * A `Path` object does not bound a planar region.
 */
class Path extends CurveCollection_1.CurveChain {
    isSameGeometryClass(other) { return other instanceof Path; }
    announceToCurveProcessor(processor, indexInParent = -1) {
        return processor.announcePath(this, indexInParent);
    }
    constructor() { super(); }
    /**
     * Create a path from a variable length list of curve primtiives
     * @param curves variable length list of individual curve primitives
     */
    static create(...curves) {
        const result = new Path();
        for (const curve of curves) {
            result.children.push(curve);
        }
        return result;
    }
    /**
     * Create a path from a an array of curve primtiives
     * @param curves array of individual curve primitives
     */
    static createArray(curves) {
        const result = new Path();
        for (const curve of curves) {
            result.children.push(curve);
        }
        return result;
    }
    cloneStroked(options) {
        const strokes = LineString3d_1.LineString3d.create();
        for (const curve of this.children)
            curve.emitStrokes(strokes, options);
        return Path.create(strokes);
    }
    dgnBoundaryType() { return 1; }
    cyclicCurvePrimitive(index) {
        if (index >= 0 && index < this.children.length)
            return this.children[index];
        return undefined;
    }
    cloneEmptyPeer() { return new Path(); }
    dispatchToGeometryHandler(handler) {
        return handler.handlePath(this);
    }
}
exports.Path = Path;


/***/ }),

/***/ "./lib/curve/PointString3d.js":
/*!************************************!*\
  !*** ./lib/curve/PointString3d.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Curve */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const PointHelpers_1 = __webpack_require__(/*! ../geometry3d/PointHelpers */ "./lib/geometry3d/PointHelpers.js");
const GeometryQuery_1 = __webpack_require__(/*! ./GeometryQuery */ "./lib/curve/GeometryQuery.js");
/* tslint:disable:variable-name no-empty*/
/**
 * A PointString3d is an array of points.
 * * PointString3D is first class (displayable) geometry derived from the GeometryQuery base class.
 * * The varous points in the PointString3d are NOT connected by line segments for display or other calculations.
 */
class PointString3d extends GeometryQuery_1.GeometryQuery {
    isSameGeometryClass(other) { return other instanceof PointString3d; }
    /** return the points array (cloned). */
    get points() { return this._points; }
    constructor() {
        super();
        this._points = [];
    }
    cloneTransformed(transform) {
        const c = this.clone();
        c.tryTransformInPlace(transform);
        return c;
    }
    static flattenArray(arr) {
        return arr.reduce((flat, toFlatten) => {
            return flat.concat(Array.isArray(toFlatten) ? PointString3d.flattenArray(toFlatten) : toFlatten);
        }, []);
    }
    /** Create a PointString3d from points. */
    static create(...points) {
        const result = new PointString3d();
        result.addPoints(points);
        return result;
    }
    /** Add multiple points to the PointString3d */
    addPoints(...points) {
        const toAdd = PointString3d.flattenArray(points);
        for (const p of toAdd) {
            if (p instanceof Point3dVector3d_1.Point3d)
                this._points.push(p);
        }
    }
    /** Add a single point to the PoinstString3d */
    addPoint(point) {
        this._points.push(point);
    }
    /** Remove the last point added to the PointString3d */
    popPoint() {
        this._points.pop();
    }
    setFrom(other) {
        this._points = PointHelpers_1.Point3dArray.clonePoint3dArray(other._points);
    }
    /** Create from an array of Point3d */
    static createPoints(points) {
        const ps = new PointString3d();
        ps._points = PointHelpers_1.Point3dArray.clonePoint3dArray(points);
        return ps;
    }
    /** Create a PointString3d from xyz coordinates packed in a Float64Array */
    static createFloat64Array(xyzData) {
        const ps = new PointString3d();
        for (let i = 0; i + 3 <= xyzData.length; i += 3)
            ps._points.push(Point3dVector3d_1.Point3d.create(xyzData[i], xyzData[i + 1], xyzData[i + 2]));
        return ps;
    }
    clone() {
        const retVal = new PointString3d();
        retVal.setFrom(this);
        return retVal;
    }
    setFromJSON(json) {
        this._points.length = 0;
        if (Array.isArray(json)) {
            let xyz;
            for (xyz of json)
                this._points.push(Point3dVector3d_1.Point3d.fromJSON(xyz));
        }
    }
    /**
     * Convert an PointString3d to a JSON object.
     * @return {*} [[x,y,z],...[x,y,z]]
     */
    toJSON() {
        const value = [];
        for (const p of this._points)
            value.push(p.toJSON());
        return value;
    }
    static fromJSON(json) {
        const ps = new PointString3d();
        ps.setFromJSON(json);
        return ps;
    }
    /** Access a single point by index. */
    pointAt(i, result) {
        if (i >= 0 && i < this._points.length) {
            if (result) {
                result.setFrom(this._points[i]);
                return result;
            }
            return this._points[i].clone();
        }
        return undefined;
    }
    /** Return the number of points. */
    numPoints() { return this._points.length; }
    /** Reverse the point order */
    reverseInPlace() {
        if (this._points.length >= 2) {
            let i0 = 0;
            let i1 = this._points.length - 1;
            while (i0 < i1) {
                const a = this._points[i0];
                this._points[i1] = this._points[i0];
                this._points[i0] = a;
                i0++;
                i1--;
            }
        }
    }
    /** Return the number of points. */
    tryTransformInPlace(transform) {
        transform.multiplyPoint3dArrayInPlace(this._points);
        return true;
    }
    /** Return the index and coordinates of the closest point to spacepoint. */
    closestPoint(spacePoint) {
        const result = { index: -1, xyz: Point3dVector3d_1.Point3d.create() };
        const index = PointHelpers_1.Point3dArray.closestPointIndex(this._points, spacePoint);
        if (index >= 0) {
            result.index = index;
            result.xyz.setFrom(this._points[index]);
        }
        return result;
    }
    /** Return true if all points are in the given plane. */
    isInPlane(plane) {
        return PointHelpers_1.Point3dArray.isCloseToPlane(this._points, plane, Geometry_1.Geometry.smallMetricDistance);
    }
    /** Extend a range to include the points in this PointString3d. */
    extendRange(rangeToExtend, transform) {
        rangeToExtend.extendArray(this._points, transform);
    }
    /** Return true if corresponding points are almost equal. */
    isAlmostEqual(other) {
        if (!(other instanceof PointString3d))
            return false;
        return PointHelpers_1.Point3dArray.isAlmostEqual(this._points, other._points);
    }
    /** Reduce to empty set of points. */
    clear() { this._points.length = 0; }
    /** Pass this PointString3d to the handler's `handlePointString` method. */
    dispatchToGeometryHandler(handler) {
        return handler.handlePointString3d(this);
    }
}
exports.PointString3d = PointString3d;


/***/ }),

/***/ "./lib/curve/StrokeOptions.js":
/*!************************************!*\
  !*** ./lib/curve/StrokeOptions.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Curve */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Angle_1 = __webpack_require__(/*! ../geometry3d/Angle */ "./lib/geometry3d/Angle.js");
/* tslint:disable:variable-name no-empty */
/** tolerance blob for various stroking methods.
 *
 * * Across many applications, the critical concepts are:   chordTol, angleTol, maxEdgeLength
 * * Chord error is an distance measured from a curve or facet to its approximating stroke or facet.
 * * angle is the angle between two contiguous strokes or across a facet edge.
 * * maxEdgeLength is the length of a stroke or a edge of a facet.
 *
 * It is rare for all three to be active at once:
 * * Nearly all stroke and facet use cases will apply an angle tolerance.
 * * * For curves, 15 degrees is typical
 * * * For facets, 22.5 degrees is typical.
 * * * Halving the angle tolerance will (roughly) make curves get twice as many strokes, and surfaces get 4 times as many facets.
 * * * The angle tolerance has the useful property that its effect is independent of scale of that data.  If data is suddenly scaled into millimeters rather than meters, the facet counts remain the same.
 * * When creating output for devicies such as 3D printing will want a chord tolerance.
 * * For graphics display, use an angle tolerance of around 15 degrees and an chord tolerance which is the size of several pixels.
 * * Analysis meshes (e.g. Finite Elements) commonly need to apply maxEdgeLength.
 * * * Using maxEdgeLength for graphics probably produces too many facets.   For example, it causes long cylinders to get many nearly-square facets instead of the samll number of long quads usually used for graphics.
 * * Facet tolerances are, as the Pirates' Code, guidelines, not absolute rules.   Facet and stroke code may ignore tolerances in awkward situations.
 * * If multiple tolerances are in effect, the actual count will usually be based on the one that demands the most strokes or facets, unless it is so high that it violates some upper limit on the number of facets on an arc or a section of a curve.
 *
 */
class StrokeOptions {
    constructor() {
        /** whether or not to triangulate each added facet */
        this.shouldTriangulate = false;
        this.defaultCircleStrokes = 16;
    }
    get needParams() { return this._needParams !== undefined ? this._needParams : false; }
    set needParams(value) { this._needParams = value; }
    get needNormals() { return this._needNormals !== undefined ? this._needNormals : false; }
    set needNormals(value) { this._needNormals = value; }
    get hasMaxEdgeLength() { return this.maxEdgeLength !== undefined && this.maxEdgeLength > 0.0; }
    // return stroke count which is the larger of the minCount or count needed for edge length condition.
    applyMaxEdgeLength(minCount, totalLength) {
        if (this.maxEdgeLength && this.maxEdgeLength > 0.0 && minCount * this.maxEdgeLength < totalLength) {
            minCount = Geometry_1.Geometry.stepCount(this.maxEdgeLength, totalLength, minCount);
        }
        return minCount;
    }
    // return stroke count which is the larger of the existing count or count needed for angle condition for given sweepRadians
    // defaultStepRadians is assumed to be larger than zero.
    applyAngleTol(minCount, sweepRadians, defaultStepRadians) {
        return StrokeOptions.applyAngleTol(this, minCount, sweepRadians, defaultStepRadians);
    }
    static applyAngleTol(options, minCount, sweepRadians, defaultStepRadians) {
        sweepRadians = Math.abs(sweepRadians);
        let stepRadians = defaultStepRadians ? defaultStepRadians : Math.PI / 8.0;
        if (options && options.angleTol && options.angleTol.radians > 0.0)
            stepRadians = options.angleTol.radians;
        if (minCount * stepRadians < sweepRadians)
            minCount = Geometry_1.Geometry.stepCount(stepRadians, sweepRadians, minCount);
        return minCount;
    }
    /**
     *
     * @param options
     * @param minCount smallest allowed count
     * @param edgeLength
     */
    static applyMaxEdgeLength(options, minCount, edgeLength) {
        if (edgeLength < 0)
            edgeLength = -edgeLength;
        if (minCount < 1)
            minCount = 1;
        if (options && options.maxEdgeLength && options.maxEdgeLength * minCount < edgeLength) {
            minCount = Math.ceil(edgeLength / options.maxEdgeLength + 0.99999);
        }
        return minCount;
    }
    applyTolerancesToArc(radius, sweepRadians = Math.PI * 2) {
        let numStrokes = 1;
        numStrokes = this.applyAngleTol(numStrokes, sweepRadians, Math.PI * 0.25);
        numStrokes = this.applyMaxEdgeLength(numStrokes, sweepRadians * radius);
        numStrokes = this.applyChordTol(numStrokes, radius, sweepRadians);
        numStrokes = this.applyMinStrokesPerPrimitive(numStrokes);
        return numStrokes;
    }
    // return stroke count which is the larger of existing count or count needed for circular arc chord tolerance condition.
    applyChordTol(minCount, radius, sweepRadians) {
        if (this.chordTol && this.chordTol > 0.0 && this.chordTol < radius) {
            const a = this.chordTol;
            const stepRadians = 2.0 * Math.acos((1.0 - a / radius));
            minCount = Geometry_1.Geometry.stepCount(stepRadians, sweepRadians, minCount);
        }
        return minCount;
    }
    applyMinStrokesPerPrimitive(minCount) {
        if (this.minStrokesPerPrimitive !== undefined && Number.isFinite(this.minStrokesPerPrimitive)
            && this.minStrokesPerPrimitive > minCount)
            minCount = this.minStrokesPerPrimitive;
        return minCount;
    }
    static createForCurves() {
        const options = new StrokeOptions();
        options.angleTol = Angle_1.Angle.createDegrees(15.0);
        return options;
    }
    static createForFacets() {
        const options = new StrokeOptions();
        options.angleTol = Angle_1.Angle.createDegrees(22.5);
        return options;
    }
}
exports.StrokeOptions = StrokeOptions;


/***/ }),

/***/ "./lib/curve/TransitionSpiral.js":
/*!***************************************!*\
  !*** ./lib/curve/TransitionSpiral.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Curve */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const AngleSweep_1 = __webpack_require__(/*! ../geometry3d/AngleSweep */ "./lib/geometry3d/AngleSweep.js");
const Angle_1 = __webpack_require__(/*! ../geometry3d/Angle */ "./lib/geometry3d/Angle.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Segment1d_1 = __webpack_require__(/*! ../geometry3d/Segment1d */ "./lib/geometry3d/Segment1d.js");
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const Matrix3d_1 = __webpack_require__(/*! ../geometry3d/Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const Quadrature_1 = __webpack_require__(/*! ../numerics/Quadrature */ "./lib/numerics/Quadrature.js");
const CurvePrimitive_1 = __webpack_require__(/*! ./CurvePrimitive */ "./lib/curve/CurvePrimitive.js");
const Ray3d_1 = __webpack_require__(/*! ../geometry3d/Ray3d */ "./lib/geometry3d/Ray3d.js");
const Plane3dByOriginAndVectors_1 = __webpack_require__(/*! ../geometry3d/Plane3dByOriginAndVectors */ "./lib/geometry3d/Plane3dByOriginAndVectors.js");
const LineString3d_1 = __webpack_require__(/*! ./LineString3d */ "./lib/curve/LineString3d.js");
// import {} from "./";
/** A transition spiral is a curve defined by its curvature, with the curvature function symmetric about midpoint.
 * * The symmetry condition creates a relationship among the following 4 quantities:
 * ** curvature0 = curvature (i.e. 1/radius) at start
 * ** curvature1 = curvature (i.e. 1/radius) at end
 * ** sweepRadians = signed turning angle from start to end
 * ** arcLength = length of curve
 * * The relationship is the equation
 * ** `sweepRadians = arcLength * average Curvature = arcLength * 0.5 * (curvature0 + curvature1)`
 * * That is, regardless of any curvature properties other than symmetry, specifying any 3 of the quantities fully determines the remaining one.
 */
class TransitionConditionalProperties {
    /**
     * capture numeric or undefined values
     * @param radius0 start radius or undefined
     * @param radius1 end radius or undefined
     * @param bearing0 start bearing or undefined
     * @param bearing1 end bearing or undefined
     * @param arcLength arc length or undefined
     */
    constructor(radius0, radius1, bearing0, bearing1, arcLength) {
        this.radius0 = radius0;
        this.radius1 = radius1;
        this.bearing0 = bearing0;
        this.bearing1 = bearing1;
        this.curveLength = arcLength;
    }
    /** return the number of defined values among the 5 properties. */
    numDefinedProperties() {
        return Geometry_1.Geometry.defined01(this.radius0)
            + Geometry_1.Geometry.defined01(this.radius1)
            + Geometry_1.Geometry.defined01(this.bearing0)
            + Geometry_1.Geometry.defined01(this.bearing1)
            + Geometry_1.Geometry.defined01(this.curveLength);
    }
    /** clone with all properties (i.e. preserve undefined states) */
    clone() {
        return new TransitionConditionalProperties(this.radius0, this.radius1, this.bearing0 === undefined ? undefined : this.bearing0.clone(), this.bearing1 === undefined ? undefined : this.bearing1.clone(), this.curveLength);
    }
    /** Examine which properties are defined and compute the (single) undefined.
     * @returns Return true if the input state had precisely one undefined member.
     */
    tryResolveAnySingleUnknown() {
        if (this.bearing0 && this.bearing1) {
            const sweepRadians = this.bearing1.radians - this.bearing0.radians;
            if (this.curveLength === undefined && this.radius0 !== undefined && this.radius1 !== undefined) {
                this.curveLength = TransitionSpiral3d.radiusRadiusSweepRadiansToArcLength(this.radius0, this.radius1, sweepRadians);
                return true;
            }
            if (this.curveLength !== undefined && this.radius0 === undefined && this.radius1 !== undefined) {
                this.radius0 = TransitionSpiral3d.radius1LengthSweepRadiansToRadius0(this.radius1, this.curveLength, sweepRadians);
                return true;
            }
            if (this.curveLength !== undefined && this.radius0 !== undefined && this.radius1 === undefined) {
                this.radius1 = TransitionSpiral3d.radius0LengthSweepRadiansToRadius1(this.radius0, this.curveLength, sweepRadians);
                return true;
            }
            return false;
        }
        // at least one bearing is undefined ...
        if (this.curveLength === undefined || this.radius0 === undefined || this.radius1 === undefined)
            return false;
        if (this.bearing0) { // bearing 1 is undefined
            this.bearing1 = Angle_1.Angle.createRadians(this.bearing0.radians + TransitionSpiral3d.radiusRadiusLengthToSweepRadians(this.radius0, this.radius1, this.curveLength));
            return true;
        }
        if (this.bearing1) { // bearing 0 is undefined
            this.bearing0 = Angle_1.Angle.createRadians(this.bearing1.radians - TransitionSpiral3d.radiusRadiusLengthToSweepRadians(this.radius0, this.radius1, this.curveLength));
            return true;
        }
        return false;
    }
    almostEqualCoordinate(a, b) {
        if (a === undefined && b === undefined)
            return true;
        if (a !== undefined && b !== undefined)
            return Geometry_1.Geometry.isSameCoordinate(a, b);
        return false;
    }
    almostEqualBearing(a, b) {
        if (a === undefined && b === undefined)
            return true;
        if (a !== undefined && b !== undefined)
            return a.isAlmostEqualNoPeriodShift(b);
        return false;
    }
    /**
     * Test if this and other have matching numeric and undefined members.
     */
    isAlmostEqual(other) {
        if (!this.almostEqualCoordinate(this.radius0, other.radius0))
            return false;
        if (!this.almostEqualCoordinate(this.radius1, other.radius1))
            return false;
        if (!this.almostEqualBearing(this.bearing0, other.bearing0))
            return false;
        if (!this.almostEqualBearing(this.bearing1, other.bearing1))
            return false;
        if (!this.almostEqualCoordinate(this.curveLength, other.curveLength))
            return false;
        return true;
    }
}
exports.TransitionConditionalProperties = TransitionConditionalProperties;
class TransitionSpiral3d extends CurvePrimitive_1.CurvePrimitive {
    // constructor demands all bearing, radius, and length data -- caller determines usual dependency of "any 4 determine the 5th"
    constructor(spiralType, radius01, bearing01, activeFractionInterval, localToWorld, arcLength, properties) {
        super();
        this._spiralType = spiralType;
        this.localToWorld = localToWorld;
        this.radius01 = radius01;
        this.bearing01 = bearing01;
        this.localToWorld = localToWorld;
        this.activeFractionInterval = activeFractionInterval;
        this._arcLength01 = arcLength;
        this._strokes = LineString3d_1.LineString3d.create();
        // initialize for compiler -- but this will be recomputed in refreshComputeProperties ...
        this._curvature01 = Segment1d_1.Segment1d.create(0, 1);
        this.refreshComputedProperties();
        this._properties = properties;
    }
    // return 1/r with convention that if true zero is given as radius it represents infinite radius (0 curvature, straight line)
    static radiusToCurvature(radius) { return (radius === 0.0) ? 0.0 : 1.0 / radius; }
    // return 1/k with convention that if near-zero is given as curvature, its infinite radius is returned as 0
    static curvatureToRadius(curvature) {
        if (Math.abs(curvature) < Geometry_1.Geometry.smallAngleRadians)
            return 0.0;
        return 1.0 / curvature;
    }
    // return the average curvature for two limit values.
    static averageCurvature(radiusLimits) {
        return 0.5 * (TransitionSpiral3d.radiusToCurvature(radiusLimits.x0) + TransitionSpiral3d.radiusToCurvature(radiusLimits.x1));
    }
    /**
     * Given two radii (or zeros for 0 curvature) return the average curvature
     * @param r0 start radius, or 0 for line
     * @param r1 end radius, or 0 for line
     */
    static averageCurvatureR0R1(r0, r1) {
        return 0.5 * (TransitionSpiral3d.radiusToCurvature(r0) + TransitionSpiral3d.radiusToCurvature(r1));
    }
    static radiusRadiusSweepRadiansToArcLength(radius0, radius1, sweepRadians) {
        return Math.abs(sweepRadians / TransitionSpiral3d.averageCurvatureR0R1(radius0, radius1));
    }
    static radiusRadiusLengthToSweepRadians(radius0, radius1, arcLength) {
        return TransitionSpiral3d.averageCurvatureR0R1(radius0, radius1) * arcLength;
    }
    static radius0LengthSweepRadiansToRadius1(radius0, arcLength, sweepRadians) {
        return TransitionSpiral3d.curvatureToRadius((2.0 * sweepRadians / arcLength) - TransitionSpiral3d.radiusToCurvature(radius0));
    }
    static radius1LengthSweepRadiansToRadius0(radius1, arcLength, sweepRadians) {
        return TransitionSpiral3d.curvatureToRadius((2.0 * sweepRadians / arcLength) - TransitionSpiral3d.radiusToCurvature(radius1));
    }
    /** Return the origial defining properties (if any) saved by the constructor. */
    get originalProperties() { return this._properties; }
    /** return the spiral type as a string (undefined resolves to default type "clothoid") */
    getSpiralType() { if (this._spiralType === undefined)
        return TransitionSpiral3d.defaultSpiralType; return this._spiralType; }
    /** Return the bearing at given fraction .... */
    fractionToBearingRadians(fraction) {
        // BUG? active interval?
        return this.bearing01.startRadians + fraction * (this._curvature01.x0 + 0.5 * fraction * (this._curvature01.x1 - this._curvature01.x0));
    }
    /** Return the curvature at given fraction ... */
    fractionToCurvature(fraction) {
        // BUG? active interval
        return this._curvature01.fractionToPoint(fraction);
    }
    static initWorkSpace() {
        TransitionSpiral3d._gaussFraction = new Float64Array(5);
        TransitionSpiral3d._gaussWeight = new Float64Array(5);
        TransitionSpiral3d._gaussMapper = Quadrature_1.Quadrature.setupGauss5;
    }
    /** Evaluate and sum the gauss quadrature formulas to integrate cos(theta), sin(theta) fractional subset of a reference length.
     * (recall that theta is a nonlinear function of the fraction.)
     * * This is a single interval of gaussian integration.
     * * The fraction is on the full spiral (not in the mapped active interval)
     * @param xyz advancing integrated point.
     * @param fractionA fraction at start of interval
     * @param fractionB fraction at end of interval.
     * @param unitArcLength length of curve for 0 to 1 fractional
     */
    fullSpiralIncrementalIntegral(xyz, fractionA, fractionB) {
        const gaussFraction = TransitionSpiral3d._gaussFraction;
        const gaussWeight = TransitionSpiral3d._gaussWeight;
        const numEval = TransitionSpiral3d._gaussMapper(fractionA, fractionB, gaussFraction, gaussWeight);
        const deltaL = this._arcLength01;
        let w = 0;
        for (let k = 0; k < numEval; k++) {
            const radians = this.fractionToBearingRadians(gaussFraction[k]);
            w = gaussWeight[k] * deltaL;
            xyz.x += w * Math.cos(radians);
            xyz.y += w * Math.sin(radians);
        }
    }
    refreshComputedProperties() {
        this._curvature01 = Segment1d_1.Segment1d.create(TransitionSpiral3d.radiusToCurvature(this.radius01.x0), TransitionSpiral3d.radiusToCurvature(this.radius01.x1));
        this._strokes.clear();
        const currentPoint = Point3dVector3d_1.Point3d.create();
        this._strokes.appendStrokePoint(currentPoint);
        const numInterval = 8;
        const fractionStep = 1.0 / numInterval;
        for (let i = 1; i <= numInterval; i++) {
            const fraction0 = (i - 1) * fractionStep;
            const fraction1 = i * fractionStep;
            this.fullSpiralIncrementalIntegral(currentPoint, fraction0, fraction1);
            this._strokes.appendStrokePoint(currentPoint);
        }
        this._strokes.tryTransformInPlace(this.localToWorld);
    }
    /**
     * Create a transition spiral with radius and bearing conditions.
     * @param radius01 radius (inverse curvature) at start and end. (radius of zero means straight line)
     * @param bearing01 bearing angles at start and end.  bearings are measured from the x axis, positive clockwise towards y axis
     * @param activeFractionInterval fractional limits of the active portion of the spiral.
     * @param localToWorld placement frame.  Fractional coordinate 0 is at the origin.
     */
    static createRadiusRadiusBearingBearing(radius01, bearing01, activeFractionInterval, localToWorld) {
        const arcLength = TransitionSpiral3d.radiusRadiusSweepRadiansToArcLength(radius01.x0, radius01.x1, bearing01.sweepRadians);
        return new TransitionSpiral3d("clothoid", radius01.clone(), bearing01.clone(), activeFractionInterval.clone(), localToWorld.clone(), arcLength, new TransitionConditionalProperties(radius01.x0, radius01.x1, bearing01.startAngle.clone(), bearing01.endAngle.clone(), undefined));
    }
    /**
     * Create a transition spiral.
     * * Inputs must provide exactly 4 of the 5 values `[radius0,radius1,bearing0,bearing1,length`.
     * @param spiralType one of "clothoid", "bloss", "biquadratic", "cosine", "sine".  If undefined, "clothoid" is used.
     * @param radius0 radius (or 0 for tangent to line) at start
     * @param radius1 radius (or 0 for tangent to line) at end
     * @param bearing0 bearing, measured CCW from x axis at start.
     * @param bearing1 bearing, measured CCW from x axis at end.
     * @param fractionInterval optional fractional interval for an "active" portion of the curve.   if omitted, the full [0,1] is used.
     * @param localToWorld placement transform
     */
    static create(spiralType, radius0, radius1, bearing0, bearing1, arcLength, fractionInterval, localToWorld) {
        const data = new TransitionConditionalProperties(radius0, radius1, bearing0, bearing1, arcLength);
        const data1 = data.clone();
        if (!data.tryResolveAnySingleUnknown())
            return undefined;
        if (fractionInterval === undefined)
            fractionInterval = Segment1d_1.Segment1d.create(0, 1);
        return new TransitionSpiral3d(spiralType, Segment1d_1.Segment1d.create(data.radius0, data.radius1), AngleSweep_1.AngleSweep.createStartEnd(data.bearing0, data.bearing1), fractionInterval ? fractionInterval.clone() : Segment1d_1.Segment1d.create(0, 1), localToWorld, data.curveLength, data1);
    }
    setFrom(other) {
        this.localToWorld.setFrom(other.localToWorld);
        this.radius01.setFrom(other.radius01);
        this._curvature01.setFrom(other._curvature01);
        this.bearing01.setFrom(other.bearing01);
        this.localToWorld.setFrom(other.localToWorld);
        this.activeFractionInterval.setFrom(other.activeFractionInterval);
        this._arcLength01 = other._arcLength01;
        return this;
    }
    clone() {
        return TransitionSpiral3d.createRadiusRadiusBearingBearing(this.radius01, this.bearing01, this.activeFractionInterval, this.localToWorld);
    }
    tryTransformInPlace(transform) {
        transform.multiplyTransformTransform(this.localToWorld, this.localToWorld);
        return true;
    }
    cloneTransformed(transform) {
        const result = this.clone();
        result.tryTransformInPlace(transform); // ok, we're confident it will always work.
        return result;
    }
    startPoint() { return this._strokes.startPoint(); }
    endPoint() { return this._strokes.endPoint(); }
    isInPlane(plane) {
        return plane.isPointInPlane(this.localToWorld.origin)
            && Geometry_1.Geometry.isSameCoordinate(0.0, this.localToWorld.matrix.dotColumnX(plane.getNormalRef()))
            && Geometry_1.Geometry.isSameCoordinate(0.0, this.localToWorld.matrix.dotColumnY(plane.getNormalRef()));
    }
    /** Return length of the spiral.  Because TransitionSpiral is parameterized directly in terms of distance along, this is a simple return value. */
    quickLength() { return this._arcLength01; }
    /** Return length of the spiral.  Because TransitionSpiral is parameterized directly in terms of distance along, this is a simple return value. */
    curveLength() { return this._arcLength01; }
    isSameGeometryClass(other) { return other instanceof TransitionSpiral3d; }
    emitStrokes(dest, options) { this._strokes.emitStrokes(dest, options); }
    emitStrokableParts(dest, options) {
        dest.startParentCurvePrimitive(this);
        this._strokes.emitStrokableParts(dest, options);
        dest.endParentCurvePrimitive(this);
    }
    // hm.. nothing to do but reverse the interval . . . maybe that's cheesy . . .
    reverseInPlace() {
        this.activeFractionInterval.reverseInPlace();
        this._strokes.reverseInPlace();
    }
    fractionToPoint(fraction, result) {
        fraction = Geometry_1.Geometry.clampToStartEnd(fraction, 0, 1);
        const numStrokes = this._strokes.points.length - 1;
        const index0 = Math.trunc(fraction * numStrokes); // This indexes the point to the left of the query
        const fraction0 = index0 / numStrokes;
        result = result ? result : new Point3dVector3d_1.Point3d();
        result.setFrom(this._strokes.points[index0]);
        const globalFraction0 = this.activeFractionInterval.fractionToPoint(fraction0);
        const globalFraction1 = this.activeFractionInterval.fractionToPoint(fraction);
        this.fullSpiralIncrementalIntegral(result, globalFraction0, globalFraction1);
        this.localToWorld.multiplyPoint3d(result, result);
        return result;
    }
    fractionToPointAndDerivative(fraction, result) {
        result = result ? result : Ray3d_1.Ray3d.createZero();
        this.fractionToPoint(fraction, result.origin);
        const radians = this.fractionToBearingRadians(fraction);
        const a = this._arcLength01;
        this.localToWorld.matrix.multiplyXY(a * Math.cos(radians), a * Math.sin(radians), result.direction);
        return result;
    }
    /** Return the frenet frame at fractional position. */
    fractionToFrenetFrame(fraction, result) {
        result = result ? result : Transform_1.Transform.createIdentity();
        result.origin.setFrom(this.fractionToPoint(fraction));
        Matrix3d_1.Matrix3d.createRigidFromMatrix3d(this.localToWorld.matrix, 0 /* XYZ */, result.matrix);
        const radians = this.fractionToBearingRadians(fraction);
        const c = Math.cos(radians);
        const s = Math.sin(radians);
        result.matrix.applyGivensColumnOp(0, 1, c, -s);
        return result;
    }
    /** Return a plane with
     *
     * * origin at fractional position along the curve
     * * vectorU is the first derivative, i.e. tangent vector with length equal to the rate of change with respect to the fraction.
     * * vectorV is the second derivative, i.e.derivative of vectorU.
     */
    fractionToPointAnd2Derivatives(fraction, result) {
        const origin = this.fractionToPoint(fraction);
        const radians = this.fractionToBearingRadians(fraction);
        const c = Math.cos(radians);
        const s = Math.sin(radians);
        const vectorX = this.localToWorld.matrix.multiplyXY(c, s);
        const vectorY = this.localToWorld.matrix.multiplyXY(-s, c);
        vectorY.scaleInPlace(this.fractionToCurvature(fraction));
        return Plane3dByOriginAndVectors_1.Plane3dByOriginAndVectors.createCapture(origin, vectorX, vectorY, result);
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleTransitionSpiral(this);
    }
    extendRange(rangeToExtend, transform) {
        this._strokes.extendRange(rangeToExtend, transform);
    }
    isAlmostEqual(other) {
        if (other instanceof TransitionSpiral3d) {
            return this.radius01.isAlmostEqual(other.radius01)
                && this.bearing01.isAlmostEqualAllowPeriodShift(other.bearing01)
                && this.localToWorld.isAlmostEqual(other.localToWorld)
                && Geometry_1.Geometry.isSameCoordinate(this._arcLength01, other._arcLength01)
                && this.activeFractionInterval.isAlmostEqual(other.activeFractionInterval)
                && this._curvature01.isAlmostEqual(other._curvature01);
        }
        return false;
    }
}
TransitionSpiral3d.defaultSpiralType = "clothoid";
exports.TransitionSpiral3d = TransitionSpiral3d;
// at load time, initialize gauss quadrature workspace
TransitionSpiral3d.initWorkSpace();


/***/ }),

/***/ "./lib/curve/UnionRegion.js":
/*!**********************************!*\
  !*** ./lib/curve/UnionRegion.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const CurveCollection_1 = __webpack_require__(/*! ./CurveCollection */ "./lib/curve/CurveCollection.js");
const Loop_1 = __webpack_require__(/*! ./Loop */ "./lib/curve/Loop.js");
const ParityRegion_1 = __webpack_require__(/*! ./ParityRegion */ "./lib/curve/ParityRegion.js");
/**
 * * A `UnionRegion` is a collection of other planar region types -- `Loop` and `ParityRegion`.
 * * The composite is the union of the contained regions.
 * * A point is "in" the composite if it is "in" one or more of the contained regions.
 */
class UnionRegion extends CurveCollection_1.CurveCollection {
    isSameGeometryClass(other) { return other instanceof UnionRegion; }
    get children() { return this._children; }
    constructor() { super(); this._children = []; }
    static create(...data) {
        const result = new UnionRegion();
        for (const child of data) {
            result.tryAddChild(child);
        }
        return result;
    }
    dgnBoundaryType() { return 5; }
    announceToCurveProcessor(processor, indexInParent = -1) {
        return processor.announceUnionRegion(this, indexInParent);
    }
    cloneStroked(options) {
        const clone = new UnionRegion();
        let child;
        for (child of this._children) {
            const childStrokes = child.cloneStroked(options);
            if (childStrokes)
                clone.children.push(childStrokes);
        }
        return clone;
    }
    cloneEmptyPeer() { return new UnionRegion(); }
    tryAddChild(child) {
        if (child instanceof ParityRegion_1.ParityRegion || child instanceof Loop_1.Loop) {
            this._children.push(child);
            return true;
        }
        return false;
    }
    getChild(i) {
        if (i < this._children.length)
            return this._children[i];
        return undefined;
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleUnionRegion(this);
    }
}
exports.UnionRegion = UnionRegion;


/***/ }),

/***/ "./lib/geometry-core.js":
/*!******************************!*\
  !*** ./lib/geometry-core.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Utility */
// REMARK:
// The docs-group-description comments are followed by empty classes with names corresponding to the doc-group.
// Normally (in committed code) these are commented out.
// The comments have distinctive strings so that simple search and replace can make the "real".
// This is useful when working on the documentation:  When the empty classes are present, VSCode will format the doc comments
// for and display them when the mouse hovers over the class name.
/**
 * @docs-package-description
 * The geometry-core package contains classes for working with CAD geometry:  points, vectors, curves, surfaces, and analytic solids
 */
/**
 * @docs-group-description CartesianGeometry
 * Points, Vectors, Planes, and Transformations for x,y,z geometry.
 * * Fundamental cartesian geometry objects:
 * * * Point2d, Point3d -- points with x,y,z coordinates
 * * * Vector2d, Vector3d -- vectors with x,y,z coordinates
 * * * Matrix3d -- 3x3 matrix
 * * * * commonly used for pure rotations
 * * * * scale and skew entries are also allowed.
 * * * Transform -- an origin and axes.
 * * * Range1d, Range2d, Range3d -- subsets of 1d, 2d, and 3d space bounded by low and high values.
 * * * Ray3d -- a ray defined by origin and direction vector
 * * * Plane3dByOriginAndUnitNormal -- a plane defined by an origin and a single vector which is perpendicular to the plane
 * * * plane3dByOriginAndVectors -- a plane defined by an origin and two vectors in the plane.
 * * Angles
 * * * Angle -- a strongly typed angle object whose method names make it clear whether input and outputs are degrees or radians.
 * * * AngleSweep -- an angular interval
 * * * YawPitchAndRollAngles -- 3 angles that define a rotated coordinate system.
 * * Utility classes
 * * * FrameBuilder -- construction of coordinate frames from mixed data sources.
 * * * ClipPlane -- a single plane
 * * * ConvexClipPlaneSet -- an array of planes bounding a convex volume
 * * * ClipPlaneSet -- an array of ConvexClipPlaneSet, defining the union of their volumes
 * * * Constant -- various numeric values exported as readonly constants
 */
// doc:export class CartesianGeometryDoc { }
/**
 * @docs-group-description ArraysAndInterfaces
 * These classes support array operations and inheritance-based algorithms.
 * * Arrays
 * * * GrowableArray -- A carrier for a Float64Array, with methods that hide reallocation of the underlying array as contents are added.
 * * * Point2dArray, Point3dArray, Point4dArray, Vector3dArray -- miscellaneous operations on arrays of 2d and 3d points.
 * * Interfaces
 * * * GeometryHandler -- a double-dispatch protocol used for efficient implementation of algorithms that work on many geometry types.
 *
 */
// doc:export class ArraysAndInterfacesDoc { }
/**
 * @docs-group-description Bspline
 * A bspline curve or surface is used for curved freeform geometry defined by controls points (sometimes called poles).
 * * BSplineCurve --  a curve in XYZ coordinates
 * * BSplineSurfaceXYZ -- a surface with XYZ
 * * BsplineSurfaceXYZW -- a surface with weighted (rational) XYZ coordinates
 * * KnotVector -- vector of breakpoints in bspline definitions.
 */
// doc:export class BsplineDoc { }
/**
 * @docs-group-description Curve
 * Curves in the GeometryQuery hierarchy: LineSegment3d, LineString3d, Arc3d, TransitionSpiral3d
 * * CurvePrimitive -- base class for parametric curves
 * * * LineSegment3d -- a (bounded) portion of an unbounded line
 * * * Arc3d -- a circular or elliptic arc
 * * * LineString3d -- a sequence of points joined by line segments
 * * * TransitionSpiral -- controlled transition between curvatures
 * * Support classes
 * * PointString3d -- a sequence of isolated points
 * * StrokeOptions -- tolerances to describe stroking accuracy
 * * RecursiveCurveProcessor, RecursiveCurveProcessorWithStack -- algorithmic support for trees with CurvePrimitives at the leaf level.
 */
// doc:export class CurveDoc { }
/**
 * @docs-group-description Numerics
 * The Numerics classes have geometric and numeric methods used during large algorithms in other classes.
 */
// doc:export class NumericsDoc { }
/**
 * @docs-group-description Polyface
 * A Polyface is a mesh structure with arrays of points that are shared among multiple incident facets.
 */
// doc:export class PolyfaceDoc { }
/**
 * @docs-group-description Serialization
 * These classes are related to serialization of geometry classes.
 * * IModelJson.Reader, IModelJson.Writer -- Conversion of in-memory geometry objects to json objects for persistence and transmission.
 */
// doc:export class SerializationDoc { }
/**
 * @docs-group-description Solid
 * Analytic Solids in the GeometryQuery hierarchy: Box, Sphere, Cone, TorusPipe, LinearSweep, RotationalSweep, RuledSweep
 * * Box -- a box solid.  This is usually rectangular on all faces, but can in one directly like a view frustum
 * * Sphere -- a sphere
 * * Cone -- a cone or cylinder
 * * TorusPipe -- a pipe elbow
 * * LinearSweep -- a linear sweep of a base contour
 * * RotationalSweep -- a rotational sweep of a base contour
 * * RuledSweep -- two or more similarly structured contours joined by linear rule lines.
 */
// doc:export class SolidDOc { }
/**
 * @docs-group-description Utility
 * These modules and classes are outside the geometric structure
 * * geometry-core.ts -- gathers and exports class, so callers can import from geometry-core without knowning which classes
 *        are in which files.
 */
// doc:export class Utility { }
/**
 * @docs-group-description Topology
 * The Topology classes provide adjacency structures used in triangulations.
 */
// doc:export class TopologyDoc { }
__export(__webpack_require__(/*! ./geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js"));
__export(__webpack_require__(/*! ./geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js"));
__export(__webpack_require__(/*! ./geometry3d/PointHelpers */ "./lib/geometry3d/PointHelpers.js"));
__export(__webpack_require__(/*! ./geometry3d/Transform */ "./lib/geometry3d/Transform.js"));
__export(__webpack_require__(/*! ./geometry3d/Matrix3d */ "./lib/geometry3d/Matrix3d.js"));
__export(__webpack_require__(/*! ./geometry3d/Range */ "./lib/geometry3d/Range.js"));
__export(__webpack_require__(/*! ./geometry3d/GrowableFloat64Array */ "./lib/geometry3d/GrowableFloat64Array.js"));
__export(__webpack_require__(/*! ./geometry3d/GrowableXYZArray */ "./lib/geometry3d/GrowableXYZArray.js"));
__export(__webpack_require__(/*! ./geometry3d/GrowableBlockedArray */ "./lib/geometry3d/GrowableBlockedArray.js"));
__export(__webpack_require__(/*! ./geometry3d/FrameBuilder */ "./lib/geometry3d/FrameBuilder.js"));
__export(__webpack_require__(/*! ./geometry3d/GeometryHandler */ "./lib/geometry3d/GeometryHandler.js"));
__export(__webpack_require__(/*! ./geometry3d/IndexedXYZCollection */ "./lib/geometry3d/IndexedXYZCollection.js"));
__export(__webpack_require__(/*! ./geometry3d/OrderedRotationAngles */ "./lib/geometry3d/OrderedRotationAngles.js"));
__export(__webpack_require__(/*! ./geometry3d/Ray3d */ "./lib/geometry3d/Ray3d.js"));
__export(__webpack_require__(/*! ./geometry3d/Plane3dByOriginAndUnitNormal */ "./lib/geometry3d/Plane3dByOriginAndUnitNormal.js"));
__export(__webpack_require__(/*! ./geometry3d/Plane3dByOriginAndVectors */ "./lib/geometry3d/Plane3dByOriginAndVectors.js"));
__export(__webpack_require__(/*! ./Geometry */ "./lib/Geometry.js"));
__export(__webpack_require__(/*! ./geometry3d/Angle */ "./lib/geometry3d/Angle.js"));
__export(__webpack_require__(/*! ./geometry3d/YawPitchRollAngles */ "./lib/geometry3d/YawPitchRollAngles.js"));
__export(__webpack_require__(/*! ./geometry3d/AngleSweep */ "./lib/geometry3d/AngleSweep.js"));
__export(__webpack_require__(/*! ./Constant */ "./lib/Constant.js"));
__export(__webpack_require__(/*! ./clipping/ClipPlane */ "./lib/clipping/ClipPlane.js"));
__export(__webpack_require__(/*! ./clipping/ConvexClipPlaneSet */ "./lib/clipping/ConvexClipPlaneSet.js"));
__export(__webpack_require__(/*! ./clipping/UnionOfConvexClipPlaneSets */ "./lib/clipping/UnionOfConvexClipPlaneSets.js"));
__export(__webpack_require__(/*! ./clipping/ClipPrimitive */ "./lib/clipping/ClipPrimitive.js"));
__export(__webpack_require__(/*! ./clipping/ClipVector */ "./lib/clipping/ClipVector.js"));
__export(__webpack_require__(/*! ./clipping/ClipUtils */ "./lib/clipping/ClipUtils.js"));
__export(__webpack_require__(/*! ./numerics/ConvexPolygon2d */ "./lib/numerics/ConvexPolygon2d.js"));
__export(__webpack_require__(/*! ./geometry4d/PlaneByOriginAndVectors4d */ "./lib/geometry4d/PlaneByOriginAndVectors4d.js"));
__export(__webpack_require__(/*! ./geometry4d/Point4d */ "./lib/geometry4d/Point4d.js"));
__export(__webpack_require__(/*! ./geometry4d/Matrix4d */ "./lib/geometry4d/Matrix4d.js"));
__export(__webpack_require__(/*! ./geometry4d/Map4d */ "./lib/geometry4d/Map4d.js"));
__export(__webpack_require__(/*! ./geometry4d/MomentData */ "./lib/geometry4d/MomentData.js"));
__export(__webpack_require__(/*! ./numerics/BezierPolynomials */ "./lib/numerics/BezierPolynomials.js"));
__export(__webpack_require__(/*! ./numerics/Newton */ "./lib/numerics/Newton.js"));
__export(__webpack_require__(/*! ./numerics/Complex */ "./lib/numerics/Complex.js"));
__export(__webpack_require__(/*! ./numerics/Polynomials */ "./lib/numerics/Polynomials.js"));
__export(__webpack_require__(/*! ./numerics/Quadrature */ "./lib/numerics/Quadrature.js"));
__export(__webpack_require__(/*! ./numerics/Range1dArray */ "./lib/numerics/Range1dArray.js"));
__export(__webpack_require__(/*! ./numerics/TriDiagonalSystem */ "./lib/numerics/TriDiagonalSystem.js"));
__export(__webpack_require__(/*! ./curve/Arc3d */ "./lib/curve/Arc3d.js"));
__export(__webpack_require__(/*! ./curve/ConstructCurveBetweenCurves */ "./lib/curve/ConstructCurveBetweenCurves.js"));
__export(__webpack_require__(/*! ./curve/CurveCollection */ "./lib/curve/CurveCollection.js"));
__export(__webpack_require__(/*! ./curve/Loop */ "./lib/curve/Loop.js"));
__export(__webpack_require__(/*! ./curve/ParityRegion */ "./lib/curve/ParityRegion.js"));
__export(__webpack_require__(/*! ./curve/Path */ "./lib/curve/Path.js"));
__export(__webpack_require__(/*! ./curve/UnionRegion */ "./lib/curve/UnionRegion.js"));
__export(__webpack_require__(/*! ./curve/CurveCurveIntersectXY */ "./lib/curve/CurveCurveIntersectXY.js"));
__export(__webpack_require__(/*! ./curve/CurvePrimitive */ "./lib/curve/CurvePrimitive.js"));
__export(__webpack_require__(/*! ./curve/CurveLocationDetail */ "./lib/curve/CurveLocationDetail.js"));
__export(__webpack_require__(/*! ./curve/CoordinateXYZ */ "./lib/curve/CoordinateXYZ.js"));
__export(__webpack_require__(/*! ./curve/GeometryQuery */ "./lib/curve/GeometryQuery.js"));
__export(__webpack_require__(/*! ./curve/CurveProcessor */ "./lib/curve/CurveProcessor.js"));
__export(__webpack_require__(/*! ./curve/LineSegment3d */ "./lib/curve/LineSegment3d.js"));
__export(__webpack_require__(/*! ./curve/LineString3d */ "./lib/curve/LineString3d.js"));
__export(__webpack_require__(/*! ./curve/PointString3d */ "./lib/curve/PointString3d.js"));
__export(__webpack_require__(/*! ./curve/StrokeOptions */ "./lib/curve/StrokeOptions.js"));
__export(__webpack_require__(/*! ./curve/TransitionSpiral */ "./lib/curve/TransitionSpiral.js"));
__export(__webpack_require__(/*! ./solid/Box */ "./lib/solid/Box.js"));
__export(__webpack_require__(/*! ./solid/Cone */ "./lib/solid/Cone.js"));
__export(__webpack_require__(/*! ./solid/LinearSweep */ "./lib/solid/LinearSweep.js"));
__export(__webpack_require__(/*! ./solid/RotationalSweep */ "./lib/solid/RotationalSweep.js"));
__export(__webpack_require__(/*! ./solid/RuledSweep */ "./lib/solid/RuledSweep.js"));
__export(__webpack_require__(/*! ./solid/SolidPrimitive */ "./lib/solid/SolidPrimitive.js"));
__export(__webpack_require__(/*! ./solid/Sphere */ "./lib/solid/Sphere.js"));
__export(__webpack_require__(/*! ./solid/SweepContour */ "./lib/solid/SweepContour.js"));
__export(__webpack_require__(/*! ./solid/TorusPipe */ "./lib/solid/TorusPipe.js"));
__export(__webpack_require__(/*! ./bspline/Bezier1dNd */ "./lib/bspline/Bezier1dNd.js"));
__export(__webpack_require__(/*! ./bspline/BezierCurveBase */ "./lib/bspline/BezierCurveBase.js"));
__export(__webpack_require__(/*! ./bspline/BezierCurve3d */ "./lib/bspline/BezierCurve3d.js"));
__export(__webpack_require__(/*! ./bspline/BezierCurve3dH */ "./lib/bspline/BezierCurve3dH.js"));
__export(__webpack_require__(/*! ./bspline/BSplineCurve */ "./lib/bspline/BSplineCurve.js"));
__export(__webpack_require__(/*! ./bspline/BSpline1dNd */ "./lib/bspline/BSpline1dNd.js"));
__export(__webpack_require__(/*! ./bspline/BSplineCurve3dH */ "./lib/bspline/BSplineCurve3dH.js"));
__export(__webpack_require__(/*! ./bspline/BSplineSurface */ "./lib/bspline/BSplineSurface.js"));
__export(__webpack_require__(/*! ./bspline/KnotVector */ "./lib/bspline/KnotVector.js"));
__export(__webpack_require__(/*! ./polyface/BoxTopology */ "./lib/polyface/BoxTopology.js"));
__export(__webpack_require__(/*! ./polyface/PolyfaceData */ "./lib/polyface/PolyfaceData.js"));
__export(__webpack_require__(/*! ./polyface/Polyface */ "./lib/polyface/Polyface.js"));
__export(__webpack_require__(/*! ./polyface/PolyfaceBuilder */ "./lib/polyface/PolyfaceBuilder.js"));
__export(__webpack_require__(/*! ./polyface/PolyfaceQuery */ "./lib/polyface/PolyfaceQuery.js"));
__export(__webpack_require__(/*! ./topology/Graph */ "./lib/topology/Graph.js"));
__export(__webpack_require__(/*! ./topology/Triangulation */ "./lib/topology/Triangulation.js"));
__export(__webpack_require__(/*! ./serialization/IModelJsonSchema */ "./lib/serialization/IModelJsonSchema.js"));
__export(__webpack_require__(/*! ./serialization/DeepCompare */ "./lib/serialization/DeepCompare.js"));


/***/ }),

/***/ "./lib/geometry3d/Angle.js":
/*!*********************************!*\
  !*** ./lib/geometry3d/Angle.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
/**
 * Carries the numeric value of an angle.
 * * The numeric value is private, and callers should not know or care whether it is in degrees or radians.
 * * The various access method are named so that callers can specify whether untyped numbers passed in or out are degrees or radians.
 */
class Angle {
    constructor(radians = 0, degrees) { this._radians = radians; this._degrees = degrees; }
    clone() { return new Angle(this._radians, this._degrees); }
    /**
     * Return a new Angle object for angle given in degrees.
     * @param degrees angle in degrees
     */
    static createDegrees(degrees) { return new Angle(Angle.degreesToRadians(degrees), degrees); }
    /**
     * Return a (new) Angle object for a value given in radians.
     * @param radians angle in radians
     */
    static createRadians(radians) { return new Angle(radians); }
    /**
     * Set this angle to a value given in radians.
     * @param radians angle given in radians
     */
    setRadians(radians) { this._radians = radians; this._degrees = undefined; }
    /**
     * Set this angle to a value given in degrees.
     * @param degrees angle given in degrees.
     */
    setDegrees(degrees) { this._radians = Angle.degreesToRadians(degrees); this._degrees = degrees; }
    /** Create an angle for a full circle. */
    static create360() { return new Angle(Math.PI * 2.0, 360.0); }
    /**
     * @return a (strongly typed) Angle whose tangent is `numerator/denominator`, using the signs of both in determining the (otherwise ambiguous)
     * quadrant.
     * @param numerator numerator for tangent
     * @param denominator denominator for tangent
     */
    static createAtan2(numerator, denominator) { return new Angle(Math.atan2(numerator, denominator)); }
    /**
     * Copy all contents of `other` to this Angle.
     * @param other source data
     */
    setFrom(other) { this._radians = other._radians; this._degrees = other._degrees; }
    /**
     * Create an Angle from a JSON object
     * @param json object from JSON.parse. If a number, value is in *DEGREES*
     * @param defaultValRadians if json is undefined, default value in radians.
     * @return a new Angle
     */
    static fromJSON(json, defaultValRadians) {
        const val = new Angle();
        val.setFromJSON(json, defaultValRadians);
        return val;
    }
    /**
     * set an Angle from a JSON object
     * * A simple number is degrees.
     * * specified `json.degrees` or `json._degrees` is degree value.
     * * specified `son.radians` or `json._radians` is radians value.
     * @param json object from JSON.parse. If a number, value is in *DEGREES*
     * @param defaultValRadians if json is undefined, default value in radians.
     */
    setFromJSON(json, defaultValRadians) {
        this._radians = defaultValRadians ? defaultValRadians : 0;
        if (!json)
            return;
        if (typeof json === "number") {
            this.setDegrees(json);
        }
        else if (typeof json.degrees === "number") {
            this.setDegrees(json.degrees);
        }
        else if (typeof json._degrees === "number") {
            this.setDegrees(json._degrees);
        }
        else if (typeof json.radians === "number") {
            this.setRadians(json.radians);
        }
        else if (typeof json._radians === "number") {
            this.setRadians(json._radians);
        }
    }
    /** Convert an Angle to a JSON object as a number in degrees */
    toJSON() { return this.degrees; }
    toJSONRadians() { return { radians: this.radians }; }
    /** @returns Return the angle measured in radians. */
    get radians() { return this._radians; }
    /** @returns Return the angle measured in degrees. */
    get degrees() { return this._degrees !== undefined ? this._degrees : Angle.radiansToDegrees(this._radians); }
    /**
     * Convert an angle in degrees to radians.
     * @param degrees angle in degrees
     */
    static degreesToRadians(degrees) { return degrees * Math.PI / 180; }
    /**
     * Convert an angle in radians to degrees.
     * @param degrees angle in radians
     */
    static radiansToDegrees(radians) {
        if (radians < 0)
            return -Angle.radiansToDegrees(-radians);
        // Now radians is positive ...
        const pi = Math.PI;
        const factor = 180.0 / pi;
        if (radians <= 0.25 * pi)
            return factor * radians;
        if (radians < 0.75 * pi)
            return 90.0 + 180 * ((radians - 0.5 * pi) / pi);
        if (radians <= 1.25 * pi)
            return 180.0 + 180 * ((radians - pi) / pi);
        if (radians <= 1.75 * pi)
            return 270.0 + 180 * ((radians - 1.5 * pi) / pi);
        // all larger radians reference from 360 degrees (2PI)
        return 360.0 + 180 * ((radians - 2.0 * pi) / pi);
    }
    /**
     * @returns Return the cosine of this Angle object's angle.
     */
    cos() { return Math.cos(this._radians); }
    /**
     * @returns Return the sine of this Angle object's angle.
     */
    sin() { return Math.sin(this._radians); }
    /**
     * @returns Return the tangent of this Angle object's angle.
     */
    tan() { return Math.tan(this._radians); }
    static isFullCircleRadians(radians) { return Math.abs(radians) >= Geometry_1.Geometry.fullCircleRadiansMinusSmallAngle; }
    get isFullCircle() { return Angle.isFullCircleRadians(this._radians); }
    /** Adjust a radians value so it is positive in 0..360 */
    static adjustDegrees0To360(degrees) {
        if (degrees >= 0) {
            const period = 360.0;
            if (degrees < period)
                return degrees;
            const numPeriods = Math.floor(degrees / period);
            return degrees - numPeriods * period;
        }
        // negative angle ...
        const radians1 = Angle.adjustDegrees0To360(-degrees);
        return 360.0 - radians1;
    }
    /** Adjust a radians value so it is positive in -180..180 */
    static adjustDegreesSigned180(degrees) {
        if (Math.abs(degrees) <= 180.0)
            return degrees;
        if (degrees >= 0) {
            const period = 360.0;
            const numPeriods = 1 + Math.floor((degrees - 180.0) / period);
            return degrees - numPeriods * period;
        }
        // negative angle ...
        return -Angle.adjustDegreesSigned180(-degrees);
    }
    /** Adjust a radians value so it is positive in 0..2Pi */
    static adjustRadians0To2Pi(radians) {
        if (radians >= 0) {
            const period = Math.PI * 2.0;
            if (radians < period)
                return radians;
            const numPeriods = Math.floor(radians / period);
            return radians - numPeriods * period;
        }
        // negative angle ...
        const radians1 = Angle.adjustRadians0To2Pi(-radians);
        return Math.PI * 2.0 - radians1;
    }
    /** Adjust a radians value so it is positive in -PI..PI */
    static adjustRadiansMinusPiPlusPi(radians) {
        if (Math.abs(radians) <= Math.PI)
            return radians;
        if (radians >= 0) {
            const period = Math.PI * 2.0;
            const numPeriods = 1 + Math.floor((radians - Math.PI) / period);
            return radians - numPeriods * period;
        }
        // negative angle ...
        return -Angle.adjustRadiansMinusPiPlusPi(-radians);
    }
    static zero() { return new Angle(0); }
    get isExactZero() { return this.radians === 0; }
    get isAlmostZero() { return Math.abs(this.radians) < Geometry_1.Geometry.smallAngleRadians; }
    /** Create an angle object with degrees adjusted into 0..360. */
    static createDegreesAdjustPositive(degrees) { return Angle.createDegrees(Angle.adjustDegrees0To360(degrees)); }
    /** Create an angle object with degrees adjusted into -180..180. */
    static createDegreesAdjustSigned180(degrees) { return Angle.createDegrees(Angle.adjustDegreesSigned180(degrees)); }
    /**
     * Test if two radians values are equivalent, allowing shift by full circle (i.e. by a multiple of `2*PI`)
     * @param radiansA first radians value
     * @param radiansB second radians value
     */
    static isAlmostEqualRadiansAllowPeriodShift(radiansA, radiansB) {
        // try to get simple conclusions with un-shifted radians ...
        const delta = Math.abs(radiansA - radiansB);
        if (delta <= Geometry_1.Geometry.smallAngleRadians)
            return true;
        const period = Math.PI * 2.0;
        if (Math.abs(delta - period) <= Geometry_1.Geometry.smallAngleRadians)
            return true;
        const numPeriod = Math.round(delta / period);
        const delta1 = delta - numPeriod * period;
        return Math.abs(delta1) <= Geometry_1.Geometry.smallAngleRadians;
    }
    /**
     * Test if this angle and other are equivalent, allowing shift by full circle (i.e. by a multiple of 360 degrees)
     */
    isAlmostEqualAllowPeriodShift(other) {
        return Angle.isAlmostEqualRadiansAllowPeriodShift(this._radians, other._radians);
    }
    /**
     * Test if two this angle and other are almost equal, NOT allowing shift by full circle multiples of 360 degrees.
     */
    isAlmostEqualNoPeriodShift(other) { return Math.abs(this._radians - other._radians) < Geometry_1.Geometry.smallAngleRadians; }
    /**
     * Test if two angle (in radians)  almost equal, NOT allowing shift by full circle multiples of `2 * PI`.
     * * (Same test as isAlmostEqualRadiansNoPeriodShift)
     */
    isAlmostEqual(other) { return this.isAlmostEqualNoPeriodShift(other); }
    /**
     * Test if two angle (in radians)  almost equal, NOT allowing shift by full circle multiples of `2 * PI`.
     */
    static isAlmostEqualRadiansNoPeriodShift(radiansA, radiansB) { return Math.abs(radiansA - radiansB) < Geometry_1.Geometry.smallAngleRadians; }
    /**
     * Test if dot product values indicate non-zero length perpendicular vectors.
     * @param dotUU dot product of vectorU with itself
     * @param dotVV dot product of vectorV with itself
     * @param dotUV dot product of vectorU with vectorV
     */
    static isPerpendicularDotSet(dotUU, dotVV, dotUV) {
        return dotUU > Geometry_1.Geometry.smallMetricDistanceSquared
            && dotVV > Geometry_1.Geometry.smallMetricDistanceSquared
            && dotUV * dotUV <= Geometry_1.Geometry.smallAngleRadiansSquared * dotUU * dotVV;
    }
    /**
     * Return cosine, sine, and radians for the half angle of a cosine,sine pair.
     * @param rCos2A cosine value (scaled by radius) for initial angle.
     * @param rSin2A sine value (scaled by radius) for final angle.
     */
    static trigValuesToHalfAngleTrigValues(rCos2A, rSin2A) {
        const r = Geometry_1.Geometry.hypotenuseXY(rCos2A, rSin2A);
        if (r < Geometry_1.Geometry.smallMetricDistance) {
            return { c: 1.0, s: 0.0, radians: 0.0 };
        }
        else {
            /* If the caller really gave you sine and cosine values, r should be 1.  However,*/
            /* to allow scaled values -- e.g. the x and y components of any vector -- we normalize*/
            /* right here.  This adds an extra sqrt and 2 divides to the whole process, but improves*/
            /* both the usefulness and robustness of the computation.*/
            let cosA = 1.0;
            let sinA = 0.0;
            const cos2A = rCos2A / r;
            const sin2A = rSin2A / r;
            if (cos2A >= 0.0) {
                /* Original angle in NE and SE quadrants.  Half angle in same quadrant */
                cosA = Math.sqrt(0.5 * (1.0 + cos2A));
                sinA = sin2A / (2.0 * (cosA));
            }
            else {
                if (sin2A > 0.0) {
                    /* Original angle in NW quadrant. Half angle in NE quadrant */
                    sinA = Math.sqrt(0.5 * (1.0 - cos2A));
                }
                else {
                    /* Original angle in SW quadrant. Half angle in SE quadrant*/
                    /* cosA comes out positive because both sines are negative. */
                    sinA = -Math.sqrt(0.5 * (1.0 - cos2A));
                }
                cosA = sin2A / (2.0 * (sinA));
            }
            return { c: cosA, s: sinA, radians: Math.atan2(sinA, cosA) };
        }
    }
    /** If value is close to -1, -0.5, 0, 0.5, 1, adjust it to the exact value. */
    static cleanupTrigValue(value, tolerance = 1.0e-15) {
        const absValue = Math.abs(value);
        if (absValue <= tolerance)
            return 0;
        let a = Math.abs(absValue - 0.5);
        if (a <= tolerance)
            return value < 0.0 ? -0.5 : 0.5;
        a = Math.abs(absValue - 1.0);
        if (a <= tolerance)
            return value < 0.0 ? -1.0 : 1.0;
        return value;
    }
    /**
     * Return the half angle cosine, sine, and radians for given dot products between vectors.
     * @param dotUU dot product of vectorU with itself
     * @param dotVV dot product of vectorV with itself
     * @param dotUV dot product of vectorU with vectorV
     */
    static dotProductsToHalfAngleTrigValues(dotUU, dotVV, dotUV, favorZero = true) {
        const rcos = dotUU - dotVV;
        const rsin = 2.0 * dotUV;
        if (favorZero && Math.abs(rsin) < Geometry_1.Geometry.smallAngleRadians * (Math.abs(dotUU) + Math.abs(dotVV)))
            return { c: 1.0, s: 0.0, radians: 0.0 };
        return Angle.trigValuesToHalfAngleTrigValues(rcos, rsin);
    }
    /**
     * * The returned angle is between 0 and PI
     * @return the angle between two vectors, with the vectors given as xyz components
     * @param ux x component of vector u
     * @param uy y component of vector u
     * @param uz z component of vector u
     * @param vx x component of vector v
     * @param vy y component of vector v
     * @param vz z component of vector v
     */
    static radiansBetweenVectorsXYZ(ux, uy, uz, vx, vy, vz) {
        //  const uu = ux * ux + uy * uy + uz * uz;
        const uDotV = ux * vx + uy * vy + uz * vz; // magU magV cos(theta)
        //    const vv = vx * vx + vy * vy + vz * vz;
        return Math.atan2(Geometry_1.Geometry.crossProductMagnitude(ux, uy, uz, vx, vy, vz), uDotV);
    }
}
Angle.piOver4Radians = 7.85398163397448280000e-001;
Angle.piOver2Radians = 1.57079632679489660000e+000;
Angle.piRadians = 3.14159265358979310000e+000;
Angle.pi2Radians = 6.28318530717958620000e+000;
Angle.degreesPerRadian = (45.0 / Angle.piOver4Radians);
Angle.radiansPerDegree = (Angle.piOver4Radians / 45.0);
Angle.piOver12Radians = 0.26179938779914943653855361527329;
exports.Angle = Angle;


/***/ }),

/***/ "./lib/geometry3d/AngleSweep.js":
/*!**************************************!*\
  !*** ./lib/geometry3d/AngleSweep.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Angle_1 = __webpack_require__(/*! ./Angle */ "./lib/geometry3d/Angle.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
/**
 * An AngleSweep is a pair of angles at start and end of an interval.
 *
 * *  For stroking purposes, the "included interval" is all angles numerically reached by theta = start + f*(end-start), where f is between 0 and 1.
 * *  This stroking formula is simple numbers -- 2PI shifts are not involved.
 * *  2PI shifts do become important in the reverse mapping of an angle to a fraction.
 * *  If (start < end) the angle proceeds CCW around the unit circle.
 * *  If (end < start) the angle proceeds CW around the unit circle.
 * *  Angles beyond 360 are fine as endpoints.
 *
 * **  (350,370) covers the same unit angles as (-10,10).
 * **  (370,350) covers the same unit angles as (10,-10).
 */
class AngleSweep {
    /** Read-property for degrees at the start of this AngleSweep. */
    get startDegrees() { return Angle_1.Angle.radiansToDegrees(this._radians0); }
    /** Read-property for degrees at the end of this AngleSweep. */
    get endDegrees() { return Angle_1.Angle.radiansToDegrees(this._radians1); }
    /** Read-property for signed start-to-end sweep in degrees. */
    get sweepDegrees() { return Angle_1.Angle.radiansToDegrees(this._radians1 - this._radians0); }
    /** Read-property for degrees at the start of this AngleSweep. */
    get startRadians() { return this._radians0; }
    /** Read-property for degrees at the end of this AngleSweep. */
    get endRadians() { return this._radians1; }
    /** Read-property for signed start-to-end sweep in radians. */
    get sweepRadians() { return this._radians1 - this._radians0; }
    /** Return the (strongly typed) start angle */
    get startAngle() { return Angle_1.Angle.createRadians(this._radians0); }
    /** Return the (strongly typed) end angle */
    get endAngle() { return Angle_1.Angle.createRadians(this._radians1); }
    /** (private) constructor with start and end angles in radians.
     *  * Use explicitly named static methods to clarify intent and units of inputs:
     *
     * * createStartEndRadians (startRadians:number, endRadians:number)
     * * createStartEndDegrees (startDegrees:number, endDegrees:number)
     * * createStartEnd (startAngle:Angle, endAngle:Angle)
     * * createStartSweepRadians (startRadians:number, sweepRadians:number)
     * * createStartSweepDegrees (startDegrees:number, sweepDegrees:number)
     * * createStartSweep (startAngle:Angle, sweepAngle:Angle)
     */
    constructor(startRadians = 0, endRadians = 0) { this._radians0 = startRadians; this._radians1 = endRadians; }
    /** create an AngleSweep from start and end angles given in radians. */
    static createStartEndRadians(startRadians = 0, endRadians = 2.0 * Math.PI, result) {
        result = result ? result : new AngleSweep();
        result.setStartEndRadians(startRadians, endRadians);
        return result;
    }
    /** Return the angle obtained by subtracting radians from this angle. */
    cloneMinusRadians(radians) { return new AngleSweep(this._radians0 - radians, this._radians1 - radians); }
    /** create an AngleSweep from start and end angles given in degrees. */
    static createStartEndDegrees(startDegrees = 0, endDegrees = 360, result) {
        return AngleSweep.createStartEndRadians(Angle_1.Angle.degreesToRadians(startDegrees), Angle_1.Angle.degreesToRadians(endDegrees), result);
    }
    /** create an angle sweep from strongly typed start and end angles */
    static createStartEnd(startAngle, endAngle, result) {
        result = result ? result : new AngleSweep();
        result.setStartEndRadians(startAngle.radians, endAngle.radians);
        return result;
    }
    /** Create an angle sweep with limits given as (strongly typed) angles for start and sweep */
    static createStartSweep(startAngle, sweepAngle, result) {
        return AngleSweep.createStartSweepRadians(startAngle.radians, sweepAngle.radians, result);
    }
    /** @returns Return a sweep with limits interpolated between this and other. */
    interpolate(fraction, other) {
        return new AngleSweep(Geometry_1.Geometry.interpolate(this._radians0, fraction, other._radians0), Geometry_1.Geometry.interpolate(this._radians1, fraction, other._radians1));
    }
    /** create an AngleSweep from start and end angles given in radians. */
    static createStartSweepRadians(startRadians = 0, sweepRadians = Math.PI, result) {
        result = result ? result : new AngleSweep();
        result.setStartEndRadians(startRadians, startRadians + sweepRadians);
        return result;
    }
    /** create an AngleSweep from start and sweep given in degrees.  */
    static createStartSweepDegrees(startDegrees = 0, sweepDegrees = 360, result) {
        return AngleSweep.createStartEndRadians(Angle_1.Angle.degreesToRadians(startDegrees), Angle_1.Angle.degreesToRadians(startDegrees + sweepDegrees), result);
    }
    /** directly set the start and end angles in radians */
    setStartEndRadians(startRadians = 0, endRadians = 2.0 * Math.PI) {
        const delta = endRadians - startRadians;
        if (Angle_1.Angle.isFullCircleRadians(delta)) {
            endRadians = startRadians + (delta > 0 ? 2.0 : -2.0) * Math.PI;
        }
        this._radians0 = startRadians;
        this._radians1 = endRadians;
    }
    /** directly set the start and end angles in degrees */
    setStartEndDegrees(startDegrees = 0, endDegrees = 360.0) {
        this.setStartEndRadians(Angle_1.Angle.degreesToRadians(startDegrees), Angle_1.Angle.degreesToRadians(endDegrees));
    }
    /** copy from other AngleSweep. */
    setFrom(other) { this._radians0 = other._radians0; this._radians1 = other._radians1; }
    /** create a full circle sweep (CCW). startRadians defaults to 0 */
    static create360(startRadians) {
        startRadians = startRadians ? startRadians : 0.0;
        return new AngleSweep(startRadians, startRadians + 2.0 * Math.PI);
    }
    /** create a sweep from the south pole to the north pole. */
    static createFullLatitude() { return AngleSweep.createStartEndRadians(-0.5 * Math.PI, 0.5 * Math.PI); }
    /** Reverse the start and end angle in place. */
    reverseInPlace() { const a = this._radians0; this._radians0 = this._radians1; this._radians1 = a; }
    /** Restrict start and end angles into the range (-90,+90) in degrees. */
    capLatitudeInPlace() {
        const limit = 0.5 * Math.PI;
        this._radians0 = Geometry_1.Geometry.clampToStartEnd(this._radians0, -limit, limit);
        this._radians1 = Geometry_1.Geometry.clampToStartEnd(this._radians1, -limit, limit);
    }
    /** Ask if the sweep is counterclockwise, i.e. positive sweep */
    get isCCW() { return this._radians1 >= this._radians0; }
    /** Ask if the sweep is a full circle. */
    get isFullCircle() { return Angle_1.Angle.isFullCircleRadians(this.sweepRadians); }
    /** Ask if the sweep is a full sweep from south pole to north pole. */
    get isFullLatitudeSweep() {
        const a = Math.PI * 0.5;
        return Angle_1.Angle.isAlmostEqualRadiansNoPeriodShift(this._radians0, -a)
            && Angle_1.Angle.isAlmostEqualRadiansNoPeriodShift(this._radians1, a);
    }
    /** return a clone of this sweep. */
    clone() { return new AngleSweep(this._radians0, this._radians1); }
    /** Convert fractional position in the sweep to radians. */
    fractionToRadians(fraction) {
        return fraction < 0.5 ?
            this._radians0 + fraction * (this._radians1 - this._radians0)
            : this._radians1 + (fraction - 1.0) * (this._radians1 - this._radians0);
    }
    /** Convert fractional position in the sweep to strongly typed Angle object. */
    fractionToAngle(fraction) {
        return Angle_1.Angle.createRadians(this.fractionToRadians(fraction));
    }
    /** return 2PI divided by the sweep radians (i.e. 360 degrees divided by sweep angle).
     * This is the number of fractional intervals required to cover a whole circle.
     */
    fractionPeriod() {
        return Geometry_1.Geometry.safeDivideFraction(Math.PI * 2.0, Math.abs(this._radians1 - this._radians0), 1.0);
    }
    /** return the fractional ized position of the angle,
     * computed without consideration of 2PI period.
     * That is, an angle that is numerically much beyond than the end angle
     * will produce a large fraction and an angle much beyond the start angle
     * will produce a large negative fraction.
     *
     */
    angleToUnboundedFraction(theta) {
        return Geometry_1.Geometry.safeDivideFraction(theta.radians - this._radians0, this._radians1 - this._radians0, 1.0);
    }
    /** map an angle to a fractional coordinate which is:
     *
     * *  the start angle is at fraction 0
     * *  the end angle is at fraction 1
     * *  interior angles are between 0 and 1
     * *  all exterior angles are at fractions greater than 1
     * *  the periodic jump is at full wraparound to the start angle
     */
    angleToPositivePeriodicFraction(theta) { return this.radiansToPositivePeriodicFraction(theta.radians); }
    /**
     * Convert each value in an array from radians to fraction.
     * @param data array that is input as radians, output as fractions
     */
    radiansArraytoPositivePeriodicFractions(data) {
        const n = data.length;
        for (let i = 0; i < n; i++) {
            data.reassign(i, this.radiansToPositivePeriodicFraction(data.at(i)));
        }
    }
    radiansToPositivePeriodicFraction(radians) {
        if (Angle_1.Angle.isAlmostEqualRadiansAllowPeriodShift(radians, this._radians0))
            return 0.0;
        if (Angle_1.Angle.isAlmostEqualRadiansAllowPeriodShift(radians, this._radians1))
            return 1.0;
        const sweep = this._radians1 - this._radians0;
        const delta = radians - this._radians0;
        if (sweep > 0) {
            const delta1 = Angle_1.Angle.adjustRadians0To2Pi(delta);
            const fraction1 = Geometry_1.Geometry.safeDivideFraction(delta1, sweep, 0.0);
            return fraction1;
        }
        const delta2 = Angle_1.Angle.adjustRadians0To2Pi(-delta);
        const fraction2 = Geometry_1.Geometry.safeDivideFraction(delta2, -sweep, 0.0);
        return fraction2;
    }
    /** map an angle to a fractional coordinate which is:
     *
     * *  the start angle is at fraction 0
     * *  the end angle is at fraction 1
     * *  interior angles are between 0 and 1
     * *  small negative for angles just "before" the start angle
     * *  more than one for angles just "after" the end angle
     * *  the periodic jump is at the middle of the "outside" interval
     */
    angleToSignedPeriodicFraction(theta) {
        return this.radiansToSignedPeriodicFraction(theta.radians);
    }
    radiansToSignedPeriodicFraction(radians) {
        if (Angle_1.Angle.isAlmostEqualRadiansAllowPeriodShift(radians, this._radians0))
            return 0.0;
        if (Angle_1.Angle.isAlmostEqualRadiansAllowPeriodShift(radians, this._radians1))
            return 1.0;
        const sweep = this._radians1 - this._radians0;
        // measure from middle of interval ...
        const delta = radians - this._radians0 - 0.5 * sweep;
        if (sweep > 0) {
            const delta1 = Angle_1.Angle.adjustRadiansMinusPiPlusPi(delta);
            const fraction1 = 0.5 + Geometry_1.Geometry.safeDivideFraction(delta1, sweep, 0.0);
            return fraction1;
        }
        const delta2 = Angle_1.Angle.adjustRadiansMinusPiPlusPi(-delta);
        const fraction = 0.5 + Geometry_1.Geometry.safeDivideFraction(delta2, -sweep, 0.0);
        return fraction;
    }
    /** test if an angle is within the sweep */
    isAngleInSweep(angle) { return this.isRadiansInSweep(angle.radians); }
    /** test if radians are within sweep  */
    isRadiansInSweep(radians) {
        // quick out for simple inside ...
        const delta0 = radians - this._radians0;
        const delta1 = radians - this._radians1;
        if (delta0 * delta1 <= 0.0)
            return true;
        return this.radiansToPositivePeriodicFraction(radians) <= 1.0;
    }
    /** set this AngleSweep from various sources:
     *
     * * if json is undefined, a full-circle sweep is returned.
     * * If json is an AngleSweep object it is is cloned
     * * If json is an array of 2 numbers, those numbers are start and end angles in degrees.
     * * If `json.degrees` is an array of 2 numbers, those numbers are start and end angles in degrees.
     * * If `json.radians` is an array of 2 numbers, those numbers are start and end angles in radians.
     */
    setFromJSON(json) {
        if (!json)
            this.setStartEndRadians(); // default full circle
        else if (json instanceof AngleSweep)
            this.setFrom(json);
        else if (Geometry_1.Geometry.isNumberArray(json.degrees, 2))
            this.setStartEndDegrees(json.degrees[0], json.degrees[1]);
        else if (Geometry_1.Geometry.isNumberArray(json.radians, 2))
            this.setStartEndRadians(json.radians[0], json.radians[1]);
        else if (Geometry_1.Geometry.isNumberArray(json, 2))
            this.setStartEndDegrees(json[0], json[1]);
    }
    /** create an AngleSweep from a json object. */
    static fromJSON(json) {
        const result = AngleSweep.create360();
        result.setFromJSON(json);
        return result;
    }
    /**
     * Convert an AngleSweep to a JSON object.
     * @return {*} {degrees: [startAngleInDegrees, endAngleInDegrees}
     */
    toJSON() {
        // return { degrees: [this.startDegrees, this.endDegrees] };
        return [this.startDegrees, this.endDegrees];
    }
    /** test if start and end angles match, with explicit name to clarify that there is no test for 360-degree shifts. */
    isAlmostEqualAllowPeriodShift(other) {
        return Angle_1.Angle.isAlmostEqualRadiansAllowPeriodShift(this._radians0, other._radians0)
            && Angle_1.Angle.isAlmostEqualRadiansNoPeriodShift(this._radians1 - this._radians0, other._radians1 - other._radians0);
    }
    /** test if start and end angles match, explicit name to clarify that 360-degree shifts are allowed. */
    isAlmostEqualNoPeriodShift(other) {
        return Angle_1.Angle.isAlmostEqualRadiansNoPeriodShift(this._radians0, other._radians0)
            && Angle_1.Angle.isAlmostEqualRadiansNoPeriodShift(this._radians1 - this._radians0, other._radians1 - other._radians0);
    }
    /** test if start and end angles match with radians tolerance.
     * * This is equivalent to isAlmostEqualNoPeriodShift.
     * * it is present for consistency with other classes
     * * It is recommended that all callers use one of he longer names to be clear of their intentions:
     * * * isAlmostEqualAllowPeriodShift
     * * * isAlmostEqualRadiansNoPeriodShift
     */
    isAlmostEqual(other) { return this.isAlmostEqualNoPeriodShift(other); }
}
exports.AngleSweep = AngleSweep;


/***/ }),

/***/ "./lib/geometry3d/FrameBuilder.js":
/*!****************************************!*\
  !*** ./lib/geometry3d/FrameBuilder.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
// import { Point2d } from "./Geometry2d";
/* tslint:disable:variable-name jsdoc-format no-empty */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Point3dVector3d_1 = __webpack_require__(/*! ./Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Transform_1 = __webpack_require__(/*! ./Transform */ "./lib/geometry3d/Transform.js");
const Matrix3d_1 = __webpack_require__(/*! ./Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const CurvePrimitive_1 = __webpack_require__(/*! ../curve/CurvePrimitive */ "./lib/curve/CurvePrimitive.js");
const CurveCollection_1 = __webpack_require__(/*! ../curve/CurveCollection */ "./lib/curve/CurveCollection.js");
const BSplineCurve_1 = __webpack_require__(/*! ../bspline/BSplineCurve */ "./lib/bspline/BSplineCurve.js");
const Arc3d_1 = __webpack_require__(/*! ../curve/Arc3d */ "./lib/curve/Arc3d.js");
const LineSegment3d_1 = __webpack_require__(/*! ../curve/LineSegment3d */ "./lib/curve/LineSegment3d.js");
const LineString3d_1 = __webpack_require__(/*! ../curve/LineString3d */ "./lib/curve/LineString3d.js");
const PointHelpers_1 = __webpack_require__(/*! ./PointHelpers */ "./lib/geometry3d/PointHelpers.js");
/**
 * Helper class to accumulate points and vectors until there is enough data to define a coordinate system.
 *
 * * For the common case of building a right handed frame:
 *
 * ** create the FrameBuilder and make calls to announcePoint and announceVector.
 * ** the frame will be fully determined by an origin and two vectors.
 * ** the first call to announcePoint will set the origin.
 * **  additional calls to announcePoint will produce announceVector call with the vector from the origin.
 * ** After each announcement, call getValidatedFrame(false)
 * ** getValidatedFrame will succeed when it has two independent vectors.
 * *  to build a left handed frame,
 *
 * **  an origin and 3 independent vectors are required.
 * **  annouce as above, but query wtih getValidatedFrame (true).
 * **  this will use the third vector to select right or left handed frame.
 */
class FrameBuilder {
    clear() { this._origin = undefined; this._vector0 = undefined; this._vector1 = undefined; this._vector2 = undefined; }
    constructor() { this.clear(); }
    /** Try to assemble the data into a nonsingular transform.
     *
     * * If allowLeftHanded is false, vector0 and vector1 determine a right handed coordinate system.
     * * if allowLeftHanded is true, the z vector of the right handed system can be flipped to agree with vector2 direction.
     */
    getValidatedFrame(allowLeftHanded = false) {
        if (this._origin && this._vector0 && this._vector1) {
            if (!allowLeftHanded) {
                const matrix = Matrix3d_1.Matrix3d.createRigidFromColumns(this._vector0, this._vector1, 0 /* XYZ */);
                if (matrix)
                    return Transform_1.Transform.createOriginAndMatrix(this._origin, matrix);
                // uh oh -- vector1 was not really independent.  clear everything after vector0.
                this._vector1 = this._vector2 = undefined;
            }
            else if (this._vector2) {
                const matrix = Matrix3d_1.Matrix3d.createRigidFromColumns(this._vector0, this._vector1, 0 /* XYZ */);
                if (matrix) {
                    if (this._vector0.tripleProduct(this._vector1, this._vector2) < 0)
                        matrix.scaleColumns(1.0, 1.0, -1.0);
                    return Transform_1.Transform.createOriginAndMatrix(this._origin, matrix);
                }
                // uh oh again -- clear vector1 and vector2, reannounce vector2 as possible vector1??
                const vector2 = this._vector2;
                this._vector1 = this._vector2 = undefined;
                this.announceVector(vector2);
            }
        }
        return undefined;
    }
    // If vector0 is known but vector1 is not, make vector1 the cross of the upvector and vector0
    applyDefaultUpVector(vector) {
        if (vector && this._vector0 && !this._vector1 && !vector.isParallelTo(this._vector0)) {
            this._vector1 = vector.crossProduct(this._vector0);
        }
    }
    get hasOrigin() { return this._origin !== undefined; }
    /** Return the number of vectors saved.   Because the save process checkes numerics, this should be the rank of the system.
     */
    savedVectorCount() {
        if (!this._vector0)
            return 0;
        if (!this._vector1)
            return 1;
        if (!this._vector2)
            return 2;
        return 3;
    }
    /** announce a new point.  If this point is different from the origin, also announce the vector from the origin.*/
    announcePoint(point) {
        if (!this._origin) {
            this._origin = point.clone();
            return this.savedVectorCount();
        }
        // the new point may provide an additional vector
        if (this._origin.isAlmostEqual(point))
            return this.savedVectorCount();
        return this.announceVector(this._origin.vectorTo(point));
    }
    announceVector(vector) {
        if (vector.isAlmostZero)
            return this.savedVectorCount();
        if (!this._vector0) {
            this._vector0 = vector;
            return 1;
        }
        if (!this._vector1) {
            if (!vector.isParallelTo(this._vector0)) {
                this._vector1 = vector;
                return 2;
            }
            return 1;
        }
        // vector0 and vector1 are independent.
        if (!this._vector2) {
            const unitPerpendicular = this._vector0.unitCrossProduct(this._vector1);
            if (unitPerpendicular && !Geometry_1.Geometry.isSameCoordinate(0, unitPerpendicular.dotProduct(vector))) {
                this._vector2 = vector;
                return 3;
            }
            return 2;
        }
        // fall through if prior vectors are all there -- no need for the new one.
        return 3;
    }
    /** Inspect the content of the data.  Announce points and vectors.   Return when savedVectorCount becomes
     * sufficient for a coordinate system.
     */
    announce(data) {
        if (this.savedVectorCount() > 1)
            return;
        if (data instanceof Point3dVector3d_1.Point3d)
            this.announcePoint(data);
        else if (data instanceof Point3dVector3d_1.Vector3d)
            this.announceVector(data);
        else if (Array.isArray(data)) {
            for (const child of data) {
                if (this.savedVectorCount() > 1)
                    break;
                this.announce(child);
            }
        }
        else if (data instanceof CurvePrimitive_1.CurvePrimitive) {
            if (data instanceof LineSegment3d_1.LineSegment3d) {
                this.announcePoint(data.startPoint());
                this.announcePoint(data.endPoint());
            }
            else if (data instanceof Arc3d_1.Arc3d) {
                const ray = data.fractionToPointAndDerivative(0.0);
                this.announcePoint(ray.origin);
                this.announceVector(ray.direction);
                this.announceVector(data.matrix.columnZCrossVector(ray.direction));
            }
            else if (data instanceof LineString3d_1.LineString3d) {
                for (const point of data.points) {
                    this.announcePoint(point);
                    if (this.savedVectorCount() > 1)
                        break;
                }
            }
            else if (data instanceof BSplineCurve_1.BSplineCurve3d) {
                const point = Point3dVector3d_1.Point3d.create();
                for (let i = 0; this.savedVectorCount() < 2; i++) {
                    if (data.getPolePoint3d(i, point) instanceof Point3dVector3d_1.Point3d)
                        this.announcePoint(point);
                    else
                        break;
                }
            }
            // TODO: unknown curve type.  Stroke? FrenetFrame?
        }
        else if (data instanceof CurveCollection_1.CurveCollection) {
            if (data.children)
                for (const child of data.children) {
                    this.announce(child);
                    if (this.savedVectorCount() > 1)
                        break;
                }
        }
    }
    /** create a localToWorld frame for the given data.
     *
     * *  origin is at first point
     * *  x axis in direction of first nonzero vector present or implied by the input.
     * *  y axis is perpendicular to x and contains (in positive side) the next vector present or implied by the input.
     */
    static createRightHandedFrame(defaultUpVector, ...params) {
        const builder = new FrameBuilder();
        for (const data of params) {
            builder.announce(data);
            builder.applyDefaultUpVector(defaultUpVector);
            const result = builder.getValidatedFrame(false);
            if (result !== undefined)
                return result;
        }
        // try direct evaluation of curve primitives?
        for (const data of params) {
            if (data instanceof CurveCollection_1.CurveCollection) {
                const children = data.children;
                if (children) {
                    for (const curve of children) {
                        if (curve instanceof CurvePrimitive_1.CurvePrimitive) {
                            const frenetFrame = curve.fractionToFrenetFrame(0.0);
                            if (frenetFrame)
                                return frenetFrame;
                        }
                    }
                }
            }
        }
        return undefined;
    }
    /** create a map with
     * *  transform0 = the local to world
     * *  transform1 = world to local
     * * ideally all points in local xy plane
     */
    static createRightHandedLocalToWorld(...params) {
        const builder = new FrameBuilder();
        for (const data of params) {
            builder.announce(data);
            const localToWorld = builder.getValidatedFrame(false);
            if (localToWorld !== undefined)
                return localToWorld;
        }
        return undefined;
    }
    /**
     * try to create a frame whose xy plane is through points.
     *
     * *  if 3 or more distinct points are present, the x axis is from the first point to the most distance, and y direction is toward the
     * point most distant from that line.
     * @param points array of points
     */
    static createFrameToDistantPoints(points) {
        if (points.length > 2) {
            const origin = points[0].clone();
            const vector01 = Point3dVector3d_1.Vector3d.create();
            PointHelpers_1.Point3dArray.indexOfMostDistantPoint(points, points[0], vector01);
            const vector02 = Point3dVector3d_1.Vector3d.create();
            PointHelpers_1.Point3dArray.indexOfPointWithMaxCrossProductMagnitude(points, origin, vector01, vector02);
            const matrix = Matrix3d_1.Matrix3d.createRigidFromColumns(vector01, vector02, 0 /* XYZ */);
            if (matrix)
                return Transform_1.Transform.createRefs(origin, matrix);
        }
        return undefined;
    }
    /**
     * Create the localToWorld transform from a range to axes of its parent coordinate system.
     * @param range [in] range to inpsect
     * @param fractionX  [in] fractonal coordinate of frame origin x
     * @param fractionY [in] fractional coordinate of frame origin y
     * @param fractionZ [in] fractgional coordinate of frame origin z
     * @param scaleSelect [in] selects size of localToWorld axes.
     * @param defaultAxisLength [in] if true and any axis length is 0, that axis vector takes this physical length.
     */
    static createLocalToWorldTransformInRange(range, scaleSelect = 2 /* NonUniformRangeContainment */, fractionX = 0, fractionY = 0, fractionZ = 0, defaultAxisLength = 1.0) {
        if (range.isNull)
            return Transform_1.Transform.createIdentity();
        let a = 1.0;
        let b = 1.0;
        let c = 1.0;
        if (scaleSelect === 1 /* LongestRangeDirection */) {
            a = b = c = Geometry_1.Geometry.correctSmallMetricDistance(range.maxLength(), defaultAxisLength);
        }
        else if (scaleSelect === 2 /* NonUniformRangeContainment */) {
            a = Geometry_1.Geometry.correctSmallMetricDistance(range.xLength(), defaultAxisLength) * Geometry_1.Geometry.maxAbsDiff(fractionX, 0, 1);
            b = Geometry_1.Geometry.correctSmallMetricDistance(range.yLength(), defaultAxisLength) * Geometry_1.Geometry.maxAbsDiff(fractionY, 0, 1);
            c = Geometry_1.Geometry.correctSmallMetricDistance(range.zLength(), defaultAxisLength) * Geometry_1.Geometry.maxAbsDiff(fractionZ, 0, 1);
        }
        return Transform_1.Transform.createRefs(range.fractionToPoint(fractionX, fractionY, fractionZ), Matrix3d_1.Matrix3d.createScale(a, b, c));
    }
}
exports.FrameBuilder = FrameBuilder;


/***/ }),

/***/ "./lib/geometry3d/GeometryHandler.js":
/*!*******************************************!*\
  !*** ./lib/geometry3d/GeometryHandler.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
class GeometryHandler {
    handleCurveCollection(_g) { }
    handlePath(g) { return this.handleCurveCollection(g); }
    handleLoop(g) { return this.handleCurveCollection(g); }
    handleParityRegion(g) { return this.handleCurveCollection(g); }
    handleUnionRegion(g) { return this.handleCurveCollection(g); }
    handleBagOfCurves(g) { return this.handleCurveCollection(g); }
}
exports.GeometryHandler = GeometryHandler;
/**
 * `NullGeometryHandler` is a base class for dispatching various geometry types to
 * appliation specific implementation of some service.
 *
 * To use:
 * * Derive a class from `NullGeometryHandler`
 * * Reimplement any or all of the specific `handleXXXX` methods
 * * Create a handler instance `myHandler`
 * * To send a `GeometryQuery` object `candidateGeometry` through the (fast) dispatch, invoke   `candidateGeometry.dispatchToHandler (myHandler)
 * * The appropriate method or methods will get called with a strongly typed `_g ` value.
 */
class NullGeometryHandler extends GeometryHandler {
    handleLineSegment3d(_g) { return undefined; }
    handleLineString3d(_g) { return undefined; }
    handleArc3d(_g) { return undefined; }
    handleCurveCollection(_g) { return undefined; }
    handleBSplineCurve3d(_g) { return undefined; }
    handleBSplineCurve3dH(_g) { return undefined; }
    handleBSplineSurface3d(_g) { return undefined; }
    handleCoordinateXYZ(_g) { return undefined; }
    handleBSplineSurface3dH(_g) { return undefined; }
    handleIndexedPolyface(_g) { return undefined; }
    handleTransitionSpiral(_g) { return undefined; }
    handlePath(_g) { return undefined; }
    handleLoop(_g) { return undefined; }
    handleParityRegion(_g) { return undefined; }
    handleUnionRegion(_g) { return undefined; }
    handleBagOfCurves(_g) { return undefined; }
    handleSphere(_g) { return undefined; }
    handleCone(_g) { return undefined; }
    handleBox(_g) { return undefined; }
    handleTorusPipe(_g) { return undefined; }
    handleLinearSweep(_g) { return undefined; }
    handleRotationalSweep(_g) { return undefined; }
    handleRuledSweep(_g) { return undefined; }
    handlePointString3d(_g) { return undefined; }
    handleBezierCurve3d(_g) { return undefined; }
    handleBezierCurve3dH(_g) { return undefined; }
}
exports.NullGeometryHandler = NullGeometryHandler;


/***/ }),

/***/ "./lib/geometry3d/GrowableBlockedArray.js":
/*!************************************************!*\
  !*** ./lib/geometry3d/GrowableBlockedArray.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @module ArraysAndInterfaces */
/**
 * Array of contiguous doubles, indexed by block number and index within block.
 * * This is essentially a rectangular matrix, with each block being a row of the matrix.
 */
class GrowableBlockedArray {
    constructor(blockSize, initialBlocks = 8) {
        this._data = new Float64Array(initialBlocks * blockSize);
        this._inUse = 0;
        this._blockSize = blockSize;
    }
    /** computed property: length (in blocks, not doubles) */
    get numBlocks() { return this._inUse; }
    /** property: number of data values per block */
    get numPerBlock() { return this._blockSize; }
    /**
     * Return a single value indexed within a blcok
     * @param blockIndex index of block to read
     * @param indexInBlock  offset within the block
     */
    getWithinBlock(blockIndex, indexWithinBlock) {
        return this._data[blockIndex * this._blockSize + indexWithinBlock];
    }
    /** clear the block count to zero, but maintain the allocated memory */
    clear() { this._inUse = 0; }
    /** Return the capacity in blocks (not doubles) */
    blockCapacity() {
        return this._data.length / this._blockSize;
    }
    /** ensure capacity (in blocks, not doubles) */
    ensureBlockCapacity(blockCapacity) {
        if (blockCapacity > this.blockCapacity()) {
            const newData = new Float64Array(blockCapacity * this._blockSize);
            for (let i = 0; i < this._data.length; i++) {
                newData[i] = this._data[i];
            }
            this._data = newData;
        }
    }
    /** Add a new block of data.
     * * If newData has fewer than numPerBlock entries, the remaining part of the new block is zeros.
     * * If newData has more entries, only the first numPerBlock are taken.
     */
    addBlock(newData) {
        const k0 = this.newBlockIndex();
        let numValue = newData.length;
        if (numValue > this._blockSize)
            numValue = this._blockSize;
        for (let i = 0; i < numValue; i++)
            this._data[k0 + i] = newData[i];
    }
    /**
     * Return the starting index of a block of (zero-initialized) doubles at the end.
     *
     * * this.data is reallocated if needed to include the new block.
     * * The inUse count is incremented to include the new block.
     * * The returned block is an index to the Float64Array (not a block index)
     */
    newBlockIndex() {
        const index = this._blockSize * this._inUse;
        if ((index + 1) > this._data.length)
            this.ensureBlockCapacity(2 * this._inUse);
        this._inUse++;
        for (let i = index; i < index + this._blockSize; i++)
            this._data[i] = 0.0;
        return index;
    }
    /** reduce the block count by one. */
    popBlock() {
        if (this._inUse > 0)
            this._inUse--;
    }
    /** convert a block index to the simple index to the underlying Float64Array. */
    blockIndexToDoubleIndex(blockIndex) { return this._blockSize * blockIndex; }
    /** Access a single double at offset within a block, with index checking and return undefined if indexing is invalid. */
    checkedComponent(blockIndex, componentIndex) {
        if (blockIndex >= this._inUse || blockIndex < 0 || componentIndex < 0 || componentIndex >= this._blockSize)
            return undefined;
        return this._data[this._blockSize * blockIndex + componentIndex];
    }
    /** Access a single double at offset within a block.  This has no index checking. */
    component(blockIndex, componentIndex) {
        return this._data[this._blockSize * blockIndex + componentIndex];
    }
    /** compre two blocks in simple lexical order.
     * @param data data array
     * @param blockSize number of items to compare
     * @param ia raw index (not block index) of first block
     * @param ib raw index (not block index) of second block
     */
    static compareLexicalBlock(data, blockSize, ia, ib) {
        let ax = 0;
        let bx = 0;
        for (let i = 0; i < blockSize; i++) {
            ax = data[ia + i];
            bx = data[ib + i];
            if (ax > bx)
                return 1;
            if (ax < bx)
                return -1;
        }
        return ia - ib; // so original order is maintained among duplicates !!!!
    }
    /** Return an array of block indices sorted per compareLexicalBlock function */
    sortIndicesLexical(compareBlocks = GrowableBlockedArray.compareLexicalBlock) {
        const n = this._inUse;
        // let numCompare = 0;
        const result = new Uint32Array(n);
        const data = this._data;
        const blockSize = this._blockSize;
        for (let i = 0; i < n; i++)
            result[i] = i;
        result.sort((blockIndexA, blockIndexB) => {
            // numCompare++;
            return compareBlocks(data, blockSize, blockIndexA * blockSize, blockIndexB * blockSize);
        });
        // console.log (n, numCompare);
        return result;
    }
    distanceBetweenBlocks(blockIndexA, blockIndexB) {
        let dd = 0.0;
        let iA = this.blockIndexToDoubleIndex(blockIndexA);
        let iB = this.blockIndexToDoubleIndex(blockIndexB);
        let a = 0;
        const data = this._data;
        for (let i = 0; i < this._blockSize; i++) {
            a = data[iA++] - data[iB++];
            dd += a * a;
        }
        return Math.sqrt(dd);
    }
    distanceBetweenSubBlocks(blockIndexA, blockIndexB, iBegin, iEnd) {
        let dd = 0.0;
        const iA = this.blockIndexToDoubleIndex(blockIndexA);
        const iB = this.blockIndexToDoubleIndex(blockIndexB);
        let a = 0;
        const data = this._data;
        for (let i = iBegin; i < iEnd; i++) {
            a = data[iA + i] - data[iB + i];
            dd += a * a;
        }
        return Math.sqrt(dd);
    }
}
exports.GrowableBlockedArray = GrowableBlockedArray;


/***/ }),

/***/ "./lib/geometry3d/GrowableFloat64Array.js":
/*!************************************************!*\
  !*** ./lib/geometry3d/GrowableFloat64Array.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A `GrowableFloat64Array` is Float64Array accompanied by a count of how many of the array's entries are considered in use.
 * * In C++ terms, this is like an std::vector
 * * As entries are added to the array, the buffer is reallocated as needed to accomodate.
 * * The reallocations leave unused space to accept further additional entries without reallocation.
 * * The `length` property returns the number of entries in use.
 * * the `capacity` property returns the (usually larger) length of the (overallocated) Float64Array.
 *
 */
class GrowableFloat64Array {
    constructor(initialCapacity = 8) {
        this._data = new Float64Array(initialCapacity);
        this._inUse = 0;
    }
    /**
     * Create a GrowableFloat64Array with given contents.
     * @param contents data to copy into the array
     */
    static create(contents) {
        const result = new GrowableFloat64Array(contents.length);
        for (const a of contents) {
            result.push(a);
        }
        return result;
    }
    static compare(a, b) {
        return a - b;
    }
    /** Return a new array with
     * * All active entries copied from this instance
     * * optionally trimmed capacity to the active length or replicate the capacity and unused space.
     */
    clone(maintainExcessCapacity = false) {
        const n = this._inUse;
        const data = this._data;
        const out = new GrowableFloat64Array(maintainExcessCapacity ? this.capacity() : n);
        for (let i = 0; i < n; i++)
            out.push(data[i]);
        return out;
    }
    /**
     * @returns the number of entries in use.
     */
    get length() {
        return this._inUse;
    }
    /**
     * Set the value at specified index.
     * @param index index of entry to set
     * @param value value to set
     */
    setAt(index, value) {
        this._data[index] = value;
    }
    /**
     * Move the value at index i to index j.
     * @param i source index
     * @param j destination index.
     */
    move(i, j) {
        this._data[j] = this._data[i];
    }
    /**
     * swap the values at indices i and j
     * @param i first index
     * @param j second index
     */
    swap(i, j) {
        const a = this._data[i];
        this._data[i] = this._data[j];
        this._data[j] = a;
    }
    /**
     * append a single value to the array.
     * @param toPush value to append to the active array.
     */
    push(toPush) {
        if (this._inUse + 1 <= this._data.length) {
            this._data[this._inUse] = toPush;
            this._inUse++;
        }
        else {
            // Make new array (double size), copy values, then push toPush
            const newData = new Float64Array(this._inUse * 2);
            for (let i = 0; i < this._inUse; i++) {
                newData[i] = this._data[i];
            }
            this._data = newData;
            this._data[this._inUse] = toPush;
            this._inUse++;
        }
    }
    /** Push a `numToCopy` consecutive values starting at `copyFromIndex` to the end of the array. */
    pushBlockCopy(copyFromIndex, numToCopy) {
        const newLength = this._inUse + numToCopy;
        this.ensureCapacity(newLength);
        const limit = copyFromIndex + numToCopy;
        for (let i = copyFromIndex; i < limit; i++)
            this._data[this._inUse++] = this._data[i];
    }
    /** Clear the array to 0 length.  The underlying memory remains allocated for reuse. */
    clear() {
        while (this._inUse > 0)
            this.pop();
    }
    /**
     * @returns the number of entries in the supporting Float64Array buffer.   This number is always at least as large as the `length` property.
     */
    capacity() {
        return this._data.length;
    }
    /**
     * * If the capacity (Float64Array length) is less than or equal to the requested newCapacity, do nothing
     * * If the requested newCapacity is larger than the existing capacity, reallocate (and copy existing values) with the larger capacity.
     * @param newCapacity
     */
    ensureCapacity(newCapacity) {
        if (newCapacity > this.capacity()) {
            const oldInUse = this._inUse;
            const newData = new Float64Array(newCapacity);
            for (let i = 0; i < oldInUse; i++)
                newData[i] = this._data[i];
            this._data = newData;
        }
    }
    /**
     * * If newLength is less than current (active) length, just set (active) length.
     * * If newLength is greater, ensureCapacity (newSize) and pad with padValue up to newSize;
     * @param newLength new data count
     * @param padValue value to use for padding if the length increases.
     */
    resize(newLength, padValue = 0) {
        // quick out for easy case ...
        if (newLength <= this._inUse) {
            this._inUse = newLength;
            return;
        }
        const oldLength = this._inUse;
        this.ensureCapacity(newLength);
        for (let i = oldLength; i < newLength; i++)
            this._data[i] = padValue;
        this._inUse = newLength;
    }
    /**
     * * Reduce the length by one.
     * * Note that there is no method return value -- use `back` to get that value before `pop()`
     * * (As with std::vector, seprating the `pop` from the value access elmiinates error testing from `pop` call)
     */
    pop() {
        // Could technically access outside of array, if filled and then reduced using pop (similar to C
        // and accessing out of bounds), but with adjusted inUse counter, that data will eventually be overwritten
        if (this._inUse > 0) {
            this._inUse--;
        }
    }
    at(index) {
        return this._data[index];
    }
    front() {
        return this._data[0];
    }
    back() {
        return this._data[this._inUse - 1];
    }
    reassign(index, value) {
        this._data[index] = value;
    }
    /**
     * * Sort the array entries.
     * * Uses insertion sort -- fine for small arrays (less than 30), slow for larger arrays
     * @param compareMethod comparison method
     */
    sort(compareMethod = GrowableFloat64Array.compare) {
        for (let i = 0; i < this._inUse; i++) {
            for (let j = i + 1; j < this._inUse; j++) {
                const tempI = this._data[i];
                const tempJ = this._data[j];
                if (compareMethod(tempI, tempJ) > 0) {
                    this._data[i] = tempJ;
                    this._data[j] = tempI;
                }
            }
        }
    }
    /**
     * * compress out values not within the [a,b] interval.
     * * Note that if a is greater than b all values are rejected.
     * @param a low value for accepted interval
     * @param b high value for accepted interval
     */
    restrictToInterval(a, b) {
        const data = this._data;
        const n = data.length;
        let numAccept = 0;
        let q = 0;
        for (let i = 0; i < n; i++) {
            q = data[i];
            if (q >= a && q <= b)
                data[numAccept++] = q;
        }
        this._inUse = numAccept;
    }
    /**
     * * compress out multiple copies of values.
     * * this is done in the current order of the array.
     */
    compressAdjcentDuplicates(tolerance = 0.0) {
        const data = this._data;
        const n = this._inUse;
        if (n === 0)
            return;
        let numAccepted = 1;
        let a = data[0];
        let b;
        for (let i = 1; i < n; i++) {
            b = data[i];
            if (Math.abs(b - a) > tolerance) {
                data[numAccepted++] = b;
                a = b;
            }
        }
        this._inUse = numAccepted;
    }
}
exports.GrowableFloat64Array = GrowableFloat64Array;


/***/ }),

/***/ "./lib/geometry3d/GrowableXYZArray.js":
/*!********************************************!*\
  !*** ./lib/geometry3d/GrowableXYZArray.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module ArraysAndInterfaces */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Point3dVector3d_1 = __webpack_require__(/*! ./Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const IndexedXYZCollection_1 = __webpack_require__(/*! ./IndexedXYZCollection */ "./lib/geometry3d/IndexedXYZCollection.js");
/** Use a Float64Array to pack xyz coordinates. */
class GrowableXYZArray extends IndexedXYZCollection_1.IndexedXYZCollection {
    /** Construct a new GrowablePoint3d array.
     * @param numPoints [in] initial capacity.
     */
    constructor(numPoints = 8) {
        super();
        this._data = new Float64Array(numPoints * 3); // 8 Points to start (3 values each)
        this._inUse = 0;
        this._capacity = numPoints;
    }
    /** @returns Return the number of points in use. */
    get length() { return this._inUse; }
    /** @returns Return the number of float64 in use. */
    get float64Length() { return this._inUse * 3; }
    /** If necessary, increase the capacity to a new pointCount.  Current coordinates and point count (length) are unchnaged. */
    ensureCapacity(pointCapacity) {
        if (pointCapacity > this._capacity) {
            const newData = new Float64Array(pointCapacity * 3);
            const numCopy = this.length * 3;
            for (let i = 0; i < numCopy; i++)
                newData[i] = this._data[i];
            this._data = newData;
            this._capacity = pointCapacity;
        }
    }
    /** Resize the actual point count, preserving excess capacity. */
    resize(pointCount) {
        if (pointCount < this.length) {
            this._inUse = pointCount >= 0 ? pointCount : 0;
        }
        else if (pointCount > this._capacity) {
            const newArray = new Float64Array(pointCount * 3);
            // Copy contents
            for (let i = 0; i < this._data.length; i += 3) {
                newArray[i] = this._data[i];
                newArray[i + 1] = this._data[i + 1];
                newArray[i + 2] = this._data[i + 2];
            }
            this._data = newArray;
            this._capacity = pointCount;
            this._inUse = pointCount;
        }
    }
    /**
     * Make a copy of the (active) points in this array.
     * (The clone does NOT get excess capacity)
     */
    clone() {
        const newPoints = new GrowableXYZArray(this.length);
        const numValue = this.length * 3;
        const newData = newPoints._data;
        const data = this._data;
        for (let i = 0; i < numValue; i++)
            newData[i] = data[i];
        newPoints._inUse = this.length;
        return newPoints;
    }
    static create(data) {
        const newPoints = new GrowableXYZArray(data.length);
        for (const p of data)
            newPoints.push(p);
        return newPoints;
    }
    /** push a point to the end of the array */
    push(toPush) {
        this.pushXYZ(toPush.x, toPush.y, toPush.z);
    }
    /** push all points of an array */
    pushAll(points) {
        for (const p of points)
            this.push(p);
    }
    /**
     * Replicate numWrap xyz values from the front of the array as new values at the end.
     * @param numWrap number of xyz values to replicate
     */
    pushWrap(numWrap) {
        if (this._inUse > 0) {
            let k;
            for (let i = 0; i < numWrap; i++) {
                k = 3 * i;
                this.pushXYZ(this._data[k], this._data[k + 1], this._data[k + 2]);
            }
        }
    }
    pushXYZ(x, y, z) {
        const index = this._inUse * 3;
        if (index >= this._data.length)
            this.ensureCapacity(this.length * 2);
        this._data[index] = x;
        this._data[index + 1] = y;
        this._data[index + 2] = z;
        this._inUse++;
    }
    /** Remove one point from the back. */
    pop() {
        if (this._inUse > 0)
            this._inUse--;
    }
    /**
     * Test if index is valid for an xyz (point or vector) withibn this array
     * @param index xyz index to test.
     */
    isIndexValid(index) {
        if (index >= this._inUse || index < 0)
            return false;
        return true;
    }
    /**
     * Clear all xyz data, but leave capacity unchanged.
     */
    clear() {
        this._inUse = 0;
    }
    /**
     * Get a point by index, strongly typed as a Point3d.  This is unchecked.  Use atPoint3dIndex to have validity test.
     * @param pointIndex index to access
     * @param result optional result
     */
    getPoint3dAt(pointIndex, result) {
        const index = 3 * pointIndex;
        return Point3dVector3d_1.Point3d.create(this._data[index], this._data[index + 1], this._data[index + 2], result);
    }
    /** copy xyz into strongly typed Point3d */
    atPoint3dIndex(pointIndex, result) {
        const index = 3 * pointIndex;
        if (this.isIndexValid(pointIndex)) {
            if (!result)
                result = Point3dVector3d_1.Point3d.create();
            result.x = this._data[index];
            result.y = this._data[index + 1];
            result.z = this._data[index + 2];
            return result;
        }
        return undefined;
    }
    /** copy xyz into strongly typed Vector3d */
    atVector3dIndex(vectorIndex, result) {
        const index = 3 * vectorIndex;
        if (vectorIndex >= 0 && vectorIndex < this._inUse) {
            if (!result)
                result = Point3dVector3d_1.Vector3d.create();
            result.x = this._data[index];
            result.y = this._data[index + 1];
            result.z = this._data[index + 2];
            return result;
        }
        return undefined;
    }
    /**
     * Read coordinates from source array, place them at indexe within this array.
     * @param destIndex point index where coordinats are to be placed in this array
     * @param source source array
     * @param sourceIndex point index in source array
     * @returns true if destIndex and sourceIndex are both valid.
     */
    transferFromGrowableXYZArray(destIndex, source, sourceIndex) {
        if (this.isIndexValid(destIndex) && source.isIndexValid(sourceIndex)) {
            const i = destIndex * 3;
            const j = sourceIndex * 3;
            this._data[i] = source._data[j];
            this._data[i + 1] = source._data[j + 1];
            this._data[i + 2] = source._data[j + 2];
            return true;
        }
        return false;
    }
    /**
     * push coordinates from the source array to the end of this array.
     * @param source source array
     * @param sourceIndex xyz index within the source
     * @returns true if sourceIndex is valid.
     */
    pushFromGrowableXYZArray(source, sourceIndex) {
        if (source.isIndexValid(sourceIndex)) {
            const j = sourceIndex * 3;
            this.pushXYZ(source._data[j], source._data[j + 1], source._data[j + 2]);
            return true;
        }
        return false;
    }
    /**
     * @returns Return the first point, or undefined if the array is empty.
     */
    front(result) {
        if (this._inUse === 0)
            return undefined;
        return this.getPoint3dAt(0, result);
    }
    /**
     * @returns Return the last point, or undefined if the array is empty.
     */
    back(result) {
        if (this._inUse < 1)
            return undefined;
        return this.getPoint3dAt(this._inUse - 1, result);
    }
    /**
     * Set the coordinates of a single point.
     * @param pointIndex index of point to set
     * @param value coordinates to set
     */
    setAt(pointIndex, value) {
        if (!this.isIndexValid(pointIndex))
            return false;
        let index = pointIndex * 3;
        this._data[index++] = value.x;
        this._data[index++] = value.y;
        this._data[index] = value.z;
        return true;
    }
    /**
     * Set the coordinates of a single point given as coordintes
     * @param pointIndex index of point to set
     * @param x x coordinate
     * @param y y coordinate
     * @param z z coordinate
     */
    setCoordinates(pointIndex, x, y, z) {
        if (!this.isIndexValid(pointIndex))
            return false;
        let index = pointIndex * 3;
        this._data[index++] = x;
        this._data[index++] = y;
        this._data[index] = z;
        return true;
    }
    /**
     * @returns Copy all points into a simple array of Point3d
     */
    getPoint3dArray() {
        const result = [];
        const data = this._data;
        const n = this.length;
        for (let i = 0; i < n; i++) {
            result.push(Point3dVector3d_1.Point3d.create(data[i * 3], data[i * 3 + 1], data[i * 3 + 2]));
        }
        return result;
    }
    /** multiply each point by the transform, replace values. */
    transformInPlace(transform) {
        const data = this._data;
        const nDouble = this.float64Length;
        const coffs = transform.matrix.coffs;
        const origin = transform.origin;
        const x0 = origin.x;
        const y0 = origin.y;
        const z0 = origin.z;
        let x = 0;
        let y = 0;
        let z = 0;
        for (let i = 0; i + 3 <= nDouble; i += 3) {
            x = data[i];
            y = data[i + 1];
            z = data[i + 2];
            data[i] = coffs[0] * x + coffs[1] * y + coffs[2] * z + x0;
            data[i + 1] = coffs[3] * x + coffs[4] * y + coffs[5] * z + y0;
            data[i + 2] = coffs[6] * x + coffs[7] * y + coffs[8] * z + z0;
        }
    }
    /** multiply each point by the transform, replace values. */
    tryTransformInverseInPlace(transform) {
        const data = this._data;
        const nDouble = this.float64Length;
        const matrix = transform.matrix;
        matrix.computeCachedInverse(true);
        const coffs = matrix.inverseCoffs;
        if (!coffs)
            return false;
        const origin = transform.origin;
        const x0 = origin.x;
        const y0 = origin.y;
        const z0 = origin.z;
        let x = 0;
        let y = 0;
        let z = 0;
        for (let i = 0; i + 3 <= nDouble; i += 3) {
            x = data[i] - x0;
            y = data[i + 1] - y0;
            z = data[i + 2] - z0;
            data[i] = coffs[0] * x + coffs[1] * y + coffs[2] * z;
            data[i + 1] = coffs[3] * x + coffs[4] * y + coffs[5] * z;
            data[i + 2] = coffs[6] * x + coffs[7] * y + coffs[8] * z;
        }
        return true;
    }
    extendRange(rangeToExtend, transform) {
        const numDouble = this.float64Length;
        const data = this._data;
        if (transform) {
            for (let i = 0; i + 3 <= numDouble; i += 3)
                rangeToExtend.extendTransformedXYZ(transform, data[i], data[i + 1], data[i + 2]);
        }
        else {
            for (let i = 0; i + 3 <= numDouble; i += 3)
                rangeToExtend.extendXYZ(data[i], data[i + 1], data[i + 2]);
        }
    }
    sumLengths() {
        let sum = 0.0;
        const n = 3 * (this._inUse - 1); // Length already takes into account what specifically is in use
        const data = this._data;
        for (let i = 0; i < n; i += 3)
            sum += Geometry_1.Geometry.hypotenuseXYZ(data[i + 3] - data[i], data[i + 4] - data[i + 1], data[i + 5] - data[i + 2]);
        return sum;
    }
    isCloseToPlane(plane, tolerance = Geometry_1.Geometry.smallMetricDistance) {
        const numCoordinate = 3 * this._inUse;
        const data = this._data;
        for (let i = 0; i < numCoordinate; i += 3)
            if (Math.abs(plane.altitudeXYZ(data[i], data[i + 1], data[i + 2])) > tolerance)
                return false;
        return true;
    }
    /** Compute a point at fractional coordinate between points i and j */
    interpolate(i, fraction, j, result) {
        if (this.isIndexValid(i) && this.isIndexValid(j)) {
            const fraction0 = 1.0 - fraction;
            const data = this._data;
            i = 3 * i;
            j = 3 * j;
            return Point3dVector3d_1.Point3d.create(fraction0 * data[i] + fraction * data[j], fraction0 * data[i + 1] + fraction * data[j + 1], fraction0 * data[i + 2] + fraction * data[j + 2], result);
        }
        return undefined;
    }
    /** Sum the signed areas of the projection to xy plane */
    areaXY() {
        let area = 0.0;
        const n = this._data.length - 6; // at least two points needed !!!!
        if (n > 2) {
            const x0 = this._data[0];
            const y0 = this._data[1];
            let dx1 = this._data[3] - x0;
            let dy1 = this._data[4] - y0;
            let dx2 = 0;
            let dy2 = 0;
            for (let i = 6; i < n; i += 3, dx1 = dx2, dy1 = dy2) {
                dx2 = this._data[i] - x0;
                dy2 = this._data[i + 1] - y0;
                area += Geometry_1.Geometry.crossProductXYXY(dx1, dy1, dx2, dy2);
            }
        }
        return 0.5 * area;
    }
    /** Compute a vector from index origin i to indexed target j  */
    vectorIndexIndex(i, j, result) {
        if (!this.isIndexValid(i) || !this.isIndexValid(j))
            return undefined;
        if (!result)
            result = Point3dVector3d_1.Vector3d.create();
        const data = this._data;
        i = 3 * i;
        j = 3 * j;
        result.x = data[j] - data[i];
        result.y = data[j + 1] - data[i + 1];
        result.z = data[j + 2] - data[i + 2];
        return result;
    }
    /** Compute a vector from origin to indexed target j */
    vectorXYAndZIndex(origin, j, result) {
        if (this.isIndexValid(j)) {
            const data = this._data;
            j = 3 * j;
            return Point3dVector3d_1.Vector3d.create(data[j] - origin.x, data[j + 1] - origin.y, data[j + 2] - origin.z, result);
        }
        return undefined;
    }
    /** Compute the cross product of vectors from from indexed origin to indexed targets i and j */
    crossProductIndexIndexIndex(originIndex, targetAIndex, targetBIndex, result) {
        const i = originIndex * 3;
        const j = targetAIndex * 3;
        const k = targetBIndex * 3;
        const data = this._data;
        if (this.isIndexValid(originIndex) && this.isIndexValid(targetAIndex) && this.isIndexValid(targetBIndex))
            return Geometry_1.Geometry.crossProductXYZXYZ(data[j] - data[i], data[j + 1] - data[i + 1], data[j + 2] - data[i + 2], data[k] - data[i], data[k + 1] - data[i + 1], data[k + 2] - data[i + 2], result);
        return undefined;
    }
    /**
     * * compute the cross product from indexed origin t indexed targets targetAIndex and targetB index.
     * * accumulate it to the result.
     */
    accumulateCrossProductIndexIndexIndex(originIndex, targetAIndex, targetBIndex, result) {
        const i = originIndex * 3;
        const j = targetAIndex * 3;
        const k = targetBIndex * 3;
        const data = this._data;
        if (this.isIndexValid(originIndex) && this.isIndexValid(targetAIndex) && this.isIndexValid(targetBIndex))
            result.addCrossProductToTargetsInPlace(data[i], data[i + 1], data[i + 2], data[j], data[j + 1], data[j + 2], data[k], data[k + 1], data[k + 2]);
        return undefined;
    }
    /** Compute the cross product of vectors from from origin to indexed targets i and j */
    crossProductXYAndZIndexIndex(origin, targetAIndex, targetBIndex, result) {
        const j = targetAIndex * 3;
        const k = targetBIndex * 3;
        const data = this._data;
        if (this.isIndexValid(targetAIndex) && this.isIndexValid(targetBIndex))
            return Geometry_1.Geometry.crossProductXYZXYZ(data[j] - origin.x, data[j + 1] - origin.y, data[j + 2] - origin.z, data[k] - origin.x, data[k + 1] - origin.y, data[k + 2] - origin.z, result);
        return undefined;
    }
    /** Return the distance between two points in the array. */
    distance(i, j) {
        if (i >= 0 && i < this._inUse && j >= 0 && j <= this._inUse) {
            const i0 = 3 * i;
            const j0 = 3 * j;
            return Geometry_1.Geometry.hypotenuseXYZ(this._data[j0] - this._data[i0], this._data[j0 + 1] - this._data[i0 + 1], this._data[j0 + 2] - this._data[i0 + 2]);
        }
        return undefined;
    }
    /** Return the distance between an array point and the input point. */
    distanceIndexToPoint(i, spacePoint) {
        if (i >= 0 && i < this._inUse) {
            const i0 = 3 * i;
            return Geometry_1.Geometry.hypotenuseXYZ(spacePoint.x - this._data[i0], spacePoint.y - this._data[i0 + 1], spacePoint.z - this._data[i0 + 2]);
        }
        return undefined;
    }
    static isAlmostEqual(dataA, dataB) {
        if (dataA && dataB) {
            if (dataA.length !== dataB.length)
                return false;
            for (let i = 0; i < dataA.length; i++)
                if (!dataA.getPoint3dAt(i).isAlmostEqual(dataB.getPoint3dAt(i)))
                    return false;
            return true;
        }
        // if both are null it is equal, otherwise unequal
        return (!dataA && !dataB);
    }
    /** Return an array of block indices sorted per compareLexicalBlock function */
    sortIndicesLexical() {
        const n = this._inUse;
        // let numCompare = 0;
        const result = new Uint32Array(n);
        for (let i = 0; i < n; i++)
            result[i] = i;
        result.sort((blockIndexA, blockIndexB) => {
            // numCompare++;
            return this.compareLexicalBlock(blockIndexA, blockIndexB);
        });
        // console.log (n, numCompare);
        return result;
    }
    /** compare two blocks in simple lexical order. */
    compareLexicalBlock(ia, ib) {
        let ax = 0;
        let bx = 0;
        for (let i = 0; i < 3; i++) {
            ax = this._data[ia * 3 + i];
            bx = this._data[ib * 3 + i];
            if (ax > bx)
                return 1;
            if (ax < bx)
                return -1;
        }
        return ia - ib; // so original order is maintained among duplicates !!!!
    }
    /** Access a single double at offset within a block.  This has no index checking. */
    component(pointIndex, componentIndex) {
        return this._data[3 * pointIndex + componentIndex];
    }
}
exports.GrowableXYZArray = GrowableXYZArray;


/***/ }),

/***/ "./lib/geometry3d/IndexedXYZCollection.js":
/*!************************************************!*\
  !*** ./lib/geometry3d/IndexedXYZCollection.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * abstract base class for access to XYZ data with indexed reference.
 * * This allows algorithms to work with Point3d[] or GrowableXYZ.
 * ** GrowableXYZArray implements these for its data.
 * ** Point3dArrayCarrier carries a (reference to) a Point3d[] and implements the methods with calls on that array reference.
 * * In addition to "point by point" accessors, there abstract members compute commonly useful vector data "between points".
 * * Methods that create vectors among multiple indices allow callers to avoid creating temporaries.
*/
class IndexedXYZCollection {
}
exports.IndexedXYZCollection = IndexedXYZCollection;


/***/ }),

/***/ "./lib/geometry3d/Matrix3d.js":
/*!************************************!*\
  !*** ./lib/geometry3d/Matrix3d.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Angle_1 = __webpack_require__(/*! ./Angle */ "./lib/geometry3d/Angle.js");
const Point4d_1 = __webpack_require__(/*! ../geometry4d/Point4d */ "./lib/geometry4d/Point4d.js");
const Point2dVector2d_1 = __webpack_require__(/*! ./Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ./Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Transform_1 = __webpack_require__(/*! ./Transform */ "./lib/geometry3d/Transform.js");
/**
 * PackedMatrix3dOps contains static methods for matrix operations where the matrix is a Float64Array.
 * * The Float64Array contains the matrix entries in row-major order
 */
class PackedMatrix3dOps {
    /**
     * Load 9 doubles into the packed format.
     * @param dest destination, allocated by caller
     * @param a00 row 0, column 0 entry
     * @param a01 row 0, column 1 entry
     * @param a02 row 0, column 2 entry
     * @param a10 row 1, column 0 entry
     * @param a11 row 1, column 1 entry
     * @param a12 row 1, column 2 entry
     * @param a20 row 2, column 0 entry
     * @param a21 row 2, column 1 entry
     * @param a22 row 2, column 2 entry
     */
    static loadMatrix(dest, a00, a01, a02, a10, a11, a12, a20, a21, a22) {
        dest[0] = a00;
        dest[1] = a01;
        dest[2] = a02;
        dest[3] = a10;
        dest[4] = a11;
        dest[5] = a12;
        dest[6] = a20;
        dest[7] = a21;
        dest[8] = a22;
    }
    /**
     * * multiply 3x3 matrix `a*b`, store in c.
     * * All params assumed length 9, allocated by caller.
     * * c may alias either input.
     */
    static multiplyMatrixMatrix(a, b, result) {
        if (!result)
            result = new Float64Array(9);
        PackedMatrix3dOps.loadMatrix(result, (a[0] * b[0] + a[1] * b[3] + a[2] * b[6]), (a[0] * b[1] + a[1] * b[4] + a[2] * b[7]), (a[0] * b[2] + a[1] * b[5] + a[2] * b[8]), (a[3] * b[0] + a[4] * b[3] + a[5] * b[6]), (a[3] * b[1] + a[4] * b[4] + a[5] * b[7]), (a[3] * b[2] + a[4] * b[5] + a[5] * b[8]), (a[6] * b[0] + a[7] * b[3] + a[8] * b[6]), (a[6] * b[1] + a[7] * b[4] + a[8] * b[7]), (a[6] * b[2] + a[7] * b[5] + a[8] * b[8]));
        return result;
    }
    /**
     * * multiply 3x3 matrix `a*bTranspose`, store in c.
     * * All params assumed length 9, allocated by caller.
     * * c may alias either input.
     */
    static multiplyMatrixMatrixTranspose(a, b, result) {
        if (!result)
            result = new Float64Array(9);
        PackedMatrix3dOps.loadMatrix(result, (a[0] * b[0] + a[1] * b[1] + a[2] * b[2]), (a[0] * b[3] + a[1] * b[4] + a[2] * b[5]), (a[0] * b[6] + a[1] * b[7] + a[2] * b[8]), (a[3] * b[0] + a[4] * b[1] + a[5] * b[2]), (a[3] * b[3] + a[4] * b[4] + a[5] * b[5]), (a[3] * b[6] + a[4] * b[7] + a[5] * b[8]), (a[6] * b[0] + a[7] * b[1] + a[8] * b[2]), (a[6] * b[3] + a[7] * b[4] + a[8] * b[5]), (a[6] * b[6] + a[7] * b[7] + a[8] * b[8]));
        return result;
    }
    /**
     * * multiply 3x3 matrix `a*bTranspose`, store in c.
     * * All params assumed length 9, allocated by caller.
     * * c may alias either input.
     */
    static multiplyMatrixTransposeMatrix(a, b, result) {
        if (!result)
            result = new Float64Array(9);
        PackedMatrix3dOps.loadMatrix(result, (a[0] * b[0] + a[3] * b[3] + a[6] * b[6]), (a[0] * b[1] + a[3] * b[4] + a[6] * b[7]), (a[0] * b[2] + a[3] * b[5] + a[6] * b[8]), (a[1] * b[0] + a[4] * b[3] + a[7] * b[6]), (a[1] * b[1] + a[4] * b[4] + a[7] * b[7]), (a[1] * b[2] + a[4] * b[5] + a[7] * b[8]), (a[2] * b[0] + a[5] * b[3] + a[8] * b[6]), (a[2] * b[1] + a[5] * b[4] + a[8] * b[7]), (a[2] * b[2] + a[5] * b[5] + a[8] * b[8]));
        return result;
    }
    /** transpose 3x3 coefficients in place */
    static transposeInPlace(a) {
        let q = a[1];
        a[1] = a[3];
        a[3] = q;
        q = a[2];
        a[2] = a[6];
        a[6] = q;
        q = a[5];
        a[5] = a[7];
        a[7] = q;
    }
    /** transpose 3x3 coefficients in place */
    static copyTransposed(a, dest) {
        if (dest === a) {
            PackedMatrix3dOps.transposeInPlace(a);
        }
        else {
            if (!dest)
                dest = new Float64Array(9);
            dest[0] = a[0];
            dest[1] = a[3];
            dest[2] = a[6];
            dest[3] = a[1];
            dest[4] = a[4];
            dest[5] = a[7];
            dest[6] = a[2];
            dest[7] = a[5];
            dest[8] = a[8];
        }
        return dest;
    }
}
/** A Matrix3d is tagged indicating one of the following states:
 * * unknown: it is not know if the matrix is invertible.
 * * inverseStored: the matrix has its inverse stored
 * * singular: the matrix is known to be singular.
 */
var InverseMatrixState;
(function (InverseMatrixState) {
    InverseMatrixState[InverseMatrixState["unknown"] = 0] = "unknown";
    InverseMatrixState[InverseMatrixState["inverseStored"] = 1] = "inverseStored";
    InverseMatrixState[InverseMatrixState["singular"] = 2] = "singular";
})(InverseMatrixState = exports.InverseMatrixState || (exports.InverseMatrixState = {}));
/** A Matrix3d is a 3x3 matrix.
 * * A very common use is to hold a rigid body rotation (which has no scaling or skew), but the 3x3 contents can
 * also hold scaling and skewing.
 * * The 9 entries are stored in row-major order in the coffs array.
 * * If the matrix inverse is known it is stored in the inverseCoffs array.
 * * The inverse status (unknown, inverseStored, singular) status is indicated by the inverseState property.
 * * constructions method that are able to determine the inverse store it immediately and
 *     note that in the inverseState.
 * * constructions (e.g. createRowValues) for which the inverse is not immediately known mark the
 *     inverseState as unknown.
 * * Later queries for the inverse trigger full computation if needed at that time.
 * * Most matrix queries are present with both "column" and "row" variants.
 * * Usage elsewhere in the library is typically "column" based.  For example, in a Transform
 *     that carries a coordinate frame the matrix columns are the unit vectors for the axes.
 */
class Matrix3d {
    /**
     *
     * @param coffs optional coefficient array.  This is captured.
     */
    constructor(coffs) {
        this.coffs = coffs ? coffs : new Float64Array(9);
        this.inverseCoffs = undefined;
        this.inverseState = InverseMatrixState.unknown;
    }
    /** The identity Matrix3d. Value is frozen and cannot be modified. */
    static get identity() {
        if (undefined === this._identity) {
            this._identity = Matrix3d.createIdentity();
            this._identity.freeze();
        }
        return this._identity;
    }
    /** Freeze this Matrix3d. */
    freeze() {
        this.computeCachedInverse(true);
        /* hm.. can't freeze the Float64Arrays . . .
        Object.freeze(this.coffs);
        if (this.inverseCoffs)
          Object.freeze(this.inverseCoffs);
        */
        Object.freeze(this);
    }
    /** Return a json object containing the 9 numeric entries as a single array in row major order,
     * `[ [1, 2, 3],[ 4, 5, 6], [7, 8, 9] ]`
     */
    toJSON() {
        return [[this.coffs[0], this.coffs[1], this.coffs[2]],
            [this.coffs[3], this.coffs[4], this.coffs[5]],
            [this.coffs[6], this.coffs[7], this.coffs[8]]];
    }
    setFromJSON(json) {
        this.inverseCoffs = undefined;
        if (!json) {
            this.setRowValues(0, 0, 0, 0, 0, 0, 0, 0, 0);
            return;
        }
        if (!Array.isArray(json)) {
            if (json instanceof Matrix3d)
                this.setFrom(json);
            return;
        }
        if (Geometry_1.Geometry.isArrayOfNumberArray(json, 3, 3)) {
            const data = json;
            this.setRowValues(data[0][0], data[0][1], data[0][2], data[1][0], data[1][1], data[1][2], data[2][0], data[2][1], data[2][2]);
            return;
        }
        if (json.length === 9) {
            const data = json;
            this.setRowValues(data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8]);
        }
        else if (json.length === 4) {
            const data = json;
            this.setRowValues(data[0], data[1], 0, data[2], data[3], 0, 0, 0, 1);
        }
    }
    /** @returns Return a new Matrix3d constructed from contents of the json value. */
    static fromJSON(json) { const result = Matrix3d.createIdentity(); result.setFromJSON(json); return result; }
    /** Test if this Matrix3d and other are within tolerance in all numeric entries.
     * @param tol optional tolerance for comparisons by Geometry.isDistanceWithinTol
     */
    isAlmostEqual(other, tol) {
        if (tol)
            return Geometry_1.Geometry.isDistanceWithinTol(this.maxDiff(other), tol);
        return Geometry_1.Geometry.isSmallMetricDistance(this.maxDiff(other));
    }
    /** Test for exact (bitwise) equality with other. */
    isExactEqual(other) { return this.maxDiff(other) === 0.0; }
    /** test if all entries in the z row and column are exact 001, i.e. the matrix only acts in 2d */
    get isXY() {
        return this.coffs[2] === 0.0
            && this.coffs[5] === 0.0
            && this.coffs[6] === 0.0
            && this.coffs[7] === 0.0
            && this.coffs[8] === 1.0;
    }
    // !! does not clear supplied result !!
    static _create(result) { return result ? result : new Matrix3d(); }
    /** @returns a Matrix3d populated by numeric values given in row-major order.
     *  set all entries in the matrix from call parameters appearing in row - major order.
     * @param axx Row x, column x(0, 0) entry
     * @param axy Row x, column y(0, 1) entry
     * @param axz Row x, column z(0, 2) entry
     * @param ayx Row y, column x(1, 0) entry
     * @param ayy Row y, column y(1, 1) entry
     * @param ayz Row y, column z(1, 2) entry
     * @param azx Row z, column x(2, 0) entry
     * @param azy Row z, column y(2, 2) entry
     * @param azz row z, column z(2, 3) entry
     */
    static createRowValues(axx, axy, axz, ayx, ayy, ayz, azx, azy, azz, result) {
        result = result ? result : new Matrix3d();
        result.inverseState = InverseMatrixState.unknown;
        result.coffs[0] = axx;
        result.coffs[1] = axy;
        result.coffs[2] = axz;
        result.coffs[3] = ayx;
        result.coffs[4] = ayy;
        result.coffs[5] = ayz;
        result.coffs[6] = azx;
        result.coffs[7] = azy;
        result.coffs[8] = azz;
        return result;
    }
    /**
     * Create a Matrix3d with caller-supplied coefficients and optional inverse coefficients.
     * * The inputs are captured into the new Matrix3d.
     * * The caller is responsible for validity of the inverse coefficients.
     * @param coffs (required) array of 9 coefficients.
     * @param inverseCoffs (optional) array of 9 coefficients.
     * @returns a Matrix3d populated by a coffs array.
     */
    static createCapture(coffs, inverseCoffs) {
        const result = new Matrix3d(coffs);
        if (inverseCoffs) {
            result.inverseCoffs = inverseCoffs;
            result.inverseState = InverseMatrixState.inverseStored;
        }
        else {
            result.inverseState = InverseMatrixState.unknown;
        }
        return result;
    }
    // install all matrix entries.
    static createColumnsInAxisOrder(axisOrder, columnA, columnB, columnC, result) {
        if (!result)
            result = new Matrix3d();
        if (axisOrder === 1 /* YZX */) {
            result.setColumns(columnC, columnA, columnB);
        }
        else if (axisOrder === 2 /* ZXY */) {
            result.setColumns(columnB, columnC, columnA);
        }
        else if (axisOrder === 4 /* XZY */) {
            result.setColumns(columnA, columnC, columnB);
        }
        else if (axisOrder === 5 /* YXZ */) {
            result.setColumns(columnB, columnA, columnC);
        }
        else if (axisOrder === 6 /* ZYX */) {
            result.setColumns(columnC, columnB, columnA);
        }
        else { // fallthrough should only happen for AxisOrder.XYZ
            result.setColumns(columnA, columnB, columnC);
        }
        return result;
    }
    /**
     *  set all entries in the matrix from call parameters appearing in row-major order.
     * @param axx Row x, column x (0,0) entry
     * @param axy Row x, column y (0,1) entry
     * @param axz Row x, column z (0,2) entry
     * @param ayx Row y, column x (1,0) entry
     * @param ayy Row y, column y (1,1) entry
     * @param ayz Row y, column z (1,2) entry
     * @param azx Row z, column x (2,0) entry
     * @param azy Row z, column y (2,2) entry
     * @param azz row z, column z (2,3) entry
     */
    setRowValues(axx, axy, axz, ayx, ayy, ayz, azx, azy, azz) {
        this.coffs[0] = axx;
        this.coffs[1] = axy;
        this.coffs[2] = axz;
        this.coffs[3] = ayx;
        this.coffs[4] = ayy;
        this.coffs[5] = ayz;
        this.coffs[6] = azx;
        this.coffs[7] = azy;
        this.coffs[8] = azz;
        this.inverseState = InverseMatrixState.unknown;
    }
    setIdentity() { this.setRowValues(1, 0, 0, 0, 1, 0, 0, 0, 1); this.setupInverseTranspose(); }
    setZero() { this.setRowValues(0, 0, 0, 0, 0, 0, 0, 0, 0); this.inverseState = InverseMatrixState.singular; }
    setFrom(other) {
        for (let i = 0; i < 9; i++)
            this.coffs[i] = other.coffs[i];
        this.inverseState = InverseMatrixState.unknown; // we don't trust the other .. . .
    }
    clone(result) {
        result = result ? result : new Matrix3d();
        result.setFrom(this);
        return result;
    }
    static createZero() {
        const retVal = new Matrix3d();
        retVal.inverseState = InverseMatrixState.singular;
        return retVal;
    }
    static createIdentity(result) {
        result = result ? result : new Matrix3d();
        result.setIdentity();
        return result;
    }
    /** Create a matrix with uniform scale factors */
    static createUniformScale(scaleFactor) {
        return Matrix3d.createScale(scaleFactor, scaleFactor, scaleFactor);
    }
    /**
     *
     * *  use createHeadsUpPerpendicular to generate a vectorV perpendicular to vectorA
     * *  construct a frame using createRigidFromColumns (vectorA, vectorB, axisOrder)
     */
    static createRigidHeadsUp(vectorA, axisOrder = 2 /* ZXY */, result) {
        const vectorB = Matrix3d.createPerpendicularVectorFavorXYPlane(vectorA);
        const matrix = Matrix3d.createRigidFromColumns(vectorA, vectorB, axisOrder, result);
        if (matrix) {
            matrix.setupInverseTranspose();
            return matrix;
        }
        return Matrix3d.createIdentity(result);
    }
    /**
     *
     * * return a vector that is perpendicular to the input direction.
     * * Among the infinite number of perpendiculars possible, this method
     * favors having one in the xy plane.
     * * Hence, when vectorA is NOT close to the Z axis, the returned vector is Z cross vectorA.
     * * But vectorA is close to the Z axis, the returned vector is unitY cross vectorA.
     */
    static createPerpendicularVectorFavorXYPlane(vector, result) {
        const a = vector.magnitude();
        const b = a / 64.0; // A constant from the dawn of time in the CAD industry.
        if (Math.abs(vector.x) < b && Math.abs(vector.y) < b) {
            return Point3dVector3d_1.Vector3d.createCrossProduct(vector.x, vector.y, vector.z, 0, -1, 0, result);
        }
        return Point3dVector3d_1.Vector3d.createCrossProduct(0, 0, 1, vector.x, vector.y, vector.z, result);
    }
    /**
     *
     * * return a vector that is perpendicular to the input direction.
     * * Among the infinite number of perpendiculars possible, this method
     * favors having one near the Z.
     * That is achieved by crossing "this" vector with the result of createHeadsUpPerpendicularFavorXYPlane.
     */
    static createPerpendicularVectorFavorPlaneContainingZ(vector, result) {
        result = Matrix3d.createPerpendicularVectorFavorXYPlane(vector, result);
        return vector.crossProduct(result, result);
    }
    /** Create a matrix with distinct x,y,z diagonal (scale) entries */
    static createScale(scaleFactorX, scaleFactorY, scaleFactorZ, result) {
        if (result)
            result.setZero();
        else
            result = new Matrix3d();
        result.coffs[0] = scaleFactorX;
        result.coffs[4] = scaleFactorY;
        result.coffs[8] = scaleFactorZ;
        if (scaleFactorX === 0 || scaleFactorY === 0 || scaleFactorZ === 0) {
            result.inverseState = InverseMatrixState.singular;
        }
        else {
            result.inverseState = InverseMatrixState.inverseStored;
            result.inverseCoffs = Float64Array.from([1 / scaleFactorX, 0, 0,
                0, 1 / scaleFactorY, 0,
                0, 0, 1 / scaleFactorZ]);
        }
        return result;
    }
    /** @returns return a rotation of specified angle around an axis */
    static createRotationAroundVector(axis, angle, result) {
        const c = angle.cos();
        const s = angle.sin();
        const v = 1.0 - c;
        const unit = axis.normalize();
        if (unit) {
            const retVal = Matrix3d.createRowValues(unit.x * unit.x * v + c, unit.x * unit.y * v - s * unit.z, unit.x * unit.z * v + s * unit.y, unit.y * unit.x * v + s * unit.z, unit.y * unit.y * v + c, unit.y * unit.z * v - s * unit.x, unit.z * unit.x * v - s * unit.y, unit.z * unit.y * v + s * unit.x, unit.z * unit.z * v + c, result);
            retVal.setupInverseTranspose();
            return retVal;
        }
        return undefined;
    }
    /** @returns return a rotation of specified angle around an axis
     * @param axisIndex index of axis (AxisIndex.X, AxisIndex.Y, AxisIndex.Z) kept fixed by the rotation.
     * @param angle angle of rotation
     * @param result optional result matrix.
     */
    static createRotationAroundAxisIndex(axisIndex, angle, result) {
        const c = angle.cos();
        const s = angle.sin();
        let myResult;
        if (axisIndex === 0 /* X */) {
            myResult = Matrix3d.createRowValues(1, 0, 0, 0, c, -s, 0, s, c, result);
        }
        else if (axisIndex === 1 /* Y */) {
            myResult = Matrix3d.createRowValues(c, 0, s, 0, 1, 0, -s, 0, c, result);
        }
        else {
            myResult = Matrix3d.createRowValues(c, -s, 0, s, c, 0, 0, 0, 1, result);
        }
        myResult.setupInverseTranspose();
        return myResult;
    }
    /** Create a matrix with
     * * ColumnX points in the rightVector direction
     * * ColumnY points in in the upVectorDirection
     * * ColumnZ is a unit cross product.
     * Optinoally rotate the standard cube by 45 to bring its left or right vertical edge to center
     * * leftNoneRight = [-1,0,1] respectively for left edge, no rotation, or right edge
     * * bottomNoneTop = [-1,0,1] respectively for isometric rotation to view the bottom, no isometric rotation, and isometric rotation to view the top
     * This is expected to be used with various principal unit vectors that are perpendicular to each other.
     *  * STANDARD TOP VIEW: (Vector3d.UnitX (), Vector3d.UnitY (), 0, 0)
     *  * STANDARD FRONT VIEW: (Vector3d.UnitX (), Vector3d.UnitZ (), 0, 0)
     *  * STANDARD BACK VIEW: (Vector3d.UnitX (-1), Vector3d.UnitZ (), 0, 0)
     *  * STANDARD RIGHT VIEW: (Vector3d.UnitY (1), Vector3d.UnitZ (), 0, 0)
     *  * STANDARD LEFT VIEW: (Vector3d.UnitY (-1), Vector3d.UnitZ (), 0, 0)
     *  * STANDARD BOTTOM VIEW: (Vector3d.UnitX (1), Vector3d.UnitY (-1), 0, 0)
     * @param leftNoneRight Normally one of {-1,0,1}, where (-1) indicates the left vertical is rotated to center and (1) for right.  Other numbers are used as multiplier for this 45 degree rotation
     * @returns undefined if columNX, columnY are coplanar.
     */
    static createViewedAxes(rightVector, upVector, leftNoneRight = 0, topNoneBottom = 0) {
        const columnZ = rightVector.crossProduct(upVector);
        if (columnZ.normalizeInPlace()) {
            const geometry = Matrix3d.createColumns(rightVector, upVector, columnZ);
            if (leftNoneRight !== 0.0) {
                let c = Math.sqrt(0.5);
                let s = leftNoneRight < 0.0 ? -c : c;
                if (Math.abs(leftNoneRight) !== 1.0) {
                    const radians = Angle_1.Angle.degreesToRadians(45.0 * leftNoneRight);
                    c = Math.cos(radians);
                    s = Math.sin(radians);
                }
                geometry.applyGivensColumnOp(2, 0, c, s); // rotate around Y
            }
            if (topNoneBottom !== 0.0) {
                const theta = topNoneBottom * Math.atan(Math.sqrt(0.5));
                const c = Math.cos(theta);
                const s = Math.sin(theta);
                geometry.applyGivensColumnOp(1, 2, c, -s); // rotate around X
            }
            return geometry;
        }
        return undefined;
    }
    /**
     * Create a rotation matrix for one of the 8 standard views.
     * * With `invert === false` the return is such that `matrix.multiply(worldVector)` returns the vector as seen in the xy (projected) coordinates of the view.
     * * With invert === true the matrix is transposed so that `matrix.mutiply(viewVector` maps the "in view" vector to a world vector.
     *
     * @param index standard veiw index `StandardViewIndex.Top, Bottom, LEft, Right, Front, Back, Iso, LeftIso`
     * @param invert if false (default), the returned Matrix3d "projects" world vectors into XY view vectors.  If true, it is inverted to map view vectors to world.
     * @param result optional result.
     */
    static createStandardWorldToView(index, invert = false, result) {
        switch (index) {
            case 2 /* Bottom */:
                result = Matrix3d.createRowValues(1, 0, 0, 0, -1, 0, 0, 0, -1);
                break;
            case 3 /* Left */:
                result = Matrix3d.createRowValues(0, -1, 0, 0, 0, 1, -1, 0, 0);
                break;
            case 4 /* Right */:
                result = Matrix3d.createRowValues(0, 1, 0, 0, 0, 1, 1, 0, 0);
                break;
            case 5 /* Front */: // 0-based 4
                result = Matrix3d.createRowValues(1, 0, 0, 0, 0, 1, 0, -1, 0);
                break;
            case 6 /* Back */: // 0-based 5
                result = Matrix3d.createRowValues(-1, 0, 0, 0, 0, 1, 0, 1, 0);
                break;
            case 7 /* Iso */:
                result = Matrix3d.createRowValues(0.707106781186548, -0.70710678118654757, 0.00000000000000000, 0.408248290463863, 0.40824829046386302, 0.81649658092772603, -0.577350269189626, -0.57735026918962573, 0.57735026918962573);
                break;
            case 8 /* RightIso */:
                result = Matrix3d.createRowValues(0.707106781186548, 0.70710678118654757, 0.00000000000000000, -0.408248290463863, 0.40824829046386302, 0.81649658092772603, 0.577350269189626, -0.57735026918962573, 0.57735026918962573);
                break;
            case 1 /* Top */:
            default:
                result = Matrix3d.createIdentity(result);
        }
        if (invert)
            result.transposeInPlace();
        return result;
    }
    /*
    // this implementation has problems distinguishing failure (normalize) from small angle.
    public getAxisAndAngleOfRotation(): { axis: Vector3d, angle: Angle, error: boolean } {
  
      const result = { axis: Vector3d.unitZ(), angle: Angle.createRadians(0), error: true };
      if (this.isIdentity()) {
        result.error = false;
        return result;
      }
      if (!this.isRigid())
        return result;
      const QminusI = this.clone();
      QminusI.coffs[0] -= 1.0;
      QminusI.coffs[4] -= 1.0;
      QminusI.coffs[8] -= 1.0;
      // Each column of (Q - I) is the motion of the corresponding axis vector
      // during the rotation.
      // Only one of the three axes can really be close to the rotation axis.
      const delta0 = QminusI.columnX();
      const delta1 = QminusI.columnY();
      const delta2 = QminusI.columnZ();
      const cross01 = delta0.crossProduct(delta1);
      const cross12 = delta1.crossProduct(delta2);
      const cross20 = delta2.crossProduct(delta0);
  
      const aa01 = cross01.magnitudeSquared();
      const aa12 = cross12.magnitudeSquared();
      const aa20 = cross20.magnitudeSquared();
  
      const cross = cross01.clone(); // This will end up as the biggest cross product
      const v0 = delta0.clone();  // This will end up as one of the two largest delta vectors
      let aaMax = aa01;
      if (aa12 > aaMax) {
        cross.setFrom(cross12);
        aaMax = aa12;
        v0.setFrom(delta1);
      }
      if (aa20 > aaMax) {
        cross.setFrom(cross20);
        aaMax = aa20;
        v0.setFrom(delta2);
      }
  
      if (aaMax === 0.0) {
        // The vectors did not move.  Just accept the zero rotation, with error flag set.
        return result;
      }
  
      v0.normalizeInPlace();
      // V0 is a unit vector perpendicular to the rotation axis.
      // Rotate it.   Its image V1 is also a unit vector, and the angle from V0 to V1 is the quat angle.
      // CrossProduct is axis vector times sine of angle.
      // Dot Product is cosine of angle.
      // V2 is zero in 180 degree case, so we use the Cross from the search as the axis
      //   as direction, being careful to keep sine positive.
      const v1 = this.multiplyVector(v0);
      const v2 = v0.crossProduct(v1);
      const sine = v2.magnitude();
      if (v2.dotProduct(cross) < 0.0)
        cross.scaleInPlace(-1.0);
      const cosine = v0.dotProduct(v1);
      result.angle.setRadians(Math.atan2(sine, cosine));
      result.axis.setFrom(cross);
      result.error = !result.axis.tryNormalizeInPlace();
      return result;
    }
  */
    /**
     * Compute the (unit vector) axis and angle of rotation.
     * @returns Returns with result.ok === true when the conversion succeeded.
     */
    getAxisAndAngleOfRotation() {
        const trace = this.coffs[0] + this.coffs[4] + this.coffs[8];
        // trace = (xx + yy * zz) * (1-c) + 3 * c = 1 + 2c ==> c = (trace-1) / 2
        const skewXY = this.coffs[3] - this.coffs[1]; // == 2sz
        const skewYZ = this.coffs[7] - this.coffs[5]; // == 2sx
        const skewZX = this.coffs[2] - this.coffs[6]; // == 2sy
        const c = (trace - 1.0) / 2.0;
        const s = Geometry_1.Geometry.hypotenuseXYZ(skewXY, skewYZ, skewZX) / 2.0;
        const e = c * c + s * s - 1.0;
        if (Math.abs(e) > Geometry_1.Geometry.smallAngleRadians) {
            // the sine and cosine are not a unit circle point.   bad matrix . ..
            return { axis: Point3dVector3d_1.Vector3d.create(0, 0, 1), angle: Angle_1.Angle.createRadians(0), ok: false };
        }
        if (Math.abs(s) < Geometry_1.Geometry.smallAngleRadians) {
            // There is no significant skew.
            // The matrix is symmetric
            // So it has simple eigenvalues -- either (1,1,1) or (1,-1,-1).
            if (c > 0) // no rotation
                return { axis: Point3dVector3d_1.Vector3d.create(0, 0, 1), angle: Angle_1.Angle.createRadians(0), ok: true };
            // 180 degree flip around some axis ?
            // Look for the simple case of a principal rotation ...
            // look for a pair of (-1) entries on the diagonal ...
            const axx = this.coffs[0];
            const ayy = this.coffs[4];
            const azz = this.coffs[8];
            const theta180 = Angle_1.Angle.createDegrees(180);
            // Look for principal axis flips as a special case . ..
            if (Geometry_1.Geometry.isAlmostEqualNumber(-1.0, ayy) && Geometry_1.Geometry.isAlmostEqualNumber(-1, azz)) {
                // rotate around
                return { axis: Point3dVector3d_1.Vector3d.create(1, 0, 0), angle: theta180, ok: true };
            }
            else if (Geometry_1.Geometry.isAlmostEqualNumber(-1.0, axx) && Geometry_1.Geometry.isAlmostEqualNumber(-1, azz)) {
                return { axis: Point3dVector3d_1.Vector3d.create(0, 1, 0), angle: theta180, ok: true };
            }
            else if (Geometry_1.Geometry.isAlmostEqualNumber(-1.0, axx) && Geometry_1.Geometry.isAlmostEqualNumber(-1, ayy)) {
                return { axis: Point3dVector3d_1.Vector3d.create(0, 0, 1), angle: theta180, ok: true };
            }
            // 180 degree flip around some other axis ...
            // eigenvalues will have 1.0 once, -1.0 twice.
            // These cases look for each place (x,y,z) that the 1.0 might appear.
            // But fastSymmetricEigenvalues reliably always seems to put the 1.0 as the x eigenvalue.
            // so only the getColumn(0) return seems reachable in unit tests.
            const eigenvectors = Matrix3d.createIdentity();
            const eigenvalues = Point3dVector3d_1.Vector3d.create(0, 0, 0);
            if (this.fastSymmetricEigenvalues(eigenvectors, eigenvalues)) {
                for (let axisIndex = 0; axisIndex < 2; axisIndex++) {
                    const lambda = eigenvalues.at(axisIndex);
                    if (Geometry_1.Geometry.isAlmostEqualNumber(1, lambda))
                        return { axis: eigenvectors.getColumn(axisIndex), angle: theta180, ok: true };
                }
                // Don't know if this can be reached ....
                return { axis: Point3dVector3d_1.Vector3d.create(0, 0, 1), angle: Angle_1.Angle.createRadians(0), ok: false };
            }
            return { axis: Point3dVector3d_1.Vector3d.create(0, 0, 1), angle: Angle_1.Angle.createRadians(0), ok: false };
        }
        const a = 1.0 / (2.0 * s);
        const result = { axis: Point3dVector3d_1.Vector3d.create(skewYZ * a, skewZX * a, skewXY * a), angle: Angle_1.Angle.createAtan2(s, c), ok: true };
        return result;
    }
    /**
     * @returns return a matrix that rotates from vectorA to vectorB.
     */
    static createRotationVectorToVector(vectorA, vectorB, result) {
        return this.createPartialRotationVectorToVector(vectorA, 1.0, vectorB, result);
    }
    /**
     * Return a matrix that rotates a fraction of the angular sweep from vectorA to vectorB.
     * @param vectorA initial vector position
     * @param fraction fractional rotation.  1.0 is "all the way"
     * @param vectorB final vector position
     * @param result optional result matrix.
     */
    static createPartialRotationVectorToVector(vectorA, fraction, vectorB, result) {
        let upVector = vectorA.unitCrossProduct(vectorB);
        if (upVector) { // the usual case --
            return Matrix3d.createRotationAroundVector(upVector, Angle_1.Angle.createRadians(fraction * vectorA.planarAngleTo(vectorB, upVector).radians));
        }
        // fail if either vector is zero ...
        if (Geometry_1.Geometry.isSmallMetricDistance(vectorA.magnitude())
            || Geometry_1.Geometry.isSmallMetricDistance(vectorB.magnitude()))
            return undefined;
        // nonzero but aligned vectors ...
        if (vectorA.dotProduct(vectorB) > 0.0)
            return Matrix3d.createIdentity(result);
        // nonzero opposing vectors ..
        upVector = Matrix3d.createPerpendicularVectorFavorPlaneContainingZ(vectorA, upVector);
        return Matrix3d.createRotationAroundVector(upVector, Angle_1.Angle.createRadians(fraction * Math.PI));
    }
    /** Create a 90 degree rotation around a principal axis */
    static create90DegreeRotationAroundAxis(axisIndex) {
        axisIndex = Geometry_1.Geometry.cyclic3dAxis(axisIndex);
        if (axisIndex === 0) {
            const retVal = Matrix3d.createRowValues(1, 0, 0, 0, 0, -1, 0, 1, 0);
            retVal.setupInverseTranspose();
            return retVal;
        }
        else if (axisIndex === 1) {
            const retVal = Matrix3d.createRowValues(0, 0, 1, 0, 1, 0, -1, 0, 0);
            retVal.setupInverseTranspose();
            return retVal;
        }
        else {
            const retVal = Matrix3d.createRowValues(0, -1, 0, 1, 0, 0, 0, 0, 1);
            retVal.setupInverseTranspose();
            return retVal;
        }
    }
    /** @returns Return (a copy of) the X column */
    columnX(result) { return Point3dVector3d_1.Vector3d.create(this.coffs[0], this.coffs[3], this.coffs[6], result); }
    /** @returns Return (a copy of)the Y column */
    columnY(result) { return Point3dVector3d_1.Vector3d.create(this.coffs[1], this.coffs[4], this.coffs[7], result); }
    /** @returns Return (a copy of)the Z column */
    columnZ(result) { return Point3dVector3d_1.Vector3d.create(this.coffs[2], this.coffs[5], this.coffs[8], result); }
    /** @returns Return the X column magnitude squared */
    columnXMagnitudeSquared() { return Geometry_1.Geometry.hypotenuseSquaredXYZ(this.coffs[0], this.coffs[3], this.coffs[6]); }
    /** @returns Return the Y column magnitude squared */
    columnYMagnitudeSquared() { return Geometry_1.Geometry.hypotenuseSquaredXYZ(this.coffs[1], this.coffs[4], this.coffs[7]); }
    /** @returns Return the Z column magnitude squared */
    columnZMagnitudeSquared() { return Geometry_1.Geometry.hypotenuseSquaredXYZ(this.coffs[2], this.coffs[5], this.coffs[8]); }
    /** @returns Return the X column magnitude */
    columnXMagnitude() { return Math.hypot(this.coffs[0], this.coffs[3], this.coffs[6]); }
    /** @returns Return the Y column magnitude */
    columnYMagnitude() { return Math.hypot(this.coffs[1], this.coffs[4], this.coffs[7]); }
    /** @returns Return the Z column magnitude */
    columnZMagnitude() { return Math.hypot(this.coffs[2], this.coffs[5], this.coffs[8]); }
    /** @returns Return magntiude of columnX cross columnY. */
    columnXYCrossProductMagnitude() {
        return Geometry_1.Geometry.crossProductMagnitude(this.coffs[0], this.coffs[3], this.coffs[6], this.coffs[1], this.coffs[4], this.coffs[7]);
    }
    /** @returns Return the X row magnitude d */
    rowXMagnitude() { return Math.hypot(this.coffs[0], this.coffs[1], this.coffs[2]); }
    /** @returns Return the Y row magnitude  */
    rowYMagnitude() { return Math.hypot(this.coffs[3], this.coffs[4], this.coffs[5]); }
    /** @returns Return the Z row magnitude  */
    rowZMagnitude() { return Math.hypot(this.coffs[6], this.coffs[7], this.coffs[8]); }
    /** @returns the dot product of column X with column Y */
    /** @returns the dot product of column X with column Y */
    columnXDotColumnY() {
        return this.coffs[0] * this.coffs[1]
            + this.coffs[3] * this.coffs[4]
            + this.coffs[6] * this.coffs[7];
    }
    /** Return (a copy of) the X row */
    rowX(result) { return Point3dVector3d_1.Vector3d.create(this.coffs[0], this.coffs[1], this.coffs[2], result); }
    /** Return (a copy of) the Y row */
    rowY(result) { return Point3dVector3d_1.Vector3d.create(this.coffs[3], this.coffs[4], this.coffs[5], result); }
    /** Return (a copy of) the Z row */
    rowZ(result) { return Point3dVector3d_1.Vector3d.create(this.coffs[6], this.coffs[7], this.coffs[8], result); }
    /** @returns Return the dot product of the vector parameter with the X column. */
    dotColumnX(vector) { return vector.x * this.coffs[0] + vector.y * this.coffs[3] + vector.z * this.coffs[6]; }
    /** @returns Return the dot product of the vector parameter with the Y column. */
    dotColumnY(vector) { return vector.x * this.coffs[1] + vector.y * this.coffs[4] + vector.z * this.coffs[7]; }
    /** @returns Return the dot product of the vector parameter with the Z column. */
    dotColumnZ(vector) { return vector.x * this.coffs[2] + vector.y * this.coffs[5] + vector.z * this.coffs[8]; }
    /** @returns Return the dot product of the vector parameter with the X row. */
    dotRowX(vector) { return vector.x * this.coffs[0] + vector.y * this.coffs[1] + vector.z * this.coffs[2]; }
    /** @returns Return the dot product of the vector parameter with the Y row. */
    dotRowY(vector) { return vector.x * this.coffs[3] + vector.y * this.coffs[4] + vector.z * this.coffs[5]; }
    /** @returns Return the dot product of the vector parameter with the Z row. */
    dotRowZ(vector) { return vector.x * this.coffs[6] + vector.y * this.coffs[7] + vector.z * this.coffs[8]; }
    /** @returns Return the dot product of the x,y,z with the X row. */
    dotRowXXYZ(x, y, z) { return x * this.coffs[0] + y * this.coffs[1] + z * this.coffs[2]; }
    /** @returns Return the dot product of the x,y,z with the Y row. */
    dotRowYXYZ(x, y, z) { return x * this.coffs[3] + y * this.coffs[4] + z * this.coffs[5]; }
    /** @returns Return the dot product of the x,y,z with the Z row. */
    dotRowZXYZ(x, y, z) { return x * this.coffs[6] + y * this.coffs[7] + z * this.coffs[8]; }
    /** @returns Return the (vector) cross product of the Z column with the vector parameter. */
    columnZCrossVector(vector, result) {
        return Geometry_1.Geometry.crossProductXYZXYZ(this.coffs[2], this.coffs[5], this.coffs[8], vector.x, vector.y, vector.z, result);
    }
    /**
     * Replace current rows Ui Uj with (c*Ui - s*Uj) and (c*Uj + s*Ui)
     * @param i first row index.  must be 0,1,2 (unchecked)
     * @param j second row index. must be 0,1,2 (unchecked)
     * @param c fist coefficient
     * @param s second coefficient
     */
    applyGivensRowOp(i, j, c, s) {
        let ii = 3 * i;
        let jj = 3 * j;
        const limit = ii + 3;
        for (; ii < limit; ii++, jj++) {
            const a = this.coffs[ii];
            const b = this.coffs[jj];
            this.coffs[ii] = a * c + b * s;
            this.coffs[jj] = -a * s + b * c;
        }
    }
    /**
     * Replace current columns Ui Uj with (c*Ui - s*Uj) and (c*Uj + s*Ui)
     * This is used in compute intensive inner loops -- there is no
     * checking for i,j being 0,1,2
     * @param i first row index.  must be 0,1,2 (unchecked)
     * @param j second row index. must be 0,1,2 (unchecked)
     * @param c fist coefficient
     * @param s second coefficient
     */
    applyGivensColumnOp(i, j, c, s) {
        const limit = i + 9;
        for (; i < limit; i += 3, j += 3) {
            const a = this.coffs[i];
            const b = this.coffs[j];
            this.coffs[i] = a * c + b * s;
            this.coffs[j] = -a * s + b * c;
        }
    }
    /**
     * create a rigid coordinate frame with:
     * * column z points from origin to x,y,z
     * * column x is perpendicular and in the xy plane
     * * column y is perpendicular to both.  It is the "up" vector on the view plane.
     * * Multiplying a world vector times the transpose of this matrix transforms into the view xy
     * * Multiplying the matrix times the an in-view vector transforms the vector to world.
     * @param x eye x coordinate
     * @param y eye y coordinate
     * @param z eye z coordinate
     * @param result
     */
    static createRigidViewAxesZTowardsEye(x, y, z, result) {
        result = Matrix3d.createIdentity(result);
        const rxy = Geometry_1.Geometry.hypotenuseXY(x, y);
        if (Geometry_1.Geometry.isSmallMetricDistance(rxy)) {
            // special case for top or bottom view.
            if (z < 0.0)
                result.scaleColumnsInPlace(1.0, -1, -1.0);
        }
        else {
            //      const d = Geometry.hypotenuseSquaredXYZ(x, y, z);
            const c = x / rxy;
            const s = y / rxy;
            result.setRowValues(-s, 0, c, c, 0, s, 0, 1, 0);
            if (z !== 0.0) {
                const r = Geometry_1.Geometry.hypotenuseXYZ(x, y, z);
                const s1 = z / r;
                const c1 = rxy / r;
                result.applyGivensColumnOp(1, 2, c1, -s1);
            }
        }
        return result;
    }
    /** Rotate so columns i and j become perpendicular */
    applyJacobiColumnRotation(i, j, matrixU) {
        const uDotU = this.coffs[i] * this.coffs[i] + this.coffs[i + 3] * this.coffs[i + 3] + this.coffs[i + 6] * this.coffs[i + 6];
        const vDotV = this.coffs[j] * this.coffs[j] + this.coffs[j + 3] * this.coffs[j + 3] + this.coffs[j + 6] * this.coffs[j + 6];
        const uDotV = this.coffs[i] * this.coffs[j] + this.coffs[i + 3] * this.coffs[j + 3] + this.coffs[i + 6] * this.coffs[j + 6];
        // const c2 = uDotU - vDotV;
        // const s2 = 2.0 * uDotV;
        const jacobi = Angle_1.Angle.trigValuesToHalfAngleTrigValues(uDotU - vDotV, 2.0 * uDotV);
        // const h = Math.hypot(c2, s2);
        // console.log(" c2 s2", c2 / h, s2 / h);
        // console.log(" C S ", Math.cos(2 * jacobi.radians), Math.sin(2 * jacobi.radians));
        // console.log("i j uDotV", i, j, uDotV);
        if (Math.abs(jacobi.s) < 2.0e-15)
            return 0.0;
        this.applyGivensColumnOp(i, j, jacobi.c, jacobi.s);
        matrixU.applyGivensRowOp(i, j, jacobi.c, jacobi.s);
        // const BTB = this.multiplyMatrixTransposeMatrix(this);
        // console.log("BTB", BTB.at(0, 0), BTB.at(1, 1), BTB.at(2, 2), "       off", BTB.at(0, 1), BTB.at(0, 2), BTB.at(1, 2), "  at(i,j)", BTB.at(i, j));
        return Math.abs(uDotV);
    }
    /**
     * Factor this as a product C * U where C has mutually perpendicular columns and
     * U is orthogonal.
     * @param matrixC (allocate by caller, computed here)
     * @param factor  (allocate by caller, computed here)
     */
    factorPerpendicularColumns(matrixC, matrixU) {
        matrixC.setFrom(this);
        matrixU.setIdentity();
        const ss = this.sumSquares();
        const tolerance = 1.0e-12 * ss;
        for (let iteration = 0; iteration < 7; iteration++) {
            const sum = matrixC.applyJacobiColumnRotation(0, 1, matrixU)
                + matrixC.applyJacobiColumnRotation(0, 2, matrixU)
                + matrixC.applyJacobiColumnRotation(1, 2, matrixU);
            // console.log ("   sum", sum);
            if (sum < tolerance) {
                // console.log("jacobi iterations", iteration);
                return true;
            }
        }
        return false;
    }
    /** Apply a jacobi step to lambda which evolves towards diagonal. */
    applySymmetricJacobi(i, j, lambda) {
        const uDotU = lambda.at(i, i);
        const vDotV = lambda.at(j, j);
        const uDotV = lambda.at(i, j);
        if (Math.abs(uDotV) < 1.0e-15 * (uDotU + vDotV))
            return 0.0;
        // const c2 = uDotU - vDotV;
        // const s2 = 2.0 * uDotV;
        const jacobi = Angle_1.Angle.trigValuesToHalfAngleTrigValues(uDotU - vDotV, 2.0 * uDotV);
        // const h = Math.hypot(c2, s2);
        // console.log(" c2 s2", c2 / h, s2 / h);
        // console.log(" C S ", Math.cos(2 * jacobi.radians), Math.sin(2 * jacobi.radians));
        // console.log("i j uDotV", i, j, uDotV);
        if (Math.abs(jacobi.s) < 2.0e-15)
            return 0.0;
        // Factored form is this *lambda * thisTranspose
        // Let Q be the rotation matrix.  Q*QT is inserted, viz
        //          this*Q * QT * lambda * Q*thisTranspose
        this.applyGivensColumnOp(i, j, jacobi.c, jacobi.s);
        lambda.applyGivensRowOp(i, j, jacobi.c, jacobi.s);
        lambda.applyGivensColumnOp(i, j, jacobi.c, jacobi.s);
        // const BTB = this.multiplyMatrixTransposeMatrix(this);
        // console.log("BTB", BTB.at(0, 0), BTB.at(1, 1), BTB.at(2, 2), "       off", BTB.at(0, 1), BTB.at(0, 2), BTB.at(1, 2), "  at(i,j)", BTB.at(i, j));
        return Math.abs(uDotV);
    }
    /**
     * Factor this (symmetrized) as a product U * lambda * UT where U is orthogonal, lambda is diagonal.
     * The upper triangle is mirrored to lower triangle to enforce symmetry.
     * @param matrixC (allocate by caller, computed here)
     * @param factor  (allocate by caller, computed here)
     */
    symmetricEigenvalues(leftEigenvectors, lambda) {
        const matrix = this.clone();
        leftEigenvectors.setIdentity();
        matrix.coffs[3] = matrix.coffs[1];
        matrix.coffs[6] = matrix.coffs[2];
        matrix.coffs[7] = matrix.coffs[5];
        const ss = this.sumSquares();
        const tolerance = 1.0e-12 * ss;
        for (let iteration = 0; iteration < 7; iteration++) {
            const sum = leftEigenvectors.applySymmetricJacobi(0, 1, matrix)
                + leftEigenvectors.applySymmetricJacobi(0, 2, matrix)
                + leftEigenvectors.applySymmetricJacobi(1, 2, matrix);
            // console.log("symmetric sum", sum);
            // console.log ("   sum", sum);
            if (sum < tolerance) {
                // console.log("symmetric iterations", iteration);
                lambda.set(matrix.at(0, 0), matrix.at(1, 1), matrix.at(2, 2));
                return true;
            }
        }
        return false;
    }
    /** Apply (in place a jacobi update that zeros out this.at(i,j).
     *
     */
    applyFastSymmetricJacobiUpdate(i, // row index of zeroed member
    j, // column index of zeroed member
    k, // other row/column index (different from i and j)
    leftEigenVectors) {
        const indexII = 4 * i;
        const indexJJ = 4 * j;
        const indexIJ = 3 * i + j;
        const indexIK = 3 * i + k;
        const indexJK = 3 * j + k;
        const dotUU = this.coffs[indexII];
        const dotVV = this.coffs[indexJJ];
        const dotUV = this.coffs[indexIJ];
        const jacobi = Angle_1.Angle.trigValuesToHalfAngleTrigValues(dotUU - dotVV, 2.0 * dotUV);
        if (Math.abs(dotUV) < 1.0e-15 * (dotUU + dotVV))
            return 0.0;
        const c = jacobi.c;
        const s = jacobi.s;
        const cc = c * c;
        const ss = s * s;
        const sc2 = 2.0 * c * s;
        this.coffs[indexII] = cc * dotUU + sc2 * dotUV + ss * dotVV;
        this.coffs[indexJJ] = ss * dotUU - sc2 * dotUV + cc * dotVV;
        this.coffs[indexIJ] = 0.0;
        const a = this.coffs[indexIK];
        const b = this.coffs[indexJK];
        this.coffs[indexIK] = a * c + b * s;
        this.coffs[indexJK] = -s * a + c * b;
        this.coffs[3 * j + i] = 0.0;
        this.coffs[3 * k + i] = this.coffs[indexIK];
        this.coffs[3 * k + j] = this.coffs[indexJK];
        leftEigenVectors.applyGivensColumnOp(i, j, c, s);
        return Math.abs(dotUV);
    }
    /**
     * Factor this (symmetrized) as a product U * lambda * UT where U is orthogonal, lambda is diagonal.
     * The upper triangle is mirrored to lower triangle to enforce symmetry.
     * @param matrixC (allocate by caller, computed here)
     * @param factor  (allocate by caller, computed here)
     */
    fastSymmetricEigenvalues(leftEigenvectors, lambda) {
        const matrix = this.clone();
        leftEigenvectors.setIdentity();
        const ss = this.sumSquares();
        const tolerance = 1.0e-12 * ss;
        for (let iteration = 0; iteration < 7; iteration++) {
            const sum = matrix.applyFastSymmetricJacobiUpdate(0, 1, 2, leftEigenvectors)
                + matrix.applyFastSymmetricJacobiUpdate(0, 2, 1, leftEigenvectors)
                + matrix.applyFastSymmetricJacobiUpdate(1, 2, 0, leftEigenvectors);
            // console.log("symmetric sum", sum);
            // console.log ("   sum", sum);
            if (sum < tolerance) {
                // console.log("symmetric iterations", iteration);
                lambda.set(matrix.at(0, 0), matrix.at(1, 1), matrix.at(2, 2));
                return true;
            }
        }
        return false;
    }
    /** Create a matrix from column vectors. */
    static createColumns(vectorU, vectorV, vectorW, result) {
        return Matrix3d.createRowValues(vectorU.x, vectorV.x, vectorW.x, vectorU.y, vectorV.y, vectorW.y, vectorU.z, vectorV.z, vectorW.z, result);
    }
    /** Create a matrix from column vectors.
     * Each column gets x and y from given XAndY, and z from w.
     */
    static createColumnsXYW(vectorU, uz, vectorV, vz, vectorW, wz, result) {
        return Matrix3d.createRowValues(vectorU.x, vectorV.x, vectorW.x, vectorU.y, vectorV.y, vectorW.y, uz, vz, wz, result);
    }
    /** Install data from xyz parts of Point4d  (w part of Point4d ignored) */
    setColumnsPoint4dXYZ(vectorU, vectorV, vectorW) {
        this.setRowValues(vectorU.x, vectorV.x, vectorW.x, vectorU.y, vectorV.y, vectorW.y, vectorU.z, vectorV.z, vectorW.z);
    }
    /**
     * set entries in one column of the matrix.
     * @param columnIndex column index. this is interpreted cyclically.
     * @param value x,yz, values for column.  If undefined, zeros are installed.
     */
    setColumn(columnIndex, value) {
        const index = Geometry_1.Geometry.cyclic3dAxis(columnIndex);
        if (value) {
            this.coffs[index] = value.x;
            this.coffs[index + 3] = value.y;
            this.coffs[index + 6] = value.z;
        }
        else {
            this.coffs[index] = 0.0;
            this.coffs[index + 3] = 0.0;
            this.coffs[index + 6] = 0.0;
        }
    }
    /** Set all columns of the matrix. Any undefined vector is zeros. */
    setColumns(vectorX, vectorY, vectorZ) {
        this.setColumn(0, vectorX);
        this.setColumn(1, vectorY);
        this.setColumn(2, vectorZ);
    }
    setRow(columnIndex, value) {
        const index = 3 * Geometry_1.Geometry.cyclic3dAxis(columnIndex);
        this.coffs[index] = value.x;
        this.coffs[index + 1] = value.y;
        this.coffs[index + 2] = value.z;
        this.inverseState = InverseMatrixState.unknown;
    }
    /** Return a (copy of) a column of the matrix.
     * @param i column index.  Thnis is corrected to 012 by Geoemtry.cyclic3dAxis.
     */
    getColumn(columnIndex, result) {
        const index = Geometry_1.Geometry.cyclic3dAxis(columnIndex);
        return Point3dVector3d_1.Vector3d.create(this.coffs[index], this.coffs[index + 3], this.coffs[index + 6], result);
    }
    /** Return a (copy of) a row of the matrix.
     * @param i row index.  Thnis is corrected to 012 by Geoemtry.cyclic3dAxis.
     */
    getRow(columnIndex, result) {
        const index = 3 * Geometry_1.Geometry.cyclic3dAxis(columnIndex);
        return Point3dVector3d_1.Vector3d.create(this.coffs[index], this.coffs[index + 1], this.coffs[index + 2], result);
    }
    /** Create a matrix from column vectors, shuffled into place per AxisTriple */
    static createShuffledColumns(vectorU, vectorV, vectorW, axisOrder, result) {
        const target = Matrix3d._create(result);
        target.setColumn(Geometry_1.Geometry.axisOrderToAxis(axisOrder, 0), vectorU);
        target.setColumn(Geometry_1.Geometry.axisOrderToAxis(axisOrder, 1), vectorV);
        target.setColumn(Geometry_1.Geometry.axisOrderToAxis(axisOrder, 2), vectorW);
        return target;
    }
    /** Create a matrix from row vectors. */
    static createRows(vectorU, vectorV, vectorW, result) {
        return Matrix3d.createRowValues(vectorU.x, vectorU.y, vectorU.z, vectorV.x, vectorV.y, vectorV.z, vectorW.x, vectorW.y, vectorW.z, result);
    }
    /** Create a matrix that scales along a specified direction. The scale factor can be negative. for instance scale of -1.0 (negative one) is a mirror. */
    static createDirectionalScale(direction, scale, result) {
        const unit = direction.normalize();
        if (unit) {
            const x = unit.x;
            const y = unit.y;
            const z = unit.z;
            const a = (scale - 1);
            return Matrix3d.createRowValues(1 + a * x * x, a * x * y, a * x * z, a * y * x, 1 + a * y * y, a * y * z, a * z * x, a * z * y, 1 + a * z * z, result);
        }
        return Matrix3d.createUniformScale(scale);
    }
    /* Create a matrix with the indicated column in the (normalized) direction, and the other two columns perpendicular. All columns are normalized.
     * * The direction vector is normalized and appears in column axisIndex
     * * If the direction vector is not close to Z, the "next" column ((axisIndex + 1) mod 3) will be in the XY plane in the direction of (direction cross Z)
     * * If the direction vector is close to Z, the "next" column ((axisIndex + 1) mode 3) will be in the direction of (direction cross Y)
    */
    // static create1Vector(direction: Vector3d, axisIndex: number): Matrix3d;
    // static createFromXYVectors(vectorX: Vector3d, vectorY: Vector3d, axisIndex: number): Matrix3d;
    /** Multiply the matrix * vector, i.e. the vector is a column vector on the right.
     * @return the vector result
     */
    multiplyVector(vector, result) {
        const x = vector.x;
        const y = vector.y;
        const z = vector.z;
        return Point3dVector3d_1.Vector3d.create((this.coffs[0] * x + this.coffs[1] * y + this.coffs[2] * z), (this.coffs[3] * x + this.coffs[4] * y + this.coffs[5] * z), (this.coffs[6] * x + this.coffs[7] * y + this.coffs[8] * z), result);
    }
    /** Multiply the matrix * vector, i.e. the vector is a column vector on the right.
     * @return the vector result
     */
    multiplyVectorArrayInPlace(data) {
        for (const v of data)
            v.set((this.coffs[0] * v.x + this.coffs[1] * v.y + this.coffs[2] * v.z), (this.coffs[3] * v.x + this.coffs[4] * v.y + this.coffs[5] * v.z), (this.coffs[6] * v.x + this.coffs[7] * v.y + this.coffs[8] * v.z));
    }
    static XYZMinusMatrixTimesXYZ(origin, matrix, vector, result) {
        const x = vector.x;
        const y = vector.y;
        const z = vector.z;
        return Point3dVector3d_1.Point3d.create(origin.x - (matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z), origin.y - (matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z), origin.z - (matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z), result);
    }
    static XYPlusMatrixTimesXY(origin, matrix, vector, result) {
        const x = vector.x;
        const y = vector.y;
        return Point2dVector2d_1.Point2d.create(origin.x + matrix.coffs[0] * x + matrix.coffs[1] * y, origin.y + matrix.coffs[3] * x + matrix.coffs[4] * y, result);
    }
    static XYZPlusMatrixTimesXYZ(origin, matrix, vector, result) {
        const x = vector.x;
        const y = vector.y;
        const z = vector.z;
        return Point3dVector3d_1.Point3d.create(origin.x + matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z, origin.y + matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z, origin.z + matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z, result);
    }
    static XYZPlusMatrixTimesCoordinates(origin, matrix, x, y, z, result) {
        return Point3dVector3d_1.Point3d.create(origin.x + matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z, origin.y + matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z, origin.z + matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z, result);
    }
    /**
     * Treat the 3x3 matrix and origin as upper 3x4 part of a 4x4 matrix, with 0001 as the final row.
     * Multiply times point with coordinates `[x,y,z,w]`
     * @param origin translation part (xyz in column 3)
     * @param matrix matrix part (leading 3x3)
     * @param x x part of multiplied point
     * @param y y part of multiplied point
     * @param z z part of multiplied point
     * @param w w part of multiplied point
     * @param result optional result.
     */
    static XYZPlusMatrixTimesWeightedCoordinates(origin, matrix, x, y, z, w, result) {
        return Point4d_1.Point4d.create(w * origin.x + matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z, w * origin.y + matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z, w * origin.z + matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z, w, result);
    }
    /**
     * Treat the 3x3 matrix and origin as upper 3x4 part of a 4x4 matrix, with 0001 as the final row.
     * Multiply times point with coordinates `[x,y,z,w]`
     * @param origin translation part (xyz in column 3)
     * @param matrix matrix part (leading 3x3)
     * @param x x part of multiplied point
     * @param y y part of multiplied point
     * @param z z part of multiplied point
     * @param w w part of multiplied point
     * @param result optional result.
     */
    static XYZPlusMatrixTimesWeightedCoordinatesToFloat64Array(origin, matrix, x, y, z, w, result) {
        if (!result)
            result = new Float64Array(4);
        result[0] = w * origin.x + matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z;
        result[1] = w * origin.y + matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z;
        result[2] = w * origin.z + matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z;
        result[3] = w;
        return result;
    }
    /**
     * Treat the 3x3 matrix and origin as upper 3x4 part of a 4x4 matrix, with 0001 as the final row.
     * Multiply times point with coordinates `[x,y,z,w]`
     * @param origin translation part (xyz in column 3)
     * @param matrix matrix part (leading 3x3)
     * @param x x part of multiplied point
     * @param y y part of multiplied point
     * @param z z part of multiplied point
     * @param w w part of multiplied point
     * @param result optional result.
     */
    static XYZPlusMatrixTimesCoordinatesToFloat64Array(origin, matrix, x, y, z, result) {
        if (!result)
            result = new Float64Array(3);
        result[0] = origin.x + matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z;
        result[1] = origin.y + matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z;
        result[2] = origin.z + matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z;
        return result;
    }
    multiplyTransposeVector(vector, result) {
        result = result ? result : new Point3dVector3d_1.Vector3d();
        const x = vector.x;
        const y = vector.y;
        const z = vector.z;
        result.x = (this.coffs[0] * x + this.coffs[3] * y + this.coffs[6] * z);
        result.y = (this.coffs[1] * x + this.coffs[4] * y + this.coffs[7] * z);
        result.z = (this.coffs[2] * x + this.coffs[5] * y + this.coffs[8] * z);
        return result;
    }
    /** Multiply the matrix * (x,y,z), i.e. the vector (x,y,z) is a column vector on the right.
     * @return the vector result
     */
    multiplyXYZ(x, y, z, result) {
        result = result ? result : new Point3dVector3d_1.Vector3d();
        result.x = (this.coffs[0] * x + this.coffs[1] * y + this.coffs[2] * z);
        result.y = (this.coffs[3] * x + this.coffs[4] * y + this.coffs[5] * z);
        result.z = (this.coffs[6] * x + this.coffs[7] * y + this.coffs[8] * z);
        return result;
    }
    /** Multiply the matrix * xyz, place result in (required) return value.
     *   @param xyz right side
     *   @param result result.
     */
    multiplyXYZtoXYZ(xyz, result) {
        const x = xyz.x;
        const y = xyz.y;
        const z = xyz.z;
        result.x = (this.coffs[0] * x + this.coffs[1] * y + this.coffs[2] * z);
        result.y = (this.coffs[3] * x + this.coffs[4] * y + this.coffs[5] * z);
        result.z = (this.coffs[6] * x + this.coffs[7] * y + this.coffs[8] * z);
        return result;
    }
    /** Multiply the matrix * (x,y,0), i.e. the vector (x,y,z) is a column vector on the right.
     *   @return the vector result
     */
    multiplyXY(x, y, result) {
        result = result ? result : new Point3dVector3d_1.Vector3d();
        result.x = (this.coffs[0] * x + this.coffs[1] * y);
        result.y = (this.coffs[3] * x + this.coffs[4] * y);
        result.z = (this.coffs[6] * x + this.coffs[7] * y);
        return result;
    }
    // origin + this*[x,y,0].  (no nulls allowed !!)
    originPlusMatrixTimesXY(origin, x, y, result) {
        return Point3dVector3d_1.Point3d.create(origin.x + this.coffs[0] * x + this.coffs[1] * y, origin.y + this.coffs[3] * x + this.coffs[4] * y, origin.z + this.coffs[6] * x + this.coffs[7] * y, result);
    }
    /** Multiply matrix * (x, y, z) using any 3d object given containing those members */
    multiplyVectorInPlace(xyzData) {
        const x = xyzData.x;
        const y = xyzData.y;
        const z = xyzData.z;
        const coffs = this.coffs;
        xyzData.x = (coffs[0] * x + coffs[1] * y + coffs[2] * z);
        xyzData.y = (coffs[3] * x + coffs[4] * y + coffs[5] * z);
        xyzData.z = (coffs[6] * x + coffs[7] * y + coffs[8] * z);
    }
    /** Multiply matrix * (x, y, z) using any 3d object given containing those members */
    multiplyTransposeVectorInPlace(xyzData) {
        const x = xyzData.x;
        const y = xyzData.y;
        const z = xyzData.z;
        const coffs = this.coffs;
        xyzData.x = (coffs[0] * x + coffs[3] * y + coffs[6] * z);
        xyzData.y = (coffs[1] * x + coffs[4] * y + coffs[7] * z);
        xyzData.z = (coffs[2] * x + coffs[5] * y + coffs[8] * z);
    }
    /** Multiply the (x,y,z) * matrix, i.e. the vector (x,y,z) is a row vector on the left.
     *   @return the vector result
     */
    multiplyTransposeXYZ(x, y, z, result) {
        result = result ? result : new Point3dVector3d_1.Vector3d();
        result.x = (this.coffs[0] * x + this.coffs[3] * y + this.coffs[6] * z);
        result.y = (this.coffs[1] * x + this.coffs[4] * y + this.coffs[7] * z);
        result.z = (this.coffs[2] * x + this.coffs[5] * y + this.coffs[8] * z);
        return result;
    }
    /** Solve matrix * result = vector, i.e. multiply result = matrixInverse * rightHandSide  */
    multiplyInverse(vector, result) {
        this.computeCachedInverse(true);
        if (this.inverseCoffs) {
            const x = vector.x;
            const y = vector.y;
            const z = vector.z;
            return Point3dVector3d_1.Vector3d.create((this.inverseCoffs[0] * x + this.inverseCoffs[1] * y + this.inverseCoffs[2] * z), (this.inverseCoffs[3] * x + this.inverseCoffs[4] * y + this.inverseCoffs[5] * z), (this.inverseCoffs[6] * x + this.inverseCoffs[7] * y + this.inverseCoffs[8] * z), result);
        }
        return undefined;
    }
    /** Solve matrix * result = vector, i.e. multiply result = matrixInverse * rightHandSide  */
    multiplyInverseTranspose(vector, result) {
        this.computeCachedInverse(true);
        if (this.inverseCoffs) {
            const x = vector.x;
            const y = vector.y;
            const z = vector.z;
            return Point3dVector3d_1.Vector3d.create((this.inverseCoffs[0] * x + this.inverseCoffs[3] * y + this.inverseCoffs[6] * z), (this.inverseCoffs[1] * x + this.inverseCoffs[4] * y + this.inverseCoffs[7] * z), (this.inverseCoffs[2] * x + this.inverseCoffs[5] * y + this.inverseCoffs[8] * z), result);
        }
        return undefined;
    }
    /**
     *
     * *  multiply matrixInverse * [x,y,z]
     * *  Equivalent to solving matrix * result = [x,y,z]
     * *  return as a Vector3d.
     */
    multiplyInverseXYZAsVector3d(x, y, z, result) {
        this.computeCachedInverse(true);
        if (this.inverseCoffs) {
            return Point3dVector3d_1.Vector3d.create((this.inverseCoffs[0] * x + this.inverseCoffs[1] * y + this.inverseCoffs[2] * z), (this.inverseCoffs[3] * x + this.inverseCoffs[4] * y + this.inverseCoffs[5] * z), (this.inverseCoffs[6] * x + this.inverseCoffs[7] * y + this.inverseCoffs[8] * z), result);
        }
        return undefined;
    }
    /**
     *
     * *  multiply matrixInverse * [x,y,z]
     * *  Equivalent to solving matrix * result = [x,y,z]
     * *  return as a Point3d.
     */
    multiplyInverseXYZAsPoint3d(x, y, z, result) {
        this.computeCachedInverse(true);
        if (this.inverseCoffs) {
            return Point3dVector3d_1.Point3d.create((this.inverseCoffs[0] * x + this.inverseCoffs[1] * y + this.inverseCoffs[2] * z), (this.inverseCoffs[3] * x + this.inverseCoffs[4] * y + this.inverseCoffs[5] * z), (this.inverseCoffs[6] * x + this.inverseCoffs[7] * y + this.inverseCoffs[8] * z), result);
        }
        return undefined;
    }
    /** Multiply two matrices.
     *   @return the matrix result
     */
    multiplyMatrixMatrix(other, result) {
        result = result ? result : new Matrix3d();
        PackedMatrix3dOps.multiplyMatrixMatrix(this.coffs, other.coffs, result.coffs);
        return result;
    }
    /** Matrix multiplication `this * otherTranspose`
     * @return the matrix result
     */
    multiplyMatrixMatrixTranspose(other, result) {
        result = result ? result : new Matrix3d();
        PackedMatrix3dOps.multiplyMatrixMatrixTranspose(this.coffs, other.coffs, result.coffs);
        return result;
    }
    /** Matrix multiplication `thisTranspose * other`
     *   @return the matrix result
     */
    multiplyMatrixTransposeMatrix(other, result) {
        result = result ? result : new Matrix3d();
        PackedMatrix3dOps.multiplyMatrixTransposeMatrix(this.coffs, other.coffs, result.coffs);
        return result;
    }
    //   [Q 0][R A] = [QR QA]
    //   [0 1][0 1]   [0  1]
    /** multiply this Matrix3d (considered as a transform with 0 translation) times other Transform.
     * @param other right hand Matrix3d for multiplication.
     * @param result optional preallocated result to reuse.
     */
    multiplyMatrixTransform(other, result) {
        if (!result)
            return Transform_1.Transform.createRefs(this.multiplyXYZ(other.origin.x, other.origin.y, other.origin.z), this.multiplyMatrixMatrix(other.matrix));
        // be sure to do the point mulitplication first before aliasing changes the matrix ..
        this.multiplyXYZtoXYZ(other.origin, result.origin);
        this.multiplyMatrixMatrix(other.matrix, result.matrix);
        return result;
    }
    /** return the transposed matrix */
    transpose(result) {
        if (!result)
            result = new Matrix3d();
        PackedMatrix3dOps.copyTransposed(this.coffs, result.coffs);
        if (this.inverseCoffs !== undefined) {
            result.inverseState = InverseMatrixState.inverseStored;
            result.inverseCoffs = PackedMatrix3dOps.copyTransposed(this.inverseCoffs, result.inverseCoffs);
        }
        else {
            result.inverseState = this.inverseState; // singular or unknown.
            result.inverseCoffs = undefined;
        }
        return result;
    }
    /** return the transposed matrix */
    transposeInPlace() {
        PackedMatrix3dOps.transposeInPlace(this.coffs);
        if (this.inverseCoffs)
            PackedMatrix3dOps.transposeInPlace(this.inverseCoffs);
    }
    /** return the inverse matrix.  The return is  null if the matrix is singular (has columns that are coplanar or colinear) */
    inverse(result) {
        this.computeCachedInverse(true);
        if (this.inverseState === InverseMatrixState.inverseStored && this.inverseCoffs)
            return Matrix3d.createRowValues(this.inverseCoffs[0], this.inverseCoffs[1], this.inverseCoffs[2], this.inverseCoffs[3], this.inverseCoffs[4], this.inverseCoffs[5], this.inverseCoffs[6], this.inverseCoffs[7], this.inverseCoffs[8], result);
        return undefined;
    }
    /** copy the transpose of the coffs to the inverseCoffs.
     * * mark the matrix as inverseStored.
     */
    setupInverseTranspose() {
        const coffs = this.coffs;
        this.inverseState = InverseMatrixState.inverseStored;
        this.inverseCoffs = Float64Array.from([coffs[0], coffs[3], coffs[6],
            coffs[1], coffs[4], coffs[7],
            coffs[2], coffs[5], coffs[8]]);
    }
    /* Alternate implementation of computedCachedInverse - more direct addressing of arrays.
       This is indeed 10% faster than using static work areas. */
    // take the cross product of two rows of source.
    // store as a column of dest.
    static indexedRowCrossProduct(source, rowStart0, rowStart1, dest, columnStart) {
        dest[columnStart] = source[rowStart0 + 1] * source[rowStart1 + 2] - source[rowStart0 + 2] * source[rowStart1 + 1];
        dest[columnStart + 3] = source[rowStart0 + 2] * source[rowStart1] - source[rowStart0] * source[rowStart1 + 2];
        dest[columnStart + 6] = source[rowStart0] * source[rowStart1 + 1] - source[rowStart0 + 1] * source[rowStart1];
    }
    // take the cross product of two columns of source.
    // store as third column in same Matrix3d.
    // This is private because the columnStart values are unchecked raw indices into the coffs
    indexedColumnCrossProductInPlace(colStart0, colStart1, colStart2) {
        const coffs = this.coffs;
        coffs[colStart2] = coffs[colStart0 + 3] * coffs[colStart1 + 6] - coffs[colStart0 + 6] * coffs[colStart1 + 3];
        coffs[colStart2 + 3] = coffs[colStart0 + 6] * coffs[colStart1] - coffs[colStart0] * coffs[colStart1 + 6];
        coffs[colStart2 + 6] = coffs[colStart0] * coffs[colStart1 + 3] - coffs[colStart0 + 3] * coffs[colStart1];
    }
    /** Form cross products among axes in axisOrder.
     * For axis order ABC,
     * * form cross product of column A and B, store in C
     * * form cross product of column C and A, store in B.
     * This means that in the final matrix:
     * * column A is strictly parallel to original column A
     * * column B is linear combination of only original A and B
     * * column C is perpenedicular to A and B of both the original and final.
     * * original column C does not participate in the result.
     */
    axisOrderCrossProductsInPlace(axisOrder) {
        switch (axisOrder) {
            case 0 /* XYZ */: {
                this.indexedColumnCrossProductInPlace(0, 1, 2);
                this.indexedColumnCrossProductInPlace(2, 0, 1);
                break;
            }
            case 1 /* YZX */: {
                this.indexedColumnCrossProductInPlace(1, 2, 0);
                this.indexedColumnCrossProductInPlace(0, 1, 2);
                break;
            }
            case 2 /* ZXY */: {
                this.indexedColumnCrossProductInPlace(2, 0, 1);
                this.indexedColumnCrossProductInPlace(1, 2, 0);
                break;
            }
            case 4 /* XZY */: {
                this.indexedColumnCrossProductInPlace(0, 2, 1);
                this.indexedColumnCrossProductInPlace(1, 0, 2);
                break;
            }
            case 5 /* YXZ */: {
                this.indexedColumnCrossProductInPlace(1, 0, 2);
                this.indexedColumnCrossProductInPlace(2, 1, 0);
                break;
            }
            case 6 /* ZYX */: {
                this.indexedColumnCrossProductInPlace(2, 1, 0);
                this.indexedColumnCrossProductInPlace(0, 2, 1);
                break;
            }
        }
    }
    /** Normalize each column in place.
     * * For false return the magnitudes are stored in the originalMagnitudes vector but no columns are altered.
     * @returns Return true if all columns had nonzero lengths.
     * @param originalMagnitudes optional vector to receive original column magnitudes.
     */
    normalizeColumnsInPlace(originalMagnitudes) {
        const ax = this.columnXMagnitude();
        const ay = this.columnYMagnitude();
        const az = this.columnZMagnitude();
        if (originalMagnitudes)
            originalMagnitudes.set(ax, ay, az);
        if (Geometry_1.Geometry.isSmallMetricDistance(ax) || Geometry_1.Geometry.isSmallMetricDistance(ay) || Geometry_1.Geometry.isSmallMetricDistance(az))
            return false;
        this.scaleColumns(1.0 / ax, 1.0 / ay, 1.0 / az, this);
        return true;
    }
    /** Normalize each row in place */
    normalizeRowsInPlace(originalMagnitudes) {
        const ax = this.rowXMagnitude();
        const ay = this.rowYMagnitude();
        const az = this.rowZMagnitude();
        if (originalMagnitudes)
            originalMagnitudes.set(ax, ay, az);
        if (Geometry_1.Geometry.isSmallMetricDistance(ax) || Geometry_1.Geometry.isSmallMetricDistance(ay) || Geometry_1.Geometry.isSmallMetricDistance(az))
            return false;
        this.scaleRows(1.0 / ax, 1.0 / ay, 1.0 / az, this);
        return true;
    }
    // take the cross product of two rows of source.
    // store as a column of dest.
    static rowColumnDot(coffA, rowStartA, coffB, columnStartB) {
        return coffA[rowStartA] * coffB[columnStartB] + coffA[rowStartA + 1] * coffB[columnStartB + 3] + coffA[rowStartA + 2] * coffB[columnStartB + 6];
    }
    /** compute the inverse of this Matrix3d. The inverse is stored for later use.
     * @returns Return true if the inverse computed.  (False if the columns collapse to a point, line or plane.)
     */
    computeCachedInverse(useCacheIfAvailable) {
        if (useCacheIfAvailable && Matrix3d.useCachedInverse && this.inverseState !== InverseMatrixState.unknown) {
            Matrix3d.numUseCache++;
            return this.inverseState === InverseMatrixState.inverseStored;
        }
        this.inverseState = InverseMatrixState.unknown;
        if (this.inverseCoffs === undefined)
            this.inverseCoffs = new Float64Array(9);
        const coffs = this.coffs;
        const inverseCoffs = this.inverseCoffs;
        Matrix3d.indexedRowCrossProduct(coffs, 3, 6, inverseCoffs, 0);
        Matrix3d.indexedRowCrossProduct(coffs, 6, 0, inverseCoffs, 1);
        Matrix3d.indexedRowCrossProduct(coffs, 0, 3, inverseCoffs, 2);
        Matrix3d.numComputeCache++;
        const d = Matrix3d.rowColumnDot(coffs, 0, inverseCoffs, 0);
        if (d === 0.0) { // better test?
            this.inverseState = InverseMatrixState.singular;
            this.inverseCoffs = undefined;
            return false;
        }
        const f = 1.0 / d;
        for (let i = 0; i < 9; i++)
            inverseCoffs[i] *= f;
        this.inverseState = InverseMatrixState.inverseStored;
        // verify inverse
        // const p = new Float64Array(9);
        // for (let i = 0; i < 9; i += 3)
        //   for (let j = 0; j < 3; j++)
        //    p[i + j] = Matrix3d.rowColumnDot (coffs, i, inverseCoffs, j);
        return true;
    }
    /* "Classic" inverse implementation with temporary vectors.
      private static rowX: Vector3d = Vector3d.create();
      private static rowY: Vector3d = Vector3d.create();
      private static rowZ: Vector3d = Vector3d.create();
      private static crossXY: Vector3d = Vector3d.create();
      private static crossZX: Vector3d = Vector3d.create();
      private static crossYZ: Vector3d = Vector3d.create();
    private computeCachedInverse(useCacheIfAvailable: boolean) {
        if (useCacheIfAvailable && Matrix3d.useCachedInverse && this.inverseState !== InverseMatrixState.unknown) {
          Matrix3d.numUseCache++;
          return this.inverseState === InverseMatrixState.inverseStored;
        }
        this.inverseState = InverseMatrixState.unknown;
        Matrix3d.numComputeCache++;
        const rowX = this.rowX(Matrix3d.rowX);
        const rowY = this.rowY(Matrix3d.rowY);
        const rowZ = this.rowZ(Matrix3d.rowZ);
        const crossXY = rowX.crossProduct(rowY, Matrix3d.crossXY);
        const crossYZ = rowY.crossProduct(rowZ, Matrix3d.crossYZ);
        const crossZX = rowZ.crossProduct(rowX, Matrix3d.crossZX);
        const d = rowX.dotProduct(crossYZ);  // that's the determinant
        if (d === 0.0) {     // better test?
          this.inverseState = InverseMatrixState.singular;
          this.inverseCoffs = undefined;
          return false;
        }
        const f = 1.0 / d;
        this.inverseState = InverseMatrixState.inverseStored;   // Currently just lists that the inverse has been stored... singular case not handled
        this.inverseCoffs = Float64Array.from([crossYZ.x * f, crossZX.x * f, crossXY.x * f,
        crossYZ.y * f, crossZX.y * f, crossXY.y * f,
        crossYZ.z * f, crossZX.z * f, crossXY.z * f]);
        return true;
      }
    */
    static flatIndexOf(row, column) {
        return 3 * Geometry_1.Geometry.cyclic3dAxis(row) + Geometry_1.Geometry.cyclic3dAxis(column);
    }
    /** Get a column by index (0,1,2), packaged as a Point4d with given weight.   Out of range index is interpreted cyclically.  */
    indexedColumnWithWeight(index, weight, result) {
        index = Geometry_1.Geometry.cyclic3dAxis(index);
        return Point4d_1.Point4d.create(this.coffs[index], this.coffs[index + 3], this.coffs[index + 6], weight, result);
    }
    /** return the entry at specific row and column */
    at(row, column) {
        return this.coffs[Matrix3d.flatIndexOf(row, column)];
    }
    /** Set the entry at specific row and column */
    setAt(row, column, value) {
        this.coffs[Matrix3d.flatIndexOf(row, column)] = value;
        this.inverseState = InverseMatrixState.unknown;
    }
    /** create a Matrix3d whose columns are scaled copies of this Matrix3d.
     * @param scaleX scale factor for columns x
     * @param scaleY scale factor for column y
     * @param scaleZ scale factor for column z
     * @param result optional result.
     */
    scaleColumns(scaleX, scaleY, scaleZ, result) {
        return Matrix3d.createRowValues(this.coffs[0] * scaleX, this.coffs[1] * scaleY, this.coffs[2] * scaleZ, this.coffs[3] * scaleX, this.coffs[4] * scaleY, this.coffs[5] * scaleZ, this.coffs[6] * scaleX, this.coffs[7] * scaleY, this.coffs[8] * scaleZ, result);
    }
    /** create a Matrix3d whose columns are scaled copies of this Matrix3d.
     * @param scaleX scale factor for columns x
     * @param scaleY scale factor for column y
     * @param scaleZ scale factor for column z
     * @param result optional result.
     */
    scaleColumnsInPlace(scaleX, scaleY, scaleZ) {
        this.coffs[0] *= scaleX;
        this.coffs[1] *= scaleY;
        this.coffs[2] *= scaleZ;
        this.coffs[3] *= scaleX;
        this.coffs[4] *= scaleY;
        this.coffs[5] *= scaleZ;
        this.coffs[6] *= scaleX;
        this.coffs[7] *= scaleY;
        this.coffs[8] *= scaleZ;
        if (this.inverseState === InverseMatrixState.inverseStored && this.inverseCoffs !== undefined) {
            // apply reciprocal scales to the ROWS of the inverse .  . .
            const divX = Geometry_1.Geometry.conditionalDivideFraction(1.0, scaleX);
            const divY = Geometry_1.Geometry.conditionalDivideFraction(1.0, scaleY);
            const divZ = Geometry_1.Geometry.conditionalDivideFraction(1.0, scaleZ);
            if (divX !== undefined && divY !== undefined && divZ !== undefined) {
                this.inverseCoffs[0] *= divX;
                this.inverseCoffs[1] *= divX;
                this.inverseCoffs[2] *= divX;
                this.inverseCoffs[3] *= divY;
                this.inverseCoffs[4] *= divY;
                this.inverseCoffs[5] *= divY;
                this.inverseCoffs[6] *= divZ;
                this.inverseCoffs[7] *= divZ;
                this.inverseCoffs[8] *= divZ;
            }
            else
                this.inverseState = InverseMatrixState.singular;
        }
    }
    /** create a Matrix3d whose rows are scaled copies of this Matrix3d.
     * @param scaleX scale factor for row x
     * @param scaleY scale factor for row y
     * @param scaleZ scale factor for row z
     * @param result optional result.
     */
    scaleRows(scaleX, scaleY, scaleZ, result) {
        return Matrix3d.createRowValues(this.coffs[0] * scaleX, this.coffs[1] * scaleX, this.coffs[2] * scaleX, this.coffs[3] * scaleY, this.coffs[4] * scaleY, this.coffs[5] * scaleY, this.coffs[6] * scaleZ, this.coffs[7] * scaleZ, this.coffs[8] * scaleZ, result);
    }
    /**
     * add scaled values from other Matrix3d to this Matrix3d
     * @param other Matrix3d with values to be added
     * @param scale scale factor to apply to th eadded values.
     */
    addScaledInPlace(other, scale) {
        for (let i = 0; i < 9; i++)
            this.coffs[i] += scale * other.coffs[i];
        this.inverseState = InverseMatrixState.unknown;
    }
    /** create a Matrix3d whose values are uniformly scaled from this.
     * @param scale scale factor to apply.
     * @param result optional result.
     * @returns Return the new or repopulated matrix
     */
    scale(scale, result) {
        return Matrix3d.createRowValues(this.coffs[0] * scale, this.coffs[1] * scale, this.coffs[2] * scale, this.coffs[3] * scale, this.coffs[4] * scale, this.coffs[5] * scale, this.coffs[6] * scale, this.coffs[7] * scale, this.coffs[8] * scale, result);
    }
    /** Return the determinant of this matrix. */
    determinant() {
        return this.coffs[0] * this.coffs[4] * this.coffs[8]
            - this.coffs[0] * this.coffs[7] * this.coffs[5]
            + this.coffs[3] * this.coffs[7] * this.coffs[2]
            - this.coffs[3] * this.coffs[1] * this.coffs[8]
            + this.coffs[6] * this.coffs[1] * this.coffs[5]
            - this.coffs[6] * this.coffs[4] * this.coffs[2];
    }
    /** Return an estimate of how independent the columns are.  Near zero is bad. Near 1 is good
     */
    conditionNumber() {
        const determinant = this.determinant();
        const columnMagnitudeProduct = Geometry_1.Geometry.hypotenuseXYZ(this.coffs[0], this.coffs[3], this.coffs[6])
            + Geometry_1.Geometry.hypotenuseXYZ(this.coffs[1], this.coffs[4], this.coffs[7])
            + Geometry_1.Geometry.hypotenuseXYZ(this.coffs[2], this.coffs[5], this.coffs[8]);
        return Geometry_1.Geometry.safeDivideFraction(determinant, columnMagnitudeProduct, 0.0);
    }
    /** Return the sum of squares of all entries */
    sumSquares() {
        let i = 0;
        let a = 0;
        for (i = 0; i < 9; i++)
            a += this.coffs[i] * this.coffs[i];
        return a;
    }
    /** Return the sum of squares of diagonal entries */
    sumDiagonalSquares() {
        let i = 0;
        let a = 0;
        for (i = 0; i < 9; i += 4)
            a += this.coffs[i] * this.coffs[i];
        return a;
    }
    /** Return the sum of diagonal entries (also known as the trace) */
    sumDiagonal() {
        return this.coffs[0] + this.coffs[4] + this.coffs[8];
    }
    /** Return the Maximum absolute value of any single entry */
    maxAbs() {
        let i = 0;
        let a = 0;
        for (i = 0; i < 9; i++)
            a = Math.max(a, Math.abs(this.coffs[i]));
        return a;
    }
    /** Return the maximum absolute difference between corresponding entries */
    maxDiff(other) {
        let i = 0;
        let a = 0;
        for (i = 0; i < 9; i++)
            a = Math.max(a, Math.abs(this.coffs[i] - other.coffs[i]));
        return a;
    }
    /** Test if the matrix is (very near to) an identity */
    get isIdentity() {
        return this.maxDiff(Matrix3d.identity) < Geometry_1.Geometry.smallAngleRadians;
    }
    /** Test if the off diagonal entries are all nearly zero */
    get isDiagonal() {
        const sumAll = this.sumSquares();
        const sumDiagonal = this.sumDiagonalSquares();
        const sumOff = Math.abs(sumAll - sumDiagonal);
        return Math.sqrt(sumOff) <= Geometry_1.Geometry.smallAngleRadians * (1.0 + Math.sqrt(sumAll));
    }
    /** Test if the below diagonal entries are all nearly zero */
    get isUpperTriangular() {
        const sumAll = this.sumSquares();
        const sumLow = Geometry_1.Geometry.hypotenuseSquaredXYZ(this.coffs[3], this.coffs[6], this.coffs[7]);
        return Math.sqrt(sumLow) <= Geometry_1.Geometry.smallAngleRadians * (1.0 + Math.sqrt(sumAll));
    }
    /** If the matrix is diagonal and all diagonals are within tolerance, return the first diagonal.  Otherwise return undefined.
     */
    sameDiagonalScale() {
        const sumAll = this.sumSquares();
        const sumDiagonal = this.sumDiagonalSquares();
        const sumOff = Math.abs(sumAll - sumDiagonal);
        if (Math.sqrt(sumOff) <= Geometry_1.Geometry.smallAngleRadians * (1.0 + Math.sqrt(sumAll))
            && Geometry_1.Geometry.isSameCoordinate(this.coffs[0], this.coffs[4]) && Geometry_1.Geometry.isSameCoordinate(this.coffs[0], this.coffs[8]))
            return this.coffs[0];
        return undefined;
    }
    /** Sum of squared differences between symmetric pairs */
    sumSkewSquares() {
        return Geometry_1.Geometry.hypotenuseSquaredXYZ(this.coffs[1] - this.coffs[3], this.coffs[2] - this.coffs[6], this.coffs[5] - this.coffs[7]);
    }
    /** Test if the matrix is a pure rotation. */
    isRigid(allowMirror = false) {
        return this.testPerpendicularUnitRowsAndColumns() && (allowMirror || this.determinant() > 0);
    }
    /** Test if all rows and columns are perpendicular to each other and have equal length.
     * If so, the length (or its negative) is the scale factor from a set of rigid axes to these axes.
     * * result.rigidAxes is the rigid axes (with the scale factor removed)
     * * result.scale is the scale factor
     */
    factorRigidWithSignedScale() {
        const product = this.multiplyMatrixMatrixTranspose(this);
        const ss = product.sameDiagonalScale();
        if (ss === undefined || ss <= 0.0)
            return undefined;
        const s = this.determinant() > 0 ? Math.sqrt(ss) : -Math.sqrt(ss);
        const divS = 1.0 / s;
        const result = { rigidAxes: this.scaleColumns(divS, divS, divS), scale: s };
        return result;
    }
    /** Test if the matrix is shuffles and negates columns. */
    get isSignedPermutation() {
        let count = 0;
        for (let row = 0; row < 3; row++)
            for (let col = 0; col < 3; col++) {
                const q = this.at(row, col);
                if (q === 0) { // This comment makes the block non-empty
                }
                else if (q === 1 || q === -1) {
                    // the rest of this row and column should be 0.
                    // "at" will apply cyclic indexing.
                    count++;
                    if (this.at(row + 1, col) !== 0)
                        return false;
                    if (this.at(row + 2, col) !== 0)
                        return false;
                    if (this.at(row, col + 1) !== 0)
                        return false;
                    if (this.at(row, col + 2) !== 0)
                        return false;
                }
                else { // entry is not from 0,1,-1 . . .
                    return false;
                }
            }
        return count === 3;
    }
    /** Test if all rows and columns are length 1 and are perpendicular to each other.  (I.e. the matrix is either a pure rotation with uniform scale factor of 1 or -1) */
    testPerpendicularUnitRowsAndColumns() {
        const product = this.multiplyMatrixMatrixTranspose(this);
        return product.isIdentity;
    }
    /** create a new orthogonal matrix (perpendicular columns, unit length, transpose is inverse)
     * vectorA is placed in the first column of the axis order.
     * vectorB is projected perpendicular to vectorA within their plane and placed in the second column.
     */
    static createRigidFromColumns(vectorA, vectorB, axisOrder, result) {
        const vectorA1 = vectorA.normalize();
        if (vectorA1) {
            const vectorC1 = vectorA1.unitCrossProduct(vectorB);
            if (vectorC1) {
                const vectorB1 = vectorC1.unitCrossProduct(vectorA);
                if (vectorB1) {
                    const retVal = Matrix3d.createShuffledColumns(vectorA1, vectorB1, vectorC1, axisOrder, result);
                    retVal.setupInverseTranspose();
                    return retVal;
                }
            }
        }
        return undefined;
    }
    /** create a new orthogonal matrix (perpendicular columns, unit length, transpose is inverse)
     * columns are taken from the source Matrix3d in order indicated by the axis order.
     */
    static createRigidFromMatrix3d(source, axisOrder = 0 /* XYZ */, result) {
        result = source.clone(result);
        result.axisOrderCrossProductsInPlace(axisOrder);
        if (result.normalizeColumnsInPlace())
            return result;
        return undefined;
    }
}
Matrix3d.useCachedInverse = true; // cached inverse can be suppressed for testing.
Matrix3d.numUseCache = 0;
Matrix3d.numComputeCache = 0;
exports.Matrix3d = Matrix3d;


/***/ }),

/***/ "./lib/geometry3d/OrderedRotationAngles.js":
/*!*************************************************!*\
  !*** ./lib/geometry3d/OrderedRotationAngles.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const Angle_1 = __webpack_require__(/*! ./Angle */ "./lib/geometry3d/Angle.js");
const Matrix3d_1 = __webpack_require__(/*! ./Matrix3d */ "./lib/geometry3d/Matrix3d.js");
/** OrderedRotationAngles represents a non-trivial rotation using three simple axis rotation angles, and an order in which to apply them. */
class OrderedRotationAngles {
    constructor(x, y, z, axisOrder) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._order = axisOrder;
    }
    // Getters and setters
    get order() { return this._order; }
    get xAngle() { return this._x.clone(); }
    get yAngle() { return this._y.clone(); }
    get zAngle() { return this._z.clone(); }
    get xDegrees() { return this._x.degrees; }
    get xRadians() { return this._x.radians; }
    get yDegrees() { return this._y.degrees; }
    get yRadians() { return this._y.radians; }
    get zDegrees() { return this._z.degrees; }
    get zRadians() { return this._z.radians; }
    static get treatVectorsAsColumns() { return OrderedRotationAngles._sTreatVectorsAsColumns; }
    static set treatVectorsAsColumns(value) { OrderedRotationAngles._sTreatVectorsAsColumns = value; }
    /** Create an OrderedRotationAngles from three angles and an ordering in which to apply them when rotating.
     * @param xRotation rotation around x
     * @param yRotation rotation around y
     * @param zRotation rotation around z
     * @param axisOrder right to left order of axis names identifies the order that rotations are applied to xyz data.
     */
    static createAngles(xRotation, yRotation, zRotation, order, result) {
        if (result) {
            result._x.setFrom(xRotation);
            result._y.setFrom(yRotation);
            result._z.setFrom(zRotation);
            result._order = order;
            return result;
        }
        return new OrderedRotationAngles(xRotation.clone(), yRotation.clone(), zRotation.clone(), order);
    }
    /** Create an OrderedRotationAngles from three angles (in radians) and an ordering in which to apply them when rotating. */
    static createRadians(xRadians, yRadians, zRadians, order, result) {
        if (result) {
            result._x.setRadians(xRadians);
            result._y.setRadians(yRadians);
            result._z.setRadians(zRadians);
            result._order = order;
            return result;
        }
        return new OrderedRotationAngles(Angle_1.Angle.createRadians(xRadians), Angle_1.Angle.createRadians(yRadians), Angle_1.Angle.createRadians(zRadians), order);
    }
    /** Create an OrderedRotationAngles from three angles (in degrees) and an ordering in which to apply them when rotating. */
    static createDegrees(xDegrees, yDegrees, zDegrees, order, result) {
        if (result) {
            result._x.setDegrees(xDegrees);
            result._y.setDegrees(yDegrees);
            result._z.setDegrees(zDegrees);
            result._order = order;
            return result;
        }
        return new OrderedRotationAngles(Angle_1.Angle.createDegrees(xDegrees), Angle_1.Angle.createDegrees(yDegrees), Angle_1.Angle.createDegrees(zDegrees), order);
    }
    /** Create an OrderedRotationAngles from a 3x3 rotational matrix, given the ordering of axis rotations that the matrix derives from. */
    static createFromMatrix3d(matrix, order, result) {
        let m11 = matrix.coffs[0], m12 = matrix.coffs[3], m13 = matrix.coffs[6];
        let m21 = matrix.coffs[1], m22 = matrix.coffs[4], m23 = matrix.coffs[7];
        let m31 = matrix.coffs[2], m32 = matrix.coffs[5], m33 = matrix.coffs[8];
        if (OrderedRotationAngles.treatVectorsAsColumns) {
            // the formulas are from row order .. flip the mIJ
            m11 = matrix.coffs[0], m12 = matrix.coffs[1], m13 = matrix.coffs[2];
            m21 = matrix.coffs[3], m22 = matrix.coffs[4], m23 = matrix.coffs[5];
            m31 = matrix.coffs[6], m32 = matrix.coffs[7], m33 = matrix.coffs[8];
        }
        let xRad;
        let yRad;
        let zRad;
        switch (order) {
            case 0 /* XYZ */: {
                yRad = Math.asin(Math.max(-1, Math.min(1, m13)));
                if (Math.abs(m13) < 0.99999) {
                    xRad = Math.atan2(-m23, m33);
                    zRad = Math.atan2(-m12, m11);
                }
                else {
                    xRad = Math.atan2(m32, m22);
                    zRad = 0;
                }
                break;
            }
            case 5 /* YXZ */: {
                xRad = Math.asin(-Math.max(-1, Math.min(1, m23)));
                if (Math.abs(m23) < 0.99999) {
                    yRad = Math.atan2(m13, m33);
                    zRad = Math.atan2(m21, m22);
                }
                else {
                    yRad = Math.atan2(-m31, m11);
                    zRad = 0;
                }
                break;
            }
            case 2 /* ZXY */: {
                xRad = Math.asin(Math.max(-1, Math.min(1, m32)));
                if (Math.abs(m32) < 0.99999) {
                    yRad = Math.atan2(-m31, m33);
                    zRad = Math.atan2(-m12, m22);
                }
                else {
                    yRad = 0;
                    zRad = Math.atan2(m21, m11);
                }
                break;
            }
            case 6 /* ZYX */: {
                yRad = -Math.asin(Math.max(-1, Math.min(1, m31)));
                if (Math.abs(m31) < 0.99999) {
                    xRad = Math.atan2(m32, m33);
                    zRad = Math.atan2(m21, m11);
                }
                else {
                    xRad = 0;
                    zRad = Math.atan2(-m12, m22);
                }
                break;
            }
            case 1 /* YZX */: {
                zRad = Math.asin(Math.max(-1, Math.min(1, m21)));
                if (Math.abs(m21) < 0.99999) {
                    xRad = Math.atan2(-m23, m22);
                    yRad = Math.atan2(-m31, m11);
                }
                else {
                    xRad = 0;
                    yRad = Math.atan2(m13, m33);
                }
                break;
            }
            case 4 /* XZY */: {
                zRad = -Math.asin(Math.max(-1, Math.min(1, m12)));
                if (Math.abs(m12) < 0.99999) {
                    xRad = Math.atan2(m32, m22);
                    yRad = Math.atan2(m13, m11);
                }
                else {
                    xRad = Math.atan2(-m23, m33);
                    yRad = 0;
                }
                break;
            }
            default: {
                xRad = yRad = zRad = 0;
            }
        }
        if (OrderedRotationAngles.treatVectorsAsColumns)
            return OrderedRotationAngles.createRadians(-xRad, -yRad, -zRad, order, result);
        return OrderedRotationAngles.createRadians(xRad, yRad, zRad, order, result);
    }
    /** Create a 3x3 rotational matrix from this OrderedRotationAngles. */
    toMatrix3d(result) {
        const rot = result !== undefined ? result : new Matrix3d_1.Matrix3d();
        const axisOrder = this.order;
        const x = this.xAngle, y = this.yAngle, z = this.zAngle;
        const a = x.cos();
        let b = x.sin();
        const c = y.cos();
        let d = y.sin();
        const e = z.cos();
        let f = z.sin();
        if (OrderedRotationAngles.treatVectorsAsColumns) {
            b = -b;
            d = -d;
            f = -f;
        }
        if (axisOrder === 0 /* XYZ */) {
            const ae = a * e, af = a * f, be = b * e, bf = b * f;
            rot.setRowValues(c * e, af + be * d, bf - ae * d, -c * f, ae - bf * d, be + af * d, d, -b * c, a * c);
        }
        else if (axisOrder === 5 /* YXZ */) {
            const ce = c * e, cf = c * f, de = d * e, df = d * f;
            rot.setRowValues(ce + df * b, a * f, cf * b - de, de * b - cf, a * e, df + ce * b, a * d, -b, a * c);
        }
        else if (axisOrder === 2 /* ZXY */) {
            const ce = c * e, cf = c * f, de = d * e, df = d * f;
            rot.setRowValues(ce - df * b, cf + de * b, -a * d, -a * f, a * e, b, de + cf * b, df - ce * b, a * c);
        }
        else if (axisOrder === 6 /* ZYX */) {
            const ae = a * e, af = a * f, be = b * e, bf = b * f;
            rot.setRowValues(c * e, c * f, -d, be * d - af, bf * d + ae, b * c, ae * d + bf, af * d - be, a * c);
        }
        else if (axisOrder === 1 /* YZX */) {
            const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
            rot.setRowValues(c * e, f, -d * e, bd - ac * f, a * e, ad * f + bc, bc * f + ad, -b * e, ac - bd * f);
        }
        else if (axisOrder === 4 /* XZY */) {
            const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
            rot.setRowValues(c * e, ac * f + bd, bc * f - ad, -f, a * e, b * e, d * e, ad * f - bc, bd * f + ac);
        }
        if (OrderedRotationAngles.treatVectorsAsColumns)
            rot.transposeInPlace();
        return rot;
    }
}
OrderedRotationAngles._sTreatVectorsAsColumns = false;
exports.OrderedRotationAngles = OrderedRotationAngles;


/***/ }),

/***/ "./lib/geometry3d/Plane3dByOriginAndUnitNormal.js":
/*!********************************************************!*\
  !*** ./lib/geometry3d/Plane3dByOriginAndUnitNormal.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
const Point3dVector3d_1 = __webpack_require__(/*! ./Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
/**
 * A plane defined by
 *
 * * Any point on the plane.
 * * a unit normal.
 */
class Plane3dByOriginAndUnitNormal {
    // constructor captures references !!!
    constructor(origin, normal) {
        this._origin = origin;
        this._normal = normal;
    }
    // This is private because it does not check validity of the unit vector.
    static _create(x, y, z, u, v, w) {
        return new Plane3dByOriginAndUnitNormal(Point3dVector3d_1.Point3d.create(x, y, z), Point3dVector3d_1.Vector3d.create(u, v, w));
    }
    /**
     * Create a plane parallel to the XY plane
     * @param origin optional plane origin.  If omitted, the origin is placed at 000
     */
    static createXYPlane(origin) {
        if (origin)
            return Plane3dByOriginAndUnitNormal._create(origin.x, origin.y, origin.z, 0, 0, 1);
        return Plane3dByOriginAndUnitNormal._create(0, 0, 0, 0, 0, 1);
    }
    /**
     * Create a plane parallel to the YZ plane
     * @param origin optional plane origin.  If omitted, the origin is placed at 000
     */
    static createYZPlane(origin) {
        if (origin)
            return Plane3dByOriginAndUnitNormal._create(origin.x, origin.y, origin.z, 1, 0, 0);
        return Plane3dByOriginAndUnitNormal._create(0, 0, 0, 1, 0, 0);
    }
    /**
     * Create a plane parallel to the ZX plane
     * @param origin optional plane origin.  If omitted, the origin is placed at 000
     */
    static createZXPlane(origin) {
        if (origin)
            return Plane3dByOriginAndUnitNormal._create(origin.x, origin.y, origin.z, 0, 1, 0);
        return Plane3dByOriginAndUnitNormal._create(0, 0, 0, 0, 1, 0);
    }
    static create(origin, normal, result) {
        const normalized = normal.normalize();
        if (!normalized)
            return undefined;
        if (result) {
            result.set(origin, normalized);
            return result;
        }
        return new Plane3dByOriginAndUnitNormal(origin.clone(), normalized);
    }
    /** Create a plane defined by two points and an in-plane vector.
     * @param pointA any point in the plane
     * @param pointB any other point in the plane
     * @param vector any vector in the plane but not parallel to the vector from pointA to pointB
     */
    static createPointPointVectorInPlane(pointA, pointB, vector) {
        const cross = vector.crossProductStartEnd(pointA, pointB);
        if (cross.tryNormalizeInPlace())
            return new Plane3dByOriginAndUnitNormal(pointA, cross);
        return undefined;
    }
    isAlmostEqual(other) {
        return this._origin.isAlmostEqual(other._origin) && this._normal.isAlmostEqual(other._normal);
    }
    setFromJSON(json) {
        if (!json) {
            this._origin.set(0, 0, 0);
            this._normal.set(0, 0, 1);
        }
        else {
            this._origin.setFromJSON(json.origin);
            this._normal.setFromJSON(json.normal);
        }
    }
    /**
     * Convert to a JSON object.
     * @return {*} [origin,normal]
     */
    toJSON() { return { origin: this._origin.toJSON(), normal: this._normal.toJSON() }; }
    static fromJSON(json) {
        const result = Plane3dByOriginAndUnitNormal.createXYPlane();
        result.setFromJSON(json);
        return result;
    }
    /** @returns a reference to the origin. */
    getOriginRef() { return this._origin; }
    /** @returns a reference to the unit normal. */
    getNormalRef() { return this._normal; }
    /** Copy coordinates from the given origin and normal. */
    set(origin, normal) {
        this._origin.setFrom(origin);
        this._normal.setFrom(normal);
    }
    clone(result) {
        if (result) {
            result.set(this._origin, this._normal);
            return result;
        }
        return new Plane3dByOriginAndUnitNormal(this._origin.clone(), this._normal.clone());
    }
    /** Create a clone and return the transform of the clone. */
    cloneTransformed(transform) {
        const result = this.clone();
        transform.multiplyPoint3d(result._origin, result._origin);
        transform.matrix.multiplyInverseTranspose(result._normal, result._normal);
        if (result._normal.normalizeInPlace())
            return result;
        return undefined;
    }
    /** Copy data from the given plane. */
    setFrom(source) {
        this.set(source._origin, source._normal);
    }
    /** @returns Return the altitude of spacePoint above or below the plane.  (Below is negative) */
    altitude(spacePoint) { return this._normal.dotProductStartEnd(this._origin, spacePoint); }
    /** @returns Return the altitude of weighted spacePoint above or below the plane.  (Below is negative) */
    weightedAltitude(spacePoint) {
        return this._normal.dotProductStart3dEnd4d(this._origin, spacePoint);
    }
    /** @returns return a point at specified (signed) altitude */
    altitudeToPoint(altitude, result) {
        return this._origin.plusScaled(this._normal, altitude, result);
    }
    /** @returns The dot product of spaceVector with the plane's unit normal.  This tells the rate of change of altitude
     * for a point moving at speed one along the spaceVector.
     */
    velocityXYZ(x, y, z) { return this._normal.dotProductXYZ(x, y, z); }
    /** @returns The dot product of spaceVector with the plane's unit normal.  This tells the rate of change of altitude
     * for a point moving at speed one along the spaceVector.
     */
    velocity(spaceVector) { return this._normal.dotProduct(spaceVector); }
    /** @returns the altitude of a point given as separate x,y,z components. */
    altitudeXYZ(x, y, z) {
        return this._normal.dotProductStartEndXYZ(this._origin, x, y, z);
    }
    /** @returns the altitude of a point given as separate x,y,z,w components. */
    altitudeXYZW(x, y, z, w) {
        return this._normal.dotProductStartEndXYZW(this._origin, x, y, z, w);
    }
    /** @returns Return the projection of spacePoint onto the plane. */
    projectPointToPlane(spacePoint, result) {
        return spacePoint.plusScaled(this._normal, -this._normal.dotProductStartEnd(this._origin, spacePoint), result);
    }
    /** @return Returns true of spacePoint is within distance tolerance of the plane. */
    isPointInPlane(spacePoint) { return Geometry_1.Geometry.isSmallMetricDistance(this.altitude(spacePoint)); }
}
exports.Plane3dByOriginAndUnitNormal = Plane3dByOriginAndUnitNormal;


/***/ }),

/***/ "./lib/geometry3d/Plane3dByOriginAndVectors.js":
/*!*****************************************************!*\
  !*** ./lib/geometry3d/Plane3dByOriginAndVectors.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
const Point3dVector3d_1 = __webpack_require__(/*! ./Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
/**
 * A Point3dVector3dVector3d is an origin and a pair of vectors.
 * This defines a plane with (possibly skewed) uv coordinates
 */
class Plane3dByOriginAndVectors {
    constructor(origin, vectorU, vectorV) {
        this.origin = origin;
        this.vectorU = vectorU;
        this.vectorV = vectorV;
    }
    static createOriginAndVectors(origin, vectorU, vectorV, result) {
        if (result) {
            result.origin.setFrom(origin);
            result.vectorU.setFrom(vectorU);
            result.vectorV.setFrom(vectorV);
            return result;
        }
        return new Plane3dByOriginAndVectors(origin.clone(), vectorU.clone(), vectorV.clone());
    }
    /**
     * Return a Plane3dByOriginAndVectors, with
     * * irigin is the translation (aka origin) from the Transform
     * * vectorU is the X column of the transform
     * * vectorV is the Y column of the transform.
     * @param transform source trnasform
     * @param xLength optional length to impose on vectorU.
     * @param yLength optional length to impose on vectorV.
     * @param result optional preexisting result
     */
    static createFromTransformColumnsXYAndLengths(transform, xLength, yLength, result) {
        if (result) {
            result.origin.setFrom(transform.getOrigin());
            transform.matrix.columnX(result.vectorU);
            transform.matrix.columnY(result.vectorV);
        }
        else {
            result = new Plane3dByOriginAndVectors(transform.getOrigin(), transform.matrix.columnX(), transform.matrix.columnY());
        }
        if (xLength !== undefined)
            result.vectorU.scaleToLength(xLength, result.vectorU);
        if (yLength !== undefined)
            result.vectorV.scaleToLength(yLength, result.vectorV);
        return result;
    }
    /** Capture origin and directions in a new planed. */
    static createCapture(origin, vectorU, vectorV, result) {
        if (!result)
            return new Plane3dByOriginAndVectors(origin, vectorU, vectorV);
        result.origin = origin;
        result.vectorU = vectorU;
        result.vectorV = vectorV;
        return result;
    }
    setOriginAndVectorsXYZ(x0, y0, z0, ux, uy, uz, vx, vy, vz) {
        this.origin.set(x0, y0, z0);
        this.vectorU.set(ux, uy, uz);
        this.vectorV.set(vx, vy, vz);
        return this;
    }
    setOriginAndVectors(origin, vectorU, vectorV) {
        this.origin.setFrom(origin);
        this.vectorU.setFrom(vectorU);
        this.vectorV.setFrom(vectorV);
        return this;
    }
    static createOriginAndVectorsXYZ(x0, y0, z0, ux, uy, uz, vx, vy, vz, result) {
        if (result)
            return result.setOriginAndVectorsXYZ(x0, y0, z0, ux, uy, uz, vx, vy, vz);
        return new Plane3dByOriginAndVectors(Point3dVector3d_1.Point3d.create(x0, y0, z0), Point3dVector3d_1.Vector3d.create(ux, uy, uz), Point3dVector3d_1.Vector3d.create(vx, vy, vz));
    }
    /** Define a plane by three points in the plane.
     * @param origin origin for the parameterization.
     * @param targetU target point for the vectorU starting at the origin.
     * @param targetV target point for the vectorV originating at the origin.
     * @param result optional result.
     */
    static createOriginAndTargets(origin, targetU, targetV, result) {
        return Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(origin.x, origin.y, origin.z, targetU.x - origin.x, targetU.y - origin.y, targetU.z - origin.z, targetV.x - origin.x, targetV.y - origin.y, targetV.z - origin.z, result);
    }
    /** Create a plane with origin at 000, unit vectorU in x direction, and unit vectorV in the y direction.
     */
    static createXYPlane(result) {
        return Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(0, 0, 0, 1, 0, 0, 0, 1, 0, result);
    }
    /** create a plane from data presented as Float64Arrays.
     * @param origin x,y,z of origin.
     * @param vectorU x,y,z of vectorU
     * @param vectorV x,y,z of vectorV
     */
    static createOriginAndVectorsArrays(origin, vectorU, vectorV, result) {
        return Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(origin[0], origin[1], origin[2], vectorU[0], vectorU[1], vectorU[2], vectorV[0], vectorV[1], vectorV[2], result);
    }
    /** create a plane from data presented as Float64Array with weights
     * @param origin x,y,z,w of origin.
     * @param vectorU x,y,z,w of vectorU
     * @param vectorV x,y,z,w of vectorV
     */
    static createOriginAndVectorsWeightedArrays(originw, vectorUw, vectorVw, result) {
        const w = originw[3];
        result = Plane3dByOriginAndVectors.createXYPlane(result);
        if (Geometry_1.Geometry.isSmallMetricDistance(w))
            return result;
        const dw = 1.0 / w;
        const au = vectorUw[3] * dw * dw;
        const av = vectorVw[3] * dw * dw;
        // for homogeneous function X, with w its weight:
        // (X/w) is the cartesian point.
        // (X/w)' = (X' w - X w')/(w*w)
        //        = X'/w  - (X/w)(w'/w)
        //        = X'/w  - X w'/w^2)
        // The w parts of the formal xyzw sums are identically 0.
        // Here the X' and its w' are taken from each vectorUw and vectorVw
        result.origin.set(originw[0] * dw, originw[1] * dw, originw[2] * dw);
        Point3dVector3d_1.Vector3d.createAdd2ScaledXYZ(vectorUw[0], vectorUw[1], vectorUw[2], dw, originw[0], originw[1], originw[2], -au, result.vectorU);
        Point3dVector3d_1.Vector3d.createAdd2ScaledXYZ(vectorVw[0], vectorVw[1], vectorVw[2], dw, originw[0], originw[1], originw[2], -av, result.vectorV);
        return result;
    }
    /**
     * Evaluate a point a grid coordinates on the plane.
     * * The computed point is `origin + vectorU * u + vectorV * v`
     * @param u coordinate along vectorU
     * @param v coordinate along vectorV
     * @param result optional result destination.
     * @returns Return the computed coordinate.
     */
    fractionToPoint(u, v, result) {
        return this.origin.plus2Scaled(this.vectorU, u, this.vectorV, v, result);
    }
    fractionToVector(u, v, result) {
        return Point3dVector3d_1.Vector3d.createAdd2Scaled(this.vectorU, u, this.vectorV, v, result);
    }
    setFromJSON(json) {
        if (!json || !json.origin || !json.vectorV) {
            this.origin.set(0, 0, 0);
            this.vectorU.set(1, 0, 0);
            this.vectorV.set(0, 1, 0);
        }
        else {
            this.origin.setFromJSON(json.origin);
            this.vectorU.setFromJSON(json.vectorU);
            this.vectorV.setFromJSON(json.vectorV);
        }
    }
    /**
     * Convert an Angle to a JSON object.
     * @return {*} [origin,normal]
     */
    toJSON() {
        return {
            origin: this.origin.toJSON(),
            vectorU: this.vectorU.toJSON(),
            vectorV: this.vectorV.toJSON(),
        };
    }
    static fromJSON(json) {
        const result = Plane3dByOriginAndVectors.createXYPlane();
        result.setFromJSON(json);
        return result;
    }
    isAlmostEqual(other) {
        return this.origin.isAlmostEqual(other.origin)
            && this.vectorU.isAlmostEqual(other.vectorU)
            && this.vectorV.isAlmostEqual(other.vectorV);
    }
}
exports.Plane3dByOriginAndVectors = Plane3dByOriginAndVectors;


/***/ }),

/***/ "./lib/geometry3d/Point2dVector2d.js":
/*!*******************************************!*\
  !*** ./lib/geometry3d/Point2dVector2d.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Angle_1 = __webpack_require__(/*! ./Angle */ "./lib/geometry3d/Angle.js");
/** Minimal object containing x,y and operations that are meaningful without change in both point and vector. */
class XY {
    /** Set both x and y. */
    set(x = 0, y = 0) { this.x = x; this.y = y; }
    /** Set both x and y to zero */
    setZero() { this.x = 0; this.y = 0; }
    constructor(x = 0, y = 0) { this.x = x; this.y = y; }
    /** Set both x and y from other. */
    setFrom(other) {
        if (other) {
            this.x = other.x;
            this.y = other.y;
        }
        else {
            this.x = 0;
            this.y = 0;
        }
    }
    /** Returns true if this and other have equal x,y parts within Geometry.smallMetricDistance. */
    isAlmostEqual(other, tol) { return Geometry_1.Geometry.isSameCoordinate(this.x, other.x, tol) && Geometry_1.Geometry.isSameCoordinate(this.y, other.y, tol); }
    /** return a json array or object with the [x,y] data.  */
    toJSON() { return [this.x, this.y]; }
    toJSONXY() { return { x: this.x, y: this.y }; }
    /** Set x and y from a JSON source */
    setFromJSON(json) {
        if (Array.isArray(json)) {
            this.set(json[0] || 0, json[1] || 0);
            return;
        }
        if (json) {
            this.set(json.x || 0, json.y || 0);
            return;
        }
        this.set(0, 0);
    }
    /** Return the distance from this point to other */
    distance(other) {
        const xDist = other.x - this.x;
        const yDist = other.y - this.y;
        return (Math.sqrt(xDist * xDist + yDist * yDist));
    }
    /** Return squared distance from this point to other */
    distanceSquared(other) {
        const xDist = other.x - this.x;
        const yDist = other.y - this.y;
        return (xDist * xDist + yDist * yDist);
    }
    /** Return the largest absolute distance between corresponding components */
    maxDiff(other) {
        return Math.max(Math.abs(this.x - other.x), Math.abs(this.y - other.y));
    }
    /** @returns true if the x,y components are both small by metric metric tolerance */
    get isAlmostZero() {
        return Geometry_1.Geometry.isSmallMetricDistance(this.x) && Geometry_1.Geometry.isSmallMetricDistance(this.y);
    }
    /** Return the largest absolute value of any component */
    maxAbs() { return Math.max(Math.abs(this.x), Math.abs(this.y)); }
    /** Return the magnitude of the vector */
    magnitude() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    /** Return the squared magnitude of the vector.  */
    magnitudeSquared() { return this.x * this.x + this.y * this.y; }
    /** @returns true if the x,y components are exactly equal. */
    isExactEqual(other) { return this.x === other.x && this.y === other.y; }
    isAlmostEqualMetric(other) { return this.maxDiff(other) <= Geometry_1.Geometry.smallMetricDistance; }
    /** Return a (full length) vector from this point to other */
    vectorTo(other, result) {
        return Vector2d.create(other.x - this.x, other.y - this.y, result);
    }
    /** Return a unit vector from this point to other */
    unitVectorTo(target, result) {
        return this.vectorTo(target, result).normalize(result);
    }
}
exports.XY = XY;
class Point2d extends XY {
    /** Constructor for Point2d */
    constructor(x = 0, y = 0) { super(x, y); }
    clone() { return new Point2d(this.x, this.y); }
    /**
     * Return a point (newly created unless result provided) with given x,y coordinates
     * @param x x coordinate
     * @param y y coordinate
     * @param result optional result
     */
    static create(x = 0, y = 0, result) {
        if (result) {
            result.x = x;
            result.y = y;
            return result;
        }
        return new Point2d(x, y);
    }
    static fromJSON(json) { const val = new Point2d(); val.setFromJSON(json); return val; }
    static createFrom(xy, result) {
        if (xy)
            return Point2d.create(xy.x, xy.y, result);
        return Point2d.create(0, 0, result);
    }
    static createZero(result) { return Point2d.create(0, 0, result); }
    addForwardLeft(tangentFraction, leftFraction, vector) {
        const dx = vector.x;
        const dy = vector.y;
        return Point2d.create(this.x + tangentFraction * dx - leftFraction * dy, this.y + tangentFraction * dy + leftFraction * dx);
    }
    forwardLeftInterpolate(tangentFraction, leftFraction, point) {
        const dx = point.x - this.x;
        const dy = point.y - this.y;
        return Point2d.create(this.x + tangentFraction * dx - leftFraction * dy, this.y + tangentFraction * dy + leftFraction * dx);
    }
    /** Return a point interpolated between this point and the right param. */
    interpolate(fraction, other, result) {
        if (fraction <= 0.5)
            return Point2d.create(this.x + fraction * (other.x - this.x), this.y + fraction * (other.y - this.y), result);
        const t = fraction - 1.0;
        return Point2d.create(other.x + t * (other.x - this.x), other.y + t * (other.y - this.y), result);
    }
    /** Return a point with independent x,y fractional interpolation. */
    interpolateXY(fractionX, fractionY, other, result) {
        return Point2d.create(Geometry_1.Geometry.interpolate(this.x, fractionX, other.x), Geometry_1.Geometry.interpolate(this.y, fractionY, other.y), result);
    }
    /** Return point minus vector */
    minus(vector, result) {
        return Point2d.create(this.x - vector.x, this.y - vector.y, result);
    }
    /** Return point plus vector */
    plus(vector, result) {
        return Point2d.create(this.x + vector.x, this.y + vector.y, result);
    }
    /** Return point plus vector */
    plusXY(dx = 0, dy = 0, result) {
        return Point2d.create(this.x + dx, this.y + dy, result);
    }
    /** Return point + vector * scalar */
    plusScaled(vector, scaleFactor, result) {
        return Point2d.create(this.x + vector.x * scaleFactor, this.y + vector.y * scaleFactor, result);
    }
    /** Return point + vectorA * scalarA + vectorB * scalarB */
    plus2Scaled(vectorA, scalarA, vectorB, scalarB, result) {
        return Point2d.create(this.x + vectorA.x * scalarA + vectorB.x * scalarB, this.y + vectorA.y * scalarA + vectorB.y * scalarB, result);
    }
    /** Return point + vectorA * scalarA + vectorB * scalarB + vectorC * scalarC */
    plus3Scaled(vectorA, scalarA, vectorB, scalarB, vectorC, scalarC, result) {
        return Point2d.create(this.x + vectorA.x * scalarA + vectorB.x * scalarB + vectorC.x * scalarC, this.y + vectorA.y * scalarA + vectorB.y * scalarB + vectorC.y * scalarC, result);
    }
    /**
     * @returns dot product of vector from this to targetA and vector from this to targetB
     * @param targetA target of first vector
     * @param targetB target of second vector
     */
    dotVectorsToTargets(targetA, targetB) {
        return (targetA.x - this.x) * (targetB.x - this.x) +
            (targetA.y - this.y) * (targetB.y - this.y);
    }
    /** Returns the (scalar) cross product of two points/vectors, computed from origin to target1 and target2 */
    crossProductToPoints(target1, target2) {
        const x1 = target1.x - this.x;
        const y1 = target1.y - this.y;
        const x2 = target2.x - this.x;
        const y2 = target2.y - this.y;
        return x1 * y2 - y1 * x2;
    }
    fractionOfProjectionToLine(startPoint, endPoint, defaultFraction) {
        const denominator = startPoint.distanceSquared(endPoint);
        if (denominator < Geometry_1.Geometry.smallMetricDistanceSquared)
            return defaultFraction ? defaultFraction : 0;
        return startPoint.dotVectorsToTargets(endPoint, this) / denominator;
    }
}
exports.Point2d = Point2d;
/** 3D vector with x,y properties */
class Vector2d extends XY {
    constructor(x = 0, y = 0) { super(x, y); }
    clone() { return new Vector2d(this.x, this.y); }
    static create(x = 0, y = 0, result) {
        if (result) {
            result.x = x;
            result.y = y;
            return result;
        }
        return new Vector2d(x, y);
    }
    // unit X vector
    static unitX(scale = 1) { return new Vector2d(scale, 0); }
    // unit Y vector
    static unitY(scale = 1) { return new Vector2d(0, scale); }
    // zero vector
    static createZero(result) { return Vector2d.create(0, 0, result); }
    /** copy contents from another Point3d, Point2d, Vector2d, or Vector3d */
    static createFrom(data, result) {
        if (data instanceof Float64Array) {
            if (data.length >= 2)
                return Vector2d.create(data[0], data[1]);
            if (data.length >= 1)
                return Vector2d.create(data[0], 0);
            return Vector2d.create(0, 0);
        }
        return Vector2d.create(data.x, data.y, result);
    }
    static fromJSON(json) { const val = new Vector2d(); val.setFromJSON(json); return val; }
    static createPolar(r, theta) {
        return Vector2d.create(r * theta.cos());
    }
    static createStartEnd(point0, point1, result) {
        if (result) {
            result.set(point1.x - point0.x, point1.y - point0.y);
            return result;
        }
        return new Vector2d(point1.x - point0.x, point1.y - point0.y);
    }
    /**
     * Return a vector that bisects the angle between two normals and extends to the intersection of two offset lines
     * @param unitPerpA unit perpendicular to incoming direction
     * @param unitPerpB  unit perpendicular to outgoing direction
     * @param offset offset distance
     */
    static createOffsetBisector(unitPerpA, unitPerpB, offset) {
        let bisector = unitPerpA.plus(unitPerpB);
        bisector = bisector.normalize();
        if (bisector) {
            const c = offset * bisector.dotProduct(unitPerpA);
            return bisector.safeDivideOrNull(c);
        }
        return undefined;
    }
    // Divide by denominator, but return undefined if denominator is zero.
    safeDivideOrNull(denominator, result) {
        if (denominator !== 0.0) {
            return this.scale(1.0 / denominator, result);
        }
        return undefined;
    }
    normalize(result) {
        const mag = Geometry_1.Geometry.correctSmallMetricDistance(this.magnitude());
        result = result ? result : new Vector2d();
        return this.safeDivideOrNull(mag, result);
    }
    /** return the fractional projection of spaceVector onto this */
    fractionOfProjectionToVector(target, defaultFraction) {
        const numerator = this.dotProduct(target);
        const denominator = target.magnitudeSquared();
        if (denominator < Geometry_1.Geometry.smallMetricDistanceSquared)
            return defaultFraction ? defaultFraction : 0;
        return numerator / denominator;
    }
    /** Negate components */
    negate(result) {
        result = result ? result : new Vector2d();
        result.x = -this.x;
        result.y = -this.y;
        return result;
    }
    // return a vector same length as this but rotate 90 degrees CCW
    rotate90CCWXY(result) {
        result = result ? result : new Vector2d();
        // save x,y to allow aliasing ..
        const xx = this.x;
        const yy = this.y;
        result.x = -yy;
        result.y = xx;
        return result;
    }
    // return a vector same length as this but rotate 90 degrees CW
    rotate90CWXY(result) {
        result = result ? result : new Vector2d();
        // save x,y to allow aliasing ..
        const xx = this.x;
        const yy = this.y;
        result.x = yy;
        result.y = -xx;
        return result;
    }
    unitPerpendicularXY(result) {
        result = result ? result : new Vector2d();
        const xx = this.x;
        const yy = this.y;
        result.x = -yy;
        result.y = xx;
        const d2 = xx * xx + yy * yy;
        if (d2 !== 0.0) {
            const a = 1.0 / Math.sqrt(d2);
            result.x *= a;
            result.y *= a;
        }
        return result;
    }
    rotateXY(angle, result) {
        const s = angle.sin();
        const c = angle.cos();
        const xx = this.x;
        const yy = this.y;
        result = result ? result : new Vector2d();
        result.x = xx * c - yy * s;
        result.y = xx * s + yy * c;
        return result;
    }
    /** return the interpolation {this + fraction * (right - this)} */
    interpolate(fraction, right, result) {
        result = result ? result : new Vector2d();
        /* For best last-bit behavior, if fraction is below 0.5, use this as base point.   If above 0.5, use right as base point.   */
        if (fraction <= 0.5) {
            result.x = this.x + fraction * (right.x - this.x);
            result.y = this.y + fraction * (right.y - this.y);
        }
        else {
            const t = fraction - 1.0;
            result.x = right.x + t * (right.x - this.x);
            result.y = right.y + t * (right.y - this.y);
        }
        return result;
    }
    /** return {this + vector}. */
    plus(vector, result) {
        result = result ? result : new Vector2d();
        result.x = this.x + vector.x;
        result.y = this.y + vector.y;
        return result;
    }
    /** return {this - vector}. */
    minus(vector, result) {
        result = result ? result : new Vector2d();
        result.x = this.x - vector.x;
        result.y = this.y - vector.y;
        return result;
    }
    /** Return {point + vector \* scalar} */
    plusScaled(vector, scaleFactor, result) {
        result = result ? result : new Vector2d();
        result.x = this.x + vector.x * scaleFactor;
        result.y = this.y + vector.y * scaleFactor;
        return result;
    }
    /** Return {point + vectorA \* scalarA + vectorB \* scalarB} */
    plus2Scaled(vectorA, scalarA, vectorB, scalarB, result) {
        result = result ? result : new Vector2d();
        result.x = this.x + vectorA.x * scalarA + vectorB.x * scalarB;
        result.y = this.y + vectorA.y * scalarA + vectorB.y * scalarB;
        return result;
    }
    /** Return {this + vectorA \* scalarA + vectorB \* scalarB + vectorC \* scalarC} */
    plus3Scaled(vectorA, scalarA, vectorB, scalarB, vectorC, scalarC, result) {
        result = result ? result : new Vector2d();
        result.x = this.x + vectorA.x * scalarA + vectorB.x * scalarB + vectorC.x * scalarC;
        result.y = this.y + vectorA.y * scalarA + vectorB.y * scalarB + vectorC.y * scalarC;
        return result;
    }
    /** Return {this * scale} */
    scale(scale, result) {
        result = result ? result : new Vector2d();
        result.x = this.x * scale;
        result.y = this.y * scale;
        return result;
    }
    /** return a vector parallel to this but with specified length */
    scaleToLength(length, result) {
        const mag = Geometry_1.Geometry.correctSmallMetricDistance(this.magnitude());
        if (mag === 0)
            return new Vector2d();
        return this.scale(length / mag, result);
    }
    /** return the dot product of this with vectorB */
    dotProduct(vectorB) { return this.x * vectorB.x + this.y * vectorB.y; }
    /** dot product with vector from pointA to pointB */
    dotProductStartEnd(pointA, pointB) {
        return this.x * (pointB.x - pointA.x)
            + this.y * (pointB.y - pointA.y);
    }
    /** vector cross product {this CROSS vectorB} */
    crossProduct(vectorB) { return this.x * vectorB.y - this.y * vectorB.x; }
    /** return the (signed) angle from this to vectorB.   This is positive if the shortest turn is counterclockwise, negative if clockwise. */
    angleTo(vectorB) {
        return Angle_1.Angle.createAtan2(this.crossProduct(vectorB), this.dotProduct(vectorB));
    }
    /*  smallerUnorientedAngleTo(vectorB: Vector2d): Angle { }
      signedAngleTo(vectorB: Vector2d, upVector: Vector2d): Angle { }
      planarAngleTo(vectorB: Vector2d, planeNormal: Vector2d): Angle { }
      // sectors
      isInSmallerSector(vectorA: Vector2d, vectorB: Vector2d): boolean { }
      isInCCWSector(vectorA: Vector2d, vectorB: Vector2d, upVector: Vector2d): boolean { }
      */
    isParallelTo(other, oppositeIsParallel = false) {
        const a2 = this.magnitudeSquared();
        const b2 = other.magnitudeSquared();
        // we know both are 0 or positive -- no need for
        if (a2 < Geometry_1.Geometry.smallMetricDistanceSquared || b2 < Geometry_1.Geometry.smallMetricDistanceSquared)
            return false;
        const dot = this.dotProduct(other);
        if (dot < 0.0 && !oppositeIsParallel)
            return false;
        const cross = this.crossProduct(other);
        /* a2,b2,cross2 are squared lengths of respective vectors */
        /* cross2 = sin^2(theta) * a2 * b2 */
        /* For small theta, sin^2(theta)~~theta^2 */
        return cross * cross <= Geometry_1.Geometry.smallAngleRadiansSquared * a2 * b2;
    }
    /**
     * @returns `true` if `this` vector is perpendicular to `other`.
     * @param other second vector.
     */
    isPerpendicularTo(other) {
        return Angle_1.Angle.isPerpendicularDotSet(this.magnitudeSquared(), other.magnitudeSquared(), this.dotProduct(other));
    }
}
exports.Vector2d = Vector2d;


/***/ }),

/***/ "./lib/geometry3d/Point3dVector3d.js":
/*!*******************************************!*\
  !*** ./lib/geometry3d/Point3dVector3d.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Angle_1 = __webpack_require__(/*! ./Angle */ "./lib/geometry3d/Angle.js");
const Ray3d_1 = __webpack_require__(/*! ./Ray3d */ "./lib/geometry3d/Ray3d.js");
/** Minimal object containing x,y,z and operations that are meaningful without change in both point and vector. */
class XYZ {
    /**
     * Set the x,y,z  parts.
     * @param x (optional) x part
     * @param y (optional) y part
     * @param z (optional) z part
     */
    set(x = 0, y = 0, z = 0) { this.x = x; this.y = y; this.z = z; }
    /** Set the x,y,z parts to zero. */
    setZero() { this.x = 0; this.y = 0; this.z = 0; }
    constructor(x = 0, y = 0, z = 0) { this.x = x; this.y = y; this.z = z; }
    /** Type guard for XAndY.
     * @note this will return true for an XYAndZ. If you wish to distinguish between the two, call isXYAndZ first.
     */
    static isXAndY(arg) { return arg.x !== undefined && arg.y !== undefined; }
    /** Type guard to determine whether an object has a member called "z" */
    static hasZ(arg) { return arg.z !== undefined; }
    /** Type guard for XYAndZ.  */
    static isXYAndZ(arg) { return this.isXAndY(arg) && this.hasZ(arg); }
    /**
     * Set the x,y,z parts from one of these input types
     *
     * * XYZ -- copy the x,y,z parts
     * * Float64Array -- Copy from indices 0,1,2 to x,y,z
     * * XY -- copy the x, y parts and set z=0
     */
    setFrom(other) {
        if (XYZ.isXAndY(other)) {
            this.x = other.x;
            this.y = other.y;
            this.z = XYZ.hasZ(other) ? other.z : 0;
        }
        else {
            this.x = other[0];
            this.y = other[1];
            this.z = other[2];
        }
    }
    /**
     * Set the x,y,z parts from a Point3d.
     * This is the same effect as `setFrom(other)` with no pretesting of variant input type
     */
    setFromPoint3d(other) {
        this.x = other.x;
        this.y = other.y;
        this.z = other.z;
    }
    /**
     * Set the x,y,z parts from a Vector3d
     * This is the same effect as `setFrom(other)` with no pretesting of variant input type
     */
    setFromVector3d(other) {
        this.x = other.x;
        this.y = other.y;
        this.z = other.z;
    }
    /** Returns true if this and other have equal x,y,z parts within Geometry.smallMetricDistance.
     * @param other The other XYAndZ to compare
     * @param tol The tolerance for the comparison. If undefined, use [[Geometry.smallMetricDistance]]
     */
    isAlmostEqual(other, tol) {
        return Geometry_1.Geometry.isSameCoordinate(this.x, other.x, tol)
            && Geometry_1.Geometry.isSameCoordinate(this.y, other.y, tol)
            && Geometry_1.Geometry.isSameCoordinate(this.z, other.z, tol);
    }
    /** Return true if this and other have equal x,y,z parts within Geometry.smallMetricDistance. */
    isAlmostEqualXYZ(x, y, z, tol) {
        return Geometry_1.Geometry.isSameCoordinate(this.x, x, tol)
            && Geometry_1.Geometry.isSameCoordinate(this.y, y, tol)
            && Geometry_1.Geometry.isSameCoordinate(this.z, z, tol);
    }
    /** Return true if this and other have equal x,y parts within Geometry.smallMetricDistance. */
    isAlmostEqualXY(other, tol) {
        return Geometry_1.Geometry.isSameCoordinate(this.x, other.x, tol)
            && Geometry_1.Geometry.isSameCoordinate(this.y, other.y, tol);
    }
    /** Return a JSON object as array [x,y,z] */
    toJSON() { return [this.x, this.y, this.z]; }
    toJSONXYZ() { return { x: this.x, y: this.y, z: this.z }; }
    /** Pack the x,y,z values in a Float64Array. */
    toFloat64Array() { return Float64Array.of(this.x, this.y, this.z); }
    /**
     * Set the x,y,z properties from one of several json forms:
     *
     * *  array of numbers: [x,y,z]
     * *  object with x,y, and (optional) z as numeric properties {x: xValue, y: yValue, z: zValue}
     */
    setFromJSON(json) {
        if (Array.isArray(json)) {
            this.set(json[0] || 0, json[1] || 0, json[2] || 0);
            return;
        }
        if (json) {
            this.set(json.x || 0, json.y || 0, json.z || 0);
            return;
        }
        this.set(0, 0, 0);
    }
    /** Return the distance from this point to other */
    distance(other) {
        const xDist = other.x - this.x;
        const yDist = other.y - this.y;
        const zDist = other.z - this.z;
        return (Math.sqrt(xDist * xDist + yDist * yDist + zDist * zDist));
    }
    /** Return squared distance from this point to other */
    distanceSquared(other) {
        const xDist = other.x - this.x;
        const yDist = other.y - this.y;
        const zDist = other.z - this.z;
        return (xDist * xDist + yDist * yDist + zDist * zDist);
    }
    /** Return the XY distance from this point to other */
    distanceXY(other) {
        const xDist = other.x - this.x;
        const yDist = other.y - this.y;
        return (Math.sqrt(xDist * xDist + yDist * yDist));
    }
    /** Return squared XY distance from this point to other */
    distanceSquaredXY(other) {
        const xDist = other.x - this.x;
        const yDist = other.y - this.y;
        return (xDist * xDist + yDist * yDist);
    }
    /** Return the largest absolute distance between corresponding components */
    maxDiff(other) {
        return Math.max(Math.abs(this.x - other.x), Math.abs(this.y - other.y), Math.abs(this.z - other.z));
    }
    /**
     * Return the x,y, z component corresponding to 0,1,2.
     */
    at(index) {
        if (index < 0.5)
            return this.x;
        if (index > 1.5)
            return this.z;
        return this.y;
    }
    /** Return the index (0,1,2) of the x,y,z component with largest absolute value */
    indexOfMaxAbs() {
        let index = 0;
        let a = Math.abs(this.x);
        let b = Math.abs(this.y);
        if (b > a) {
            index = 1;
            a = b;
        }
        b = Math.abs(this.z);
        if (b > a) {
            index = 2;
            a = b;
        }
        return index;
    }
    /** Return true if the if x,y,z components are all nearly zero to tolerance Geometry.smallMetricDistance */
    get isAlmostZero() {
        return Geometry_1.Geometry.isSmallMetricDistance(this.x) && Geometry_1.Geometry.isSmallMetricDistance(this.y) && Geometry_1.Geometry.isSmallMetricDistance(this.z);
    }
    /** Return the largest absolute value of any component */
    maxAbs() { return Math.max(Math.abs(this.x), Math.abs(this.y), Math.abs(this.z)); }
    /** Return the sqrt of the sum of squared x,y,z parts */
    magnitude() { return Math.hypot(this.x, this.y, this.z); }
    /** Return the sum of squared x,y,z parts */
    magnitudeSquared() { return this.x * this.x + this.y * this.y + this.z * this.z; }
    /** Return sqrt of the sum of squared x,y parts */
    magnitudeXY() { return Math.hypot(this.x, this.y); }
    /** Return the sum of squared x,y parts */
    magnitudeSquaredXY() { return this.x * this.x + this.y * this.y; }
    /** exact equality test. */
    isExactEqual(other) { return this.x === other.x && this.y === other.y && this.z === other.z; }
    /** equality test with Geometry.smallMetricDistance tolerance */
    isAlmostEqualMetric(other) { return this.maxDiff(other) <= Geometry_1.Geometry.smallMetricDistance; }
    /** add x,y,z from other in place. */
    addInPlace(other) { this.x += other.x; this.y += other.y; this.z += other.z; }
    /** add (in place) the scaled x,y,z of other */
    addScaledInPlace(other, scale) {
        this.x += scale * other.x;
        this.y += scale * other.y;
        this.z += scale * other.z;
    }
    /** Multiply the x, y, z parts by scale. */
    scaleInPlace(scale) { this.x *= scale; this.y *= scale; this.z *= scale; }
    /** Clone strongly typed as Point3d */
    cloneAsPoint3d() { return Point3d.create(this.x, this.y, this.z); }
    /** Return a (full length) vector from this point to other */
    vectorTo(other, result) {
        return Vector3d.create(other.x - this.x, other.y - this.y, other.z - this.z, result);
    }
    /** Return a multiple of a the (full length) vector from this point to other */
    scaledVectorTo(other, scale, result) {
        return Vector3d.create(scale * (other.x - this.x), scale * (other.y - this.y), scale * (other.z - this.z), result);
    }
    /** Return a unit vector from this vector to other. Return a 000 vector if the input is too small to normalize.
     * @param other target of created vector.
     * @param result optional result vector.
     */
    unitVectorTo(target, result) { return this.vectorTo(target, result).normalize(result); }
    /** Freeze this XYZ */
    freeze() { Object.freeze(this); }
}
exports.XYZ = XYZ;
/** 3D point with x,y,z properties */
class Point3d extends XYZ {
    /** Constructor for Point3d */
    constructor(x = 0, y = 0, z = 0) { super(x, y, z); }
    static fromJSON(json) { const val = new Point3d(); val.setFromJSON(json); return val; }
    /** Return a new Point3d with the same coordinates */
    clone(result) { return Point3d.create(this.x, this.y, this.z, result); }
    /** Create a new Point3d with given coordinates
     * @param x x part
     * @param y y part
     * @param z z partpubli
     */
    static create(x = 0, y = 0, z = 0, result) {
        if (result) {
            result.x = x;
            result.y = y;
            result.z = z;
            return result;
        }
        return new Point3d(x, y, z);
    }
    /** Copy contents from another Point3d, Point2d, Vector2d, or Vector3d */
    static createFrom(data, result) {
        if (data instanceof Float64Array) {
            if (data.length >= 3)
                return Point3d.create(data[0], data[1], data[2], result);
            if (data.length >= 2)
                return Point3d.create(data[0], data[1], 0, result);
            if (data.length >= 1)
                return Point3d.create(data[0], 0, 0, result);
            return Point3d.create(0, 0, 0, result);
        }
        return Point3d.create(data.x, data.y, XYZ.hasZ(data) ? data.z : 0, result);
    }
    /**
     * Copy x,y,z from
     * @param xyzData flat array of xyzxyz for multiple points
     * @param pointIndex index of point to extract.   This index is multiplied by 3 to obtain starting index in the array.
     * @param result optional result point.
     */
    static createFromPacked(xyzData, pointIndex, result) {
        const indexX = pointIndex * 3;
        if (indexX >= 0 && indexX + 2 < xyzData.length)
            return Point3d.create(xyzData[indexX], xyzData[indexX + 1], xyzData[indexX + 2], result);
        return undefined;
    }
    /**
     * Copy and unweight xyzw.
     * @param xyzData flat array of xyzwxyzw for multiple points
     * @param pointIndex index of point to extract.   This index is multiplied by 4 to obtain starting index in the array.
     * @param result optional result point.
     */
    static createFromPackedXYZW(xyzData, pointIndex, result) {
        const indexX = pointIndex * 4;
        if (indexX >= 0 && indexX + 3 < xyzData.length) {
            const w = xyzData[indexX + 3];
            if (!Geometry_1.Geometry.isSmallMetricDistance(w)) {
                const divW = 1.0 / w;
                return Point3d.create(divW * xyzData[indexX], divW * xyzData[indexX + 1], divW * xyzData[indexX + 2], result);
            }
        }
        return undefined;
    }
    /** Create a new point with 000 xyz */
    static createZero(result) { return Point3d.create(0, 0, 0, result); }
    /** Return the cross product of the vectors from this to pointA and pointB
     *
     * *  the result is a vector
     * *  the result is perpendicular to both vectors, with right hand orientation
     * *  the magnitude of the vector is twice the area of the triangle.
     */
    crossProductToPoints(pointA, pointB, result) {
        return Vector3d.createCrossProduct(pointA.x - this.x, pointA.y - this.y, pointA.z - this.z, pointB.x - this.x, pointB.y - this.y, pointB.z - this.z, result);
    }
    /** Return the triple product of the vectors from this to pointA, pointB, pointC
     *
     * * This is a scalar (number)
     * *  This is 6 times the (signed) volume of the tetrahedron on the 4 points.
     */
    tripleProductToPoints(pointA, pointB, pointC) {
        return Geometry_1.Geometry.tripleProduct(pointA.x - this.x, pointA.y - this.y, pointA.z - this.z, pointB.x - this.x, pointB.y - this.y, pointB.z - this.z, pointC.x - this.x, pointC.y - this.y, pointC.z - this.z);
    }
    /** Return the cross product of the vectors from this to pointA and pointB
     *
     * *  the result is a scalar
     * *  the magnitude of the vector is twice the signed area of the triangle.
     * *  this is positive for counter-clockwise order of the points, negative for clockwise.
     */
    crossProductToPointsXY(pointA, pointB) {
        return Geometry_1.Geometry.crossProductXYXY(pointA.x - this.x, pointA.y - this.y, pointB.x - this.x, pointB.y - this.y);
    }
    /** Return a point interpolated between this point and the right param. */
    interpolate(fraction, other, result) {
        if (fraction <= 0.5)
            return Point3d.create(this.x + fraction * (other.x - this.x), this.y + fraction * (other.y - this.y), this.z + fraction * (other.z - this.z), result);
        const t = fraction - 1.0;
        return Point3d.create(other.x + t * (other.x - this.x), other.y + t * (other.y - this.y), other.z + t * (other.z - this.z), result);
    }
    /**
     * Return a ray whose ray.origin is interpolated, and ray.direction is the vector between points with a
     * scale factor applied.
     * @param fraction fractional position between points.
     * @param other endpoint of interpolation
     * @param tangentScale scale factor to apply to the startToEnd vector
     * @param result  optional receiver.
     */
    interpolatePointAndTangent(fraction, other, tangentScale, result) {
        result = result ? result : Ray3d_1.Ray3d.createZero();
        const dx = other.x - this.x;
        const dy = other.y - this.y;
        const dz = other.z - this.z;
        result.direction.set(tangentScale * dx, tangentScale * dy, tangentScale * dz);
        if (fraction <= 0.5)
            result.origin.set(this.x + fraction * dx, this.y + fraction * dy, this.z + fraction * dz);
        else {
            const t = fraction - 1.0;
            result.origin.set(other.x + t * dx, other.y + t * dy, other.z + t * dz);
        }
        return result;
    }
    /** Return a point with independent x,y,z fractional interpolation. */
    interpolateXYZ(fractionX, fractionY, fractionZ, other, result) {
        return Point3d.create(Geometry_1.Geometry.interpolate(this.x, fractionX, other.x), Geometry_1.Geometry.interpolate(this.y, fractionY, other.y), Geometry_1.Geometry.interpolate(this.z, fractionZ, other.z), result);
    }
    /** Interpolate between points, then add a shift in the xy plane by a fraction of the XY projection perpendicular. */
    interpolatePerpendicularXY(fraction, pointB, fractionXYPerp, result) {
        result = result ? result : new Point3d();
        const vector = pointB.minus(this);
        this.interpolate(fraction, pointB, result);
        result.x -= fractionXYPerp * vector.y;
        result.y += fractionXYPerp * vector.x;
        return result;
    }
    /** Return point minus vector */
    minus(vector, result) {
        return Point3d.create(this.x - vector.x, this.y - vector.y, this.z - vector.z, result);
    }
    /** Return point plus vector */
    plus(vector, result) {
        return Point3d.create(this.x + vector.x, this.y + vector.y, this.z + vector.z, result);
    }
    /** Return point plus vector */
    plusXYZ(dx = 0, dy = 0, dz = 0, result) {
        return Point3d.create(this.x + dx, this.y + dy, this.z + dz, result);
    }
    /** Return point + vector * scalar */
    plusScaled(vector, scaleFactor, result) {
        return Point3d.create(this.x + vector.x * scaleFactor, this.y + vector.y * scaleFactor, this.z + vector.z * scaleFactor, result);
    }
    /** Return point + vectorA * scalarA + vectorB * scalarB */
    plus2Scaled(vectorA, scalarA, vectorB, scalarB, result) {
        return Point3d.create(this.x + vectorA.x * scalarA + vectorB.x * scalarB, this.y + vectorA.y * scalarA + vectorB.y * scalarB, this.z + vectorA.z * scalarA + vectorB.z * scalarB, result);
    }
    /** Return point + vectorA * scalarA + vectorB * scalarB + vectorC * scalarC */
    plus3Scaled(vectorA, scalarA, vectorB, scalarB, vectorC, scalarC, result) {
        return Point3d.create(this.x + vectorA.x * scalarA + vectorB.x * scalarB + vectorC.x * scalarC, this.y + vectorA.y * scalarA + vectorB.y * scalarB + vectorC.y * scalarC, this.z + vectorA.z * scalarA + vectorB.z * scalarB + vectorC.z * scalarC, result);
    }
    /**
     * Return a point that is scaled from the source point.
     * @param source existing point
     * @param scale scale factor to apply to its x,y,z parts
     * @param result optional point to receive coordinates
     */
    static createScale(source, scale, result) {
        return Point3d.create(source.x * scale, source.y * scale, source.z * scale, result);
    }
    /** create a point that is a linear combination (weighted sum) of 2 input points.
     * @param pointA first input point
     * @param scaleA scale factor for pointA
     * @param pointB second input point
     * @param scaleB scale factor for pointB
     */
    static createAdd2Scaled(pointA, scaleA, pointB, scaleB, result) {
        return Point3d.create(pointA.x * scaleA + pointB.x * scaleB, pointA.y * scaleA + pointB.y * scaleB, pointA.z * scaleA + pointB.z * scaleB, result);
    }
    /** Create a point that is a linear combination (weighted sum) of 3 input points.
     * @param pointA first input point
     * @param scaleA scale factor for pointA
     * @param pointB second input point
     * @param scaleB scale factor for pointB
     * @param pointC third input point.
     * @param scaleC scale factor for pointC
     */
    static createAdd3Scaled(pointA, scaleA, pointB, scaleB, pointC, scaleC, result) {
        return Point3d.create(pointA.x * scaleA + pointB.x * scaleB + pointC.x * scaleC, pointA.y * scaleA + pointB.y * scaleB + pointC.y * scaleC, pointA.z * scaleA + pointB.z * scaleB + pointC.z * scaleC, result);
    }
    /**
     * Return the dot product of vectors from this to pointA and this to pointB.
     * @param targetA target point for first vector
     * @param targetB target point for second vector
     */
    dotVectorsToTargets(targetA, targetB) {
        return (targetA.x - this.x) * (targetB.x - this.x) +
            (targetA.y - this.y) * (targetB.y - this.y) +
            (targetA.z - this.z) * (targetB.z - this.z);
    }
    /** Return the fractional projection of this onto a line between points.
     *
     */
    fractionOfProjectionToLine(startPoint, endPoint, defaultFraction = 0) {
        const denominator = startPoint.distanceSquared(endPoint);
        if (denominator < Geometry_1.Geometry.smallMetricDistanceSquared)
            return defaultFraction;
        return startPoint.dotVectorsToTargets(endPoint, this) / denominator;
    }
}
exports.Point3d = Point3d;
/** 3D vector with x,y,z properties */
class Vector3d extends XYZ {
    constructor(x = 0, y = 0, z = 0) { super(x, y, z); }
    /**
     * Copy xyz from this instance to a new (or optionally resused) Vector3d
     * @param result optional instance to reuse.
     */
    clone(result) { return Vector3d.create(this.x, this.y, this.z, result); }
    /**
     * return a Vector3d (new or reused from optional result)
     * @param x x component
     * @param y y component
     * @param z z component
     * @param result optional instance to reuse
     */
    static create(x = 0, y = 0, z = 0, result) {
        if (result) {
            result.x = x;
            result.y = y;
            result.z = z;
            return result;
        }
        return new Vector3d(x, y, z);
    }
    /**
     * Create a vector which is cross product of two vectors supplied as separate arguments
     * @param ux x coordinate of vector u
     * @param uy y coordinate of vector u
     * @param uz z coordinate of vector u
     * @param vx x coordinate of vector v
     * @param vy y coordinate of vector v
     * @param vz z coordinate of vector v
     * @param result optional result vector.
     */
    static createCrossProduct(ux, uy, uz, vx, vy, vz, result) {
        return Vector3d.create(uy * vz - uz * vy, uz * vx - ux * vz, ux * vy - uy * vx, result);
    }
    /**
     * Accumulate a vector which is cross product vectors from origin (ax,ay,az) to targets (bx,by,bz) and (cx,cy,cz)
     * @param ax x coordinate of origin
     * @param ay y coordinate of origin
     * @param az z coordinate of origin
     * @param bx x coordinate of target point b
     * @param by y coordinate of target point b
     * @param bz z coordinate of target point b
     * @param cx x coordinate of target point c
     * @param cy y coordinate of target point c
     * @param cz z coordinate of target point c
     */
    addCrossProductToTargetsInPlace(ax, ay, az, bx, by, bz, cx, cy, cz) {
        const ux = bx - ax;
        const uy = by - ay;
        const uz = bz - az;
        const vx = cx - ax;
        const vy = cy - ay;
        const vz = cz - az;
        this.x += uy * vz - uz * vy;
        this.y += uz * vx - ux * vz;
        this.z += ux * vy - uy * vx;
    }
    /**
     * Return the cross product of the vectors from origin to pointA and pointB.
     *
     * * the result is a vector
     * * the result is perpendicular to both vectors, with right hand orientation
     * * the magnitude of the vector is twice the area of the triangle.
     */
    static createCrossProductToPoints(origin, pointA, pointB, result) {
        return Vector3d.createCrossProduct(pointA.x - origin.x, pointA.y - origin.y, pointA.z - origin.z, pointB.x - origin.x, pointB.y - origin.y, pointB.z - origin.z, result);
    }
    /**
     * Return a vector defined by polar coordinates distance and angle from x axis
     * @param r distance measured from origin
     * @param theta angle from x axis to the vector (in xy plane)
     * @param z optional z coordinate
     */
    static createPolar(r, theta, z) {
        return Vector3d.create(r * theta.cos(), r * theta.sin(), z);
    }
    /**
     * Return a vector defined in spherical coordinates.
     * @param r sphere radius
     * @param theta angle in xy plane
     * @param phi angle from xy plane to the vector
     */
    static createSpherical(r, theta, phi) {
        const cosPhi = phi.cos();
        return Vector3d.create(cosPhi * r * theta.cos(), cosPhi * r * theta.sin(), phi.sin());
    }
    static fromJSON(json) { const val = new Vector3d(); val.setFromJSON(json); return val; }
    /** Copy contents from another Point3d, Point2d, Vector2d, or Vector3d */
    static createFrom(data, result) {
        if (data instanceof Float64Array) {
            if (data.length >= 3)
                return Vector3d.create(data[0], data[1], data[2]);
            if (data.length >= 2)
                return Vector3d.create(data[0], data[1], 0);
            if (data.length >= 1)
                return Vector3d.create(data[0], 0, 0);
            return Vector3d.create(0, 0, 0);
        }
        return Vector3d.create(data.x, data.y, XYZ.hasZ(data) ? data.z : 0.0, result);
    }
    /**
     * Return a vector defined by start and end points (end - start).
     * @param start start point for vector
     * @param end end point for vector
     * @param result optional result
     */
    static createStartEnd(start, end, result) {
        if (result) {
            result.set(end.x - start.x, end.y - start.y, end.z - start.z);
            return result;
        }
        return new Vector3d(end.x - start.x, end.y - start.y, end.z - start.z);
    }
    /**
     * @param x0 start point x coordinate
     * @param y0 start point y coordinate
     * @param z0 start point z coordinate
     * @param x1 end point x coordinate
     * @param y1 end point y coordinate
     * @param z1 end point z coordinate
     * @param result optional result vector
     */
    static createStartEndXYZXYZ(x0, y0, z0, x1, y1, z1, result) {
        if (result) {
            result.set(x1 - x0, y1 - y0, z1 - z0);
            return result;
        }
        return new Vector3d(x1 - x0, y1 - y0, z1 - z0);
    }
    /**
     * Return a vector which is the input vector rotated around the axis vector.
     * @param vector initial vector
     * @param axis axis of rotation
     * @param angle angle of rotation.  If undefined, 90 degrees is implied
     * @param result optional result vector
     */
    static createRotateVectorAroundVector(vector, axis, angle) {
        // Rodriguez formula, https://en.wikipedia.org/wiki/Rodrigues'_rotation_formula
        const unitAxis = axis.normalize();
        if (unitAxis) {
            const xProduct = unitAxis.crossProduct(vector);
            if (angle) {
                const c = angle.cos();
                const s = angle.sin();
                return Vector3d.createAdd3Scaled(vector, c, xProduct, s, unitAxis, unitAxis.dotProduct(vector) * (1.0 - c));
            }
            else {
                // implied c = 0, s = 1 . . .
                return vector.plusScaled(unitAxis, unitAxis.dotProduct(vector));
            }
        }
        // unchanged vector if axis is null
        return undefined;
    }
    /**
     * Set (replace) xzz components so they are a vector from point0 to point1
     * @param point0 start point of computed vector
     * @param point1 end point of computed vector.
     */
    setStartEnd(point0, point1) {
        this.x = point1.x - point0.x;
        this.y = point1.y - point0.y;
        this.z = point1.z - point0.z;
    }
    /** Return a vector with 000 xyz parts. */
    static createZero(result) { return Vector3d.create(0, 0, 0, result); }
    /** Return a unit X vector optionally multiplied by a scale  */
    static unitX(scale = 1) { return new Vector3d(scale, 0, 0); }
    /** Return a unit Y vector  */
    static unitY(scale = 1) { return new Vector3d(0, scale, 0); }
    /** Return a unit Z vector  */
    static unitZ(scale = 1) { return new Vector3d(0, 0, scale); }
    /** Divide by denominator, but return undefined if denominator is zero. */
    safeDivideOrNull(denominator, result) {
        if (denominator !== 0.0) {
            return this.scale(1.0 / denominator, result);
        }
        return undefined;
    }
    /**
     * Return a pair object containing (a) property `v` which is a unit vector in the direction
     * of the input and (b) property mag which is the magnitude (length) of the input (instance) prior to normalization.
     * If the instance (input) is a near zero length the `v` property of the output is undefined.
     * @param result optional result.
     */
    normalizeWithLength(result) {
        const magnitude = Geometry_1.Geometry.correctSmallMetricDistance(this.magnitude());
        result = result ? result : new Vector3d();
        return { v: this.safeDivideOrNull(magnitude, result), mag: magnitude };
    }
    /**
     * Return a unit vector parallel with this.  Return undefined if this.magnitude is near zero.
     * @param result optional result.
     */
    normalize(result) { return this.normalizeWithLength(result).v; }
    /**
     * If this vector has nonzero length, divide by the length to change to a unit vector.
     * @returns true if normalization completed.
     */
    normalizeInPlace() {
        const a = Geometry_1.Geometry.inverseMetricDistance(this.magnitude());
        if (!a)
            return false;
        this.x *= a;
        this.y *= a;
        this.z *= a;
        return true;
    }
    /** Return the fractional projection of spaceVector onto this */
    fractionOfProjectionToVector(target, defaultFraction = 0) {
        const numerator = this.dotProduct(target);
        const denominator = target.magnitudeSquared();
        if (denominator < Geometry_1.Geometry.smallMetricDistanceSquared)
            return defaultFraction;
        return numerator / denominator;
    }
    /** Return a new vector with components negated from the calling instance.
     * @param result optional result vector.
     */
    negate(result) {
        result = result ? result : new Vector3d();
        result.x = -this.x;
        result.y = -this.y;
        result.z = -this.z;
        return result;
    }
    /** Return a vector same length as this but rotate 90 degrees CCW */
    rotate90CCWXY(result) {
        result = result ? result : new Vector3d();
        // save x,y to allow aliasing ..
        const xx = this.x;
        const yy = this.y;
        result.x = -yy;
        result.y = xx;
        result.z = this.z;
        return result;
    }
    unitPerpendicularXY(result) {
        result = result ? result : new Vector3d();
        const xx = this.x;
        const yy = this.y;
        result.x = -yy;
        result.y = xx;
        result.z = 0.0;
        const d2 = xx * xx + yy * yy;
        if (d2 !== 0.0) {
            const a = 1.0 / Math.sqrt(d2);
            result.x *= a;
            result.y *= a;
        }
        return result;
    }
    rotateXY(angle, result) {
        const s = angle.sin();
        const c = angle.cos();
        const xx = this.x;
        const yy = this.y;
        result = result ? result : new Vector3d();
        result.x = xx * c - yy * s;
        result.y = xx * s + yy * c;
        result.z = this.z;
        return result;
    }
    rotate90Towards(target, result) {
        const normal = this.crossProduct(target).normalize();
        return normal ? normal.crossProduct(this, result) : undefined;
    }
    rotate90Around(axis, result) {
        const unitNormal = axis.normalize();
        return unitNormal ? unitNormal.crossProduct(this).plusScaled(unitNormal, unitNormal.dotProduct(this), result) : undefined;
    }
    // Adding vectors
    interpolate(fraction, right, result) {
        result = result ? result : new Vector3d();
        if (fraction <= 0.5) {
            result.x = this.x + fraction * (right.x - this.x);
            result.y = this.y + fraction * (right.y - this.y);
            result.z = this.z + fraction * (right.z - this.z);
        }
        else {
            const t = fraction - 1.0;
            result.x = right.x + t * (right.x - this.x);
            result.y = right.y + t * (right.y - this.y);
            result.z = right.z + t * (right.z - this.z);
        }
        return result;
    }
    plus(vector, result) {
        result = result ? result : new Vector3d();
        result.x = this.x + vector.x;
        result.y = this.y + vector.y;
        result.z = this.z + vector.z;
        return result;
    }
    minus(vector, result) {
        result = result ? result : new Vector3d();
        result.x = this.x - vector.x;
        result.y = this.y - vector.y;
        result.z = this.z - vector.z;
        return result;
    }
    /** Return vector + vector * scalar */
    plusScaled(vector, scaleFactor, result) {
        result = result ? result : new Vector3d();
        result.x = this.x + vector.x * scaleFactor;
        result.y = this.y + vector.y * scaleFactor;
        result.z = this.z + vector.z * scaleFactor;
        return result;
    }
    /** Return point + vectorA * scalarA + vectorB * scalarB */
    plus2Scaled(vectorA, scalarA, vectorB, scalarB, result) {
        result = result ? result : new Vector3d();
        result.x = this.x + vectorA.x * scalarA + vectorB.x * scalarB;
        result.y = this.y + vectorA.y * scalarA + vectorB.y * scalarB;
        result.z = this.z + vectorA.z * scalarA + vectorB.z * scalarB;
        return result;
    }
    /** Return `point + vectorA * scalarA + vectorB * scalarB + vectorC * scalarC` */
    plus3Scaled(vectorA, scalarA, vectorB, scalarB, vectorC, scalarC, result) {
        result = result ? result : new Vector3d();
        result.x = this.x + vectorA.x * scalarA + vectorB.x * scalarB + vectorC.x * scalarC;
        result.y = this.y + vectorA.y * scalarA + vectorB.y * scalarB + vectorC.y * scalarC;
        result.z = this.z + vectorA.z * scalarA + vectorB.z * scalarB + vectorC.z * scalarC;
        return result;
    }
    /** Return `point + vectorA * scalarA + vectorB * scalarB` */
    static createAdd2Scaled(vectorA, scaleA, vectorB, scaleB, result) {
        return Vector3d.create(vectorA.x * scaleA + vectorB.x * scaleB, vectorA.y * scaleA + vectorB.y * scaleB, vectorA.z * scaleA + vectorB.z * scaleB, result);
    }
    /** Return `point + vectorA * scalarA + vectorB * scalarB` with all components presented as numbers */
    static createAdd2ScaledXYZ(ax, ay, az, scaleA, bx, by, bz, scaleB, result) {
        return Vector3d.create(ax * scaleA + bx * scaleB, ay * scaleA + by * scaleB, az * scaleA + bz * scaleB, result);
    }
    static createAdd3Scaled(vectorA, scaleA, vectorB, scaleB, vectorC, scaleC, result) {
        return Vector3d.create(vectorA.x * scaleA + vectorB.x * scaleB + vectorC.x * scaleC, vectorA.y * scaleA + vectorB.y * scaleB + vectorC.y * scaleC, vectorA.z * scaleA + vectorB.z * scaleB + vectorC.z * scaleC, result);
    }
    /** Return vector * scalar */
    scale(scale, result) {
        result = result ? result : new Vector3d();
        result.x = this.x * scale;
        result.y = this.y * scale;
        result.z = this.z * scale;
        return result;
    }
    scaleToLength(length, result) {
        const mag = Geometry_1.Geometry.correctSmallMetricDistance(this.magnitude());
        if (mag === 0)
            return new Vector3d();
        return this.scale(length / mag, result);
    }
    unitCrossProduct(vectorB, result) {
        return this.crossProduct(vectorB, result).normalize(result);
    }
    unitCrossProductWithDefault(vectorB, x, y, z, result) {
        const unit = this.crossProduct(vectorB, result).normalize(result);
        if (unit === undefined)
            return Vector3d.create(x, y, z, result);
        return unit;
    }
    normalizeWithDefault(x, y, z, result) {
        const unit = this.normalize(result);
        if (unit)
            return unit;
        return Vector3d.create(x, y, z, result);
    }
    tryNormalizeInPlace(smallestMagnitude = Geometry_1.Geometry.smallMetricDistance) {
        const a = this.magnitude();
        if (a < smallestMagnitude || a === 0.0)
            return false;
        this.scaleInPlace(1.0 / a);
        return true;
    }
    sizedCrossProduct(vectorB, productLength, result) {
        result = this.crossProduct(vectorB, result);
        if (result.tryNormalizeInPlace()) {
            result.scaleInPlace(productLength);
            return result;
        }
        return undefined;
    }
    /**
     * Compute the squared magnitude of a cross product (without allocating a temporary vector object)
     * @param vectorB second vector of cross product
     * @returns the squared magnitude of the cross product of this instance with vectorB.
     */
    crossProductMagnitudeSquared(vectorB) {
        const xx = this.y * vectorB.z - this.z * vectorB.y;
        const yy = this.z * vectorB.x - this.x * vectorB.z;
        const zz = this.x * vectorB.y - this.y * vectorB.x;
        return xx * xx + yy * yy + zz * zz;
    }
    /**
     * Compute the  magnitude of a cross product (without allocating a temporary vector object)
     * @param vectorB second vector of cross product
     * @returns the  magnitude of the cross product of this instance with vectorB.
     */
    crossProductMagnitude(vectorB) {
        return Math.sqrt(this.crossProductMagnitudeSquared(vectorB));
    }
    /**
     * @param vectorB second vector of cross product
     * @returns the dot product of this instance with vectorB
     */
    dotProduct(vectorB) {
        return this.x * vectorB.x + this.y * vectorB.y + this.z * vectorB.z;
    }
    /** @returns the dot product of this instance with the with vector from pointA to pointB
     * @param pointA start point of second vector of dot product
     * @param pointB end point of second vector of dot product
     */
    dotProductStartEnd(pointA, pointB) {
        return this.x * (pointB.x - pointA.x)
            + this.y * (pointB.y - pointA.y)
            + this.z * (pointB.z - pointA.z);
    }
    /** Dot product with vector (pointB - pointA * pointB.w) */
    dotProductStart3dEnd4d(pointA, pointB) {
        const w = pointB.w;
        return this.x * (pointB.x - pointA.x * w)
            + this.y * (pointB.y - pointA.y * w)
            + this.z * (pointB.z - pointA.z * w);
    }
    /** Cross product with vector from pointA to pointB */
    crossProductStartEnd(pointA, pointB, result) {
        return Vector3d.createCrossProduct(this.x, this.y, this.z, pointB.x - pointA.x, pointB.y - pointA.y, pointB.z - pointA.z, result);
    }
    /** Cross product (xy parts only) with vector from pointA to pointB */
    crossProductStartEndXY(pointA, pointB) {
        return Geometry_1.Geometry.crossProductXYXY(this.x, this.y, pointB.x - pointA.x, pointB.y - pointA.y);
    }
    /** Dot product with vector from pointA to pointB, with pointB given as x,y,z */
    dotProductStartEndXYZ(pointA, x, y, z) {
        return this.x * (x - pointA.x)
            + this.y * (y - pointA.y)
            + this.z * (z - pointA.z);
    }
    /** Dot product with vector from pointA to pointB, with pointB given as (weighted) x,y,z,w
     * * pointB is a homogeneous point that has to be unweighted
     * * if the weight is near zero metric, the return is zero.
     */
    dotProductStartEndXYZW(pointA, x, y, z, w) {
        if (Geometry_1.Geometry.isSmallMetricDistance(w))
            return 0.0;
        const dw = 1.0 / w;
        return this.x * (dw * x - pointA.x)
            + this.y * (dw * y - pointA.y)
            + this.z * (dw * z - pointA.z);
    }
    /** Return the dot product of the instance and vectorB, using only the x and y parts. */
    dotProductXY(vectorB) {
        return this.x * vectorB.x + this.y * vectorB.y;
    }
    /**
     * Dot product with vector (x,y,z)
     * @param x x component for dot product
     * @param y y component for dot product
     * @param z z component for dot product
     */
    dotProductXYZ(x, y, z = 0) {
        return this.x * x + this.y * y + this.z * z;
    }
    /** Return the triple product of the instance, vectorB, and vectorC  */
    tripleProduct(vectorB, vectorC) {
        return Geometry_1.Geometry.tripleProduct(this.x, this.y, this.z, vectorB.x, vectorB.y, vectorB.z, vectorC.x, vectorC.y, vectorC.z);
    }
    /** Return the cross product of the instance and vectorB, using only the x and y parts. */
    crossProductXY(vectorB) {
        return this.x * vectorB.y - this.y * vectorB.x;
    }
    crossProduct(vectorB, result) {
        return Vector3d.createCrossProduct(this.x, this.y, this.z, vectorB.x, vectorB.y, vectorB.z, result);
    }
    // angles
    angleTo(vectorB) {
        return Angle_1.Angle.createAtan2(this.crossProductMagnitude(vectorB), this.dotProduct(vectorB));
    }
    angleToXY(vectorB) {
        return Angle_1.Angle.createAtan2(this.crossProductXY(vectorB), this.dotProductXY(vectorB));
    }
    planarRadiansTo(vector, planeNormal) {
        const square = planeNormal.dotProduct(planeNormal);
        if (square === 0.0)
            return 0.0;
        const factor = 1.0 / square;
        const projection0 = this.plusScaled(planeNormal, -this.dotProduct(planeNormal) * factor);
        const projection1 = vector.plusScaled(planeNormal, -vector.dotProduct(planeNormal) * factor);
        return projection0.signedRadiansTo(projection1, planeNormal);
    }
    planarAngleTo(vector, planeNormal) {
        return Angle_1.Angle.createRadians(this.planarRadiansTo(vector, planeNormal));
    }
    signedRadiansTo(vector1, vectorW) {
        const p = this.crossProduct(vector1);
        const theta = Math.atan2(p.magnitude(), this.dotProduct(vector1));
        if (vectorW.dotProduct(p) < 0.0)
            return -theta;
        else
            return theta;
    }
    signedAngleTo(vector1, vectorW) { return Angle_1.Angle.createRadians(this.signedRadiansTo(vector1, vectorW)); }
    /*  smallerUnorientedAngleTo(vectorB: Vector3d): Angle { }
      signedAngleTo(vectorB: Vector3d, upVector: Vector3d): Angle { }
      // sectors
      isInSmallerSector(vectorA: Vector3d, vectorB: Vector3d): boolean { }
      isInCCWSector(vectorA: Vector3d, vectorB: Vector3d, upVector: Vector3d): boolean { }
      */
    /**
     * Test if this vector is parallel to other.
     * @param other second vector in comparison
     * @param oppositeIsParallel if the vectors are on the same line but in opposite directions, return this value.
     * @param returnValueIfAnInputIsZeroLength if either vector is near zero length, return this value.
     */
    isParallelTo(other, oppositeIsParallel = false, returnValueIfAnInputIsZeroLength = false) {
        const a2 = this.magnitudeSquared();
        const b2 = other.magnitudeSquared();
        // we know both are 0 or positive -- no need for
        if (a2 < Geometry_1.Geometry.smallMetricDistanceSquared || b2 < Geometry_1.Geometry.smallMetricDistanceSquared)
            return returnValueIfAnInputIsZeroLength;
        const dot = this.dotProduct(other);
        if (dot < 0.0 && !oppositeIsParallel)
            return returnValueIfAnInputIsZeroLength;
        const cross2 = this.crossProductMagnitudeSquared(other);
        /* a2,b2,cross2 are squared lengths of respective vectors */
        /* cross2 = sin^2(theta) * a2 * b2 */
        /* For small theta, sin^2(theta)~~theta^2 */
        return cross2 <= Geometry_1.Geometry.smallAngleRadiansSquared * a2 * b2;
    }
    /**
     * Test if this vector is perpendicular to other.
     * @param other second vector in comparison
     * @param returnValueIfAnInputIsZeroLength if either vector is near zero length, return this value.
     */
    isPerpendicularTo(other, returnValueIfAnInputIsZeroLength = false) {
        const aa = this.magnitudeSquared();
        if (aa < Geometry_1.Geometry.smallMetricDistanceSquared)
            return returnValueIfAnInputIsZeroLength;
        const bb = other.magnitudeSquared();
        if (bb < Geometry_1.Geometry.smallMetricDistanceSquared)
            return returnValueIfAnInputIsZeroLength;
        const ab = this.dotProduct(other);
        return ab * ab <= Geometry_1.Geometry.smallAngleRadiansSquared * aa * bb;
    }
}
exports.Vector3d = Vector3d;


/***/ }),

/***/ "./lib/geometry3d/PointHelpers.js":
/*!****************************************!*\
  !*** ./lib/geometry3d/PointHelpers.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
/* tslint:disable:variable-name jsdoc-format no-empty */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Point2dVector2d_1 = __webpack_require__(/*! ./Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ./Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Matrix4d_1 = __webpack_require__(/*! ../geometry4d/Matrix4d */ "./lib/geometry4d/Matrix4d.js");
const Point4d_1 = __webpack_require__(/*! ../geometry4d/Point4d */ "./lib/geometry4d/Point4d.js");
const Ray3d_1 = __webpack_require__(/*! ./Ray3d */ "./lib/geometry3d/Ray3d.js");
const IndexedXYZCollection_1 = __webpack_require__(/*! ./IndexedXYZCollection */ "./lib/geometry3d/IndexedXYZCollection.js");
class NumberArray {
    /** return the sum of values in an array,   The summation is done with correction terms which
     * improves last-bit numeric accuracy.
     */
    static PreciseSum(data) {
        const n = data.length;
        if (n === 0)
            return 0.0;
        let sum = data[0];
        let c = 0.0;
        let y;
        let t;
        for (let i = 1; i < n; i++) {
            y = data[i] - c;
            t = sum + y;
            c = (t - sum) - y;
            sum = t;
        }
        return sum;
    }
    /** Return true if arrays have identical counts and equal entries (using `!==` comparison) */
    static isExactEqual(dataA, dataB) {
        if (dataA && dataB) {
            if (dataA.length !== dataB.length)
                return false;
            for (let i = 0; i < dataA.length; i++)
                if (dataA[i] !== dataB[i])
                    return false;
            return true;
        }
        return (!dataA && !dataB);
    }
    /** Return true if arrays have identical counts and entries equal within tolerance */
    static isAlmostEqual(dataA, dataB, tolerance) {
        if (dataA && dataB) {
            if (dataA.length !== dataB.length)
                return false;
            for (let i = 0; i < dataA.length; i++)
                if (Math.abs(dataA[i] - dataB[i]) >= tolerance)
                    return false;
            return true;
        }
        return (!dataA && !dataB);
    }
    /** return the sum of numbers in an array.  Note that "PreciseSum" may be more accurate. */
    static sum(data) {
        let sum = 0;
        for (const x of data) {
            sum += x;
        }
        return sum;
    }
    static isCoordinateInArray(x, data) {
        if (data) {
            for (const y of data) {
                if (Geometry_1.Geometry.isSameCoordinate(x, y))
                    return true;
            }
        }
        return false;
    }
    static MaxAbsArray(values) {
        const arrLen = values.length;
        if (arrLen === 0) {
            return 0.0;
        }
        let a = Math.abs(values[0]);
        for (let i = 1; i < arrLen; i++) {
            const b = Math.abs(values[i]);
            if (a < b) {
                a = b;
            }
        }
        return a;
    }
    static MaxAbsTwo(a1, a2) {
        a1 = Math.abs(a1);
        a2 = Math.abs(a2);
        return (a1 > a2) ? a1 : a2;
    }
    static maxAbsDiff(dataA, dataB) {
        let a = 0.0;
        const n = Math.min(dataA.length, dataB.length);
        for (let i = 0; i < n; i++) {
            a = Math.max(a, Math.abs(dataA[i] - dataB[i]));
        }
        return a;
    }
    static maxAbsDiffFloat64(dataA, dataB) {
        let a = 0.0;
        const n = Math.min(dataA.length, dataB.length);
        for (let i = 0; i < n; i++) {
            a = Math.max(a, Math.abs(dataA[i] - dataB[i]));
        }
        return a;
    }
}
exports.NumberArray = NumberArray;
class Point2dArray {
    static isAlmostEqual(dataA, dataB) {
        if (dataA && dataB) {
            if (dataA.length !== dataB.length)
                return false;
            for (let i = 0; i < dataA.length; i++) {
                if (!dataA[i].isAlmostEqual(dataB[i]))
                    return false;
            }
            return true;
        }
        return (!dataA && !dataB);
    }
    /**
     * @returns return an array containing clones of the Point3d data[]
     * @param data source data
     */
    static clonePoint2dArray(data) {
        return data.map((p) => p.clone());
    }
    /**
     * Return the number of points when trailing points that match point 0 are excluded.
     * @param data array of XAndY points.
     */
    static pointCountExcludingTrailingWraparound(data) {
        let n = data.length;
        if (n < 2)
            return n;
        const x0 = data[0].x;
        const y0 = data[0].y;
        while (n > 1) {
            if (!Geometry_1.Geometry.isSameCoordinate(data[n - 1].x, x0) || !Geometry_1.Geometry.isSameCoordinate(data[n - 1].y, y0))
                return n;
            n--;
        }
        return n;
    }
}
exports.Point2dArray = Point2dArray;
class Vector3dArray {
    static isAlmostEqual(dataA, dataB) {
        if (dataA && dataB) {
            if (dataA.length !== dataB.length)
                return false;
            for (let i = 0; i < dataA.length; i++)
                if (!dataA[i].isAlmostEqual(dataB[i]))
                    return false;
            return true;
        }
        return (!dataA && !dataB);
    }
    /**
     * @returns return an array containing clones of the Vector3d data[]
     * @param data source data
     */
    static cloneVector3dArray(data) {
        return data.map((p) => Point3dVector3d_1.Vector3d.create(p.x, p.y, p.z));
    }
}
exports.Vector3dArray = Vector3dArray;
class Point4dArray {
    /** pack each point and its corresponding weight into a buffer of xyzwxyzw... */
    static packPointsAndWeightsToFloat64Array(points, weights, result) {
        result = result ? result : new Float64Array(4 * points.length);
        let i = 0;
        let k = 0;
        for (k = 0; k < points.length; k++) {
            result[i++] = points[k].x;
            result[i++] = points[k].y;
            result[i++] = points[k].z;
            result[i++] = weights[k];
        }
        return result;
    }
    static packToFloat64Array(data, result) {
        result = result ? result : new Float64Array(4 * data.length);
        let i = 0;
        for (const p of data) {
            result[i++] = p.x;
            result[i++] = p.y;
            result[i++] = p.z;
            result[i++] = p.w;
        }
        return result;
    }
    /** unpack from xyzwxyzw... to array of Point4d */
    static unpackToPoint4dArray(data) {
        const result = [];
        for (let i = 0; i + 3 < data.length; i += 4) {
            result.push(Point4d_1.Point4d.create(data[i], data[i + 1], data[i + 2], data[i + 3]));
        }
        return result;
    }
    /** unpack from xyzwxyzw... array to array of Point3d and array of weight.
     */
    static unpackFloat64ArrayToPointsAndWeights(data, points, weights, pointFormatter = Point3dVector3d_1.Point3d.create) {
        points.length = 0;
        weights.length = 0;
        for (let i = 0; i + 3 < data.length; i += 4) {
            points.push(pointFormatter(data[i], data[i + 1], data[i + 2]));
            weights.push(data[i + 3]);
        }
    }
    /**
     * Multiply (and replace) each block of 4 values as a Point4d.
     * @param transform transform to apply
     * @param xyzw array of x,y,z,w points.
     */
    static multiplyInPlace(transform, xyzw) {
        const numXYZW = xyzw.length;
        const xyzw1 = Point4dArray._workPoint4d;
        for (let i = 0; i + 3 < numXYZW; i += 4) {
            transform.multiplyXYZW(xyzw[i], xyzw[i + 1], xyzw[i + 2], xyzw[i + 3], xyzw1);
            xyzw[i] = xyzw1.x;
            xyzw[i + 1] = xyzw1.y;
            xyzw[i + 2] = xyzw1.z;
            xyzw[i + 3] = xyzw1.w;
        }
    }
    static isAlmostEqual(dataA, dataB) {
        if (dataA && dataB) {
            if (dataA.length !== dataB.length)
                return false;
            if (dataA instanceof Float64Array && dataB instanceof Float64Array) {
                for (let i = 0; i < dataA.length; i++)
                    if (!Geometry_1.Geometry.isSameCoordinate(dataA[i], dataB[i]))
                        return false;
            }
            else if (Array.isArray(dataA) && Array.isArray(dataB)) {
                for (let i = 0; i < dataA.length; i++)
                    if (!dataA[i].isAlmostEqual(dataB[i]))
                        return false;
            }
            return true;
        }
        // if both are null it is equal, otherwise unequal
        return (!dataA && !dataB);
    }
    /** return true iff all xyzw points' altitudes are within tolerance of the plane.*/
    static isCloseToPlane(data, plane, tolerance = Geometry_1.Geometry.smallMetricDistance) {
        if (Array.isArray(data)) {
            for (const xyzw of data) {
                if (Math.abs(plane.altitudeXYZW(xyzw.x, xyzw.y, xyzw.z, xyzw.w)) > tolerance)
                    return false;
            }
        }
        else if (data instanceof Float64Array) {
            const numXYZ = data.length;
            for (let i = 0; i + 2 < numXYZ; i += 4) {
                if (Math.abs(plane.altitudeXYZW(data[i], data[i + 1], data[i + 2], data[i + 3])) > tolerance)
                    return false;
            }
        }
        return true;
    }
}
Point4dArray._workPoint4d = Point4d_1.Point4d.create();
exports.Point4dArray = Point4dArray;
class Point3dArray {
    static packToFloat64Array(data) {
        const result = new Float64Array(3 * data.length);
        let i = 0;
        for (const p of data) {
            result[i++] = p.x;
            result[i++] = p.y;
            result[i++] = p.z;
        }
        return result;
    }
    static unpackNumbersToPoint3dArray(data) {
        const result = [];
        for (let i = 0; i + 2 < data.length; i += 3) {
            result.push(Point3dVector3d_1.Point3d.create(data[i], data[i + 1], data[i + 2]));
        }
        return result;
    }
    /**
     * return an 2-dimensional array containing all the values of `data` in arrays of numPerBlock
     * @param data simple array of numbers
     * @param numPerBlock number of values in each block at first level down
     */
    static unpackNumbersToNestedArrays(data, numPerBlock) {
        const result = [];
        const n = data.length;
        let i = 0;
        let i1 = 0;
        while (i < n) {
            // there is at least one more value for a block
            const row = [];
            i1 = i + numPerBlock;
            if (i1 > n)
                i1 = n;
            for (; i < i1; i++) {
                row.push(data[i]);
            }
            result.push(row);
        }
        return result;
    }
    /**
     * return an 3-dimensional array containing all the values of `data` in arrays numPerRow blocks of numPerBlock
     * @param data simple array of numbers
     * @param numPerBlock number of values in each block at first level down
     */
    static unpackNumbersToNestedArraysIJK(data, numPerBlock, numPerRow) {
        const result = [];
        const n = data.length;
        let i = 0;
        let i1 = 0;
        let i2;
        while (i < n) {
            const row = [];
            i2 = i + numPerBlock * numPerRow;
            while (i < i2) {
                const block = [];
                i1 = i + numPerBlock;
                if (i1 > n)
                    i1 = n;
                for (; i < i1; i++) {
                    block.push(data[i]);
                }
                row.push(block);
            }
            result.push(row);
        }
        return result;
    }
    static multiplyInPlace(transform, xyz) {
        const xyz1 = Point3dVector3d_1.Point3d.create();
        const numXYZ = xyz.length;
        for (let i = 0; i + 2 < numXYZ; i += 3) {
            transform.multiplyXYZ(xyz[i], xyz[i + 1], xyz[i + 2], xyz1);
            xyz[i] = xyz1.x;
            xyz[i + 1] = xyz1.y;
            xyz[i + 2] = xyz1.z;
        }
    }
    static isAlmostEqual(dataA, dataB) {
        if (dataA && dataB) {
            if (dataA.length !== dataB.length)
                return false;
            if (dataA instanceof Float64Array && dataB instanceof Float64Array) {
                for (let i = 0; i < dataA.length; i++)
                    if (!Geometry_1.Geometry.isSameCoordinate(dataA[i], dataB[i]))
                        return false;
            }
            else if (Array.isArray(dataA) && Array.isArray(dataB)) {
                for (let i = 0; i < dataA.length; i++)
                    if (!dataA[i].isAlmostEqual(dataB[i]))
                        return false;
            }
            return true;
        }
        // if both are null it is equal, otherwise unequal
        return (!dataA && !dataB);
    }
    /** return simple average of all coordinates.   (000 if empty array) */
    static centroid(points, result) {
        result = Point3dVector3d_1.Point3d.create(0, 0, 0, result);
        const p = Point3dVector3d_1.Point3d.create();
        if (points.length > 0) {
            for (let i = 0; i < points.length; i++) {
                points.atPoint3dIndex(i, p);
                result.x += p.x;
                result.y += p.y;
                result.z += p.z;
            }
            result.scaleInPlace(1.0 / points.length);
        }
        return result;
    }
    /** Return the index of the point most distant from spacePoint */
    static indexOfMostDistantPoint(points, spacePoint, farVector) {
        if (points.length === 0)
            return undefined;
        let dMax = -1;
        let d;
        let result = -1;
        for (let i = 0; i < points.length; i++) {
            d = spacePoint.distance(points[i]);
            if (d > dMax) {
                spacePoint.vectorTo(points[i], farVector);
                dMax = d;
                result = i;
            }
        }
        return result;
    }
    /** return the index of the point whose vector from space point has the largest magnitude of cross product with given vector. */
    static indexOfPointWithMaxCrossProductMagnitude(points, spacePoint, vector, farVector) {
        if (points.length === 0)
            return undefined;
        let dMax = -1;
        let d;
        let result = -1;
        let vectorAB; // to be reused in loop !!!
        for (let i = 0; i < points.length; i++) {
            vectorAB = spacePoint.vectorTo(points[i], vectorAB);
            d = vectorAB.crossProductMagnitude(vector);
            if (d > dMax) {
                farVector.setFrom(vectorAB);
                dMax = d;
                result = i;
            }
        }
        return result;
    }
    /** Return the index of the closest point in the array (full xyz) */
    static closestPointIndex(data, spacePoint) {
        let index = -1;
        let dMin = Number.MAX_VALUE;
        let d;
        const x0 = spacePoint.x;
        const y0 = spacePoint.y;
        const z0 = spacePoint.z;
        for (let i = 0; i < data.length; i++) {
            d = Geometry_1.Geometry.distanceXYZXYZ(x0, y0, z0, data[i].x, data[i].y, data[i].z);
            if (d < dMin) {
                index = i;
                dMin = d;
            }
        }
        return index;
    }
    /** return true iff all points' altitudes are within tolerance of the plane.*/
    static isCloseToPlane(data, plane, tolerance = Geometry_1.Geometry.smallMetricDistance) {
        if (Array.isArray(data)) {
            let xyz;
            for (xyz of data) {
                if (Math.abs(plane.altitude(xyz)) > tolerance)
                    return false;
            }
        }
        else if (data instanceof Float64Array) {
            const numXYZ = data.length;
            for (let i = 0; i + 2 < numXYZ; i += 3) {
                if (Math.abs(plane.altitudeXYZ(data[i], data[i + 1], data[i + 2])) > tolerance)
                    return false;
            }
        }
        return true;
    }
    /**
     * Sum lengths of edges.
     * @param data points.
     */
    static sumEdgeLengths(data, addClosureEdge = false) {
        let sum = 0.0;
        if (Array.isArray(data)) {
            const n = data.length - 1;
            for (let i = 0; i < n; i++)
                sum += data[i].distance(data[i + 1]);
            if (addClosureEdge && n > 0)
                sum += data[0].distance(data[n]);
        }
        else if (data instanceof Float64Array) {
            const numXYZ = data.length;
            let i = 0;
            for (; i + 5 < numXYZ; i += 3) { // final i points at final point x
                sum += Geometry_1.Geometry.hypotenuseXYZ(data[i + 3] - data[i], data[i + 4] - data[i + 1], data[i + 5] - data[i + 2]);
            }
            if (addClosureEdge && i >= 3) {
                sum += Geometry_1.Geometry.hypotenuseXYZ(data[0] - data[i], data[1] - data[i + 1], data[2] - data[i + 2]);
            }
        }
        return sum;
    }
    /**
     * @returns return an array containing clones of the Point3d data[]
     * @param data source data
     */
    static clonePoint3dArray(data) {
        return data.map((p) => Point3dVector3d_1.Point3d.create(p.x, p.y, p.z));
    }
    /**
     * @returns return an array containing Point2d with xy parts of each Point3d
     * @param data source data
     */
    static clonePoint2dArray(data) {
        return data.map((p) => Point2dVector2d_1.Point2d.create(p.x, p.y));
    }
}
exports.Point3dArray = Point3dArray;
/** Static class for operations that treat an array of points as a polygon (with area!) */
class PolygonOps {
    /** Sum areas of triangles from points[0] to each far edge.
    * * Consider triangles from points[0] to each edge.
    * * Sum the areas(absolute, without regard to orientation) all these triangles.
    * @returns sum of absolute triangle areas.
    */
    static sumTriangleAreas(points) {
        let s = 0.0;
        const n = points.length;
        if (n >= 3) {
            const origin = points[0];
            const vector0 = origin.vectorTo(points[1]);
            let vector1 = Point3dVector3d_1.Vector3d.create();
            // This will work with or without closure edge.  If closure is given, the last vector is 000.
            for (let i = 2; i < n; i++) {
                vector1 = origin.vectorTo(points[i], vector1);
                s += vector0.crossProductMagnitude(vector1);
                vector0.setFrom(vector1);
            }
        }
        s *= 0.5;
        // console.log ("polygon area ", s, points);
        return s;
    }
    /** Sum areas of triangles from points[0] to each far edge.
    * * Consider triangles from points[0] to each edge.
    * * Sum the areas(absolute, without regard to orientation) all these triangles.
    * @returns sum of absolute triangle areas.
    */
    static sumTriangleAreasXY(points) {
        let s = 0.0;
        const n = points.length;
        if (n >= 3) {
            const origin = points[0];
            const vector0 = origin.vectorTo(points[1]);
            let vector1 = Point3dVector3d_1.Vector3d.create();
            // This will work with or without closure edge.  If closure is given, the last vector is 000.
            for (let i = 2; i < n; i++) {
                vector1 = origin.vectorTo(points[i], vector1);
                s += vector0.crossProductXY(vector1);
                vector0.setFrom(vector1);
            }
        }
        s *= 0.5;
        // console.log ("polygon area ", s, points);
        return s;
    }
    /** return a vector which is perpendicular to the polygon and has magnitude equal to the polygon area. */
    static areaNormalGo(points, result) {
        if (!result)
            result = new Point3dVector3d_1.Vector3d();
        const n = points.length;
        if (n === 3) {
            points.crossProductIndexIndexIndex(0, 1, 2, result);
        }
        else if (n >= 3) {
            result.setZero();
            // This will work with or without closure edge.  If closure is given, the last vector is 000.
            for (let i = 2; i < n; i++) {
                points.accumulateCrossProductIndexIndexIndex(0, i - 1, i, result);
            }
        }
        // ALL BRANCHES SUM FULL CROSS PRODUCTS AND EXPECT SCALE HERE
        result.scaleInPlace(0.5);
        return result;
    }
    static areaNormal(points, result) {
        if (!result)
            result = Point3dVector3d_1.Vector3d.create();
        PolygonOps.areaNormalGo(new Point3dArrayCarrier(points), result);
        return result;
    }
    /** return the area of the polygon (assuming planar) */
    static area(points) {
        return PolygonOps.areaNormal(points).magnitude();
    }
    /** return the projected XY area of the polygon (assuming planar) */
    static areaXY(points) {
        let area = 0.0;
        for (let i = 1; i + 1 < points.length; i++)
            area += points[0].crossProductToPointsXY(points[i], points[i + 1]);
        return 0.5 * area;
    }
    static centroidAreaNormal(points) {
        const n = points.length;
        if (n === 3) {
            const normal = points[0].crossProductToPoints(points[1], points[2]);
            const a = 0.5 * normal.magnitude();
            const result = Ray3d_1.Ray3d.createCapture(Point3dArray.centroid(new Point3dArrayCarrier(points)), normal);
            if (result.tryNormalizeInPlaceWithAreaWeight(a))
                return result;
            return undefined;
        }
        if (n >= 3) {
            const origin = points[0];
            const vector0 = origin.vectorTo(points[1]);
            let vector1 = Point3dVector3d_1.Vector3d.create();
            let cross = Point3dVector3d_1.Vector3d.create();
            const centroidSum = Point3dVector3d_1.Vector3d.createZero();
            const normalSum = Point3dVector3d_1.Vector3d.createZero();
            // This will work with or without closure edge.  If closure is given, the last vector is 000.
            for (let i = 2; i < n; i++) {
                vector1 = origin.vectorTo(points[i], vector1);
                cross = vector0.crossProduct(vector1, cross);
                normalSum.addInPlace(cross); // this grows to twice the area
                const b = cross.magnitude() / 6.0;
                centroidSum.plus2Scaled(vector0, b, vector1, b, centroidSum);
                vector0.setFrom(vector1);
            }
            const area = 0.5 * normalSum.magnitude();
            const inverseArea = Geometry_1.Geometry.conditionalDivideFraction(1, area);
            if (inverseArea !== undefined) {
                const result = Ray3d_1.Ray3d.createCapture(origin.plusScaled(centroidSum, inverseArea, origin), normalSum);
                result.tryNormalizeInPlaceWithAreaWeight(area);
                return result;
            }
        }
        return undefined;
    }
    // Has the potential to be combined with centroidAreaNormal for point3d array and Ray3d return listed above...
    // Returns undefined if given point array less than 3 or if not safe to divide at any point
    static centroidAndAreaXY(points, centroid) {
        let area = 0.0;
        centroid.set(0, 0);
        if (points.length < 3)
            return undefined;
        const origin = points[0];
        let vectorSum = Point2dVector2d_1.Vector2d.create(0, 0); // == sum ((U+V)/3) * (U CROSS V)/2 -- but leave out divisions
        let areaSum = 0.0; // == sum (U CROSS V) / 2 -- but leave out divisions
        for (let i = 1; i + 1 < points.length; i++) {
            const vector0 = origin.vectorTo(points[i]);
            const vector1 = origin.vectorTo(points[i + 1]);
            const tempArea = vector0.crossProduct(vector1);
            vectorSum = vectorSum.plus(vector0.plus(vector1).scale(tempArea));
            areaSum += tempArea;
        }
        area = areaSum * 0.5;
        const a = Geometry_1.Geometry.conditionalDivideFraction(1.0, 6.0 * area);
        if (a === undefined) {
            centroid.setFrom(origin);
            return undefined;
        }
        centroid.setFrom(origin.plusScaled(vectorSum, a));
        return area;
    }
    /**
     *
     * @param points array of points around the polygon.  This is assumed to NOT have closure edge.
     * @param result caller-allocated result vector.
     */
    static unitNormal(points, result) {
        const n = points.length;
        if (n === 3) {
            points.crossProductIndexIndexIndex(0, 1, 2, result);
            return result.normalizeInPlace();
        }
        if (n === 4) {
            // cross product of diagonals is more stable than from single of the points . . .
            points.vectorIndexIndex(0, 2, PolygonOps._vector0);
            points.vectorIndexIndex(1, 3, PolygonOps._vector1);
            PolygonOps._vector0.crossProduct(PolygonOps._vector1, result);
            return result.normalizeInPlace();
        }
        // more than 4 points  ... no shortcuts ...
        PolygonOps.areaNormalGo(points, result);
        return result.normalizeInPlace();
    }
    /** Return the matrix of area products of a polygon with respect to an origin.
     * The polygon is assumed to be planar and non-self-intersecting.
     */
    static addSecondMomentAreaProducts(points, origin, moments) {
        const unitNormal = PolygonOps._normal;
        if (PolygonOps.unitNormal(points, unitNormal)) {
            // The direction of the normal makes the various detJ values positive or negative so that non-convex polygons
            // sum correctly.
            const vector01 = PolygonOps._vector0;
            const vector02 = PolygonOps._vector1;
            const placement = PolygonOps._matrixA;
            const matrixAB = PolygonOps._matrixB;
            const matrixABC = PolygonOps._matrixC;
            const vectorOrigin = points.vectorXYAndZIndex(origin, 0, PolygonOps._vectorOrigin);
            const numPoints = points.length;
            let detJ = 0;
            for (let i2 = 2; i2 < numPoints; i2++) {
                points.vectorIndexIndex(0, i2 - 1, vector01);
                points.vectorIndexIndex(0, i2, vector02);
                detJ = unitNormal.tripleProduct(vector01, vector02);
                placement.setOriginAndVectors(vectorOrigin, vector01, vector02, unitNormal);
                placement.multiplyMatrixMatrix(PolygonOps._triangleMomentWeights, matrixAB);
                matrixAB.multiplyMatrixMatrixTranspose(placement, matrixABC);
                moments.addScaledInPlace(matrixABC, detJ);
            }
        }
    }
    /** Test the direction of turn at the vertices of the polygon, ignoring z-coordinates.
     *
     * *  For a polygon without self intersections, this is a convexity and orientation test: all positive is convex and counterclockwise,
     * all negative is convex and clockwise
     * *  Beware that a polygon which turns through more than a full turn can cross itself and close, but is not convex
     * *  Returns 1 if all turns are to the left, -1 if all to the right, and 0 if there are any zero turns
     */
    static testXYPolygonTurningDirections(pPointArray) {
        // Reduce count by trailing duplicates; leaves iLast at final index
        let numPoint = pPointArray.length;
        let iLast = numPoint - 1;
        while (iLast > 1 && pPointArray[iLast].x === pPointArray[0].x && pPointArray[iLast].y === pPointArray[0].y) {
            numPoint = iLast--;
        }
        if (numPoint > 2) {
            let vector0 = Point2dVector2d_1.Point2d.create(pPointArray[iLast].x - pPointArray[iLast - 1].x, pPointArray[iLast].y - pPointArray[iLast - 1].y);
            const vector1 = Point2dVector2d_1.Point2d.create(pPointArray[0].x - pPointArray[iLast].x, pPointArray[0].y - pPointArray[iLast].y);
            const baseArea = vector0.x * vector1.y - vector0.y * vector1.x;
            // In a convex polygon, all successive-vector cross products will
            // have the same sign as the base area, hence all products will be
            // positive.
            for (let i1 = 1; i1 < numPoint; i1++) {
                vector0 = vector1.clone();
                Point2dVector2d_1.Point2d.create(pPointArray[i1].x - pPointArray[i1 - 1].x, pPointArray[i1].y - pPointArray[i1 - 1].y, vector1);
                const currArea = vector0.x * vector1.y - vector0.y * vector1.x;
                if (currArea * baseArea <= 0.0)
                    return 0;
            }
            // Fall out with all signs same as base area
            return baseArea > 0.0 ? 1 : -1;
        }
        return 0;
    }
    /**
     * Classify a point with respect to a polygon.
     * Returns 1 if point is "in" by parity, 0 if "on", -1 if "out", -2 if nothing worked.
     */
    static parity(pPoint, pPointArray, tol = 0.0) {
        let parity;
        const x = pPoint.x;
        const y = pPoint.y;
        const numPoint = pPointArray.length;
        if (numPoint < 2)
            return (Math.abs(x - pPointArray[0].x) <= tol && Math.abs(y - pPointArray[0].y) <= tol) ? 0 : -1;
        // Try really easy ways first...
        parity = PolygonOps.parityYTest(pPoint, pPointArray, tol);
        if (parity !== undefined)
            return parity;
        parity = PolygonOps.parityXTest(pPoint, pPointArray, tol);
        if (parity !== undefined)
            return parity;
        // Is test point within tol of one of the polygon points in x and y?
        for (let i = 0; i < numPoint; i++)
            if (Math.abs(x - pPointArray[i].x) <= tol && Math.abs(y - pPointArray[i].y) <= tol)
                return 0;
        // Nothing easy worked. Try some ray casts
        const maxTheta = 10.0;
        let theta = 0.276234342921378;
        const dTheta = theta;
        while (theta < maxTheta) {
            parity = PolygonOps.parityVectorTest(pPoint, theta, pPointArray, tol);
            if (parity !== undefined)
                return parity;
            theta += dTheta;
        }
        return -2;
    }
    /**
     * Classify a point with respect to a polygon defined by the xy parts of the points, using only the y
     * coordinate for the tests.
     *
     * *  Return undefined (failure, could not determine answer) if any polygon point has the same y-coord as test point
     * *  Goal is to execute the simplest cases as fast as possible, and fail promptly for others
     */
    static parityYTest(pPoint, pPointArray, tol) {
        // Var names h, crossing to allow closest code correspondence between x,y code
        const numPoint = pPointArray.length;
        const crossing0 = pPoint.x;
        const h = pPoint.y;
        let h0 = h - pPointArray[numPoint - 1].y;
        let h1;
        let crossing;
        let s;
        let numLeft = 0;
        if (Math.abs(h0) <= tol)
            return undefined;
        let i0;
        for (let i = 0; i < numPoint; i++, h0 = h1) { // <-- h0 won't be assigned to h1 until after first iteration
            h1 = h - pPointArray[i].y;
            if (Math.abs(h1) <= tol)
                return undefined;
            if (h0 * h1 < 0.0) {
                s = -h0 / (h1 - h0);
                i0 = i - 1;
                if (i0 < 0)
                    i0 = numPoint - 1;
                crossing = pPointArray[i0].x + s * (pPointArray[i].x - pPointArray[i0].x);
                if (Math.abs(crossing - crossing0) <= tol)
                    return 0;
                else if (crossing < crossing0)
                    numLeft++;
            }
        }
        return (numLeft & 0x01) ? 1 : -1;
    }
    /**
     * Classify a point with respect to a polygon defined by the xy parts of the points, using only the x
     * coordinate for the tests.
     *
     * *  Return undefined (failure, could not determine answer) if any polygon point has the same x coordinate as the test point
     * *  Goal is to execute the simplest cases as fast as possible, and fail promptly for others
     */
    static parityXTest(pPoint, pPointArray, tol) {
        // Var names h, crossing to allow closest code correspondence between x,y code
        const numPoint = pPointArray.length;
        const crossing0 = pPoint.y;
        const h = pPoint.x;
        let h0 = h - pPointArray[numPoint - 1].x;
        let h1;
        let crossing;
        let s;
        let numLeft = 0;
        if (Math.abs(h0) <= tol)
            return undefined;
        let i0;
        for (let i = 0; i < numPoint; i++, h0 = h1) { // <-- h0 won't be assigned to h1 until after first iteration
            h1 = h - pPointArray[i].x;
            if (Math.abs(h1) <= tol)
                return undefined;
            if (h0 * h1 < 0.0) {
                s = -h0 / (h1 - h0);
                i0 = i - 1;
                if (i0 < 0)
                    i0 = numPoint - 1;
                crossing = pPointArray[i0].y + s * (pPointArray[i].y - pPointArray[i0].y);
                if (Math.abs(crossing - crossing0) <= tol)
                    return 0;
                else if (crossing < crossing0)
                    numLeft++;
            }
        }
        return (numLeft & 0x01) ? 1 : -1;
    }
    /**
     * Classify a point with respect to a polygon defined by the xy parts of the points, using a given ray cast
     * direction.
     *
     * *  Return false (failure, could not determine answer) if any polygon point is on the ray
     */
    static parityVectorTest(pPoint, theta, pPointArray, tol) {
        const numPoint = pPointArray.length;
        let v1;
        let u0;
        let u1;
        let u;
        let s;
        let numLeft = 0;
        const tangent = Point2dVector2d_1.Vector2d.create(Math.cos(theta), Math.sin(theta));
        const normal = Point2dVector2d_1.Vector2d.create(-tangent.y, tangent.x);
        let v0 = normal.dotProductStartEnd(pPoint, pPointArray[numPoint - 1]);
        if (Math.abs(v0) <= tol)
            return undefined;
        let i0;
        for (let i = 0; i < numPoint; i++, v0 = v1) { // <-- v0 won't be assigned to v1 until after first iteration
            v1 = normal.dotProductStartEnd(pPoint, pPointArray[i]);
            if (Math.abs(v1) <= tol)
                return undefined;
            if (v0 * v1 < 0.0) {
                s = -v0 / (v1 - v0);
                i0 = i - 1;
                if (i0 < 0)
                    i0 = numPoint - 1;
                u0 = tangent.dotProductStartEnd(pPoint, pPointArray[i0]);
                u1 = tangent.dotProductStartEnd(pPoint, pPointArray[i]);
                u = u0 + s * (u1 - u0);
                if (Math.abs(u) <= tol)
                    return 0;
                else if (u < 0.0)
                    numLeft++;
            }
        }
        return (numLeft & 0x01) ? 1 : -1;
    }
}
/** These values are the integrated area moment products [xx,xy,xz, x]
 * for a right triangle in the first quadrant at the origin -- (0,0),(1,0),(0,1)
 */
PolygonOps._triangleMomentWeights = Matrix4d_1.Matrix4d.createRowValues(2.0 / 24.0, 1.0 / 24.0, 0, 4.0 / 24.0, 1.0 / 24.0, 2.0 / 24.0, 0, 4.0 / 24.0, 0, 0, 0, 0, 4.0 / 24.0, 4.0 / 24.0, 0, 12.0 / 24.0);
// statics for shared reuse.
// many methods use these.
// only use them in "leaf" methods that are certain not to call other users . . .
PolygonOps._vector0 = Point3dVector3d_1.Vector3d.create();
PolygonOps._vector1 = Point3dVector3d_1.Vector3d.create();
PolygonOps._vectorOrigin = Point3dVector3d_1.Vector3d.create();
PolygonOps._normal = Point3dVector3d_1.Vector3d.create();
PolygonOps._matrixA = Matrix4d_1.Matrix4d.createIdentity();
PolygonOps._matrixB = Matrix4d_1.Matrix4d.createIdentity();
PolygonOps._matrixC = Matrix4d_1.Matrix4d.createIdentity();
exports.PolygonOps = PolygonOps;
/**
 * Helper object to access members of a Point3d[] in geometric calculations.
 * * The collection holds only a reference to the actual array.
 * * The actual array may be replaced by the user as needed.
 * * When replaced, there is no cached data to be updated.
*/
class Point3dArrayCarrier extends IndexedXYZCollection_1.IndexedXYZCollection {
    /** CAPTURE caller supplied array ... */
    constructor(data) {
        super();
        this.data = data;
    }
    isValidIndex(index) {
        return index >= 0 && index < this.data.length;
    }
    /**
     * @param index index of point within the array
     * @param result caller-allocated destination
     * @returns undefined if the index is out of bounds
     */
    atPoint3dIndex(index, result) {
        if (this.isValidIndex(index)) {
            const source = this.data[index];
            return Point3dVector3d_1.Point3d.create(source.x, source.y, source.z, result);
        }
        return undefined;
    }
    /**
     * @param index index of point within the array
     * @param result caller-allocated destination
     * @returns undefined if the index is out of bounds
     */
    atVector3dIndex(index, result) {
        if (this.isValidIndex(index)) {
            const source = this.data[index];
            return Point3dVector3d_1.Vector3d.create(source.x, source.y, source.z, result);
        }
        return undefined;
    }
    /**
     * @param indexA index of point within the array
     * @param indexB index of point within the array
     * @param result caller-allocated vector.
     * @returns undefined if either index is out of bounds
     */
    vectorIndexIndex(indexA, indexB, result) {
        if (this.isValidIndex(indexA) && this.isValidIndex(indexB))
            return Point3dVector3d_1.Vector3d.createStartEnd(this.data[indexA], this.data[indexB], result);
        return undefined;
    }
    /**
     * @param origin origin for vector
     * @param indexB index of point within the array
     * @param result caller-allocated vector.
     * @returns undefined if index is out of bounds
     */
    vectorXYAndZIndex(origin, indexB, result) {
        if (this.isValidIndex(indexB))
            return Point3dVector3d_1.Vector3d.createStartEnd(origin, this.data[indexB], result);
        return undefined;
    }
    /**
     * @param origin origin for vector
     * @param indexA index of first target within the array
     * @param indexB index of second target within the array
     * @param result caller-allocated vector.
     * @returns undefined if either index is out of bounds
     */
    crossProductXYAndZIndexIndex(origin, indexA, indexB, result) {
        if (this.isValidIndex(indexA) && this.isValidIndex(indexB))
            return Point3dVector3d_1.Vector3d.createCrossProductToPoints(origin, this.data[indexA], this.data[indexB], result);
        return undefined;
    }
    /**
   * @param originIndex index of origin
   * @param indexA index of first target within the array
   * @param indexB index of second target within the array
   * @param result caller-allocated vector.
   * @returns return true if indexA, indexB both valid
   */
    crossProductIndexIndexIndex(originIndex, indexA, indexB, result) {
        if (this.isValidIndex(originIndex) && this.isValidIndex(indexA) && this.isValidIndex(indexB))
            return Point3dVector3d_1.Vector3d.createCrossProductToPoints(this.data[originIndex], this.data[indexA], this.data[indexB], result);
        return undefined;
    }
    /**
     * @param origin index of origin
     * @param indexA index of first target within the array
     * @param indexB index of second target within the array
     * @param result caller-allocated vector.
     * @returns return true if indexA, indexB both valid
     */
    accumulateCrossProductIndexIndexIndex(originIndex, indexA, indexB, result) {
        const data = this.data;
        if (this.isValidIndex(originIndex) && this.isValidIndex(indexA) && this.isValidIndex(indexB))
            result.addCrossProductToTargetsInPlace(data[originIndex].x, data[originIndex].y, data[originIndex].z, data[indexA].x, data[indexA].y, data[indexA].z, data[indexB].x, data[indexB].y, data[indexB].z);
    }
    /**
     * read-only property for number of XYZ in the collection.
     */
    get length() {
        return this.data.length;
    }
}
exports.Point3dArrayCarrier = Point3dArrayCarrier;


/***/ }),

/***/ "./lib/geometry3d/Range.js":
/*!*********************************!*\
  !*** ./lib/geometry3d/Range.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Point2dVector2d_1 = __webpack_require__(/*! ./Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ./Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Transform_1 = __webpack_require__(/*! ./Transform */ "./lib/geometry3d/Transform.js");
const Matrix3d_1 = __webpack_require__(/*! ./Matrix3d */ "./lib/geometry3d/Matrix3d.js");
class RangeBase {
    /** @return 0 if high<= low, otherwise `1/(high-low)` for use in fractionalizing */
    static npcScaleFactor(low, high) { return (high <= low) ? 0.0 : 1.0 / (high - low); }
    static isExtremeValue(x) { return Math.abs(x) >= RangeBase._EXTREME_POSITIVE; }
    static isExtremePoint3d(xyz) { return RangeBase.isExtremeValue(xyz.x) || RangeBase.isExtremeValue(xyz.y) || RangeBase.isExtremeValue(xyz.z); }
    static isExtremePoint2d(xy) { return RangeBase.isExtremeValue(xy.x) || RangeBase.isExtremeValue(xy.y); }
    /**
     * * Both low,high pairs have order expectations:  The condition `high > low` means null interval.
     * * If there is interval overlap, the distance is zero.
     * @returns The min absolute distance from any point of `[lowA,highA]' to any point of `[lowB,highB]'.
     * @param lowA low of interval A
     * @param highA high of interval A
     * @param lowB low of interval B
     * @param highB high of interval B
     */
    static rangeToRangeAbsoluteDistance(lowA, highA, lowB, highB) {
        if (highA < lowA)
            return RangeBase._EXTREME_POSITIVE;
        if (highB < lowB)
            return RangeBase._EXTREME_POSITIVE;
        if (highB < lowA)
            return lowA - highB;
        if (highB <= highA)
            return 0.0;
        if (lowB <= highA)
            return 0.0;
        return lowB - highA;
    }
    static coordinateToRangeAbsoluteDistance(x, low, high) {
        if (high < low)
            return RangeBase._EXTREME_POSITIVE;
        if (x < low)
            return low - x;
        if (x > high)
            return x - high;
        return 0.0;
    }
}
RangeBase._EXTREME_POSITIVE = 1.0e200;
RangeBase._EXTREME_NEGATIVE = -1.0e200;
exports.RangeBase = RangeBase;
class Range3d extends RangeBase {
    /** Set this transform to values that indicate it has no contents. */
    setNull() {
        this.low.x = RangeBase._EXTREME_POSITIVE;
        this.low.y = RangeBase._EXTREME_POSITIVE;
        this.low.z = RangeBase._EXTREME_POSITIVE;
        this.high.x = RangeBase._EXTREME_NEGATIVE;
        this.high.y = RangeBase._EXTREME_NEGATIVE;
        this.high.z = RangeBase._EXTREME_NEGATIVE;
    }
    freeze() { Object.freeze(this); Object.freeze(this.low); Object.freeze(this.high); }
    static toFloat64Array(val) { return Float64Array.of(val.low.x, val.low.y, val.low.z, val.high.x, val.high.y, val.high.z); }
    toFloat64Array() { return Range3d.toFloat64Array(this); }
    /**
     * Construct a Range3d from an array of double-precision values
     * @param f64 the array, which should contain exactly 6 values in this order: lowx, lowy, lowz, highx, highy, highz
     * @return a new Range3d object
     */
    static fromFloat64Array(f64) {
        if (f64.length !== 6)
            throw new Error("invalid array");
        return new Range3d(f64[0], f64[1], f64[2], f64[3], f64[4], f64[5]);
    }
    /**
     * Construct a Range3d from an un-typed array. This mostly useful when interpreting ECSQL query results of the 'blob' type, where you know that that result is a Range3d.
     * @param buffer untyped array
     * @return a new Range3d object
     */
    static fromArrayBuffer(buffer) { return this.fromFloat64Array(new Float64Array(buffer)); }
    // explicit ctor - no enforcement of value relationships
    constructor(lowx = RangeBase._EXTREME_POSITIVE, lowy = RangeBase._EXTREME_POSITIVE, lowz = RangeBase._EXTREME_POSITIVE, highx = RangeBase._EXTREME_NEGATIVE, highy = RangeBase._EXTREME_NEGATIVE, highz = RangeBase._EXTREME_NEGATIVE) {
        super();
        this.low = Point3dVector3d_1.Point3d.create(lowx, lowy, lowz);
        this.high = Point3dVector3d_1.Point3d.create(highx, highy, highz);
    }
    /** Returns true if this and other have equal low and high point x,y,z parts */
    isAlmostEqual(other) {
        return (this.low.isAlmostEqual(other.low) && this.high.isAlmostEqual(other.high))
            || (this.isNull && other.isNull);
    }
    /** copy low and high values from other. */
    setFrom(other) { this.low.setFrom(other.low); this.high.setFrom(other.high); }
    static createFrom(other, result) {
        if (result) {
            result.setFrom(other);
            return result;
        }
        return Range3d.createXYZXYZOrCorrectToNull(other.low.x, other.low.y, other.low.z, other.high.x, other.high.y, other.high.z, result);
    }
    setFromJSON(json) {
        if (!json)
            return;
        this.setNull();
        if (Array.isArray(json)) {
            const point = Point3dVector3d_1.Point3d.create();
            for (const value of json) {
                point.setFromJSON(value);
                this.extendPoint(point);
            }
            return;
        }
        const low = Point3dVector3d_1.Point3d.fromJSON(json.low);
        const high = Point3dVector3d_1.Point3d.fromJSON(json.high);
        if (!RangeBase.isExtremePoint3d(low) && !RangeBase.isExtremePoint3d(high)) {
            this.extendPoint(low);
            this.extendPoint(high);
        }
    }
    /** Return a JSON object */
    toJSON() { return { low: this.low.toJSON(), high: this.high.toJSON() }; }
    static fromJSON(json) {
        const result = new Range3d();
        result.setFromJSON(json);
        return result;
    }
    // internal use only -- directly set all coordinates, test only if directed.
    setDirect(xA, yA, zA, xB, yB, zB, correctToNull) {
        this.low.x = xA;
        this.low.y = yA;
        this.low.z = zA;
        this.high.x = xB;
        this.high.y = yB;
        this.high.z = zB;
        if (correctToNull) {
            if (this.low.x > this.high.x
                || this.low.y > this.high.y
                || this.low.z > this.high.z)
                this.setNull();
        }
    }
    clone(result) {
        result = result ? result : new Range3d();
        result.setDirect(this.low.x, this.low.y, this.low.z, this.high.x, this.high.y, this.high.z, false);
        return result;
    }
    /** Return a range initialized to have no content. */
    static createNull(result) {
        result = result ? result : new Range3d();
        result.setNull();
        return result;
    }
    /** Extend (modify in place) so that the range is large enough to include the supplied points. */
    extend(...point) {
        let p;
        for (p of point)
            this.extendPoint(p);
    }
    /** Return a range large enough to include the supplied points. If no points are given, the range is a null range */
    static create(...point) {
        const result = Range3d.createNull();
        let p;
        for (p of point)
            result.extendPoint(p);
        return result;
    }
    /** create a Range3d enclosing the transformed points. */
    static createTransformed(transform, ...point) {
        const result = Range3d.createNull();
        let p;
        for (p of point)
            result.extendTransformedXYZ(transform, p.x, p.y, p.z);
        return result;
    }
    /** create a Range3d enclosing the transformed points. */
    static createTransformedArray(transform, points) {
        const result = Range3d.createNull();
        result.extendArray(points, transform);
        return result;
    }
    /** create a Range3d enclosing the points after inverse transform. */
    static createInverseTransformedArray(transform, points) {
        const result = Range3d.createNull();
        result.extendInverseTransformedArray(points, transform);
        return result;
    }
    /** Set the range to be a single point supplied as x,y,z values */
    setXYZ(x, y, z) {
        this.low.x = this.high.x = x;
        this.low.y = this.high.y = y;
        this.low.z = this.high.z = z;
    }
    /** Create a single point range */
    static createXYZ(x, y, z, result) {
        result = result ? result : new Range3d();
        result.setDirect(x, y, z, x, y, z, false);
        return result;
    }
    /** Create a box with 2 pairs of xyz candidates. Theses are compared and shuffled as needed for the box. */
    static createXYZXYZ(xA, yA, zA, xB, yB, zB, result) {
        result = result ? result : new Range3d();
        result.setDirect(Math.min(xA, xB), Math.min(yA, yB), Math.min(zA, zB), Math.max(xA, xB), Math.max(yA, yB), Math.max(zA, zB), false);
        return result;
    }
    /** Create a box with 2 pairs of xyz candidates. If any direction has order flip, create null. */
    static createXYZXYZOrCorrectToNull(xA, yA, zA, xB, yB, zB, result) {
        result = result ? result : new Range3d();
        result.setDirect(Math.min(xA, xB), Math.min(yA, yB), Math.min(zA, zB), Math.max(xA, xB), Math.max(yA, yB), Math.max(zA, zB), true);
        return result;
    }
    /** Creates a 3d range from a 2d range's low and high members, setting the corresponding z values to the value given. */
    static createRange2d(range, z = 0, result) {
        const retVal = result ? result : new Range3d();
        retVal.setNull();
        retVal.extendXYZ(range.low.x, range.low.y, z);
        retVal.extendXYZ(range.high.x, range.high.y, z);
        return retVal;
    }
    /** Create a range around an array of points. */
    static createArray(points, result) {
        result = result ? result : new Range3d();
        result.setNull();
        let point;
        for (point of points)
            result.extendPoint(point);
        return result;
    }
    /** extend a range around an array of points (optionally transformed) */
    extendArray(points, transform) {
        if (Array.isArray(points))
            if (transform)
                for (const point of points)
                    this.extendTransformedXYZ(transform, point.x, point.y, point.z);
            else
                for (const point of points)
                    this.extendXYZ(point.x, point.y, point.z);
        else // growable array -- this should be implemented without point extraction !!!
         if (transform)
            for (let i = 0; i < points.length; i++)
                this.extendTransformedXYZ(transform, points.getPoint3dAt(i).x, points.getPoint3dAt(i).y, points.getPoint3dAt(i).z);
        else
            for (let i = 0; i < points.length; i++)
                this.extendXYZ(points.getPoint3dAt(i).x, points.getPoint3dAt(i).y, points.getPoint3dAt(i).z);
    }
    /** extend a range around an array of points (optionally transformed) */
    extendInverseTransformedArray(points, transform) {
        if (Array.isArray(points))
            for (const point of points)
                this.extendInverseTransformedXYZ(transform, point.x, point.y, point.z);
        else // growable array -- this should be implemented without point extraction !!!
            for (let i = 0; i < points.length; i++)
                this.extendInverseTransformedXYZ(transform, points.getPoint3dAt(i).x, points.getPoint3dAt(i).y, points.getPoint3dAt(i).z);
    }
    /** multiply the point x,y,z by transform and use the coordinate to extend this range.
     */
    extendTransformedXYZ(transform, x, y, z) {
        const origin = transform.origin;
        const coffs = transform.matrix.coffs;
        this.extendXYZ(origin.x + coffs[0] * x + coffs[1] * y + coffs[2] * z, origin.y + coffs[3] * x + coffs[4] * y + coffs[5] * z, origin.z + coffs[6] * x + coffs[7] * y + coffs[8] * z);
    }
    /** multiply the point x,y,z,w by transform and use the coordinate to extend this range.
     */
    extendTransformedXYZW(transform, x, y, z, w) {
        const origin = transform.origin;
        const coffs = transform.matrix.coffs;
        this.extendXYZW(origin.x * w + coffs[0] * x + coffs[1] * y + coffs[2] * z, origin.y * w + coffs[3] * x + coffs[4] * y + coffs[5] * z, origin.z * w + coffs[6] * x + coffs[7] * y + coffs[8] * z, w);
    }
    /** multiply the point x,y,z by transform and use the coordinate to extend this range.
     */
    extendInverseTransformedXYZ(transform, x, y, z) {
        const origin = transform.origin;
        if (!transform.matrix.computeCachedInverse(true))
            return false;
        const coffs = transform.matrix.inverseCoffs;
        const xx = x - origin.x;
        const yy = y - origin.y;
        const zz = z - origin.z;
        this.extendXYZ(coffs[0] * xx + coffs[3] * yy + coffs[6] * zz, coffs[1] * xx + coffs[4] * yy + coffs[7] * zz, coffs[2] * xx + coffs[5] * yy + coffs[8] * zz);
        return true;
    }
    /** Extend the range by the two transforms applied to xyz */
    extendTransformTransformedXYZ(transformA, transformB, x, y, z) {
        const origin = transformB.origin;
        const coffs = transformB.matrix.coffs;
        this.extendTransformedXYZ(transformA, origin.x + coffs[0] * x + coffs[1] * y + coffs[2] * z, origin.y + coffs[3] * x + coffs[4] * y + coffs[5] * z, origin.z + coffs[6] * x + coffs[7] * y + coffs[8] * z);
    }
    /** Test if the box has high<low for any of x,y,z, condition. Note that a range around a single point is NOT null. */
    get isNull() {
        return this.high.x < this.low.x
            || this.high.y < this.low.y
            || this.high.z < this.low.z;
    }
    /** Test if  data has high<low for any of x,y,z, condition. Note that a range around a single point is NOT null. */
    static isNull(data) {
        return data.high.x < data.low.x
            || data.high.y < data.low.y
            || data.high.z < data.low.z;
    }
    /** Test of the range contains a single point. */
    get isSinglePoint() {
        return this.high.x === this.low.x
            && this.high.y === this.low.y
            && this.high.z === this.low.z;
    }
    /**  Return the length of the box in the x direction */
    xLength() { const a = this.high.x - this.low.x; return a > 0.0 ? a : 0.0; }
    /**  Return the length of the box in the y direction */
    yLength() { const a = this.high.y - this.low.y; return a > 0.0 ? a : 0.0; }
    /**  Return the length of the box in the z direction */
    zLength() { const a = this.high.z - this.low.z; return a > 0.0 ? a : 0.0; }
    /**  Return the largest of the x,y, z lengths of the range. */
    maxLength() { return Math.max(this.xLength(), this.yLength(), this.zLength()); }
    /** return the diagonal vector. There is no check for isNull -- if the range isNull(), the vector will have very large negative coordinates. */
    diagonal(result) { return this.low.vectorTo(this.high, result); }
    /**  Return the diagonal vector. There is no check for isNull -- if the range isNull(), the vector will have very large negative coordinates. */
    diagonalFractionToPoint(fraction, result) { return this.low.interpolate(fraction, this.high, result); }
    /**  Return a point given by fractional positions on the XYZ axes. This is done with no check for isNull !!! */
    fractionToPoint(fractionX, fractionY, fractionZ, result) {
        return this.low.interpolateXYZ(fractionX, fractionY, fractionZ, this.high, result);
    }
    /**  Return a point given by fractional positions on the XYZ axes.
     *  Returns undefined if the range is null.
     */
    localXYZToWorld(fractionX, fractionY, fractionZ, result) {
        if (this.isNull)
            return undefined;
        return this.low.interpolateXYZ(fractionX, fractionY, fractionZ, this.high, result);
    }
    /** Return a point given by fractional positions on the XYZ axes.
     * * Returns undefined if the range is null.
     */
    localToWorld(xyz, result) {
        return this.localXYZToWorld(xyz.x, xyz.y, xyz.z, result);
    }
    /** Replace fractional coordinates by world coordinates.
     * @returns false if null range.
     */
    localToWorldArrayInPlace(points) {
        if (this.isNull)
            return false;
        for (const p of points)
            this.low.interpolateXYZ(p.x, p.y, p.z, this.high, p);
        return false;
    }
    /** Return fractional coordinates of point within the range.
     * * returns undefined if the range is null.
     * * returns undefined if any direction (x,y,z) has zero length
     */
    worldToLocal(point, result) {
        const ax = RangeBase.npcScaleFactor(this.low.x, this.high.x);
        const ay = RangeBase.npcScaleFactor(this.low.y, this.high.y);
        const az = RangeBase.npcScaleFactor(this.low.z, this.high.z);
        if (ax === 0.0 || ay === 0.0 || az === 0.0)
            return undefined;
        return Point3dVector3d_1.Point3d.create((point.x - this.low.x) * ax, (point.y - this.low.y) * ay, (point.z - this.low.z) * az, result);
    }
    /** Return fractional coordinates of point within the range.
     * * returns undefined if the range is null.
     * * returns undefined if any direction (x,y,z) has zero length
     */
    worldToLocalArrayInPlace(point) {
        const ax = RangeBase.npcScaleFactor(this.low.x, this.high.x);
        const ay = RangeBase.npcScaleFactor(this.low.y, this.high.y);
        const az = RangeBase.npcScaleFactor(this.low.z, this.high.z);
        if (ax === 0.0 || ay === 0.0 || az === 0.0)
            return false;
        for (const p of point)
            Point3dVector3d_1.Point3d.create((p.x - this.low.x) * ax, (p.y - this.low.y) * ay, (p.z - this.low.z) * az, p);
        return true;
    }
    /** Return an array with the 8 corners on order wth "x varies fastest, then y, then z" */
    corners() {
        return [
            Point3dVector3d_1.Point3d.create(this.low.x, this.low.y, this.low.z),
            Point3dVector3d_1.Point3d.create(this.high.x, this.low.y, this.low.z),
            Point3dVector3d_1.Point3d.create(this.low.x, this.high.y, this.low.z),
            Point3dVector3d_1.Point3d.create(this.high.x, this.high.y, this.low.z),
            Point3dVector3d_1.Point3d.create(this.low.x, this.low.y, this.high.z),
            Point3dVector3d_1.Point3d.create(this.high.x, this.low.y, this.high.z),
            Point3dVector3d_1.Point3d.create(this.low.x, this.high.y, this.high.z),
            Point3dVector3d_1.Point3d.create(this.high.x, this.high.y, this.high.z)
        ];
    }
    /** Return the largest absolute value among any coordinates in the box corners. */
    maxAbs() {
        if (this.isNull)
            return 0.0;
        return Math.max(this.low.maxAbs(), this.high.maxAbs());
    }
    /** returns true if the x direction size is nearly zero */
    get isAlmostZeroX() { return Geometry_1.Geometry.isSmallMetricDistance(this.xLength()); }
    /** returns true if the y direction size is nearly zero */
    get isAlmostZeroY() { return Geometry_1.Geometry.isSmallMetricDistance(this.yLength()); }
    /** returns true if the z direction size is nearly zero */
    get isAlmostZeroZ() { return Geometry_1.Geometry.isSmallMetricDistance(this.zLength()); }
    /** Test if a point given as x,y,z is within the range. */
    containsXYZ(x, y, z) {
        return x >= this.low.x
            && y >= this.low.y
            && z >= this.low.z
            && x <= this.high.x
            && y <= this.high.y
            && z <= this.high.z;
    }
    /** Test if a point is within the range. */
    containsPoint(point) { return this.containsXYZ(point.x, point.y, point.z); }
    /** Test if the x,y coordinates of a point are within the range. */
    containsPointXY(point) {
        return point.x >= this.low.x
            && point.y >= this.low.y
            && point.x <= this.high.x
            && point.y <= this.high.y;
    }
    /** Test of other range is within this range */
    containsRange(other) {
        return other.low.x >= this.low.x
            && other.low.y >= this.low.y
            && other.low.z >= this.low.z
            && other.high.x <= this.high.x
            && other.high.y <= this.high.y
            && other.high.z <= this.high.z;
    }
    /** Test if there is any intersection with other range */
    intersectsRange(other) {
        return !(this.low.x > other.high.x
            || this.low.y > other.high.y
            || this.low.z > other.high.z
            || other.low.x > this.high.x
            || other.low.y > this.high.y
            || other.low.z > this.high.z);
    }
    /** Test if there is any intersection with other range */
    intersectsRangeXY(other) {
        return !(this.low.x > other.high.x
            || this.low.y > other.high.y
            || other.low.x > this.high.x
            || other.low.y > this.high.y);
    }
    /** Return 0 if the point is within the range, otherwise the distance to the closest face or corner */
    distanceToPoint(point) {
        if (this.isNull)
            return RangeBase._EXTREME_POSITIVE;
        return Math.min(Geometry_1.Geometry.hypotenuseXYZ(RangeBase.coordinateToRangeAbsoluteDistance(point.x, this.low.x, this.high.x), RangeBase.coordinateToRangeAbsoluteDistance(point.y, this.low.y, this.high.y), RangeBase.coordinateToRangeAbsoluteDistance(point.z, this.low.z, this.high.z)), RangeBase._EXTREME_POSITIVE);
    }
    /** returns 0 if the ranges have any overlap, otherwise the shortest absolute distance from one to the other. */
    distanceToRange(other) {
        return Math.min(Geometry_1.Geometry.hypotenuseXYZ(RangeBase.rangeToRangeAbsoluteDistance(this.low.x, this.high.x, other.low.x, other.high.x), RangeBase.rangeToRangeAbsoluteDistance(this.low.y, this.high.y, other.low.y, other.high.y), RangeBase.rangeToRangeAbsoluteDistance(this.low.z, this.high.z, other.low.z, other.high.z)), RangeBase._EXTREME_POSITIVE);
    }
    /** Expand this range by distances a (possibly signed) in all directions */
    extendXYZ(x, y, z) {
        if (x < this.low.x)
            this.low.x = x;
        if (x > this.high.x)
            this.high.x = x;
        if (y < this.low.y)
            this.low.y = y;
        if (y > this.high.y)
            this.high.y = y;
        if (z < this.low.z)
            this.low.z = z;
        if (z > this.high.z)
            this.high.z = z;
    }
    /** Expand this range by distances a (weighted and possibly signed) in all directions */
    extendXYZW(x, y, z, w) {
        if (!Geometry_1.Geometry.isSmallMetricDistance(w))
            this.extendXYZ(x / w, y / w, z / w);
    }
    /** Expand this range to include a point. */
    extendPoint(point) { this.extendXYZ(point.x, point.y, point.z); }
    /** Expand this range to include a transformed point. */
    extendTransformedPoint(transform, point) {
        this.extendTransformedXYZ(transform, point.x, point.y, point.z);
    }
    /** Expand this range to include a range. */
    extendRange(other) {
        if (!Range3d.isNull(other)) {
            this.extendXYZ(other.low.x, other.low.y, other.low.z);
            this.extendXYZ(other.high.x, other.high.y, other.high.z);
        }
    }
    /** Return the intersection of ranges. */
    intersect(other, result) {
        if (!this.intersectsRange(other))
            return Range3d.createNull(result);
        return Range3d.createXYZXYZOrCorrectToNull(Math.max(this.low.x, other.low.x), Math.max(this.low.y, other.low.y), Math.max(this.low.z, other.low.z), Math.min(this.high.x, other.high.x), Math.min(this.high.y, other.high.y), Math.min(this.high.z, other.high.z), result);
    }
    /** Return the union of ranges. */
    union(other, result) {
        if (this.isNull)
            return other.clone(result);
        if (other.isNull)
            return this.clone(result);
        // we trust null ranges have EXTREME values, so a null in either input leads to expected results.
        return Range3d.createXYZXYZOrCorrectToNull(Math.min(this.low.x, other.low.x), Math.min(this.low.y, other.low.y), Math.min(this.low.z, other.low.z), Math.max(this.high.x, other.high.x), Math.max(this.high.y, other.high.y), Math.max(this.high.z, other.high.z), result);
    }
    /**
     * move low and high points by scaleFactor around the center point.
     * @param scaleFactor scale factor applied to low, high distance from center.
     */
    scaleAboutCenterInPlace(scaleFactor) {
        if (!this.isNull) {
            scaleFactor = Math.abs(scaleFactor);
            // do the scalar stuff to avoid making a temporary object ....
            const xMid = 0.5 * (this.low.x + this.high.x);
            const yMid = 0.5 * (this.low.y + this.high.y);
            const zMid = 0.5 * (this.low.z + this.high.z);
            this.high.x = Geometry_1.Geometry.interpolate(xMid, scaleFactor, this.high.x);
            this.high.y = Geometry_1.Geometry.interpolate(yMid, scaleFactor, this.high.y);
            this.high.z = Geometry_1.Geometry.interpolate(zMid, scaleFactor, this.high.z);
            this.low.x = Geometry_1.Geometry.interpolate(xMid, scaleFactor, this.low.x);
            this.low.y = Geometry_1.Geometry.interpolate(yMid, scaleFactor, this.low.y);
            this.low.z = Geometry_1.Geometry.interpolate(zMid, scaleFactor, this.low.z);
        }
    }
    /**
     * move all limits by a fixed amount.
     * * positive delta expands the range size
     * * negative delta reduces the range size
     * * if any dimension reduces below zero size, the whole range becomes null
     * @param delta shift to apply.
     */
    expandInPlace(delta) {
        this.setDirect(this.low.x - delta, this.low.y - delta, this.low.z - delta, this.high.x + delta, this.high.y + delta, this.high.z + delta, true);
    }
    /** Create a local to world transform from this range. */
    getLocalToWorldTransform(result) {
        return Transform_1.Transform.createOriginAndMatrix(Point3dVector3d_1.Point3d.create(this.low.x, this.low.y, this.low.z), Matrix3d_1.Matrix3d.createRowValues(this.high.x - this.low.x, 0, 0, 0, this.high.y - this.low.y, 0, 0, 0, this.high.z - this.low.z), result);
    }
    /**
     * Creates an NPC to world transformation to go from 000...111 to the globally aligned cube with diagonally opposite corners that are the
     * min and max of this range. The diagonal component for any degenerate direction is 1.
     */
    getNpcToWorldRangeTransform(result) {
        const transform = this.getLocalToWorldTransform(result);
        const matrix = transform.matrix;
        if (matrix.coffs[0] === 0)
            matrix.coffs[0] = 1;
        if (matrix.coffs[4] === 0)
            matrix.coffs[4] = 1;
        if (matrix.coffs[8] === 0)
            matrix.coffs[8] = 1;
        return transform;
    }
}
exports.Range3d = Range3d;
class Range1d extends RangeBase {
    setNull() {
        this.low = RangeBase._EXTREME_POSITIVE;
        this.high = RangeBase._EXTREME_NEGATIVE;
    }
    // internal use only -- directly set all coordinates, test only if directed.
    setDirect(low, high, correctToNull) {
        this.low = low;
        this.high = high;
        if (correctToNull && low > high)
            this.setNull();
    }
    // explicit ctor - no enforcement of value relationships
    constructor(low = RangeBase._EXTREME_POSITIVE, high = RangeBase._EXTREME_NEGATIVE) {
        super();
        this.low = low;
        this.high = high; // duplicates set_direct, but compiler is not convinced they are set.
        this.set_direct(low, high);
    }
    /** Returns true if this and other have equal low and high parts */
    isAlmostEqual(other) {
        return (Geometry_1.Geometry.isSameCoordinate(this.low, other.low) && Geometry_1.Geometry.isSameCoordinate(this.high, other.high))
            || (this.isNull && other.isNull);
    }
    /** copy contents from other Range1d. */
    setFrom(other) { this.low = other.low; this.high = other.high; }
    /** Convert from a JSON object of one of these forms:
     *
     * *  Any array of numbers: `[value,value, value]`
     * *  An object with low and high as properties: `{low:lowValue, high: highValue}`
     */
    setFromJSON(json) {
        this.setNull();
        if (Array.isArray(json)) {
            let value;
            for (value of json) {
                if (Number.isFinite(value))
                    this.extendX(value);
            }
        }
        else if (json.low && json.low && json.high && json.high) {
            this.setNull();
            this.extendX(json.low);
            this.extendX(json.high);
        }
    }
    static fromJSON(json) {
        const result = new Range1d();
        if (json)
            result.setFromJSON(json);
        return result;
    }
    /** Convert to a JSON object of form
     * ```
     *    [lowValue,highValue]
     * ```
     */
    toJSON() { if (this.isNull)
        return new Array();
    else
        return [this.low, this.high]; }
    // internal use only -- directly set both lwo and high coordinates, without tests.
    set_direct(low, high) {
        this.low = low;
        this.high = high;
    }
    /** return a new Range1d with contents of this.
     * @param result optional result.
     */
    clone(result) {
        result = result ? result : new Range1d();
        result.set_direct(this.low, this.high);
        return result;
    }
    /** return a new Range1d with contents of this.
     * @param result optional result.
     */
    static createFrom(other, result) {
        result = result ? result : new Range1d();
        result.set_direct(other.low, other.high);
        return result;
    }
    /** Create a range with no content.
     * @param result optional result.
     */
    static createNull(result) {
        result = result ? result : new Range1d();
        result.setNull();
        return result;
    }
    /**
     * Set this range to be a single value.
     * @param x value to use as both low and high.
     */
    setX(x) { this.low = this.high = x; }
    /** Create a single point box */
    static createX(x, result) {
        result = result ? result : new Range1d();
        result.set_direct(x, x);
        return result;
    }
    /** Create a box from two values. Values are reversed if needed
     * @param xA first value
     * @param xB second value
     */
    static createXX(xA, xB, result) {
        result = result ? result : new Range1d();
        result.set_direct(Math.min(xA, xB), Math.max(xA, xB));
        return result;
    }
    /** Create a box from two values, but null range if the values are reversed
     * @param xA first value
     * @param xB second value
     */
    static createXXOrCorrectToNull(xA, xB, result) {
        if (xB < xA)
            return Range1d.createNull(result);
        result = result ? result : new Range1d();
        result.set_direct(Math.min(xA, xB), Math.max(xA, xB));
        return result;
    }
    /** Create a range containing all the values in an array.
     * @param values array of points to be contained in the range.
     * @param result optional result.
     */
    static createArray(values, result) {
        result = result ? result : new Range1d();
        let x;
        for (x of values)
            result.extendX(x);
        return result;
    }
    /** extend to include an array of values */
    extendArray(values) {
        let x;
        for (x of values)
            this.extendX(x);
    }
    /** extend to include `values` at indices `beginIndex <= i < endIndex]`
     * @param values array of values
     * @param beginIndex first index to include
     * @param numValue nubmer of values to access
     */
    extendArraySubset(values, beginIndex, numValue) {
        const endIndex = beginIndex + numValue;
        for (let i = beginIndex; i < endIndex; i++)
            this.extendX(values[i]);
    }
    /** Test if the box has high<low Note that a range around a single point is NOT null. */
    get isNull() {
        return this.high < this.low;
    }
    /** Test of the range contains a single point. */
    get isSinglePoint() {
        return this.high === this.low;
    }
    /** Return the length of the range in the x direction */
    length() { const a = this.high - this.low; return a > 0.0 ? a : 0.0; }
    /** return a point given by fractional positions within the range. This is done with no check for isNull !!! */
    fractionToPoint(fraction) {
        return Geometry_1.Geometry.interpolate(this.low, fraction, this.high);
    }
    /** Return the largest absolute value among the box limits. */
    maxAbs() {
        if (this.isNull)
            return 0.0;
        return Math.max(Math.abs(this.low), Math.abs(this.high));
    }
    /** Test if the x direction size is nearly zero */
    get isAlmostZeroLength() { return Geometry_1.Geometry.isSmallMetricDistance(this.length()); }
    /** Test if a number is within the range. */
    containsX(x) {
        return x >= this.low
            && x <= this.high;
    }
    /** Test of other range is within this range */
    containsRange(other) {
        return other.low >= this.low
            && other.high <= this.high;
    }
    /** Test if there is any intersection with other range */
    intersectsRange(other) {
        return !(this.low > other.high || other.low > this.high);
    }
    /** returns 0 if the ranges have any overlap, otherwise the shortest absolute distance from one to the other. */
    distanceToRange(other) {
        return RangeBase.rangeToRangeAbsoluteDistance(this.low, this.high, other.low, other.high);
    }
    /** Return 0 if the point is within the range, otherwise the (unsigned) distance to the closest face or corner */
    distanceToX(x) {
        if (this.isNull)
            return RangeBase._EXTREME_POSITIVE;
        return RangeBase.coordinateToRangeAbsoluteDistance(x, this.low, this.high);
    }
    /** Expand this range by a single coordinate */
    extendX(x) {
        if (x < this.low)
            this.low = x;
        if (x > this.high)
            this.high = x;
    }
    /** Expand this range to include a range. */
    extendRange(other) {
        if (!other.isNull) {
            this.extendX(other.low);
            this.extendX(other.high);
        }
    }
    /** Return the intersection of ranges. */
    intersect(other, result) {
        if (!this.intersectsRange(other))
            return Range1d.createNull(result);
        return Range1d.createXXOrCorrectToNull(Math.max(this.low, other.low), Math.min(this.high, other.high), result);
    }
    /** Return the union of ranges. */
    /** Return the intersection of ranges. */
    union(other, result) {
        // we trust null ranges have EXTREME values, so a null in either input leads to expected results.
        return Range1d.createXX(Math.min(this.low, other.low), Math.max(this.high, other.high), result);
    }
    /**
     * move low and high points by scaleFactor around the center point.
     * @param scaleFactor scale factor applied to low, high distance from center.
     */
    scaleAboutCenterInPlace(scaleFactor) {
        if (!this.isNull) {
            scaleFactor = Math.abs(scaleFactor);
            // do the scalar stuff to avoid making a temporary object ....
            const xMid = 0.5 * (this.low + this.high);
            this.high = Geometry_1.Geometry.interpolate(xMid, scaleFactor, this.high);
            this.low = Geometry_1.Geometry.interpolate(xMid, scaleFactor, this.low);
        }
    }
    /**
     * move all limits by a fixed amount.
     * * positive delta expands the range size
     * * negative delta reduces the range size
     * * if any dimension reduces below zero size, the whole range becomes null
     * @param delta shift to apply.
     */
    expandInPlace(delta) {
        this.setDirect(this.low - delta, this.high + delta, true);
    }
}
exports.Range1d = Range1d;
class Range2d extends RangeBase {
    setNull() {
        this.low.x = RangeBase._EXTREME_POSITIVE;
        this.low.y = RangeBase._EXTREME_POSITIVE;
        this.high.x = RangeBase._EXTREME_NEGATIVE;
        this.high.y = RangeBase._EXTREME_NEGATIVE;
    }
    static toFloat64Array(val) { return Float64Array.of(val.low.x, val.low.y, val.high.x, val.high.y); }
    toFloat64Array() { return Range2d.toFloat64Array(this); }
    /**
     * Construct a Range2d from an array of double-precision values
     * @param f64 the array, which should contain exactly 4 values in this order: lowx, lowy, highx, highy
     * @return a new Range2d object
     */
    static fromFloat64Array(f64) {
        if (f64.length !== 6)
            throw new Error("invalid array");
        return new Range3d(f64[0], f64[1], f64[2], f64[3], f64[4], f64[5]);
    }
    /**
     * Construct a Range2d from an un-typed array. This mostly useful when interpreting ECSQL query results of the 'blob' type, where you know that that result is a Range3d.
     * @param buffer untyped array
     * @return a new Range2d object
     */
    static fromArrayBuffer(buffer) { return this.fromFloat64Array(new Float64Array(buffer)); }
    // explicit ctor - no enforcement of value relationships
    constructor(lowx = Range2d._EXTREME_POSITIVE, lowy = Range2d._EXTREME_POSITIVE, highx = Range2d._EXTREME_NEGATIVE, highy = Range2d._EXTREME_NEGATIVE) {
        super();
        this.low = Point2dVector2d_1.Point2d.create(lowx, lowy);
        this.high = Point2dVector2d_1.Point2d.create(highx, highy);
    }
    isAlmostEqual(other) {
        return (this.low.isAlmostEqual(other.low) && this.high.isAlmostEqual(other.high))
            || (this.isNull && other.isNull);
    }
    setFrom(other) {
        this.low.set(other.low.x, other.low.y);
        this.high.set(other.high.x, other.high.y);
    }
    static createFrom(other, result) {
        if (result) {
            result.setFrom(other);
            return result;
        }
        return Range2d.createXYXYOrCorrectToNull(other.low.x, other.low.y, other.high.x, other.high.y, result);
    }
    /** treat any array of numbers as numbers to be inserted !!! */
    setFromJSON(json) {
        this.setNull();
        if (Array.isArray(json)) {
            const point = Point2dVector2d_1.Point2d.create();
            for (const value of json) {
                point.setFromJSON(value);
                this.extendPoint(point);
            }
            return;
        }
        const low = Point2dVector2d_1.Point2d.fromJSON(json.low);
        const high = Point2dVector2d_1.Point2d.fromJSON(json.high);
        if (!RangeBase.isExtremePoint2d(low) && !RangeBase.isExtremePoint2d(high)) {
            this.extendPoint(low);
            this.extendPoint(high);
        }
    }
    freeze() { Object.freeze(this.low); Object.freeze(this.high); }
    toJSON() { return this.isNull ? [] : [this.low.toJSON(), this.high.toJSON()]; }
    static fromJSON(json) {
        const result = new Range2d();
        if (json)
            result.setFromJSON(json);
        return result;
    }
    // internal use only -- directly set all coordinates, without tests.
    setDirect(xA, yA, xB, yB, correctToNull) {
        this.low.x = xA;
        this.low.y = yA;
        this.high.x = xB;
        this.high.y = yB;
        if (correctToNull) {
            if (this.low.x > this.high.x || this.low.y > this.high.y)
                this.setNull();
        }
    }
    /** return a clone of this range (or copy to optional result) */
    clone(result) {
        result = result ? result : new Range2d();
        result.setDirect(this.low.x, this.low.y, this.high.x, this.high.y, false);
        return result;
    }
    /** create a range with no content. */
    static createNull(result) {
        result = result ? result : new Range2d();
        result.setNull();
        return result;
    }
    /** Set low and hight to a single xy value. */
    setXY(x, y) {
        this.low.x = this.high.x = x;
        this.low.y = this.high.y = y;
    }
    /** Create a single point box */
    static createXY(x, y, result) {
        result = result ? result : new Range2d();
        result.setDirect(x, y, x, y, false);
        return result;
    }
    /** Create a box with 2 pairs of xy candidates. Theses are compared and shuffled as needed for the box. */
    static createXYXY(xA, yA, xB, yB, result) {
        result = result ? result : new Range2d();
        result.setDirect(Math.min(xA, xB), Math.min(yA, yB), Math.max(xA, xB), Math.max(yA, yB), false);
        return result;
    }
    /** Create a box with 2 pairs of xy candidates. If any direction has order flip, create null. */
    static createXYXYOrCorrectToNull(xA, yA, xB, yB, result) {
        if (xA > xB || yA > yB)
            return Range2d.createNull(result);
        result = result ? result : new Range2d();
        result.setDirect(Math.min(xA, xB), Math.min(yA, yB), Math.max(xA, xB), Math.max(yA, yB), true);
        return result;
    }
    /** Create a range around an array of points. */
    static createArray(points, result) {
        result = result ? result : new Range2d();
        let point;
        for (point of points)
            result.extendPoint(point);
        return result;
    }
    /** Test if the box has high<low for any of x,y, condition. Note that a range around a single point is NOT null. */
    get isNull() {
        return this.high.x < this.low.x
            || this.high.y < this.low.y;
    }
    /** Test if the box has high strictly less than low for any of x,y, condition. Note that a range around a single point is NOT null. */
    static isNull(range) {
        return range.high.x < range.low.x
            || range.high.y < range.low.y;
    }
    /** Test of the range contains a single point. */
    get isSinglePoint() {
        return this.high.x === this.low.x
            && this.high.y === this.low.y;
    }
    /** Length of the box in the x direction */
    xLength() { const a = this.high.x - this.low.x; return a > 0.0 ? a : 0.0; }
    /** Length of the box in the y direction */
    yLength() { const a = this.high.y - this.low.y; return a > 0.0 ? a : 0.0; }
    /** return the diagonal vector. There is no check for isNull -- if the range isNull(), the vector will have very large negative coordinates. */
    diagonal(result) { return this.low.vectorTo(this.high, result); }
    /** return the diagonal vector. There is no check for isNull -- if the range isNull(), the vector will have very large negative coordinates. */
    diagonalFractionToPoint(fraction, result) { return this.low.interpolate(fraction, this.high, result); }
    /** return a point given by fractional positions on the XY axes. This is done with no check for isNull !!! */
    fractionToPoint(fractionX, fractionY, result) {
        return this.low.interpolateXY(fractionX, fractionY, this.high, result);
    }
    /** Largest absolute value among any coordinates in the box corners. */
    maxAbs() {
        if (this.isNull)
            return 0.0;
        return Math.max(this.low.maxAbs(), this.high.maxAbs());
    }
    /** Test if the x direction size is nearly zero */
    get isAlmostZeroX() { return Geometry_1.Geometry.isSmallMetricDistance(this.xLength()); }
    /** Test if the y direction size is nearly zero */
    get isAlmostZeroY() { return Geometry_1.Geometry.isSmallMetricDistance(this.yLength()); }
    /** Test if a point given as x,y is within the range. */
    containsXY(x, y) {
        return x >= this.low.x
            && y >= this.low.y
            && x <= this.high.x
            && y <= this.high.y;
    }
    /** Test if a point is within the range. */
    containsPoint(point) { return this.containsXY(point.x, point.y); }
    /** Test of other range is within this range */
    containsRange(other) {
        return other.low.x >= this.low.x
            && other.low.y >= this.low.y
            && other.high.x <= this.high.x
            && other.high.y <= this.high.y;
    }
    /** Test if there is any intersection with other range */
    intersectsRange(other) {
        return !(this.low.x > other.high.x
            || this.low.y > other.high.y
            || other.low.x > this.high.x
            || other.low.y > this.high.y);
    }
    /** Return 0 if the point is within the range, otherwise the distance to the closest face or corner */
    distanceToPoint(point) {
        if (this.isNull)
            return Range2d._EXTREME_POSITIVE;
        return Math.min(Geometry_1.Geometry.hypotenuseXY(RangeBase.coordinateToRangeAbsoluteDistance(point.x, this.low.x, this.high.x), RangeBase.coordinateToRangeAbsoluteDistance(point.y, this.low.y, this.high.y)), Range2d._EXTREME_POSITIVE);
    }
    /** Return 0 if the point is within the range, otherwise the distance to the closest face or corner */
    distanceToRange(other) {
        return Math.min(Geometry_1.Geometry.hypotenuseXY(RangeBase.rangeToRangeAbsoluteDistance(this.low.x, this.high.x, other.low.x, other.high.x), RangeBase.rangeToRangeAbsoluteDistance(this.low.y, this.high.y, other.low.y, other.high.y)), Range2d._EXTREME_POSITIVE);
    }
    /** Expand this range by distances a (possibly signed) in all directions */
    extendXY(x, y) {
        if (x < this.low.x)
            this.low.x = x;
        if (x > this.high.x)
            this.high.x = x;
        if (y < this.low.y)
            this.low.y = y;
        if (y > this.high.y)
            this.high.y = y;
    }
    /** Expand this range to include a point. */
    extendPoint(point) { this.extendXY(point.x, point.y); }
    /** Expand this range to include a range. */
    extendRange(other) {
        if (!Range2d.isNull(other)) {
            this.extendXY(other.low.x, other.low.y);
            this.extendXY(other.high.x, other.high.y);
        }
    }
    /** Return the intersection of ranges. */
    intersect(other, result) {
        if (!this.intersectsRange(other))
            return Range2d.createNull(result);
        return Range2d.createXYXY(Math.max(this.low.x, other.low.x), Math.max(this.low.y, other.low.y), Math.min(this.high.x, other.high.x), Math.min(this.high.y, other.high.y), result);
    }
    /** Return the union of ranges. */
    union(other, result) {
        if (this.isNull)
            return Range2d.createFrom(other, result);
        if (Range2d.isNull(other))
            return this.clone(result);
        // we trust null ranges have EXTREME values, so a null in either input leads to expected results.
        return Range2d.createXYXY(Math.min(this.low.x, other.low.x), Math.min(this.low.y, other.low.y), Math.max(this.high.x, other.high.x), Math.max(this.high.y, other.high.y), result);
    }
    /**
     * move low and high points by scaleFactor around the center point.
     * @param scaleFactor scale factor applied to low, high distance from center.
     */
    scaleAboutCenterInPlace(scaleFactor) {
        if (!this.isNull) {
            scaleFactor = Math.abs(scaleFactor);
            // do the scalar stuff to avoid making a temporary object ....
            const xMid = 0.5 * (this.low.x + this.high.x);
            const yMid = 0.5 * (this.low.y + this.high.y);
            this.high.x = Geometry_1.Geometry.interpolate(xMid, scaleFactor, this.high.x);
            this.high.y = Geometry_1.Geometry.interpolate(yMid, scaleFactor, this.high.y);
            this.low.x = Geometry_1.Geometry.interpolate(xMid, scaleFactor, this.low.x);
            this.low.y = Geometry_1.Geometry.interpolate(yMid, scaleFactor, this.low.y);
        }
    }
    /**
     * move all limits by a fixed amount.
     * * positive delta expands the range size
     * * negative delta reduces the range size
     * * if any dimension reduces below zero size, the whole range becomes null
     * @param delta shift to apply.
     */
    expandInPlace(delta) {
        this.setDirect(this.low.x - delta, this.low.y - delta, this.high.x + delta, this.high.y + delta, true);
    }
}
exports.Range2d = Range2d;


/***/ }),

/***/ "./lib/geometry3d/Ray3d.js":
/*!*********************************!*\
  !*** ./lib/geometry3d/Ray3d.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
const Point3dVector3d_1 = __webpack_require__(/*! ./Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Transform_1 = __webpack_require__(/*! ./Transform */ "./lib/geometry3d/Transform.js");
const Matrix3d_1 = __webpack_require__(/*! ./Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
/** A Ray3d contains
 * * an origin point.
 * * a direction vector.  The vector is NOT required to be normalized.
 *  * an optional weight (number).
 *
 */
class Ray3d {
    // constructor captures references !!!
    constructor(origin, direction) {
        this.origin = origin;
        this.direction = direction;
    }
    static _create(x, y, z, u, v, w) {
        return new Ray3d(Point3dVector3d_1.Point3d.create(x, y, z), Point3dVector3d_1.Vector3d.create(u, v, w));
    }
    static createXAxis() { return Ray3d._create(0, 0, 0, 1, 0, 0); }
    static createYAxis() { return Ray3d._create(0, 0, 0, 0, 1, 0); }
    static createZAxis() { return Ray3d._create(0, 0, 0, 0, 0, 1); }
    static createZero(result) {
        if (result) {
            result.origin.setZero();
            result.direction.setZero();
            return result;
        }
        return new Ray3d(Point3dVector3d_1.Point3d.createZero(), Point3dVector3d_1.Vector3d.createZero());
    }
    isAlmostEqual(other) {
        return this.origin.isAlmostEqual(other.origin) && this.direction.isAlmostEqual(other.direction);
    }
    static create(origin, direction, result) {
        if (result) {
            result.set(origin, direction);
            return result;
        }
        return new Ray3d(origin.clone(), direction.clone());
    }
    /**
     * Given a homogeneous point and its derivative components, construct a Ray3d with cartesian coordinates and derivatives.
     * @param weightedPoint `[x,y,z,w]` parts of weighted point.
     * @param weightedDerivative `[x,y,z,w]` derivatives
     * @param result
     */
    static createWeightedDerivative(weightedPoint, weightedDerivative, result) {
        const w = weightedPoint[3];
        const dw = weightedDerivative[3];
        const x = weightedPoint[0];
        const y = weightedPoint[1];
        const z = weightedPoint[2];
        const dx = weightedDerivative[0] * w - weightedPoint[0] * dw;
        const dy = weightedDerivative[1] * w - weightedPoint[1] * dw;
        const dz = weightedDerivative[2] * w - weightedPoint[2] * dw;
        if (Geometry_1.Geometry.isSmallMetricDistance(w))
            return undefined;
        const divW = 1.0 / w;
        const divWW = divW * divW;
        return Ray3d.createXYZUVW(x * divW, y * divW, z * divW, dx * divWW, dy * divWW, dz * divWW, result);
    }
    /** Create from coordinates of the origin and direction. */
    static createXYZUVW(originX, originY, originZ, directionX, directionY, directionZ, result) {
        if (result) {
            result.getOriginRef().set(originX, originY, originZ);
            result.getDirectionRef().set(directionX, directionY, directionZ);
            return result;
        }
        return new Ray3d(Point3dVector3d_1.Point3d.create(originX, originY, originZ), Point3dVector3d_1.Vector3d.create(directionX, directionY, directionZ));
    }
    /** Capture origin and direction in a new Ray3d. */
    static createCapture(origin, direction) {
        return new Ray3d(origin, direction);
    }
    /** Create from (clones of) origin, direction, and numeric weight. */
    static createPointVectorNumber(origin, direction, a, result) {
        if (result) {
            result.origin.setFrom(origin);
            result.direction.setFrom(direction);
            result.a = a;
            return result;
        }
        result = new Ray3d(origin.clone(), direction.clone());
        result.a = a;
        return result;
    }
    /** Create from origin and target.  The direction vector is the full length (non-unit) vector from origin to target. */
    static createStartEnd(origin, target, result) {
        if (result) {
            result.origin.setFrom(origin);
            result.direction.setStartEnd(origin, target);
            return result;
        }
        return new Ray3d(origin, Point3dVector3d_1.Vector3d.createStartEnd(origin, target));
    }
    /** @returns Return a reference to the ray's origin. */
    getOriginRef() { return this.origin; }
    /** @returns Return a reference to the ray's direction vector. */
    getDirectionRef() { return this.direction; }
    /** copy coordinates from origin and direction. */
    set(origin, direction) {
        this.origin.setFrom(origin);
        this.direction.setFrom(direction);
    }
    /** Clone the ray. */
    clone(result) {
        if (result) {
            result.set(this.origin, this.direction);
            return result;
        }
        return new Ray3d(this.origin.clone(), this.direction.clone());
    }
    /** Create a clone and return the transform of the clone. */
    cloneTransformed(transform) {
        return new Ray3d(transform.multiplyPoint3d(this.origin), transform.multiplyVector(this.direction));
    }
    /** Apply a transform in place. */
    transformInPlace(transform) {
        transform.multiplyPoint3d(this.origin, this.origin);
        transform.multiplyVector(this.direction, this.direction);
    }
    /** Copy data from another ray. */
    setFrom(source) { this.set(source.origin, source.direction); }
    /** * fraction 0 is the ray origin.
     * * fraction 1 is at the end of the direction vector when placed at the origin.
     * @returns Return a point at fractional position along the ray.
     */
    fractionToPoint(fraction) { return this.origin.plusScaled(this.direction, fraction); }
    /** @returns Return the dot product of the ray's direction vector with a vector from the ray origin to the space point. */
    dotProductToPoint(spacePoint) { return this.direction.dotProductStartEnd(this.origin, spacePoint); }
    /**
     * @returns Return the fractional coordinate (along the direction vector) of the spacePoint projected to the ray.
     */
    pointToFraction(spacePoint) {
        return Geometry_1.Geometry.safeDivideFraction(this.direction.dotProductStartEnd(this.origin, spacePoint), this.direction.magnitudeSquared(), 0);
    }
    /**
     *
     * @returns Return the spacePoint projected onto the ray.
     */
    projectPointToRay(spacePoint) {
        return this.origin.plusScaled(this.direction, this.pointToFraction(spacePoint));
    }
    /** Return a transform for rigid axes
     * at ray origin with z in ray direction.  If the direction vector is zero, axes default to identity (from createHeadsUpTriad)
     */
    toRigidZFrame() {
        const axes = Matrix3d_1.Matrix3d.createRigidHeadsUp(this.direction, 2 /* ZXY */);
        return Transform_1.Transform.createOriginAndMatrix(this.origin, axes);
    }
    /**
     * Convert {origin:[x,y,z], direction:[u,v,w]} to a Ray3d.
     */
    setFromJSON(json) {
        if (!json) {
            this.origin.set(0, 0, 0);
            this.direction.set(0, 0, 1);
            return;
        }
        this.origin.setFromJSON(json.origin);
        this.direction.setFromJSON(json.direction);
    }
    /**
     * try to scale the direction vector to a given magnitude.
     * @returns Returns false if ray direction is a zero vector.
     */
    trySetDirectionMagnitudeInPlace(magnitude = 1.0) {
        if (this.direction.tryNormalizeInPlace()) {
            this.direction.scaleInPlace(magnitude);
            return true;
        }
        this.direction.setZero();
        this.a = 0.0;
        return false;
    }
    // input a ray and "a" understood as an area.
    // if a is clearly nonzero metric squared and the vector can be normalized, install those and return true.
    // otherwise set ray.z to zero and zero the vector of the ray and return false.
    tryNormalizeInPlaceWithAreaWeight(a) {
        const tolerance = Geometry_1.Geometry.smallMetricDistanceSquared;
        this.a = a;
        if (Math.abs(a) > tolerance && this.direction.tryNormalizeInPlace(tolerance))
            return true;
        this.direction.setZero();
        this.a = 0.0;
        return false;
    }
    /**
     * Convert an Angle to a JSON object.
     * @return {*} [origin,normal]
     */
    toJSON() { return { origin: this.origin.toJSON(), direction: this.direction.toJSON() }; }
    static fromJSON(json) {
        const result = Ray3d.createXAxis();
        result.setFromJSON(json);
        return result;
    }
    /** return distance to point in space */
    distance(spacePoint) {
        const uu = this.direction.magnitudeSquared();
        const uv = this.dotProductToPoint(spacePoint);
        const aa = Geometry_1.Geometry.inverseMetricDistanceSquared(uu);
        if (aa)
            return Math.sqrt(this.origin.distanceSquared(spacePoint) - uv * uv * aa);
        else
            return Math.sqrt(this.origin.distanceSquared(spacePoint));
    }
    /**
     * Return the intersection of the unbounded ray with a plane.
     * Stores the point of intersection in the result point given as a parameter,
     * and returns the parameter along the ray where the intersection occurs.
     * Returns undefined if the ray and plane are parallel.
     */
    intersectionWithPlane(plane, result) {
        const vectorA = Point3dVector3d_1.Vector3d.createStartEnd(plane.getOriginRef(), this.origin);
        const uDotN = this.direction.dotProduct(plane.getNormalRef());
        const aDotN = vectorA.dotProduct(plane.getNormalRef());
        const division = Geometry_1.Geometry.conditionalDivideFraction(-aDotN, uDotN);
        if (undefined === division)
            return undefined;
        if (result) {
            this.origin.plusScaled(this.direction, division, result);
        }
        return division;
    }
}
exports.Ray3d = Ray3d;


/***/ }),

/***/ "./lib/geometry3d/Segment1d.js":
/*!*************************************!*\
  !*** ./lib/geometry3d/Segment1d.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
/**
 * * A Segment1d is an interval of an axis named x.
 * * The interval is defined by two values x0 and x1.
 * * The x0 and x1 values can be in either order.
 * * * if `x0 < x1` fractional coordinates within the segment move from left to right.
 * * * if `x0 > x1` fractional coordinatesw within the segment move from right to left.
 * * This differs from a Range1d in that:
 * * For a Range1d the reversed ordering of its limit values means "empty interval".
 * * For a Segment1d the reversed ordering is a real interval but fractional positions mvoe backwards.
 * * The segment is parameterized with a fraction
 * * * Fraction 0 is the start (`x0`)
 * * * Fraction 1 is the end (`x1`)
 * * * The fraction equation is `x = x0 + fraction * (x1-x0)` or (equivalently) `x = (1-fraction) * x0 + fraction * x1`
 */
class Segment1d {
    constructor(x0, x1) {
        this.x0 = x0;
        this.x1 = x1;
    }
    set(x0, x1) { this.x0 = x0, this.x1 = x1; }
    /**
     * create segment1d with given end values
     * @param x0 start value
     * @param x1 end value
     * @param result optional pre-existing result to be reinitialized.
     */
    static create(x0 = 0, x1 = 1, result) {
        if (!result)
            return new Segment1d(x0, x1);
        result.set(x0, x1);
        return result;
    }
    /**
     * Copy both end values from other Segment1d
     * @param other source Segment1d
     */
    setFrom(other) { this.x0 = other.x0; this.x1 = other.x1; }
    /**
     * clone this Segment1d, return as a separate object.
     */
    clone() { return new Segment1d(this.x0, this.x1); }
    /**
     * @returns true if both coordinates (`x0` and `x1`) are in the 0..1 range.
     */
    get isIn01() {
        return Geometry_1.Geometry.isIn01(this.x0) && Geometry_1.Geometry.isIn01(this.x1);
    }
    /**
     * Evalauate the segment at fractional position
     * @returns position within the segment
     * @param fraction fractional position within this segment
     */
    fractionToPoint(fraction) { return Geometry_1.Geometry.interpolate(this.x0, fraction, this.x1); }
    /**
     * * swap the x0 and x1 member values.
     * * This makes the fractionToPoint evaluates reverse direction.
     */
    reverseInPlace() { const x = this.x0; this.x0 = this.x1; this.x1 = x; }
    /**
     * Near equality test, using Geometry.isSameCoordinate for tolerances.
     */
    isAlmostEqual(other) {
        return Geometry_1.Geometry.isSameCoordinate(this.x0, other.x0) && Geometry_1.Geometry.isSameCoordinate(this.x1, other.x1);
    }
    /**
     * Return true if the segment limits are (exactly) 0 and 1
     */
    get isExact01() { return this.x0 === 0.0 && this.x1 === 1.0; }
}
exports.Segment1d = Segment1d;


/***/ }),

/***/ "./lib/geometry3d/Transform.js":
/*!*************************************!*\
  !*** ./lib/geometry3d/Transform.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Point4d_1 = __webpack_require__(/*! ../geometry4d/Point4d */ "./lib/geometry4d/Point4d.js");
const Range_1 = __webpack_require__(/*! ./Range */ "./lib/geometry3d/Range.js");
const Point2dVector2d_1 = __webpack_require__(/*! ./Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ./Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Matrix3d_1 = __webpack_require__(/*! ./Matrix3d */ "./lib/geometry3d/Matrix3d.js");
/** A transform is an origin and a Matrix3d.
 *
 * * This describes a coordinate frame with
 * this origin, with the columns of the Matrix3d being the
 * local x,y,z axis directions.
 * *  Beware that for common transformations (e.g. scale about point,
 * rotate around line, mirror across a plane) the "fixed point" that is used
 * when describing the transform is NOT the "origin" stored in the transform.
 * Setup methods (e.g createFixedPointAndMatrix, createScaleAboutPoint)
 * take care of determining the appropriate origin coordinates.
 */
class Transform {
    // Constructor accepts and uses POINTER to content .. no copy here.
    constructor(origin, matrix) { this._origin = origin; this._matrix = matrix; }
    /** The identity Transform. Value is frozen and cannot be modified. */
    static get identity() {
        if (undefined === this._identity) {
            this._identity = Transform.createIdentity();
            this._identity.freeze();
        }
        return this._identity;
    }
    freeze() { Object.freeze(this); Object.freeze(this._origin); this._matrix.freeze(); }
    setFrom(other) { this._origin.setFrom(other._origin), this._matrix.setFrom(other._matrix); }
    /** Set this Transform to be an identity. */
    setIdentity() { this._origin.setZero(); this._matrix.setIdentity(); }
    setFromJSON(json) {
        if (json) {
            if (json instanceof Object && json.origin && json.matrix) {
                this._origin.setFromJSON(json.origin);
                this._matrix.setFromJSON(json.matrix);
                return;
            }
            if (Geometry_1.Geometry.isArrayOfNumberArray(json, 3, 4)) {
                const data = json;
                this._matrix.setRowValues(data[0][0], data[0][1], data[0][2], data[1][0], data[1][1], data[1][2], data[2][0], data[2][1], data[2][2]);
                this._origin.set(data[0][3], data[1][3], data[2][3]);
                return;
            }
        }
        this.setIdentity();
    }
    /**
     * Test for near equality with other Transform.  Comparison uses the isAlmostEqual methods on
     * the origin and matrix parts.
     * @param other Transform to compare to.
     */
    isAlmostEqual(other) { return this._origin.isAlmostEqual(other._origin) && this._matrix.isAlmostEqual(other._matrix); }
    toJSON() {
        // return { origin: this._origin.toJSON(), matrix: this._matrix.toJSON() };
        return [
            [this._matrix.coffs[0], this._matrix.coffs[1], this._matrix.coffs[2], this._origin.x],
            [this._matrix.coffs[3], this._matrix.coffs[4], this._matrix.coffs[5], this._origin.y],
            [this._matrix.coffs[6], this._matrix.coffs[7], this._matrix.coffs[8], this._origin.z],
        ];
    }
    static fromJSON(json) {
        const result = Transform.createIdentity();
        result.setFromJSON(json);
        return result;
    }
    /** Copy the contents of this transform into a new Transform (or to the result, if specified). */
    clone(result) {
        if (result) {
            result._matrix.setFrom(this._matrix);
            result._origin.setFrom(this._origin);
            return result;
        }
        return new Transform(Point3dVector3d_1.Point3d.createFrom(this._origin), this._matrix.clone());
    }
    /** @returns Return a copy of this Transform, modified so that its axes are rigid
     */
    cloneRigid(axisOrder = 0 /* XYZ */) {
        const axes0 = Matrix3d_1.Matrix3d.createRigidFromMatrix3d(this.matrix, axisOrder);
        if (!axes0)
            return undefined;
        return new Transform(this.origin.cloneAsPoint3d(), axes0);
    }
    /** Create a copy with the given origin and matrix captured as the Transform origin and Matrix3d. */
    static createRefs(origin, matrix, result) {
        if (result) {
            result._origin = origin;
            result._matrix = matrix;
            return result;
        }
        return new Transform(origin, matrix);
    }
    /** Create a transform with complete contents given */
    static createRowValues(qxx, qxy, qxz, ax, qyx, qyy, qyz, ay, qzx, qzy, qzz, az, result) {
        if (result) {
            result._origin.set(ax, ay, az);
            result._matrix.setRowValues(qxx, qxy, qxz, qyx, qyy, qyz, qzx, qzy, qzz);
            return result;
        }
        return new Transform(Point3dVector3d_1.Point3d.create(ax, ay, az), Matrix3d_1.Matrix3d.createRowValues(qxx, qxy, qxz, qyx, qyy, qyz, qzx, qzy, qzz));
    }
    /**
     * create a Transform with translation provided by x,y,z parts.
     * @param x x part of translation
     * @param y y part of translation
     * @param z z part of translation
     * @param result optional result
     * @returns new or updated transform.
     */
    static createTranslationXYZ(x = 0, y = 0, z = 0, result) {
        return Transform.createRefs(Point3dVector3d_1.Vector3d.create(x, y, z), Matrix3d_1.Matrix3d.createIdentity(), result);
    }
    /** Create a matrix with specified translation part.
     * @param XYZ x,y,z parts of the translation.
     * @returns new or updated transform.
     */
    static createTranslation(translation, result) {
        return Transform.createRefs(translation, Matrix3d_1.Matrix3d.createIdentity(), result);
    }
    /** Return a reference to the matrix within the transform.  (NOT a copy) */
    get matrix() { return this._matrix; }
    /** Return a reference to the origin within the transform.  (NOT a copy) */
    get origin() { return this._origin; }
    /** return a (clone of) the origin part of the transform, as a Point3d */
    getOrigin() { return Point3dVector3d_1.Point3d.createFrom(this._origin); }
    /** return a (clone of) the origin part of the transform, as a Vector3d */
    getTranslation() { return Point3dVector3d_1.Vector3d.createFrom(this._origin); }
    /** test if the transform has 000 origin and identity Matrix3d */
    get isIdentity() {
        return this._matrix.isIdentity && this._origin.isAlmostZero;
    }
    /** Return an identity transform, optionally filling existing transform.  */
    static createIdentity(result) {
        if (result) {
            result._origin.setZero();
            result._matrix.setIdentity();
            return result;
        }
        return Transform.createRefs(Point3dVector3d_1.Point3d.createZero(), Matrix3d_1.Matrix3d.createIdentity());
    }
    /** Create by directly installing origin and matrix
     * this is a the appropriate construction when the columns of the matrix are coordinate axes of a local-to-global mapping
     * Note there is a closely related createFixedPointAndMatrix whose point input is the fixed point of the global-to-global transformation.
     */
    static createOriginAndMatrix(origin, matrix, result) {
        return Transform.createRefs(origin ? origin.cloneAsPoint3d() : Point3dVector3d_1.Point3d.createZero(), matrix === undefined ? Matrix3d_1.Matrix3d.createIdentity() : matrix.clone(), result);
    }
    /** Create by directly installing origin and columns of the matrix
     */
    static createOriginAndMatrixColumns(origin, vectorX, vectorY, vectorZ, result) {
        if (result)
            result.setOriginAndMatrixColumns(origin, vectorX, vectorY, vectorZ);
        else
            result = Transform.createRefs(Point3dVector3d_1.Vector3d.createFrom(origin), Matrix3d_1.Matrix3d.createColumns(vectorX, vectorY, vectorZ));
        return result;
    }
    /** Reinitialize by directly installing origin and columns of the matrix
     */
    setOriginAndMatrixColumns(origin, vectorX, vectorY, vectorZ) {
        this._origin.setFrom(origin);
        this._matrix.setColumns(vectorX, vectorY, vectorZ);
    }
    /** Create a transform with the specified matrix. Compute an origin (different from the given fixedPoint)
     * so that the fixedPoint maps back to itself.
     */
    static createFixedPointAndMatrix(fixedPoint, matrix, result) {
        const origin = Matrix3d_1.Matrix3d.XYZMinusMatrixTimesXYZ(fixedPoint, matrix, fixedPoint);
        return Transform.createRefs(origin, matrix.clone(), result);
    }
    /** Create a Transform which leaves the fixedPoint unchanged and
     * scales everything else around it by a single scale factor.
     */
    static createScaleAboutPoint(fixedPoint, scale, result) {
        const matrix = Matrix3d_1.Matrix3d.createScale(scale, scale, scale);
        const origin = Matrix3d_1.Matrix3d.XYZMinusMatrixTimesXYZ(fixedPoint, matrix, fixedPoint);
        return Transform.createRefs(origin, matrix, result);
    }
    /** Transform the input 2d point.  Return as a new point or in the pre-allocated result (if result is given) */
    multiplyPoint2d(source, result) {
        return Matrix3d_1.Matrix3d.XYPlusMatrixTimesXY(this._origin, this._matrix, source, result);
    }
    /** Transform the input 3d point.  Return as a new point or in the pre-allocated result (if result is given) */
    multiplyPoint3d(point, result) {
        return Matrix3d_1.Matrix3d.XYZPlusMatrixTimesXYZ(this._origin, this._matrix, point, result);
    }
    /** Transform the input point.  Return as a new point or in the pre-allocated result (if result is given) */
    multiplyXYZ(x, y, z, result) {
        return Matrix3d_1.Matrix3d.XYZPlusMatrixTimesCoordinates(this._origin, this._matrix, x, y, z, result);
    }
    /** Multiply a specific row of the transform times xyz. Return the (number). */
    multiplyComponentXYZ(componentIndex, x, y, z) {
        const coffs = this._matrix.coffs;
        const i0 = 3 * componentIndex;
        return this.origin.at(componentIndex) + coffs[i0] * x + coffs[i0 + 1] * y + coffs[i0 + 2] * z;
    }
    /** Multiply a specific row of the transform times (weighted!) xyzw. Return the (number). */
    multiplyComponentXYZW(componentIndex, x, y, z, w) {
        const coffs = this._matrix.coffs;
        const i0 = 3 * componentIndex;
        return this.origin.at(componentIndex) * w +
            coffs[i0] * x + coffs[i0 + 1] * y + coffs[i0 + 2] * z;
    }
    /** Transform the input homogeneous point.  Return as a new point or in the pre-allocated result (if result is given) */
    multiplyXYZW(x, y, z, w, result) {
        return Matrix3d_1.Matrix3d.XYZPlusMatrixTimesWeightedCoordinates(this._origin, this._matrix, x, y, z, w, result);
    }
    /** Transform the input homogeneous point.  Return as a new point or in the pre-allocated result (if result is given) */
    multiplyXYZWToFloat64Array(x, y, z, w, result) {
        return Matrix3d_1.Matrix3d.XYZPlusMatrixTimesWeightedCoordinatesToFloat64Array(this._origin, this._matrix, x, y, z, w, result);
    }
    /** Transform the input homogeneous point.  Return as a new point or in the pre-allocated result (if result is given) */
    multiplyXYZToFloat64Array(x, y, z, result) {
        return Matrix3d_1.Matrix3d.XYZPlusMatrixTimesCoordinatesToFloat64Array(this._origin, this._matrix, x, y, z, result);
    }
    /** Multiply the tranposed transform (as 4x4 with 0001 row) by Point4d given as xyzw..  Return as a new point or in the pre-allocated result (if result is given) */
    multiplyTransposeXYZW(x, y, z, w, result) {
        const coffs = this._matrix.coffs;
        const origin = this._origin;
        return Point4d_1.Point4d.create(x * coffs[0] + y * coffs[3] + z * coffs[6], x * coffs[1] + y * coffs[4] + z * coffs[7], x * coffs[2] + y * coffs[5] + z * coffs[8], x * origin.x + y * origin.y + z * origin.z + w, result);
    }
    /** for each point:  replace point by Transform*point */
    multiplyPoint3dArrayInPlace(points) {
        let point;
        for (point of points)
            Matrix3d_1.Matrix3d.XYZPlusMatrixTimesXYZ(this._origin, this._matrix, point, point);
    }
    /** @returns Return product of the transform's inverse times a point. */
    multiplyInversePoint3d(point, result) {
        return this._matrix.multiplyInverseXYZAsPoint3d(point.x - this._origin.x, point.y - this._origin.y, point.z - this._origin.z, result);
    }
    /**
     * *  for each point:   multiply    transform * point
     * *  if result is given, resize to match source and replace each corresponding pi
     * *  if result is not given, return a new array.
     */
    multiplyInversePoint3dArray(source, result) {
        if (!this._matrix.computeCachedInverse(true))
            return undefined;
        const originX = this.origin.x;
        const originY = this.origin.y;
        const originZ = this.origin.z;
        if (result) {
            const n = Transform.matchArrayLengths(source, result, Point3dVector3d_1.Point3d.createZero);
            for (let i = 0; i < n; i++)
                this._matrix.multiplyInverseXYZAsPoint3d(source[i].x - originX, source[i].y - originY, source[i].z - originZ, result[i]);
        }
        result = [];
        for (const p of source)
            result.push(this._matrix.multiplyInverseXYZAsPoint3d(p.x - originX, p.y - originY, p.z - originZ));
        return result;
    }
    /**
     * *  for each point in source:   multiply    transformInverse * point  in place inthe point.
     * * return false if not invertible.
     */
    multiplyInversePoint3dArrayInPlace(source) {
        if (!this._matrix.computeCachedInverse(true))
            return false;
        const originX = this.origin.x;
        const originY = this.origin.y;
        const originZ = this.origin.z;
        const n = source.length;
        for (let i = 0; i < n; i++)
            this._matrix.multiplyInverseXYZAsPoint3d(source[i].x - originX, source[i].y - originY, source[i].z - originZ, source[i]);
        return true;
    }
    // modify destination so it has non-null points for the same length as the source.
    // (ASSUME existing elements of dest are non-null, and that parameters are given as either Point2d or Point3d arrays)
    static matchArrayLengths(source, dest, constructionFunction) {
        const numSource = source.length;
        const numDest = dest.length;
        if (numSource > numDest) {
            for (let i = numDest; i < numSource; i++) {
                dest.push(constructionFunction());
            }
        }
        else if (numDest > numSource) {
            dest.length = numSource;
        }
        return numSource;
    }
    /**
     * *  for each point:   multiply    transform * point
     * *  if result is given, resize to match source and replace each corresponding pi
     * *  if result is not given, return a new array.
     */
    multiplyPoint2dArray(source, result) {
        if (result) {
            const n = Transform.matchArrayLengths(source, result, Point2dVector2d_1.Point2d.createZero);
            for (let i = 0; i < n; i++)
                Matrix3d_1.Matrix3d.XYPlusMatrixTimesXY(this._origin, this._matrix, source[i], result[i]);
            return result;
        }
        result = [];
        for (const p of source)
            result.push(Matrix3d_1.Matrix3d.XYPlusMatrixTimesXY(this._origin, this._matrix, p));
        return result;
    }
    /**
     * *  for each point:   multiply    transform * point
     * *  if result is given, resize to match source and replace each corresponding pi
     * *  if result is not given, return a new array.
     */
    multiplyPoint3dArray(source, result) {
        if (result) {
            const n = Transform.matchArrayLengths(source, result, Point3dVector3d_1.Point3d.createZero);
            for (let i = 0; i < n; i++)
                Matrix3d_1.Matrix3d.XYZPlusMatrixTimesXYZ(this._origin, this._matrix, source[i], result[i]);
            return result;
        }
        result = [];
        for (const p of source)
            result.push(Matrix3d_1.Matrix3d.XYZPlusMatrixTimesXYZ(this._origin, this._matrix, p));
        return result;
    }
    /** Multiply the vector by the Matrix3d part of the transform.
     *
     * *  The transform's origin is not used.
     * *  Return as new or result by usual optional result convention
     */
    multiplyVector(vector, result) {
        return this._matrix.multiplyVector(vector, result);
    }
    /** Multiply the vector (x,y,z) by the Matrix3d part of the transform.
     *
     * *  The transform's origin is not used.
     * *  Return as new or result by usual optional result convention
     */
    multiplyVectorXYZ(x, y, z, result) {
        return this._matrix.multiplyXYZ(x, y, z, result);
    }
    /** multiply this Transform times other Transform.
     * @param other right hand transform for multiplication.
     * @param result optional preallocated result to reuse.
     */
    multiplyTransformTransform(other, result) {
        if (!result)
            return Transform.createRefs(Matrix3d_1.Matrix3d.XYZPlusMatrixTimesXYZ(this._origin, this._matrix, other._origin), this._matrix.multiplyMatrixMatrix(other._matrix));
        result.setMultiplyTransformTransform(this, other);
        return result;
    }
    /**
     * multiply transformA * transformB, store to calling instance.
     * @param transformA left operand
     * @param transformB right operand
     */
    setMultiplyTransformTransform(transformA, transformB) {
        if (Transform._scratchPoint === undefined)
            Transform._scratchPoint = Point3dVector3d_1.Point3d.create();
        Matrix3d_1.Matrix3d.XYZPlusMatrixTimesXYZ(transformA._origin, transformA._matrix, transformB._origin, Transform._scratchPoint);
        this._origin.setFrom(Transform._scratchPoint);
        transformA._matrix.multiplyMatrixMatrix(transformB._matrix, this._matrix);
    }
    //   [Q A][R 0] = [QR A]
    //   [0 1][0 1]   [0  1]
    /** multiply this Transform times other Matrix3d, with other considered to be a Transform with 0 translation.
     * @param other right hand Matrix3d for multiplication.
     * @param result optional preallocated result to reuse.
     */
    multiplyTransformMatrix3d(other, result) {
        if (!result)
            return Transform.createRefs(this._origin.cloneAsPoint3d(), this._matrix.multiplyMatrixMatrix(other));
        this._matrix.multiplyMatrixMatrix(other, result._matrix);
        result._origin.setFrom(this._origin);
        return result;
    }
    /** transform each of the 8 corners of a range. Return the range of the transformed corers */
    multiplyRange(range, result) {
        // snag current values to allow aliasing.
        const lowx = range.low.x;
        const lowy = range.low.y;
        const lowz = range.low.z;
        const highx = range.high.x;
        const highy = range.high.y;
        const highz = range.high.z;
        result = Range_1.Range3d.createNull(result);
        result.extendTransformedXYZ(this, lowx, lowy, lowz);
        result.extendTransformedXYZ(this, highx, lowy, lowz);
        result.extendTransformedXYZ(this, lowx, highy, lowz);
        result.extendTransformedXYZ(this, highx, highy, lowz);
        result.extendTransformedXYZ(this, lowx, lowy, highz);
        result.extendTransformedXYZ(this, highx, lowy, highz);
        result.extendTransformedXYZ(this, lowx, highy, highz);
        result.extendTransformedXYZ(this, highx, highy, highz);
        return result;
    }
    /**
     * @returns Return a Transform which is the inverse of this transform. Return undefined if this Transform's matrix is singular.
     */
    inverse() {
        const matrixInverse = this._matrix.inverse();
        if (!matrixInverse)
            return undefined;
        return Transform.createRefs(matrixInverse.multiplyXYZ(-this._origin.x, -this._origin.y, -this._origin.z), matrixInverse);
    }
    /** Initialize transforms that map each direction of a box (axis aligned) to `[0,1]`.
     * @param min the "000" corner of the box
     * @param max the "111" corner of the box
     * @param npcToGlobal (object created by caller, re-initialized) transform that carries 01 coordinates into the min,max box.
     * @param globalToNpc (object created by caller, re-initialized) transform that carries world coordinates into 01
     */
    static initFromRange(min, max, npcToGlobal, globalToNpc) {
        const diag = max.minus(min);
        if (diag.x === 0.0)
            diag.x = 1.0;
        if (diag.y === 0.0)
            diag.y = 1.0;
        if (diag.z === 0.0)
            diag.z = 1.0;
        const rMatrix = new Matrix3d_1.Matrix3d();
        if (npcToGlobal) {
            Matrix3d_1.Matrix3d.createScale(diag.x, diag.y, diag.z, rMatrix);
            Transform.createOriginAndMatrix(min, rMatrix, npcToGlobal);
        }
        if (globalToNpc) {
            const origin = new Point3dVector3d_1.Point3d(-min.x / diag.x, -min.y / diag.y, -min.z / diag.z);
            Matrix3d_1.Matrix3d.createScale(1.0 / diag.x, 1.0 / diag.y, 1.0 / diag.z, rMatrix);
            Transform.createOriginAndMatrix(origin, rMatrix, globalToNpc);
        }
    }
}
exports.Transform = Transform;


/***/ }),

/***/ "./lib/geometry3d/YawPitchRollAngles.js":
/*!**********************************************!*\
  !*** ./lib/geometry3d/YawPitchRollAngles.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Angle_1 = __webpack_require__(/*! ./Angle */ "./lib/geometry3d/Angle.js");
const Matrix3d_1 = __webpack_require__(/*! ./Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ./Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
/** Three angles that determine the orientation of an object in space. Sometimes referred to as [Tait–Bryan angles](https://en.wikipedia.org/wiki/Euler_angles). */
class YawPitchRollAngles {
    constructor(yaw = Angle_1.Angle.zero(), pitch = Angle_1.Angle.zero(), roll = Angle_1.Angle.zero()) {
        this.yaw = yaw;
        this.pitch = pitch;
        this.roll = roll;
    }
    /** Freeze this YawPitchRollAngles */
    freeze() { Object.freeze(this.yaw); Object.freeze(this.pitch); Object.freeze(this.roll); }
    /** constructor for YawPitchRollAngles with angles in degrees. */
    static createDegrees(yawDegrees, pitchDegrees, rollDegrees) {
        return new YawPitchRollAngles(Angle_1.Angle.createDegrees(yawDegrees), Angle_1.Angle.createDegrees(pitchDegrees), Angle_1.Angle.createDegrees(rollDegrees));
    }
    /** constructor for YawPitchRollAngles with angles in radians. */
    static createRadians(yawRadians, pitchRadians, rollRadians) {
        return new YawPitchRollAngles(Angle_1.Angle.createRadians(yawRadians), Angle_1.Angle.createRadians(pitchRadians), Angle_1.Angle.createRadians(rollRadians));
    }
    static fromJSON(json) {
        json = json ? json : {};
        return new YawPitchRollAngles(Angle_1.Angle.fromJSON(json.yaw), Angle_1.Angle.fromJSON(json.pitch), Angle_1.Angle.fromJSON(json.roll));
    }
    setFromJSON(json) {
        json = json ? json : {};
        this.yaw = Angle_1.Angle.fromJSON(json.yaw);
        this.pitch = Angle_1.Angle.fromJSON(json.pitch);
        this.roll = Angle_1.Angle.fromJSON(json.roll);
    }
    /** Convert to a JSON object of form { pitch: 20 , roll: 29.999999999999996 , yaw: 10 }. Any values that are exactly zero (with tolerance `Geometry.smallAngleRadians`) are omitted. */
    toJSON() {
        const val = {};
        if (!this.pitch.isAlmostZero)
            val.pitch = this.pitch.toJSON();
        if (!this.roll.isAlmostZero)
            val.roll = this.roll.toJSON();
        if (!this.yaw.isAlmostZero)
            val.yaw = this.yaw.toJSON();
        return val;
    }
    /**
     * Install all rotations from `other` into `this`.
     * @param other YawPitchRollAngles source
     */
    setFrom(other) {
        this.yaw.setFrom(other.yaw);
        this.pitch.setFrom(other.pitch);
        this.roll.setFrom(other.roll);
    }
    /**
     * * Compare angles between `this` and `other`.
     * * Comparisons are via `isAlmostEqualAllowPeriodShift`.
     * @param other YawPitchRollAngles source
     */
    isAlmostEqual(other) {
        return this.yaw.isAlmostEqualAllowPeriodShift(other.yaw)
            && this.pitch.isAlmostEqualAllowPeriodShift(other.pitch)
            && this.roll.isAlmostEqualAllowPeriodShift(other.roll);
    }
    /**
     * Make a copy of this YawPitchRollAngles.
     */
    clone() { return new YawPitchRollAngles(this.yaw.clone(), this.pitch.clone(), this.roll.clone()); }
    /**
     * Expand the angles into a (rigid rotation) matrix.
     *
     * * The returned matrix is "rigid" -- unit length rows and columns, and its transpose is its inverse.
     * * The "rigid" matrix is always a right handed coordinate system.
     * @param result optional pre-allocated `Matrix3d`
     */
    toMatrix3d(result) {
        const c0 = Math.cos(this.yaw.radians);
        const s0 = Math.sin(this.yaw.radians);
        const c1 = Math.cos(this.pitch.radians);
        const s1 = Math.sin(this.pitch.radians);
        const c2 = Math.cos(this.roll.radians);
        const s2 = Math.sin(this.roll.radians);
        return Matrix3d_1.Matrix3d.createRowValues(c0 * c1, -(s0 * c2 + c0 * s1 * s2), (s0 * s2 - c0 * s1 * c2), s0 * c1, (c0 * c2 - s0 * s1 * s2), -(c0 * s2 + s0 * s1 * c2), s1, c1 * s2, c1 * c2, result);
    }
    /** @returns Return the largest angle in radians */
    maxAbsRadians() {
        return Geometry_1.Geometry.maxAbsXYZ(this.yaw.radians, this.pitch.radians, this.roll.radians);
    }
    /** Return the sum of the angles in squared radians */
    sumSquaredRadians() {
        return Geometry_1.Geometry.hypotenuseSquaredXYZ(this.yaw.radians, this.pitch.radians, this.roll.radians);
    }
    /** @returns true if the rotation is 0 */
    isIdentity(allowPeriodShift = true) {
        if (allowPeriodShift)
            return Angle_1.Angle.isAlmostEqualRadiansAllowPeriodShift(0.0, this.yaw.radians)
                && Angle_1.Angle.isAlmostEqualRadiansAllowPeriodShift(0.0, this.pitch.radians)
                && Angle_1.Angle.isAlmostEqualRadiansAllowPeriodShift(0.0, this.roll.radians);
        else
            return Angle_1.Angle.isAlmostEqualRadiansNoPeriodShift(0.0, this.yaw.radians)
                && Angle_1.Angle.isAlmostEqualRadiansNoPeriodShift(0.0, this.pitch.radians)
                && Angle_1.Angle.isAlmostEqualRadiansNoPeriodShift(0.0, this.roll.radians);
    }
    /** Return the largest difference of angles (in radians) between this and other */
    maxDiffRadians(other) {
        return Math.max(this.yaw.radians - other.yaw.radians, this.pitch.radians - other.pitch.radians, this.roll.radians - other.roll.radians);
    }
    /** Return the largest angle in degrees. */
    maxAbsDegrees() { return Geometry_1.Geometry.maxAbsXYZ(this.yaw.degrees, this.pitch.degrees, this.roll.degrees); }
    /** Return the sum of squared angles in degrees. */
    sumSquaredDegrees() { return Geometry_1.Geometry.hypotenuseSquaredXYZ(this.yaw.degrees, this.pitch.degrees, this.roll.degrees); }
    /** Return an object from a Transform as an origin and YawPitchRollAngles. */
    static tryFromTransform(transform) {
        // bundle up the transform's origin with the angle data extracted from the transform
        return {
            angles: YawPitchRollAngles.createFromMatrix3d(transform.matrix),
            origin: Point3dVector3d_1.Point3d.createFrom(transform.origin),
        };
    }
    /** Attempts to create a YawPitchRollAngles object from an Matrix3d
     * * This conversion fails if the matrix is not rigid (unit rows and columns, transpose is inverse)
     * * In the failure case the method's return value is `undefined`.
     * * In the failure case, if the optional result was supplied, that result will nonetheless be filled with a set of angles.
     */
    static createFromMatrix3d(matrix, result) {
        const s1 = matrix.at(2, 0);
        const c1 = Math.sqrt(matrix.at(2, 1) * matrix.at(2, 1) + matrix.at(2, 2) * matrix.at(2, 2));
        const pitchA = Angle_1.Angle.createAtan2(s1, c1); // with positive cosine
        const pitchB = Angle_1.Angle.createAtan2(s1, -c1); // with negative cosine
        const angles = result ? result : new YawPitchRollAngles(); // default undefined . . .
        if (c1 < Geometry_1.Geometry.smallAngleRadians) { // This is a radians test !!!
            angles.yaw = Angle_1.Angle.createAtan2(-matrix.at(0, 1), matrix.at(1, 1));
            angles.pitch = pitchA;
            angles.roll = Angle_1.Angle.createRadians(0.0);
        }
        else {
            const yawA = Angle_1.Angle.createAtan2(matrix.at(1, 0), matrix.at(0, 0));
            const rollA = Angle_1.Angle.createAtan2(matrix.at(2, 1), matrix.at(2, 2));
            const yawB = Angle_1.Angle.createAtan2(-matrix.at(1, 0), -matrix.at(0, 0));
            const rollB = Angle_1.Angle.createAtan2(-matrix.at(2, 1), -matrix.at(2, 2));
            const yprA = new YawPitchRollAngles(yawA, pitchA, rollA);
            const yprB = new YawPitchRollAngles(yawB, pitchB, rollB);
            const absFactor = 0.95;
            const radiansA = yprA.maxAbsRadians();
            const radiansB = yprB.maxAbsRadians();
            if (radiansA < absFactor * radiansB) {
                angles.setFrom(yprA);
            }
            else if (radiansB < absFactor * radiansA) {
                angles.setFrom(yprB);
            }
            else {
                const sumA = yprA.sumSquaredRadians();
                const sumB = yprB.sumSquaredRadians();
                if (sumA <= sumB) {
                    angles.setFrom(yprA);
                }
                else {
                    angles.setFrom(yprB);
                }
            }
        }
        const matrix1 = angles.toMatrix3d();
        return matrix.maxDiff(matrix1) < Geometry_1.Geometry.smallAngleRadians ? angles : undefined;
    }
}
exports.YawPitchRollAngles = YawPitchRollAngles;


/***/ }),

/***/ "./lib/geometry4d/Map4d.js":
/*!*********************************!*\
  !*** ./lib/geometry4d/Map4d.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const Matrix3d_1 = __webpack_require__(/*! ../geometry3d/Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const Matrix4d_1 = __webpack_require__(/*! ./Matrix4d */ "./lib/geometry4d/Matrix4d.js");
/** Map4 carries two Matrix4d which are inverses of each other.
 */
class Map4d {
    constructor(matrix0, matrix1) {
        this._matrix0 = matrix0;
        this._matrix1 = matrix1;
    }
    /** @returns Return a reference to (not copy of) the "forward" Matrix4d */
    get transform0() { return this._matrix0; }
    /** @returns Return a reference to (not copy of) the "reverse" Matrix4d */
    get transform1() { return this._matrix1; }
    /** Create a Map4d, capturing the references to the two matrices. */
    static createRefs(matrix0, matrix1) {
        return new Map4d(matrix0, matrix1);
    }
    /** Create an identity map. */
    static createIdentity() { return new Map4d(Matrix4d_1.Matrix4d.createIdentity(), Matrix4d_1.Matrix4d.createIdentity()); }
    /** Create a Map4d with given transform pair.
     * @returns undefined if the transforms are not inverses of each other.
     */
    static createTransform(transform0, transform1) {
        if (transform1 === undefined) {
            transform1 = transform0.inverse();
            if (transform1 === undefined)
                return undefined;
        }
        else {
            const product = transform0.multiplyTransformTransform(transform1);
            if (!product.isIdentity)
                return undefined;
        }
        return new Map4d(Matrix4d_1.Matrix4d.createTransform(transform0), Matrix4d_1.Matrix4d.createTransform(transform1));
    }
    /**
     * Create a mapping the scales and translates (no rotation) between boxes.
     * @param lowA low point of box A
     * @param highA high point of box A
     * @param lowB low point of box B
     * @param highB high point of box B
     */
    static createBoxMap(lowA, highA, lowB, highB, result) {
        const t0 = Matrix4d_1.Matrix4d.createBoxToBox(lowA, highA, lowB, highB, result ? result.transform0 : undefined);
        const t1 = Matrix4d_1.Matrix4d.createBoxToBox(lowB, highB, lowA, highA, result ? result.transform1 : undefined);
        if (t0 && t1) {
            if (result)
                return result;
            return new Map4d(t0, t1);
        }
        return undefined;
    }
    /** Copy contents from another Map4d */
    setFrom(other) { this._matrix0.setFrom(other._matrix0), this._matrix1.setFrom(other._matrix1); }
    /** @returns Return a clone of this Map4d */
    clone() { return new Map4d(this._matrix0.clone(), this._matrix1.clone()); }
    /** Reinitialize this Map4d as an identity. */
    setIdentity() { this._matrix0.setIdentity(); this._matrix1.setIdentity(); }
    /** Set this map4d from a json object that the two Matrix4d values as properties named matrix0 and matrix1 */
    setFromJSON(json) {
        if (json.matrix0 && json.matrix1) {
            this._matrix0.setFromJSON(json.matrix0);
            this._matrix1.setFromJSON(json.matrix1);
        }
        else
            this.setIdentity();
    }
    /** Create a map4d from a json object that the two Matrix4d values as properties named matrix0 and matrix1 */
    static fromJSON(json) {
        const result = new Map4d(Matrix4d_1.Matrix4d.createIdentity(), Matrix4d_1.Matrix4d.createIdentity());
        result.setFromJSON(json);
        return result;
    }
    /** @returns a json object `{matrix0: value0, matrix1: value1}` */
    toJSON() { return { matrix0: this._matrix0.toJSON(), matrix1: this._matrix1.toJSON() }; }
    isAlmostEqual(other) {
        return this._matrix0.isAlmostEqual(other._matrix0) && this._matrix1.isAlmostEqual(other._matrix1);
    }
    /** Create a map between a frustum and world coordinates.
     * @param origin lower left of frustum
     * @param uVector Vector from lower left rear to lower right rear
     * @param vVector Vector from lower left rear to upper left rear
     * @param wVector Vector from lower left rear to lower left front, i.e. lower left rear towards eye.
     * @param fraction front size divided by rear size.
     */
    static createVectorFrustum(origin, uVector, vVector, wVector, fraction) {
        fraction = Math.max(fraction, 1.0e-8);
        const slabToWorld = Transform_1.Transform.createOriginAndMatrix(origin, Matrix3d_1.Matrix3d.createColumns(uVector, vVector, wVector));
        const worldToSlab = slabToWorld.inverse();
        if (!worldToSlab)
            return undefined;
        const worldToSlabMap = new Map4d(Matrix4d_1.Matrix4d.createTransform(worldToSlab), Matrix4d_1.Matrix4d.createTransform(slabToWorld));
        const slabToNPCMap = new Map4d(Matrix4d_1.Matrix4d.createRowValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, fraction, 0, 0, 0, fraction - 1.0, 1), Matrix4d_1.Matrix4d.createRowValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1.0 / fraction, 0, 0, 0, (1.0 - fraction) / fraction, 1));
        const result = slabToNPCMap.multiplyMapMap(worldToSlabMap);
        /*
        let numIdentity = 0;
        const productA = worldToSlabMap.matrix0.multiplyMatrixMatrix(worldToSlabMap.matrix1);
        if (productA.isIdentity())
          numIdentity++;
        const productB = slabToNPCMap.matrix0.multiplyMatrixMatrix(slabToNPCMap.matrix1);
        if (productB.isIdentity())
          numIdentity++;
        const product = result.matrix0.multiplyMatrixMatrix(result.matrix1);
        if (product.isIdentity())
          numIdentity++;
        if (numIdentity === 3)
            return result;
          */
        return result;
    }
    multiplyMapMap(other) {
        return new Map4d(this._matrix0.multiplyMatrixMatrix(other._matrix0), other._matrix1.multiplyMatrixMatrix(this._matrix1));
    }
    reverseInPlace() {
        const temp = this._matrix0;
        this._matrix0 = this._matrix1;
        this._matrix1 = temp;
    }
    /** return a Map4d whose transform0 is
     * other.transform0 * this.transform0 * other.transform1
     */
    sandwich0This1(other) {
        return new Map4d(other._matrix0.multiplyMatrixMatrix(this._matrix0.multiplyMatrixMatrix(other._matrix1)), other._matrix0.multiplyMatrixMatrix(this._matrix1.multiplyMatrixMatrix(other._matrix1)));
    }
    /** return a Map4d whose transform0 is
     * other.transform1 * this.transform0 * other.transform0
     */
    sandwich1This0(other) {
        return new Map4d(other._matrix1.multiplyMatrixMatrix(this._matrix0.multiplyMatrixMatrix(other._matrix0)), other._matrix1.multiplyMatrixMatrix(this._matrix1.multiplyMatrixMatrix(other._matrix0)));
    }
} // Map4d
exports.Map4d = Map4d;


/***/ }),

/***/ "./lib/geometry4d/Matrix4d.js":
/*!************************************!*\
  !*** ./lib/geometry4d/Matrix4d.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Numerics */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const Matrix3d_1 = __webpack_require__(/*! ../geometry3d/Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const Point4d_1 = __webpack_require__(/*! ./Point4d */ "./lib/geometry4d/Point4d.js");
/**
 * * A Matrix4d is a matrix with 4 rows and 4 columns.
 * * The 4 rows may be described as the x,y,z,w rows.
 * * The 4 columns may be described as the x,y,z,w columns.
 * * The matrix is physically stored as a FLoat64Array with 16 numbers.
 * * The layout in the Float64Array is "by row"
 * * * indices 0,1,2,3 are the "x row".   They may be called the xx,xy,xz,xw entries
 * * * indices 4,5,6,7 are the "y row"    They may be called the yx,yy,yz,yw entries
 * * * indices 8,9,10,11 are the "z row"  They may be called the zx,zy,zz,zw entries
 * * * indices 12,13,14,15 are the "w row".  They may be called the wx,wy,wz,ww entries
 * * If "w row" contains numeric values 0,0,0,1, the Matrix4d is equivalent to a Transform with
 * * * The upper right 3x3 matrix (entries 0,1,2,4,5,6,8,9,10) are the 3x3 matrix part of the transform
 * * * The far right column entries xw,yw,zw are the "origin" (sometimes called "translation") part of the transform.
 */
class Matrix4d {
    constructor() { this._coffs = new Float64Array(16); }
    setFrom(other) {
        for (let i = 0; i < 16; i++)
            this._coffs[i] = other._coffs[i];
    }
    clone() {
        const result = new Matrix4d();
        for (let i = 0; i < 16; i++)
            result._coffs[i] = this._coffs[i];
        return result;
    }
    /** zero this matrix4d in place. */
    setZero() {
        for (let i = 0; i < 16; i++)
            this._coffs[i] = 0;
    }
    /** set to identity. */
    setIdentity() {
        for (let i = 0; i < 16; i++)
            this._coffs[i] = 0;
        this._coffs[0] = this._coffs[5] = this._coffs[10] = this._coffs[15] = 1.0;
    }
    static is1000(a, b, c, d, tol) {
        return Math.abs(a - 1.0) <= tol
            && Math.abs(b) <= tol
            && Math.abs(c) <= tol
            && Math.abs(d) <= tol;
    }
    /** set to identity. */
    isIdentity(tol = 1.0e-10) {
        return Matrix4d.is1000(this._coffs[0], this._coffs[1], this._coffs[2], this._coffs[3], tol)
            && Matrix4d.is1000(this._coffs[5], this._coffs[6], this._coffs[7], this._coffs[4], tol)
            && Matrix4d.is1000(this._coffs[10], this._coffs[11], this._coffs[8], this._coffs[9], tol)
            && Matrix4d.is1000(this._coffs[15], this._coffs[12], this._coffs[13], this._coffs[14], tol);
    }
    /** create a Matrix4d filled with zeros. */
    static createZero(result) {
        if (result) {
            result.setZero();
            return result;
        }
        return new Matrix4d(); // this is zero.
    }
    /** create a Matrix4d with values supplied "across the rows" */
    static createRowValues(cxx, cxy, cxz, cxw, cyx, cyy, cyz, cyw, czx, czy, czz, czw, cwx, cwy, cwz, cww, result) {
        result = result ? result : new Matrix4d();
        result._coffs[0] = cxx;
        result._coffs[1] = cxy;
        result._coffs[2] = cxz;
        result._coffs[3] = cxw;
        result._coffs[4] = cyx;
        result._coffs[5] = cyy;
        result._coffs[6] = cyz;
        result._coffs[7] = cyw;
        result._coffs[8] = czx;
        result._coffs[9] = czy;
        result._coffs[10] = czz;
        result._coffs[11] = czw;
        result._coffs[12] = cwx;
        result._coffs[13] = cwy;
        result._coffs[14] = cwz;
        result._coffs[15] = cww;
        return result;
    }
    /** directly set columns from typical 3d data:
     *
     * * vectorX, vectorY, vectorZ as columns 0,1,2, with weight0.
     * * origin as column3, with weight 1
     */
    setOriginAndVectors(origin, vectorX, vectorY, vectorZ) {
        this._coffs[0] = vectorX.x;
        this._coffs[1] = vectorY.x;
        this._coffs[2] = vectorZ.x;
        this._coffs[3] = origin.x;
        this._coffs[4] = vectorX.y;
        this._coffs[5] = vectorY.y;
        this._coffs[6] = vectorZ.y;
        this._coffs[7] = origin.y;
        this._coffs[8] = vectorX.z;
        this._coffs[9] = vectorY.z;
        this._coffs[10] = vectorZ.z;
        this._coffs[11] = origin.z;
        this._coffs[12] = 0.0;
        this._coffs[13] = 0.0;
        this._coffs[14] = 0.0;
        this._coffs[15] = 1.0;
    }
    /** promote a transform to full Matrix4d (with 0001 in final row) */
    static createTransform(source, result) {
        const matrix = source.matrix;
        const point = source.origin;
        return Matrix4d.createRowValues(matrix.coffs[0], matrix.coffs[1], matrix.coffs[2], point.x, matrix.coffs[3], matrix.coffs[4], matrix.coffs[5], point.y, matrix.coffs[6], matrix.coffs[7], matrix.coffs[8], point.z, 0, 0, 0, 1, result);
    }
    /** return an identity matrix. */
    static createIdentity(result) {
        result = Matrix4d.createZero(result);
        result._coffs[0] = 1.0;
        result._coffs[5] = 1.0;
        result._coffs[10] = 1.0;
        result._coffs[15] = 1.0;
        return result;
    }
    /** return matrix with translation directly inserted (along with 1 on diagonal) */
    static createTranslationXYZ(x, y, z, result) {
        result = Matrix4d.createZero(result);
        result._coffs[0] = 1.0;
        result._coffs[5] = 1.0;
        result._coffs[10] = 1.0;
        result._coffs[15] = 1.0;
        result._coffs[3] = x;
        result._coffs[7] = y;
        result._coffs[11] = z;
        return result;
    }
    /**
     * Create a Matrix4d with translation and scaling values directly inserted (along with 1 as final diagonal entry)
     * @param tx x entry for translation column
     * @param ty y entry for translation column
     * @param tz z entry for translation column
     * @param scaleX x diagonal entry
     * @param scaleY y diagonal entry
     * @param scaleZ z diagonal entry
     * @param result optional result.
     */
    static createTranslationAndScaleXYZ(tx, ty, tz, scaleX, scaleY, scaleZ, result) {
        return Matrix4d.createRowValues(scaleX, 0, 0, tx, 0, scaleY, 0, ty, 0, 0, scaleZ, tz, 0, 0, 0, 1, result);
    }
    /**
     * Create a mapping the scales and translates (no rotation) from box A to boxB
     * @param lowA low point of box A
     * @param highA high point of box A
     * @param lowB low point of box B
     * @param highB high point of box B
     */
    static createBoxToBox(lowA, highA, lowB, highB, result) {
        const ax = highA.x - lowA.x;
        const ay = highA.y - lowA.y;
        const az = highA.z - lowA.z;
        const bx = highB.x - lowB.x;
        const by = highB.y - lowB.y;
        const bz = highB.z - lowB.z;
        const abx = Geometry_1.Geometry.conditionalDivideFraction(bx, ax);
        const aby = Geometry_1.Geometry.conditionalDivideFraction(by, ay);
        const abz = Geometry_1.Geometry.conditionalDivideFraction(bz, az);
        if (abx !== undefined && aby !== undefined && abz !== undefined) {
            return Matrix4d.createTranslationAndScaleXYZ(lowB.x - abx * lowA.x, lowB.y - aby * lowA.y, lowB.z - abz * lowA.z, abx, aby, abz, result);
        }
        return undefined;
    }
    setFromJSON(json) {
        if (Geometry_1.Geometry.isArrayOfNumberArray(json, 4, 4))
            for (let i = 0; i < 4; ++i) {
                for (let j = 0; j < 4; ++j)
                    this._coffs[i * 4 + j] = json[i][j];
            }
        else
            this.setZero();
    }
    /**
     * Return the largest (absolute) difference between this and other Matrix4d.
     * @param other matrix to compare to
     */
    maxDiff(other) {
        let a = 0.0;
        for (let i = 0; i < 16; i++)
            a = Math.max(a, Math.abs(this._coffs[i] - other._coffs[i]));
        return a;
    }
    /**
     * Return the largest absolute value in the Matrix4d
     */
    maxAbs() {
        let a = 0.0;
        for (let i = 0; i < 16; i++)
            a = Math.max(a, Math.abs(this._coffs[i]));
        return a;
    }
    isAlmostEqual(other) {
        return Geometry_1.Geometry.isSmallMetricDistance(this.maxDiff(other));
    }
    /**
     * Convert an Matrix4d to a Matrix4dProps.
     */
    toJSON() {
        const value = [];
        for (let i = 0; i < 4; ++i) {
            const row = i * 4;
            value.push([this._coffs[row], this._coffs[row + 1], this._coffs[row + 2], this._coffs[row + 3]]);
        }
        return value;
    }
    static fromJSON(json) {
        const result = new Matrix4d();
        result.setFromJSON(json);
        return result;
    }
    /**
     * Return a point with entries from positions [i0, i0+step, i0+2*step, i0+3*step].
     * * There are no tests for index going out of the 0..15 range.
     * * Usual uses are:
     * * * i0 at left of row (0,4,8,12), step = 1 to extract a row.
     * * * i0 at top of row (0,1,2,3), step = 4 to extract a column
     * * * i0 = 0, step = 5 to extract the diagonal
     * @returns a Point4d with 4 entries taken from positions at steps in the flat 16-member array.
     * @param i0 start index (for 16 member array)
     * @param step step between members
     * @param result optional preallocated point.
     */
    getSteppedPoint(i0, step, result) {
        return Point4d_1.Point4d.create(this._coffs[i0], this._coffs[i0 + step], this._coffs[i0 + 2 * step], this._coffs[i0 + 3 * step], result);
    }
    /** @returns Return column 0 as Point4d. */
    columnX() { return this.getSteppedPoint(0, 4); }
    /** @returns Return column 1 as Point4d. */
    columnY() { return this.getSteppedPoint(1, 4); }
    /** @returns Return column 2 as Point4d. */
    columnZ() { return this.getSteppedPoint(2, 4); }
    /** @returns Return column 3 as Point4d. */
    columnW() { return this.getSteppedPoint(3, 4); }
    /** @returns Return row 0 as Point4d. */
    rowX() { return this.getSteppedPoint(0, 1); }
    /** @returns Return row 1 as Point4d. */
    rowY() { return this.getSteppedPoint(4, 1); }
    /** @returns Return row 2 as Point4d. */
    rowZ() { return this.getSteppedPoint(8, 1); }
    /** @returns Return row 3 as Point4d. */
    rowW() { return this.getSteppedPoint(12, 1); }
    /**
     * @returns true if the 2 row has content other than [0,0,0,1]
     */
    get hasPerspective() {
        return this._coffs[12] !== 0.0
            || this._coffs[13] !== 0.0
            || this._coffs[14] !== 0.0
            || this._coffs[15] !== 1.0;
    }
    /**
     * Return a Point4d with the diagonal entries of the matrix
     */
    diagonal() { return this.getSteppedPoint(0, 5); }
    /** return the weight component of this matrix */
    weight() { return this._coffs[15]; }
    /** return the leading 3x3 matrix part of this matrix */
    matrixPart() {
        return Matrix3d_1.Matrix3d.createRowValues(this._coffs[0], this._coffs[1], this._coffs[2], this._coffs[4], this._coffs[5], this._coffs[6], this._coffs[8], this._coffs[9], this._coffs[10]);
    }
    /**
     * Return the (affine, non-perspective) Transform with the upper 3 rows of this matrix
     * @return undefined if this Matrix4d has perspective effects in the w row.
     */
    get asTransform() {
        if (this.hasPerspective)
            return undefined;
        return Transform_1.Transform.createRowValues(this._coffs[0], this._coffs[1], this._coffs[2], this._coffs[3], this._coffs[4], this._coffs[5], this._coffs[6], this._coffs[7], this._coffs[8], this._coffs[9], this._coffs[10], this._coffs[11]);
    }
    /** multiply this * other. */
    multiplyMatrixMatrix(other, result) {
        result = (result && result !== this && result !== other) ? result : new Matrix4d();
        for (let i0 = 0; i0 < 16; i0 += 4) {
            for (let k = 0; k < 4; k++)
                result._coffs[i0 + k] =
                    this._coffs[i0] * other._coffs[k] +
                        this._coffs[i0 + 1] * other._coffs[k + 4] +
                        this._coffs[i0 + 2] * other._coffs[k + 8] +
                        this._coffs[i0 + 3] * other._coffs[k + 12];
        }
        return result;
    }
    /** multiply this * transpose(other). */
    multiplyMatrixMatrixTranspose(other, result) {
        result = (result && result !== this && result !== other) ? result : new Matrix4d();
        let j = 0;
        for (let i0 = 0; i0 < 16; i0 += 4) {
            for (let k = 0; k < 16; k += 4)
                result._coffs[j++] =
                    this._coffs[i0] * other._coffs[k] +
                        this._coffs[i0 + 1] * other._coffs[k + 1] +
                        this._coffs[i0 + 2] * other._coffs[k + 2] +
                        this._coffs[i0 + 3] * other._coffs[k + 3];
        }
        return result;
    }
    /** multiply transpose (this) * other. */
    multiplyMatrixTransposeMatrix(other, result) {
        result = (result && result !== this && result !== other) ? result : new Matrix4d();
        let j = 0;
        for (let i0 = 0; i0 < 4; i0 += 1) {
            for (let k0 = 0; k0 < 4; k0 += 1)
                result._coffs[j++] =
                    this._coffs[i0] * other._coffs[k0] +
                        this._coffs[i0 + 4] * other._coffs[k0 + 4] +
                        this._coffs[i0 + 8] * other._coffs[k0 + 8] +
                        this._coffs[i0 + 12] * other._coffs[k0 + 12];
        }
        return result;
    }
    /** Return a transposed matrix. */
    cloneTransposed(result) {
        return Matrix4d.createRowValues(this._coffs[0], this._coffs[4], this._coffs[8], this._coffs[12], this._coffs[1], this._coffs[5], this._coffs[9], this._coffs[13], this._coffs[2], this._coffs[6], this._coffs[10], this._coffs[14], this._coffs[3], this._coffs[7], this._coffs[11], this._coffs[15], result);
    }
    /** multiply matrix times column [x,y,z,w].  return as Point4d.   (And the returned value is NOT normalized down to unit w) */
    multiplyXYZW(x, y, z, w, result) {
        result = result ? result : Point4d_1.Point4d.createZero();
        return result.set(this._coffs[0] * x + this._coffs[1] * y + this._coffs[2] * z + this._coffs[3] * w, this._coffs[4] * x + this._coffs[5] * y + this._coffs[6] * z + this._coffs[7] * w, this._coffs[8] * x + this._coffs[9] * y + this._coffs[10] * z + this._coffs[11] * w, this._coffs[12] * x + this._coffs[13] * y + this._coffs[14] * z + this._coffs[15] * w);
    }
    /** multiply matrix times column vectors [x,y,z,w] where [x,y,z,w] appear in blocks in an array.
     * replace the xyzw in the block
     */
    multiplyBlockedFloat64ArrayInPlace(data) {
        const n = data.length;
        let x, y, z, w;
        for (let i = 0; i + 3 < n; i += 4) {
            x = data[i];
            y = data[i + 1];
            z = data[i + 2];
            w = data[i + 3];
            data[i] = this._coffs[0] * x + this._coffs[1] * y + this._coffs[2] * z + this._coffs[3] * w;
            data[i + 1] = this._coffs[4] * x + this._coffs[5] * y + this._coffs[6] * z + this._coffs[7] * w;
            data[i + 2] = this._coffs[8] * x + this._coffs[9] * y + this._coffs[10] * z + this._coffs[11] * w;
            data[i + 3] = this._coffs[12] * x + this._coffs[13] * y + this._coffs[14] * z + this._coffs[15] * w;
        }
    }
    /** multiply matrix times XYAndZ  and w. return as Point4d  (And the returned value is NOT normalized down to unit w) */
    multiplyPoint3d(pt, w, result) {
        return this.multiplyXYZW(pt.x, pt.y, pt.z, w, result);
    }
    /** multiply matrix times and array  of XYAndZ. return as array of Point4d  (And the returned value is NOT normalized down to unit w) */
    multiplyPoint3dArray(pts, results, w = 1.0) {
        pts.forEach((pt, i) => { results[i] = this.multiplyXYZW(pt.x, pt.y, pt.z, w, results[i]); });
    }
    /** multiply [x,y,z,w] times matrix.  return as Point4d.   (And the returned value is NOT normalized down to unit w) */
    multiplyTransposeXYZW(x, y, z, w, result) {
        result = result ? result : Point4d_1.Point4d.createZero();
        return result.set(this._coffs[0] * x + this._coffs[4] * y + this._coffs[8] * z + this._coffs[12] * w, this._coffs[1] * x + this._coffs[5] * y + this._coffs[9] * z + this._coffs[13] * w, this._coffs[2] * x + this._coffs[6] * y + this._coffs[10] * z + this._coffs[14] * w, this._coffs[3] * x + this._coffs[7] * y + this._coffs[11] * z + this._coffs[15] * w);
    }
    /** @returns dot product of row rowIndex of this with column columnIndex of other.
     */
    rowDotColumn(rowIndex, other, columnIndex) {
        const i = rowIndex * 4;
        const j = columnIndex;
        return this._coffs[i] * other._coffs[j]
            + this._coffs[i + 1] * other._coffs[j + 4]
            + this._coffs[i + 2] * other._coffs[j + 8]
            + this._coffs[i + 3] * other._coffs[j + 12];
    }
    /** @returns dot product of row rowIndexThis of this with row rowIndexOther of other.
     */
    rowDotRow(rowIndexThis, other, rowIndexOther) {
        const i = rowIndexThis * 4;
        const j = rowIndexOther * 4;
        return this._coffs[i] * other._coffs[j]
            + this._coffs[i + 1] * other._coffs[j + 1]
            + this._coffs[i + 2] * other._coffs[j + 2]
            + this._coffs[i + 3] * other._coffs[j + 3];
    }
    /** @returns dot product of row rowIndexThis of this with row rowIndexOther of other.
     */
    columnDotColumn(columnIndexThis, other, columnIndexOther) {
        const i = columnIndexThis;
        const j = columnIndexOther;
        return this._coffs[i] * other._coffs[j]
            + this._coffs[i + 4] * other._coffs[j + 4]
            + this._coffs[i + 8] * other._coffs[j + 8]
            + this._coffs[i + 12] * other._coffs[j + 12];
    }
    /** @returns dot product of column columnIndexThis of this with row rowIndexOther other.
     */
    columnDotRow(columnIndexThis, other, rowIndexOther) {
        const i = columnIndexThis;
        const j = 4 * rowIndexOther;
        return this._coffs[i] * other._coffs[j]
            + this._coffs[i + 4] * other._coffs[j + 1]
            + this._coffs[i + 8] * other._coffs[j + 2]
            + this._coffs[i + 12] * other._coffs[j + 3];
    }
    /** @returns return a matrix entry by row and column index.
     */
    atIJ(rowIndex, columnIndex) {
        return this._coffs[rowIndex * 4 + columnIndex];
    }
    /** multiply matrix * [x,y,z,w]. immediately renormalize to return in a Point3d.
     * If zero weight appears in the result (i.e. input is on eyeplane) leave the mapped xyz untouched.
     */
    multiplyXYZWQuietRenormalize(x, y, z, w, result) {
        result = result ? result : Point3dVector3d_1.Point3d.createZero();
        result.set(this._coffs[0] * x + this._coffs[1] * y + this._coffs[2] * z + this._coffs[3] * w, this._coffs[4] * x + this._coffs[5] * y + this._coffs[6] * z + this._coffs[7] * w, this._coffs[8] * x + this._coffs[9] * y + this._coffs[10] * z + this._coffs[11] * w);
        const w1 = this._coffs[12] * x + this._coffs[13] * y + this._coffs[14] * z + this._coffs[15] * w;
        if (!Geometry_1.Geometry.isSmallMetricDistance(w1)) {
            const a = 1.0 / w1;
            result.x *= a;
            result.y *= a;
            result.z *= a;
        }
        return result;
    }
    /** multiply matrix * an array of Point4d. immediately renormalize to return in an array of Point3d. */
    multiplyPoint4dArrayQuietRenormalize(pts, results) {
        pts.forEach((pt, i) => { results[i] = this.multiplyXYZWQuietRenormalize(pt.x, pt.y, pt.z, pt.w, results[i]); });
    }
    /** multiply a Point4d, return with the optional result convention. */
    multiplyPoint4d(point, result) {
        return this.multiplyXYZW(point.xyzw[0], point.xyzw[1], point.xyzw[2], point.xyzw[3], result);
    }
    /** multiply a Point4d, return with the optional result convention. */
    multiplyTransposePoint4d(point, result) {
        return this.multiplyTransposeXYZW(point.xyzw[0], point.xyzw[1], point.xyzw[2], point.xyzw[3], result);
    }
    /** multiply matrix * point. This produces a weighted xyzw.
     * Immediately renormalize back to xyz and return (with optional result convention).
     * If zero weight appears in the result (i.e. input is on eyeplane)leave the mapped xyz untouched.
     */
    multiplyPoint3dQuietNormalize(point, result) {
        return this.multiplyXYZWQuietRenormalize(point.x, point.y, point.z, 1.0, result);
    }
    /** multiply each matrix * points[i].   This produces a weighted xyzw.
     * Immediately renormalize back to xyz and replace the original point.
     * If zero weight appears in the result (i.e. input is on eyeplane)leave the mapped xyz untouched.
     */
    multiplyPoint3dArrayQuietNormalize(points) {
        points.forEach((point) => this.multiplyXYZWQuietRenormalize(point.x, point.y, point.z, 1.0, point));
    }
    /**
     * Add the product terms [xx,xy,xz,xw, yx, yy, yz, yw, zx, zy, zz, zs, wx, wy, wz, ww] to respective entries in the matrix
     * @param x x component for products
     * @param y y component for products
     * @param z z component for products
     * @param w w component for products
     */
    addMomentsInPlace(x, y, z, w) {
        this._coffs[0] += x * x;
        this._coffs[1] += x * y;
        this._coffs[2] += x * z;
        this._coffs[3] += x * w;
        this._coffs[4] += y * x;
        this._coffs[5] += y * y;
        this._coffs[6] += y * z;
        this._coffs[7] += y * w;
        this._coffs[8] += z * x;
        this._coffs[9] += z * y;
        this._coffs[10] += z * z;
        this._coffs[11] += z * w;
        this._coffs[12] += w * x;
        this._coffs[13] += w * y;
        this._coffs[14] += w * z;
        this._coffs[15] += w * w;
    }
    /** accumulate all coefficients of other to this. */
    addScaledInPlace(other, scale = 1.0) {
        for (let i = 0; i < 16; i++)
            this._coffs[i] += scale * other._coffs[i];
    }
    /**
     * Add scale times rowA to rowB.
     * @param rowIndexA row that is not modified
     * @param rowIndexB row that is modified.
     * @param firstColumnIndex first column modified.  All from there to the right are updated
     * @param scale scale
     */
    rowOperation(rowIndexA, rowIndexB, firstColumnIndex, scale) {
        if (scale === 0.0)
            return;
        let iA = rowIndexA * 4 + firstColumnIndex;
        let iB = rowIndexB * 4 + firstColumnIndex;
        for (let i = firstColumnIndex; i < 4; i++, iA++, iB++)
            this._coffs[iB] += scale * this._coffs[iA];
    }
    /** Compute an inverse matrix.
     * * This uses simple Bauss-Jordan elimination -- no pivot.
     * @returns undefined if 1/pivot becomes too large. (i.e. apparent 0 pivot)
     */
    createInverse() {
        const work = this.clone();
        const inverse = Matrix4d.createIdentity();
        // console.log(work.rowArrays());
        // console.log(inverse.rowArrays());
        let pivotIndex;
        let pivotRow;
        let pivotValue;
        let divPivot;
        // Downward gaussian elimination, no pivoting:
        for (pivotRow = 0; pivotRow < 3; pivotRow++) {
            pivotIndex = pivotRow * 5;
            pivotValue = work._coffs[pivotIndex];
            // console.log("** pivot row " + pivotRow + " pivotvalue " + pivotValue);
            divPivot = Geometry_1.Geometry.conditionalDivideFraction(1.0, pivotValue);
            if (divPivot === undefined)
                return undefined;
            let indexB = pivotIndex + 4;
            for (let rowB = pivotRow + 1; rowB < 4; rowB++, indexB += 4) {
                const scale = -work._coffs[indexB] * divPivot;
                work.rowOperation(pivotRow, rowB, pivotRow, scale);
                inverse.rowOperation(pivotRow, rowB, 0, scale);
                // console.log(work.rowArrays());
                // console.log(inverse.rowArrays());
            }
        }
        // console.log("\n**********************Backsub\n");
        // upward gaussian elimination ...
        for (pivotRow = 1; pivotRow < 4; pivotRow++) {
            pivotIndex = pivotRow * 5;
            pivotValue = work._coffs[pivotIndex];
            // console.log("** pivot row " + pivotRow + " pivotvalue " + pivotValue);
            divPivot = Geometry_1.Geometry.conditionalDivideFraction(1.0, pivotValue);
            if (divPivot === undefined)
                return undefined;
            let indexB = pivotRow;
            for (let rowB = 0; rowB < pivotRow; rowB++, indexB += 4) {
                const scale = -work._coffs[indexB] * divPivot;
                work.rowOperation(pivotRow, rowB, pivotRow, scale);
                inverse.rowOperation(pivotRow, rowB, 0, scale);
                // console.log("Eliminate Row " + rowB + " from pivot " + pivotRow);
                // console.log(work.rowArrays());
                // console.log(inverse.rowArrays());
            }
        }
        // divide through by pivots (all have  beeen confirmed nonzero)
        inverse.scaleRowsInPlace(1.0 / work._coffs[0], 1.0 / work._coffs[5], 1.0 / work._coffs[10], 1.0 / work._coffs[15]);
        // console.log("descaled", inverse.rowArrays());
        return inverse;
    }
    /** @returns Restructure the matrix rows as separate arrays. (Useful for printing)
     * @param f optional function to provide alternate values for each entry (e.g. force fuzz to zero.)
     */
    rowArrays(f) {
        if (f)
            return [
                [f(this._coffs[0]), f(this._coffs[1]), f(this._coffs[2]), f(this._coffs[3])],
                [f(this._coffs[4]), f(this._coffs[5]), f(this._coffs[6]), f(this._coffs[7])],
                [f(this._coffs[8]), f(this._coffs[9]), f(this._coffs[10]), f(this._coffs[11])],
                [f(this._coffs[12]), f(this._coffs[13]), f(this._coffs[14]), f(this._coffs[15])]
            ];
        else
            return [
                [this._coffs[0], this._coffs[1], this._coffs[2], this._coffs[3]],
                [this._coffs[4], this._coffs[5], this._coffs[6], this._coffs[7]],
                [this._coffs[8], this._coffs[9], this._coffs[10], this._coffs[11]],
                [this._coffs[12], this._coffs[13], this._coffs[14], this._coffs[15]]
            ];
    }
    /**
     * Scale each row by respective scale factors.
     * @param ax scale factor for row 0
     * @param ay scale factor for row 1
     * @param az scale factor for row 2
     * @param aw scale factor for row 3
     */
    scaleRowsInPlace(ax, ay, az, aw) {
        for (let i = 0; i < 4; i++)
            this._coffs[i] *= ax;
        for (let i = 4; i < 8; i++)
            this._coffs[i] *= ay;
        for (let i = 8; i < 12; i++)
            this._coffs[i] *= az;
        for (let i = 12; i < 16; i++)
            this._coffs[i] *= aw;
    }
}
exports.Matrix4d = Matrix4d;


/***/ }),

/***/ "./lib/geometry4d/MomentData.js":
/*!**************************************!*\
  !*** ./lib/geometry4d/MomentData.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Numerics */
// import { Point2d } from "./Geometry2d";
/* tslint:disable:variable-name jsdoc-format no-empty no-console*/
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const Matrix3d_1 = __webpack_require__(/*! ../geometry3d/Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const Matrix4d_1 = __webpack_require__(/*! ./Matrix4d */ "./lib/geometry4d/Matrix4d.js");
/**
 * A MomentData structrue carries data used in calculation of moments of inertia.
 * * origin = local origin used as moments are summed.
 * * sums = array of summed moments.
 *   * The [i,j] entry of the sums is a summed or integrated moment for product of axis i and j.
 *      * axes 0,1,2 are x,y,z
 *         * e.g. entry [0,1] is summed product xy
 *      * axis 3 is "w", which is 1 in sums.
 *         * e.g. entry 03 is summed x
 */
class MomentData {
    constructor() {
        this.origin = Point3dVector3d_1.Point3d.createZero();
        this.sums = Matrix4d_1.Matrix4d.createZero();
        this.localToWorldMap = Transform_1.Transform.createIdentity();
        this.radiusOfGyration = Point3dVector3d_1.Vector3d.create();
    }
    static momentTensorFromInertiaProducts(products) {
        const rr = products.sumDiagonal();
        const result = Matrix3d_1.Matrix3d.createScale(rr, rr, rr);
        result.addScaledInPlace(products, -1.0);
        return result;
    }
    static sortColumnsForIncreasingMoments(axes, moments) {
        const points = [
            axes.indexedColumnWithWeight(0, moments.x),
            axes.indexedColumnWithWeight(1, moments.y),
            axes.indexedColumnWithWeight(2, moments.z)
        ].sort((dataA, dataB) => {
            if (dataA.w < dataB.w)
                return -1;
            if (dataA.w > dataB.w)
                return 1;
            return 0;
        });
        axes.setColumnsPoint4dXYZ(points[0], points[1], points[2]);
        moments.set(points[0].w, points[1].w, points[2].w);
    }
    static pointsToPrincipalAxes(points) {
        const moments = new MomentData();
        if (points.length === 0)
            return moments;
        moments.clearSums(points[0]);
        moments.accumulatePointMomentsFromOrigin(points);
        if (moments.shiftSumsToCentroid()) {
            const products = moments.sums.matrixPart();
            const tensor = MomentData.momentTensorFromInertiaProducts(products);
            const moment2 = Point3dVector3d_1.Vector3d.create();
            const axisVectors = Matrix3d_1.Matrix3d.createZero();
            tensor.fastSymmetricEigenvalues(axisVectors, moment2);
            MomentData.sortColumnsForIncreasingMoments(axisVectors, moment2);
            moments.localToWorldMap = Transform_1.Transform.createOriginAndMatrix(moments.origin, axisVectors);
            moments.radiusOfGyration.set(Math.sqrt(moment2.x), Math.sqrt(moment2.y), Math.sqrt(moment2.z));
            moments.radiusOfGyration.scaleInPlace(1.0 / Math.sqrt(moments.sums.weight()));
        }
        return moments;
    }
    /**
     * Compute principal axes from inertial products
     * @param origin The origin used for the inertia products.
     * @param inertiaProducts The inertia products -- sums or integrals of [xx,xy,xz,xw; yx,yy, yz,yw; zx,zy,zz,zw; wx,wy,wz,w]
     */
    static inertiaProductsToPrincipalAxes(origin, inertiaProducts) {
        const moments = new MomentData();
        moments.sums.setFrom(inertiaProducts);
        moments.origin.setFrom(origin);
        if (!moments.shiftSumsToCentroid())
            return undefined;
        const products = moments.sums.matrixPart();
        const tensor = MomentData.momentTensorFromInertiaProducts(products);
        const moment2 = Point3dVector3d_1.Vector3d.create();
        const axisVectors = Matrix3d_1.Matrix3d.createZero();
        tensor.fastSymmetricEigenvalues(axisVectors, moment2);
        MomentData.sortColumnsForIncreasingMoments(axisVectors, moment2);
        moments.localToWorldMap = Transform_1.Transform.createOriginAndMatrix(moments.origin, axisVectors);
        moments.radiusOfGyration.set(Math.sqrt(moment2.x), Math.sqrt(moment2.y), Math.sqrt(moment2.z));
        moments.radiusOfGyration.scaleInPlace(1.0 / Math.sqrt(moments.sums.weight()));
        return moments;
    }
    clearSums(origin) {
        this.sums.setZero();
        if (origin)
            this.origin.setFrom(origin);
        else
            this.origin.setZero();
    }
    accumulatePointMomentsFromOrigin(points) {
        for (const p of points) {
            this.sums.addMomentsInPlace(p.x - this.origin.x, p.y - this.origin.y, p.z - this.origin.z, 1.0);
        }
    }
    shiftSumsToCentroid() {
        const xyz = this.sums.columnW().realPoint();
        if (xyz) {
            this.origin.addInPlace(xyz);
            const translation = Matrix4d_1.Matrix4d.createTranslationXYZ(-xyz.x, -xyz.y, -xyz.z);
            const TA = translation.multiplyMatrixMatrix(this.sums);
            TA.multiplyMatrixMatrixTranspose(translation, this.sums);
            return true;
        }
        return false;
    }
}
exports.MomentData = MomentData;


/***/ }),

/***/ "./lib/geometry4d/PlaneByOriginAndVectors4d.js":
/*!*****************************************************!*\
  !*** ./lib/geometry4d/PlaneByOriginAndVectors4d.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const Point4d_1 = __webpack_require__(/*! ./Point4d */ "./lib/geometry4d/Point4d.js");
/**
 * A Plane4dByOriginAndVectors is a 4d origin and pair of 4d "vectors" defining a 4d plane.
 *
 * * The parameterization of the plane is    `X = A + U*t + V*v`
 * * The unit coefficient of pointA makes this like a Plane3dByOriginAndVectors. Hence it is not a barycentric combination of 4d points.
 */
class PlaneByOriginAndVectors4d {
    constructor(origin, vectorU, vectorV) {
        this.origin = origin;
        this.vectorU = vectorU;
        this.vectorV = vectorV;
    }
    /** @returns Return a clone of this plane */
    clone(result) {
        if (result) {
            result.setFrom(this);
            return result;
        }
        return new PlaneByOriginAndVectors4d(this.origin.clone(), this.vectorU.clone(), this.vectorV.clone());
    }
    /** copy all content from other plane */
    setFrom(other) {
        this.origin.setFrom(other.origin);
        this.vectorU.setFrom(other.vectorU);
        this.vectorV.setFrom(other.vectorV);
    }
    /** @returns Return true if origin, vectorU, and vectorV pass isAlmostEqual. */
    isAlmostEqual(other) {
        return this.origin.isAlmostEqual(other.origin)
            && this.vectorU.isAlmostEqual(other.vectorU)
            && this.vectorV.isAlmostEqual(other.vectorV);
    }
    /** Create a plane with (copies of) origin, vectorU, vectorV parameters
     */
    static createOriginAndVectors(origin, vectorU, vectorV, result) {
        if (result) {
            result.setOriginAndVectors(origin, vectorU, vectorV);
            return result;
        }
        return new PlaneByOriginAndVectors4d(origin.clone(), vectorU.clone(), vectorV.clone());
    }
    /** Set all numeric data from complete list of (x,y,z,w) in origin, vectorU, and vectorV */
    setOriginAndVectorsXYZW(x0, y0, z0, w0, ux, uy, uz, uw, vx, vy, vz, vw) {
        this.origin.set(x0, y0, z0, w0);
        this.vectorU.set(ux, uy, uz, uw);
        this.vectorV.set(vx, vy, vz, vw);
        return this;
    }
    /** Copy the contents of origin, vectorU, vectorV parameters to respective member variables */
    setOriginAndVectors(origin, vectorU, vectorV) {
        this.origin.setFrom(origin);
        this.vectorU.setFrom(vectorU);
        this.vectorV.setFrom(vectorV);
        return this;
    }
    /** Create from complete list of (x,y,z,w) in origin, vectorU, and vectorV */
    static createOriginAndVectorsXYZW(x0, y0, z0, w0, ux, uy, uz, uw, vx, vy, vz, vw, result) {
        if (result)
            return result.setOriginAndVectorsXYZW(x0, y0, z0, w0, ux, uy, uz, uw, vx, vy, vz, vw);
        return new PlaneByOriginAndVectors4d(Point4d_1.Point4d.create(x0, y0, z0, w0), Point4d_1.Point4d.create(ux, uy, uz, uw), Point4d_1.Point4d.create(vx, vy, vz, uw));
    }
    static createOriginAndTargets3d(origin, targetU, targetV, result) {
        return PlaneByOriginAndVectors4d.createOriginAndVectorsXYZW(origin.x, origin.y, origin.z, 1.0, targetU.x - origin.x, targetU.y - origin.y, targetU.z - origin.z, 0.0, targetV.x - origin.x, targetV.y - origin.y, targetV.z - origin.z, 0.0, result);
    }
    fractionToPoint(u, v, result) {
        return this.origin.plus2Scaled(this.vectorU, u, this.vectorV, v, result);
    }
    static createXYPlane(result) {
        return PlaneByOriginAndVectors4d.createOriginAndVectorsXYZW(0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, result);
    }
}
exports.PlaneByOriginAndVectors4d = PlaneByOriginAndVectors4d;


/***/ }),

/***/ "./lib/geometry4d/Point4d.js":
/*!***********************************!*\
  !*** ./lib/geometry4d/Point4d.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Numerics */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Ray3d_1 = __webpack_require__(/*! ../geometry3d/Ray3d */ "./lib/geometry3d/Ray3d.js");
const Plane3dByOriginAndVectors_1 = __webpack_require__(/*! ../geometry3d/Plane3dByOriginAndVectors */ "./lib/geometry3d/Plane3dByOriginAndVectors.js");
const Plane3dByOriginAndUnitNormal_1 = __webpack_require__(/*! ../geometry3d/Plane3dByOriginAndUnitNormal */ "./lib/geometry3d/Plane3dByOriginAndUnitNormal.js");
/**
 *
 * @param ddg numerator second derivative
 * @param dh denominator derivative
 * @param ddh denominator second derivative
 * @param f primary function (g/h)
 * @param df derivative of (g/h)
 * @param divh = (1/h)
 * @param dgdivh previously computed first derivative of (g/h)
 */
function quotientDerivative2(ddg, dh, ddh, f, df, divh) {
    return divh * (ddg - 2.0 * df * dh - f * ddh);
}
exports.quotientDerivative2 = quotientDerivative2;
/** 4 Dimensional point (x,y,z,w) used in perspective calculations.
 * * the coordinates are stored in a Float64Array of length 4.
 * * properties `x`, `y`, `z`, `w` access array members.
 * *
 * * The coordinates are physically stored as a single FLoat64Array with 4 entries. (w last)
 * *
 */
class Point4d {
    /** Set x,y,z,w of this point.  */
    set(x = 0, y = 0, z = 0, w = 0) {
        this.xyzw[0] = x;
        this.xyzw[1] = y;
        this.xyzw[2] = z;
        this.xyzw[3] = w;
        return this;
    }
    /** @returns Return the x component of this point. */
    get x() { return this.xyzw[0]; }
    set x(val) { this.xyzw[0] = val; }
    /** @returns Return the y component of this point. */
    get y() { return this.xyzw[1]; }
    set y(val) { this.xyzw[1] = val; }
    /** @returns Return the z component of this point. */
    get z() { return this.xyzw[2]; }
    set z(val) { this.xyzw[2] = val; }
    /** @returns Return the w component of this point. */
    get w() { return this.xyzw[3]; }
    set w(val) { this.xyzw[3] = val; }
    constructor(x = 0, y = 0, z = 0, w = 0) {
        this.xyzw = new Float64Array(4);
        this.xyzw[0] = x;
        this.xyzw[1] = y;
        this.xyzw[2] = z;
        this.xyzw[3] = w;
    }
    /** @returns Return a Point4d with specified x,y,z,w */
    static create(x = 0, y = 0, z = 0, w = 0, result) {
        return result ? result.set(x, y, z, w) : new Point4d(x, y, z, w);
    }
    setFrom(other) {
        this.xyzw[0] = other.xyzw[0];
        this.xyzw[1] = other.xyzw[1];
        this.xyzw[2] = other.xyzw[2];
        this.xyzw[3] = other.xyzw[3];
        return this;
    }
    clone(result) {
        return result ? result.setFrom(this) : new Point4d(this.xyzw[0], this.xyzw[1], this.xyzw[2], this.xyzw[3]);
    }
    setFromJSON(json) {
        if (Geometry_1.Geometry.isNumberArray(json, 4))
            this.set(json[0], json[1], json[2], json[3]);
        else
            this.set(0, 0, 0, 0);
    }
    static fromJSON(json) {
        const result = new Point4d();
        result.setFromJSON(json);
        return result;
    }
    isAlmostEqual(other) {
        return Geometry_1.Geometry.isSameCoordinate(this.x, other.x)
            && Geometry_1.Geometry.isSameCoordinate(this.y, other.y)
            && Geometry_1.Geometry.isSameCoordinate(this.z, other.z)
            && Geometry_1.Geometry.isSameCoordinate(this.w, other.w);
    }
    /**
     * Test for same coordinate by direct x,y,z,w args
     * @param x x to test
     * @param y y to test
     * @param z z to test
     * @param w w to test
     */
    isAlmostEqualXYZW(x, y, z, w) {
        return Geometry_1.Geometry.isSameCoordinate(this.x, x)
            && Geometry_1.Geometry.isSameCoordinate(this.y, y)
            && Geometry_1.Geometry.isSameCoordinate(this.z, z)
            && Geometry_1.Geometry.isSameCoordinate(this.w, w);
    }
    /**
     * Convert an Angle to a JSON object.
     * @return {*} [[x,y,z,w]
     */
    toJSON() {
        return [this.xyzw[0], this.xyzw[1], this.xyzw[2], this.xyzw[3]];
    }
    /** Return the 4d distance from this point to other, with all 4 components squared into the hypotenuse.
     * * x,y,z,w all participate without normalization.
     */
    distanceXYZW(other) {
        return Geometry_1.Geometry.hypotenuseXYZW(other.xyzw[0] - this.xyzw[0], other.xyzw[1] - this.xyzw[1], other.xyzw[2] - this.xyzw[2], other.xyzw[3] - this.xyzw[3]);
    }
    /** Return the squared 4d distance from this point to other, with all 4 components squared into the hypotenuse.
     * * x,y,z,w all participate without normalization.
     */
    distanceSquaredXYZW(other) {
        return Geometry_1.Geometry.hypotenuseSquaredXYZW(other.xyzw[0] - this.xyzw[0], other.xyzw[1] - this.xyzw[1], other.xyzw[2] - this.xyzw[2], other.xyzw[3] - this.xyzw[3]);
    }
    /** Return the distance between the instance and other after normalizing by weights
     */
    realDistanceXY(other) {
        const wA = this.w;
        const wB = other.w;
        if (Geometry_1.Geometry.isSmallMetricDistance(wA) || Geometry_1.Geometry.isSmallMetricDistance(wB))
            return undefined;
        return Geometry_1.Geometry.hypotenuseXY(other.xyzw[0] / wB - this.xyzw[0] / wA, other.xyzw[1] / wB - this.xyzw[1] / wA);
    }
    /** Return the largest absolute distance between corresponding components
     * * x,y,z,w all participate without normalization.
     */
    maxDiff(other) {
        return Math.max(Math.abs(other.xyzw[0] - this.xyzw[0]), Math.abs(other.xyzw[1] - this.xyzw[1]), Math.abs(other.xyzw[2] - this.xyzw[2]), Math.abs(other.xyzw[3] - this.xyzw[3]));
    }
    /** @returns Return the largest absolute entry of all 4 components x,y,z,w */
    maxAbs() {
        return Math.max(Math.abs(this.xyzw[0]), Math.abs(this.xyzw[1]), Math.abs(this.xyzw[2]), Math.abs(this.xyzw[3]));
    }
    /**  @returns Returns the magnitude including all 4 components x,y,z,w */
    magnitudeXYZW() {
        return Geometry_1.Geometry.hypotenuseXYZW(this.xyzw[0], this.xyzw[1], this.xyzw[2], this.xyzw[3]);
    }
    /**  @returns Returns the magnitude of the leading xyz components */
    magnitudeSquaredXYZ() {
        return Geometry_1.Geometry.hypotenuseSquaredXYZ(this.xyzw[0], this.xyzw[1], this.xyzw[2]);
    }
    /** @returns Return the difference (this-other) using all 4 components x,y,z,w */
    minus(other, result) {
        return Point4d.create(this.xyzw[0] - other.xyzw[0], this.xyzw[1] - other.xyzw[1], this.xyzw[2] - other.xyzw[2], this.xyzw[3] - other.xyzw[3], result);
    }
    /** @returns Return `((other.w * this) -  (this.w * other))` */
    crossWeightedMinus(other, result) {
        const wa = this.xyzw[3];
        const wb = other.xyzw[3];
        return Point3dVector3d_1.Vector3d.create(wb * this.xyzw[0] - wa * other.xyzw[0], wb * this.xyzw[1] - wa * other.xyzw[1], wb * this.xyzw[2] - wa * other.xyzw[2], result);
    }
    /** @returns Return the sum of this and other, using all 4 components x,y,z,w */
    plus(other, result) {
        return Point4d.create(this.xyzw[0] + other.xyzw[0], this.xyzw[1] + other.xyzw[1], this.xyzw[2] + other.xyzw[2], this.xyzw[3] + other.xyzw[3], result);
    }
    get isAlmostZero() {
        return Geometry_1.Geometry.isSmallMetricDistance(this.maxAbs());
    }
    static createZero() { return new Point4d(0, 0, 0, 0); }
    /**
     * Create plane coefficients for the plane containing pointA, pointB, and 0010.
     * @param pointA first point
     * @param pointB second point
     */
    static createPlanePointPointZ(pointA, pointB, result) {
        return Point4d.create(pointA.y * pointB.w - pointA.w * pointB.y, pointA.w * pointB.x - pointA.x * pointB.w, 0.0, pointA.x * pointB.y - pointA.y * pointB.x, result);
    }
    /**
     * extract 4 consecutive numbers from a Float64Array into a Point4d.
     * @param data buffer of numbers
     * @param xIndex first index for x,y,z,w sequence
     */
    static createFromPackedXYZW(data, xIndex = 0, result) {
        return Point4d.create(data[xIndex], data[xIndex + 1], data[xIndex + 2], data[xIndex + 3], result);
    }
    static createFromPointAndWeight(xyz, w) {
        return new Point4d(xyz.x, xyz.y, xyz.z, w);
    }
    /** Return `point + vector * scalar` */
    plusScaled(vector, scaleFactor, result) {
        return Point4d.create(this.xyzw[0] + vector.xyzw[0] * scaleFactor, this.xyzw[1] + vector.xyzw[1] * scaleFactor, this.xyzw[2] + vector.xyzw[2] * scaleFactor, this.xyzw[3] + vector.xyzw[3] * scaleFactor, result);
    }
    /** Return interpolation between instance and pointB at fraction
     */
    interpolate(fraction, pointB, result) {
        const v = 1.0 - fraction;
        return Point4d.create(this.xyzw[0] * v + pointB.xyzw[0] * fraction, this.xyzw[1] * v + pointB.xyzw[1] * fraction, this.xyzw[2] * v + pointB.xyzw[2] * fraction, this.xyzw[3] * v + pointB.xyzw[3] * fraction, result);
    }
    /** Return `point + vectorA * scalarA + vectorB * scalarB` */
    plus2Scaled(vectorA, scalarA, vectorB, scalarB, result) {
        return Point4d.create(this.xyzw[0] + vectorA.xyzw[0] * scalarA + vectorB.xyzw[0] * scalarB, this.xyzw[1] + vectorA.xyzw[1] * scalarA + vectorB.xyzw[1] * scalarB, this.xyzw[2] + vectorA.xyzw[2] * scalarA + vectorB.xyzw[2] * scalarB, this.xyzw[3] + vectorA.xyzw[3] * scalarA + vectorB.xyzw[3] * scalarB, result);
    }
    /** Return `point + vectorA * scalarA + vectorB * scalarB + vectorC * scalarC` */
    plus3Scaled(vectorA, scalarA, vectorB, scalarB, vectorC, scalarC, result) {
        return Point4d.create(this.xyzw[0] + vectorA.xyzw[0] * scalarA + vectorB.xyzw[0] * scalarB + vectorC.xyzw[0] * scalarC, this.xyzw[1] + vectorA.xyzw[1] * scalarA + vectorB.xyzw[1] * scalarB + vectorC.xyzw[1] * scalarC, this.xyzw[2] + vectorA.xyzw[2] * scalarA + vectorB.xyzw[2] * scalarB + vectorC.xyzw[2] * scalarC, this.xyzw[3] + vectorA.xyzw[3] * scalarA + vectorB.xyzw[3] * scalarB + vectorC.xyzw[3] * scalarC, result);
    }
    /** Return `point + vectorA * scalarA + vectorB * scalarB` */
    static createAdd2Scaled(vectorA, scalarA, vectorB, scalarB, result) {
        return Point4d.create(vectorA.xyzw[0] * scalarA + vectorB.xyzw[0] * scalarB, vectorA.xyzw[1] * scalarA + vectorB.xyzw[1] * scalarB, vectorA.xyzw[2] * scalarA + vectorB.xyzw[2] * scalarB, vectorA.xyzw[3] * scalarA + vectorB.xyzw[3] * scalarB, result);
    }
    /** Return `point + vectorA \ scalarA + vectorB * scalarB + vectorC * scalarC` */
    static createAdd3Scaled(vectorA, scalarA, vectorB, scalarB, vectorC, scalarC, result) {
        return Point4d.create(vectorA.xyzw[0] * scalarA + vectorB.xyzw[0] * scalarB + vectorC.xyzw[0] * scalarC, vectorA.xyzw[1] * scalarA + vectorB.xyzw[1] * scalarB + vectorC.xyzw[1] * scalarC, vectorA.xyzw[2] * scalarA + vectorB.xyzw[2] * scalarB + vectorC.xyzw[2] * scalarC, vectorA.xyzw[3] * scalarA + vectorB.xyzw[3] * scalarB + vectorC.xyzw[3] * scalarC, result);
    }
    /** Return dot produt of (4d) vectors from the instance to targetA and targetB */
    dotVectorsToTargets(targetA, targetB) {
        return (targetA.xyzw[0] - this.xyzw[0]) * (targetB.xyzw[0] - this.xyzw[0]) +
            (targetA.xyzw[1] - this.xyzw[1]) * (targetB.xyzw[1] - this.xyzw[1]) +
            (targetA.xyzw[2] - this.xyzw[2]) * (targetB.xyzw[2] - this.xyzw[2]) +
            (targetA.xyzw[3] - this.xyzw[3]) * (targetB.xyzw[3] - this.xyzw[3]);
    }
    /** return (4d) dot product of the instance and other point. */
    dotProduct(other) {
        return this.xyzw[0] * other.xyzw[0] + this.xyzw[1] * other.xyzw[1] + this.xyzw[2] * other.xyzw[2] + this.xyzw[3] * other.xyzw[3];
    }
    /** return (4d) dot product of the instance with xyzw */
    dotProductXYZW(x, y, z, w) {
        return this.xyzw[0] * x + this.xyzw[1] * y + this.xyzw[2] * z + this.xyzw[3] * w;
    }
    /** dotProduct with (point.x, point.y, point.z, 1) Used in PlaneAltitudeEvaluator interface */
    altitude(point) {
        return this.xyzw[0] * point.x + this.xyzw[1] * point.y + this.xyzw[2] * point.z + this.xyzw[3];
    }
    /** dotProduct with (point.x, point.y, point.z, 1) Used in PlaneAltitudeEvaluator interface */
    weightedAltitude(point) {
        return this.xyzw[0] * point.x + this.xyzw[1] * point.y + this.xyzw[2] * point.z + this.xyzw[3] * point.w;
    }
    /** dotProduct with (vector.x, vector.y, vector.z, 0).  Used in PlaneAltitudeEvaluator interface */
    velocity(vector) {
        return this.xyzw[0] * vector.x + this.xyzw[1] * vector.y + this.xyzw[2] * vector.z;
    }
    /** dotProduct with (x,y,z, 0).  Used in PlaneAltitudeEvaluator interface */
    velocityXYZ(x, y, z) {
        return this.xyzw[0] * x + this.xyzw[1] * y + this.xyzw[2] * z;
    }
    /** unit X vector */
    static unitX() { return new Point4d(1, 0, 0, 0); }
    /** unit Y vector */
    static unitY() { return new Point4d(0, 1, 0, 0); }
    /** unit Z vector */
    static unitZ() { return new Point4d(0, 0, 1, 0); }
    /** unit W vector */
    static unitW() { return new Point4d(0, 0, 0, 1); }
    // Divide by denominator, but return undefined if denominator is zero.
    safeDivideOrNull(denominator, result) {
        if (denominator !== 0.0) {
            return this.scale(1.0 / denominator, result);
        }
        return undefined;
    }
    /** scale all components (including w!!) */
    scale(scale, result) {
        result = result ? result : new Point4d();
        result.xyzw[0] = this.xyzw[0] * scale;
        result.xyzw[1] = this.xyzw[1] * scale;
        result.xyzw[2] = this.xyzw[2] * scale;
        result.xyzw[3] = this.xyzw[3] * scale;
        return result;
    }
    /** Negate components (including w!!) */
    negate(result) {
        result = result ? result : new Point4d();
        result.xyzw[0] = -this.xyzw[0];
        result.xyzw[1] = -this.xyzw[1];
        result.xyzw[2] = -this.xyzw[2];
        result.xyzw[3] = -this.xyzw[3];
        return result;
    }
    /**
     * If `this.w` is nonzero, return a 4d point `(x/w,y/w,z/w, 1)`
     * If `this.w` is zero, return undefined.
     * @param result optional result
     */
    normalizeWeight(result) {
        const mag = Geometry_1.Geometry.correctSmallMetricDistance(this.xyzw[3]);
        result = result ? result : new Point4d();
        return this.safeDivideOrNull(mag, result);
    }
    /**
     * If `this.w` is nonzero, return a 3d point `(x/w,y/w,z/w)`
     * If `this.w` is zero, return undefined.
     * @param result optional result
     */
    realPoint(result) {
        const mag = Geometry_1.Geometry.correctSmallMetricDistance(this.xyzw[3]);
        if (mag === 0.0)
            return undefined;
        const a = 1.0 / mag; // in zero case everything multiplies right back to true zero.
        return Point3dVector3d_1.Point3d.create(this.xyzw[0] * a, this.xyzw[1] * a, this.xyzw[2] * a, result);
    }
    /**
     * * If w is nonzero, return Point3d with x/w,y/w,z/w.
     * * If w is zero, return 000
     * @param x x coordinate
     * @param y y coordinate
     * @param z z coordinate
     * @param w w coordinate
     * @param result optional result
     */
    static createRealPoint3dDefault000(x, y, z, w, result) {
        const mag = Geometry_1.Geometry.correctSmallMetricDistance(w);
        const a = mag === 0 ? 0.0 : (1.0 / mag); // in zero case everything multiplies right back to true zero.
        return Point3dVector3d_1.Point3d.create(x * a, y * a, z * a, result);
    }
    /**
     * * If w is nonzero, return Vector3d which is the derivative of the projecte xyz with given w and 4d derivatives.
     * * If w is zero, return 000
     * @param x x coordinate
     * @param y y coordinate
     * @param z z coordinate
     * @param w w coordinate
     * @param dx x coordinate of derivative
     * @param dy y coordinate of derivative
     * @param dz z coordinate of derivative
     * @param dw w coordinate of derivative
     * @param result optional result
     */
    static createRealDerivativeRay3dDefault000(x, y, z, w, dx, dy, dz, dw, result) {
        const mag = Geometry_1.Geometry.correctSmallMetricDistance(w);
        // real point is X/w.
        // real derivative is (X' * w - X *w) / ww, and weight is always 0 by cross products.
        const a = mag === 0 ? 0.0 : (1.0 / mag); // in zero case everything multiplies right back to true zero.
        const aa = a * a;
        return Ray3d_1.Ray3d.createXYZUVW(x * a, y * a, z * a, (dx * w - dw * x) * aa, (dy * w - dw * y) * aa, (dz * w - dw * z) * aa, result);
    }
    /**
     * * If w is nonzero, return Vector3d which is the derivative of the projecte xyz with given w and 4d derivatives.
     * * If w is zero, return 000
     * @param x x coordinate
     * @param y y coordinate
     * @param z z coordinate
     * @param w w coordinate
     * @param dx x coordinate of derivative
     * @param dy y coordinate of derivative
     * @param dz z coordinate of derivative
     * @param dw w coordinate of derivative
     * @param result optional result
     */
    static createRealDerivativePlane3dByOriginAndVectorsDefault000(x, y, z, w, dx, dy, dz, dw, ddx, ddy, ddz, ddw, result) {
        const mag = Geometry_1.Geometry.correctSmallMetricDistance(w);
        // real point is X/w.
        // real derivative is (X' * w - X *w) / ww, and weight is always 0 by cross products.
        const a = mag === 0 ? 0.0 : (1.0 / mag); // in zero case everything multiplies right back to true zero.
        const aa = a * a;
        const fx = x * a;
        const fy = y * a;
        const fz = z * a;
        const dfx = (dx * w - dw * x) * aa;
        const dfy = (dy * w - dw * y) * aa;
        const dfz = (dz * w - dw * z) * aa;
        return Plane3dByOriginAndVectors_1.Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(fx, fy, fz, dfx, dfy, dfz, quotientDerivative2(ddx, dw, ddw, fx, dfx, a), quotientDerivative2(ddy, dw, ddw, fy, dfy, a), quotientDerivative2(ddz, dw, ddw, fz, dfz, a), result);
    }
    /**
     * * If this.w is nonzero, return Point3d with x/w,y/w,z/w.
     * * If this.w is zero, return 000
     */
    realPointDefault000(result) {
        const mag = Geometry_1.Geometry.correctSmallMetricDistance(this.xyzw[3]);
        if (mag === 0.0)
            return Point3dVector3d_1.Point3d.create(0, 0, 0, result);
        result = result ? result : new Point3dVector3d_1.Point3d();
        const a = 1.0 / mag;
        return Point3dVector3d_1.Point3d.create(this.xyzw[0] * a, this.xyzw[1] * a, this.xyzw[2] * a, result);
    }
    /** divide all components (x,y,z,w) by the 4d magnitude.
     *
     * * This is appropriate for normalizing a quaternion
     * * Use normalizeWeight to divide by the w component.
     */
    normalizeXYZW(result) {
        const mag = Geometry_1.Geometry.correctSmallMetricDistance(this.magnitudeXYZW());
        result = result ? result : new Point4d();
        return this.safeDivideOrNull(mag, result);
    }
    /**
     * Return the determinant of the 3x3 matrix using components i,j,k of the 3 inputs.
     */
    static determinantIndexed3X3(pointA, pointB, pointC, i, j, k) {
        return Geometry_1.Geometry.tripleProduct(pointA.xyzw[i], pointA.xyzw[j], pointA.xyzw[k], pointB.xyzw[i], pointB.xyzw[j], pointB.xyzw[k], pointC.xyzw[i], pointC.xyzw[j], pointC.xyzw[k]);
    }
    /**
     * Return a Point4d perpendicular to all 3 inputs. (A higher level cross product concept)
     * @param pointA first point
     * @param pointB second point
     * @param pointC third point
     */
    static perpendicularPoint4dPlane(pointA, pointB, pointC) {
        return Point4d.create(Point4d.determinantIndexed3X3(pointA, pointB, pointC, 1, 2, 3), -Point4d.determinantIndexed3X3(pointA, pointB, pointC, 2, 3, 0), Point4d.determinantIndexed3X3(pointA, pointB, pointC, 3, 0, 1), -Point4d.determinantIndexed3X3(pointA, pointB, pointC, 0, 1, 2));
    }
    toPlane3dByOriginAndUnitNormal(result) {
        const aa = this.magnitudeSquaredXYZ();
        const direction = Point3dVector3d_1.Vector3d.create(this.x, this.y, this.z);
        const w = this.w;
        const divW = Geometry_1.Geometry.conditionalDivideFraction(1.0, w);
        if (divW !== undefined) {
            const b = -w / aa;
            direction.scaleInPlace(1.0 / Math.sqrt(aa));
            return Plane3dByOriginAndUnitNormal_1.Plane3dByOriginAndUnitNormal.create(Point3dVector3d_1.Point3d.create(this.x * b, this.y * b, this.z * b), direction, result);
        }
        return undefined;
    }
} // DPoint4d
exports.Point4d = Point4d;


/***/ }),

/***/ "./lib/numerics/BezierPolynomials.js":
/*!*******************************************!*\
  !*** ./lib/numerics/BezierPolynomials.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Numerics */
// import { Angle, AngleSweep, Geometry } from "../Geometry";
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const PascalCoefficients_1 = __webpack_require__(/*! ./PascalCoefficients */ "./lib/numerics/PascalCoefficients.js");
const Polynomials_1 = __webpack_require__(/*! ./Polynomials */ "./lib/numerics/Polynomials.js");
/* tslint:disable:variable-name*/
/**
 * * BezierCoffs is an abstract base class for one-dimensional (u to f(u)) Bezier polynomials.
 * * The base class carries a Float64Array with coefficients.
 * * The Float64Array is NOT Growable unless derived classes add logic to do so.  Its length is the Bezier polynomial order.
 * * The family of derived classes is starts with low order (at least linear through cubic) with highly optimized calculations.
 * * The general degree Bezier class also uses this as its base class.
 * * The length of the coefficient array is NOT always the bezier order.   Use the `order` property to access the order.
 */
class BezierCoffs {
    /**
     * * If `data` is a number, an array of that size is created with zeros.
     * * If `data` is a Float64Array, it is cloned (NOT CAPTURED)
     * * If `data` is a number array, its values are copied.
     */
    constructor(data) {
        if (data instanceof Float64Array) {
            this.coffs = data.slice();
        }
        else if (Array.isArray(data)) {
            this.coffs = new Float64Array(data.length);
            let i = 0;
            for (const a of data)
                this.coffs[i++] = a;
        }
        else {
            this.coffs = new Float64Array(data);
        }
    }
    /**
     * * Ensure the coefficient array size matches order.  (Reallocate as needed)
     * * fill with zeros.
     * @param order required order
     */
    allocateToOrder(order) {
        if (this.coffs.length !== order) {
            this.coffs = new Float64Array(order);
        }
        else {
            this.coffs.fill(0);
        }
    }
    /**
     * create an object of same order with zero coefficients.
     * The base implementation makes a generic Bezier of the same order.
     */
    createPeer() {
        const peer = new UnivariateBezier(this.order);
        return peer;
    }
    /** The order (number of coefficients) as a readable property  */
    get order() { return this.coffs.length; }
    /** Copy coefficients from other Bezier. Note that the coefficient count (order) of "this" can change. */
    copyFrom(other) {
        if (this.order === other.order)
            for (let i = 0; i < this.coffs.length; i++) {
                this.coffs[i] = other.coffs[i];
            }
        else
            this.coffs = other.coffs.slice();
    }
    /**
     * Apply a scale factor to all coefficients.
     * @param scale scale factor to apply to all coefficients.
     */
    scaleInPlace(scale) {
        for (let i = 0; i < this.coffs.length; i++)
            this.coffs[i] *= scale;
    }
    /** add a constant to each coefficient.
     * @param a constant to add.
     */
    addInPlace(a) {
        for (let i = 0; i < this.coffs.length; i++)
            this.coffs[i] += a;
    }
    /** Compute parameter values where the bezier value matches _targetValue.
     * * The base class finds roots only in 01.  (i.e. ignores _restrictTo01)
     * * Order-specific implementations apply special case  analytic logic, e.g. for degree 1,2,3,4.
     */
    roots(targetValue, _restrictTo01) {
        const bezier = UnivariateBezier.create(this);
        bezier.addInPlace(-targetValue);
        return UnivariateBezier.deflateRoots01(bezier);
    }
    /** Given an array of numbers, optionally remove those not in the 0..1 interval.
     * @param roots candidate values
     * @param restrictTo01 If false, no filtering occurs and the pointer to the original array is unchanged.
     *     If true, filtering is done and values are returned, possibly in a new array and possibly in the original.
     */
    filter01(roots, restrictTo01 = false) {
        if (!roots || !restrictTo01)
            return roots;
        let anyFound = false;
        for (const r of roots) {
            if (Geometry_1.Geometry.isIn01(r)) {
                anyFound = true;
                break;
            }
        }
        if (anyFound) {
            const roots01 = [];
            for (const r of roots) {
                if (Geometry_1.Geometry.isIn01(r))
                    roots01.push(r);
            }
            return roots01;
        }
        return undefined;
    }
    zero() { this.coffs.fill(0); }
    /** Subdivide -- write results into caller-supplied bezier coffs (which must be of the same order) */
    subdivide(u, left, right) {
        const order = this.order;
        if (left.order !== order && right.order !== order)
            return false;
        const v = 1.0 - u;
        right.copyFrom(this);
        // each left will be filled in directly, so there is no need to initialize it.
        let n1 = order - 1; // number of interpolations in inner loop.
        for (let i0 = 0; i0 < order; i0++) {
            left.coffs[i0] = right.coffs[0];
            for (let i = 0; i < n1; i++)
                right.coffs[i] = v * right.coffs[i] + u * right.coffs[i + 1];
            n1--;
        }
        return true;
    }
    /** Return the maximum absolute difference between coefficients of two sets of BezierCoffs */
    static maxAbsDiff(dataA, dataB) {
        const order = dataA.order;
        if (dataB.order !== order)
            return undefined;
        let d = 0.0;
        let d1;
        for (let i = 0; i < order; i++) {
            d1 = Math.abs(dataA.coffs[i] - dataB.coffs[i]);
            if (d1 > d)
                d = d1;
        }
        return d;
    }
}
exports.BezierCoffs = BezierCoffs;
/**
 * Static methods to operate on univariate beizer polynomials, with coefficients in simple Float64Array or as components of blocked arrays.
 */
class BezierPolynomialAlgebra {
    /**
     * * Univariate bezierA has its coefficients at offset indexA in each block within the array of blocks.
     * * Symbolically:   `product(s) += scale * (constA - polynomialA(s)) *polynomialB(s)`
     * * Where coefficients of polynomialA(s) are in column indexA and coefficients of polynominalB(s) are differences within column indexB.
     * * Treating data as 2-dimensional array:   `product = sum (iA) sum (iB)    (constA - basisFunction[iA} data[indexA][iA]) * basisFunction[iB] * (dataOrder-1)(data[iB + 1][indexB] - data[iB][indexB])`
     * * Take no action if product length is other than `dataOrder + dataOrder - 2`
     */
    static accumulateScaledShiftedComponentTimesComponentDelta(product, data, dataBlockSize, dataOrder, scale, indexA, constA, indexB) {
        const orderB = dataOrder - 1; // coefficients of the first difference are implicitly present as differences of adjacent entries.
        const orderA = dataOrder;
        const orderC = dataOrder + orderB - 1;
        if (product.length !== orderC)
            return;
        const coffA = PascalCoefficients_1.PascalCoefficients.getRow(orderA - 1);
        const coffB = PascalCoefficients_1.PascalCoefficients.getRow(orderB - 1);
        const coffC = PascalCoefficients_1.PascalCoefficients.getRow(orderC - 1);
        let qA;
        for (let a = 0; a < orderA; a++) {
            qA = scale * (constA + data[indexA + a * dataBlockSize]) * coffA[a];
            for (let b = 0, k = indexB; b < orderB; b++, k += dataBlockSize) {
                product[a + b] += qA * coffB[b] * (data[k + dataBlockSize] - data[k]) / coffC[a + b];
            }
        }
    }
    /**
     * * Univariate bezierA has its coefficients at offset indexA in each block within the array of blocks.
     * * Univariate bezierB has its coefficients at offset indexB in each block within the array of blocks.
     * * return the sum coefficients for `constA * polynominalA + constB * polynomialB`
     * * Symbolically:   `product(s) = (constA * polynomialA(s) + constB * polynominalB(s)`
     * * The two polyomials are the same order, so this just direct sum of scaled coefficients.
     *
     * * Take no action if product length is other than `dataOrder + dataOrder - 2`
     */
    static scaledComponentSum(sum, data, dataBlockSize, dataOrder, indexA, constA, indexB, constB) {
        const orderA = dataOrder;
        if (sum.length !== orderA)
            return;
        for (let a = 0, rowBase = 0; a < orderA; a++, rowBase += dataBlockSize) {
            sum[a] = constA * data[rowBase + indexA] + constB * data[rowBase + indexB];
        }
    }
    /**
     * * Univariate bezier has its coefficients at offset index in each block within the array of blocks.
     * * return the (dataOrder - 1) differences,
     *
     * * Take no action if difference length is other than `dataOrder - 1`
     */
    static componentDifference(difference, data, dataBlockSize, dataOrder, index) {
        const orderA = dataOrder;
        const orderDiff = orderA - 1;
        if (difference.length !== orderDiff)
            return;
        for (let i = 0, k = index; i < orderDiff; k += dataBlockSize, i++)
            difference[i] = data[k + dataBlockSize] - data[k];
    }
    /**
     * * Univariate bezierA has its coefficients in dataA[i]
     * * Univariate bezierB has its coefficients in dataB[i]
     * * return the product coefficients for polynominalA(s) * polynomialB(s) * scale
     * * Take no action if product length is other than `orderA + orderB - 1`
     */
    static accumulateProduct(product, dataA, dataB, scale = 1.0) {
        const orderA = dataA.length;
        const orderB = dataB.length;
        const orderC = orderA + orderB - 1;
        if (product.length !== orderC)
            return;
        let a;
        let b;
        let qA;
        const coffA = PascalCoefficients_1.PascalCoefficients.getRow(orderA - 1);
        const coffB = PascalCoefficients_1.PascalCoefficients.getRow(orderB - 1);
        const coffC = PascalCoefficients_1.PascalCoefficients.getRow(orderC - 1);
        for (a = 0; a < orderA; a++) {
            qA = scale * coffA[a] * dataA[a];
            for (b = 0; b < orderB; b++) {
                product[a + b] += qA * coffB[b] * dataB[b] / coffC[a + b];
            }
        }
    }
    /**
     * * Univariate bezierA has its coefficients in dataA[i]
     * * Univariate bezierB has its coefficients in dataB[i]
     * * return the product coefficients for polynominalADifferencs(s) * polynomialB(s) * scale
     * * Take no action if product length is other than `orderA + orderB - 2`
     */
    static accumulateProductWithDifferences(product, dataA, dataB, scale = 1.0) {
        const orderA = dataA.length - 1; // We deal with its differences, which are lower order !!!
        const orderB = dataB.length;
        const orderC = orderA + orderB - 1;
        if (product.length !== orderC)
            return;
        let a;
        let b;
        let qA;
        const coffA = PascalCoefficients_1.PascalCoefficients.getRow(orderA - 1);
        const coffB = PascalCoefficients_1.PascalCoefficients.getRow(orderB - 1);
        const coffC = PascalCoefficients_1.PascalCoefficients.getRow(orderC - 1);
        for (a = 0; a < orderA; a++) {
            qA = scale * coffA[a] * (dataA[a + 1] - dataA[a]);
            for (b = 0; b < orderB; b++) {
                product[a + b] += qA * coffB[b] * dataB[b] / coffC[a + b];
            }
        }
    }
    /**
     * * Univariate bezier has its coefficients in data[i]
     * * return the diference data[i+1]-data[i] in difference.
     * * Take no action if product length is other than `orderA + orderB - 1`
     */
    static univariateDifference(data, difference) {
        const differenceOrder = difference.length;
        if (difference.length + 1 !== differenceOrder)
            for (let i = 0; i < differenceOrder; i++) {
                difference[i] = data[i + 1] - data[i];
            }
    }
    /**
     * * Univariate bezierA has its coefficients in dataA[i]
     * * Univariate bezierB has its coefficients in resultB[i]
     * * add (with no scaling) bezierA to bezierB
     * * Take no action if resultB.length is other than dataA.length.
     */
    static accumulate(dataA, orderA, resultB) {
        if (resultB.length !== orderA)
            return;
        for (let i = 0; i < orderA; i++) {
            resultB[i] += dataA[i];
        }
    }
}
exports.BezierPolynomialAlgebra = BezierPolynomialAlgebra;
/**
 * * The UnivariateBezier class is a univariate bezier polynomial with no particular order.
 * * More specific classes -- Order2Bezier, Order3Bezier, Order4Bezier -- can be used when a fixed order is known and the more specialized implementations are appropriate.
 * * When working with xy and xyz curves whose order is the common 2,3,4, various queries (e.g. project point to curve)
 *     generate higher order one-dimensional bezier polynomials with order that is a small multiple of the
 *     curve order.   Hence those polynomials commonly reach degree 8 to 12.
 * * Higher order bezier polynomials are possible, but performance and accuracy issues become significant.
 * * Some machine-level constraints apply for curves of extrmely high order, e.g. 70.   For instance, at that level use of
 *     Pascal triangle coefficients becomes inaccurate because IEEE doubles cannot represent integers that
 *     large.
 */
class UnivariateBezier extends BezierCoffs {
    get order() { return this._order; }
    constructor(data) {
        super(data);
        this._order = super.order;
    }
    /** (Re) initialize with given order (and all coffs zero) */
    allocateOrder(order) {
        if (this._order !== order) {
            super.allocateToOrder(order);
            this._order = order;
        }
    }
    /** Return a copy, optionally with coffs array length reduced to actual order. */
    clone(compressToMinimalAllocation = false) {
        if (compressToMinimalAllocation) {
            const result1 = new UnivariateBezier(this.order);
            result1.coffs = this.coffs.slice(0, this.order);
            return result1;
        }
        const result = new UnivariateBezier(this.coffs.length);
        result._order = this._order;
        result.coffs = this.coffs.slice();
        return result;
    }
    /** Create a new bezier which is a copy of other.
     * * Note that `other` may be a more specialized class such as `Order2Bezier`, but the result is general `Bezier`
     * @param other coefficients to copy.
     */
    static create(other) {
        const result = new UnivariateBezier(other.order);
        result.coffs = other.coffs.slice();
        return result;
    }
    /**
     * copy coefficients into a new bezier.
     * @param coffs coefficients for bezier
     */
    static createCoffs(data) {
        return new UnivariateBezier(data);
    }
    /**
     * copy coefficients into a new bezier.
     * * if result is omitted, a new UnivariateBezier is allocated and returned.
     * * if result is present but has other order, its coefficients are reallocated
     * * if result is present and has matching order, the values are replace.
     * @param coffs coefficients for bezier
     * @param index0 first index to access
     * @param order number of coefficients, i.e. order for the result
     * @param result optional result.
     *
     */
    static createArraySubset(coffs, index0, order, result) {
        if (!result)
            result = new UnivariateBezier(order);
        else if (result.order !== order)
            result.allocateToOrder(order);
        for (let i = 0; i < order; i++)
            result.coffs[i] = coffs[index0 + i];
        return result;
    }
    /**
     * Create a product of 2 bezier polynomials.
     * @param bezierA
     * @param bezierB
     */
    static createProduct(bezierA, bezierB) {
        const result = new UnivariateBezier(bezierA.order + bezierB.order - 1);
        const pascalA = PascalCoefficients_1.PascalCoefficients.getRow(bezierA.order - 1);
        const pascalB = PascalCoefficients_1.PascalCoefficients.getRow(bezierB.order - 1);
        const pascalC = PascalCoefficients_1.PascalCoefficients.getRow(bezierA.order + bezierB.order - 2);
        for (let iA = 0; iA < bezierA.order; iA++) {
            const a = bezierA.coffs[iA] * pascalA[iA];
            for (let iB = 0; iB < bezierB.order; iB++) {
                const b = bezierB.coffs[iB] * pascalB[iB];
                const iC = iA + iB;
                const c = pascalC[iC];
                result.coffs[iC] += a * b / c;
            }
        }
        return result;
    }
    /**
     * Add a sqaured bezier polynomial (given as simple coffs)
     * @param coffA coefficients of bezier to square
     * @param scale scale factor
     * @return false if order mismatch -- must have `2 * bezierA.length  === this.order + 1`
     */
    addSquaredSquaredBezier(coffA, scale) {
        const orderA = coffA.length;
        const orderC = this.order;
        if (orderA * 2 !== orderC + 1)
            return false;
        const pascalA = PascalCoefficients_1.PascalCoefficients.getRow(orderA - 1);
        const pascalC = PascalCoefficients_1.PascalCoefficients.getRow(orderC - 1);
        const coffC = this.coffs;
        for (let iA = 0; iA < orderA; iA++) {
            const a = coffA[iA] * pascalA[iA] * scale;
            for (let iB = 0; iB < orderA; iB++) {
                const b = coffA[iB] * pascalA[iB];
                const iC = iA + iB;
                const c = pascalC[iC];
                coffC[iC] += a * b / c;
            }
        }
        return true;
    }
    /** evaluate the basis fucntions at specified u.
     * @param u bezier parameter for evaluation.
     * @returns Return a (newly allocated) array of basis function values.
     */
    basisFunctions(u, result) {
        this._basisValues = PascalCoefficients_1.PascalCoefficients.getBezierBasisValues(this.order, u, this._basisValues);
        if (!result || result.length !== this.order)
            result = new Float64Array(this.order);
        let i = 0;
        for (const a of this._basisValues)
            result[i++] = a;
        return result;
    }
    /**
     * Sum weights[i] * data[...] in blocks of numPerBlock.
     * This is for low level use -- counts are not checked.
     * @param weights
     * @param data
     * @param numPerBlock
     */
    static sumWeightedBlocks(weights, numWeights, data, numPerBlock, result) {
        for (let k0 = 0; k0 < numPerBlock; k0++) {
            result[k0] = 0;
        }
        let k = 0;
        let i;
        for (let iWeight = 0; iWeight < numWeights; iWeight++) {
            const w = weights[iWeight];
            for (i = 0; i < numPerBlock; i++) {
                result[i] += w * data[k++];
            }
        }
    }
    /**
     * Given (multidimensional) control points, sum the control points weighted by the basis fucntion values at parameter u.
     * @param u bezier parameter
     * @param polygon Array with coefficients in blocks.
     * @param blockSize size of blocks
     * @param result `blockSize` summed values.
     */
    sumBasisFunctions(u, polygon, blockSize, result) {
        const order = this._order;
        if (!result)
            result = new Float64Array(order);
        this._basisValues = PascalCoefficients_1.PascalCoefficients.getBezierBasisValues(this.order, u, this._basisValues);
        UnivariateBezier.sumWeightedBlocks(this._basisValues, order, polygon, blockSize, result);
        return result;
    }
    /**
     * Given (multidimensional) control points, sum the control points weighted by the basis function derivative values at parameter u.
     * @param u bezier parameter
     * @param polygon Array with coefficients in blocks.
     * @param blockSize size of blocks
     * @param result `blockSize` summed values.
     */
    sumBasisFunctionDerivatives(u, polygon, blockSize, result) {
        const order = this._order;
        if (!result)
            result = new Float64Array(blockSize);
        this._basisValues = PascalCoefficients_1.PascalCoefficients.getBezierBasisDerivatives(this.order, u, this._basisValues);
        UnivariateBezier.sumWeightedBlocks(this._basisValues, order, polygon, blockSize, result);
        return result;
    }
    /**
     * Evaluate the bezier function at a parameter value.  (i.e. summ the basis functions times coefficients)
     * @param u parameter for evaluation
     */
    evaluate(u) {
        this._basisValues = PascalCoefficients_1.PascalCoefficients.getBezierBasisValues(this.order, u, this._basisValues);
        let sum = 0;
        for (let i = 0; i < this.order; i++)
            sum += this._basisValues[i] * this.coffs[i];
        return sum;
    }
    /**
     * Apply deflation from the left to a bezier.
     * * This assumes that the left coefficient is zero.
     */
    deflateLeft() {
        // coefficient 0 is zero (caller promises.)
        // get bezier coffs for both orders ...
        const order1 = this.order;
        const order0 = order1 - 1;
        const coff0 = PascalCoefficients_1.PascalCoefficients.getRow(order0 - 1);
        const coff1 = PascalCoefficients_1.PascalCoefficients.getRow(order1 - 1);
        let a;
        for (let i = 0; i < order0; i++) {
            a = this.coffs[i + 1];
            this.coffs[i] = a * coff1[i + 1] / coff0[i];
        }
        this._order--;
    }
    /**
     * Apply deflation from the right to a frame.
     * * This assumes that the right coefficient is zero.
     * @param frame frame description
     */
    deflateRight() {
        // final coefficient is zero (caller promises.)
        // get bezier coffs for both orders ...
        const order1 = this.order;
        const order0 = order1 - 1;
        const coff0 = PascalCoefficients_1.PascalCoefficients.getRow(order0 - 1);
        const coff1 = PascalCoefficients_1.PascalCoefficients.getRow(order1 - 1);
        let a, b;
        for (let i = 0; i < order0; i++) {
            a = this.coffs[i];
            b = a * coff1[i] / coff0[i];
            this.coffs[i] = b;
        }
        this._order--;
    }
    /**
     * divide the polynomial by `(x-root)`.
     * * If `root` is truly a root.
     * @param root root to remove
     */
    deflateRoot(root) {
        const orderA = this.order;
        const orderC = orderA - 1; // the order of the deflated bezier.
        if (orderA === 1) {
            this._order = 0;
            return this.coffs[0];
        }
        if (orderA < 1) {
            this._order = 0;
            return 0.0;
        }
        const pascalA = PascalCoefficients_1.PascalCoefficients.getRow(orderA - 1);
        const pascalC = PascalCoefficients_1.PascalCoefficients.getRow(orderC - 1);
        const b0 = -root;
        const b1 = 1.0 - root;
        let remainder = 0;
        if (root > 0.5) {
            let c0 = this.coffs[0] / b0;
            let c1;
            this.coffs[0] = c0;
            let a1 = this.coffs[1];
            for (let i = 1; i < orderC; i++) {
                a1 = this.coffs[i] * pascalA[i];
                c1 = (a1 - c0 * b1) / b0;
                this.coffs[i] = c1 / pascalC[i];
                c0 = c1;
            }
            remainder = this.coffs[orderA - 1] - c0 * b1;
        }
        else {
            // work backwards (to get division by larger of b0, b1)
            // replace coefficients of a starting wtih orderA -1 --
            // at end move them all forward.
            let c1 = this.coffs[orderA - 1] / b1;
            let c0;
            this.coffs[orderA - 1] = c1;
            let a1;
            for (let i = orderA - 2; i > 0; i--) {
                a1 = this.coffs[i] * pascalA[i];
                c0 = (a1 - c1 * b0) / b1;
                this.coffs[i] = c0 / pascalC[i - 1]; // pascalC index is from destination, which is not shifted.
                c1 = c0;
            }
            remainder = (this.coffs[0] - c1 * b0);
            for (let i = 0; i < orderC; i++)
                this.coffs[i] = this.coffs[i + 1];
        }
        this._order = orderC;
        // This should be zero !!!! (If not, `root` was not really a root!!)
        return remainder;
    }
    /**
     * Run a Newton iteration from startFraction.
     * @param startFraction [in] fraction for first iteration
     * @param tolerance [in] convergence tolerance.   The iteration is considered converged on the
     * second time the tolerance is satisfied.   For a typical iteration (not double root), the extra pass
     * will double the number of digits.  Hence this tolerance is normally set to 10 to 12 digits, trusting
     * that the final iteration will clean it up to nearly machine precision.
     * @returns final fraction of iteration if converged.  undefined if iteration failed to converge.
     */
    runNewton(startFraction, tolerance = 1.0e-11) {
        const derivativeFactor = this.order - 1;
        let numConverged = 0;
        let u = startFraction;
        let f, df;
        const bigStep = 10.0;
        const order = this.order;
        const coffs = this.coffs;
        const orderD = order - 1;
        for (let iterations = 0; iterations++ < 10;) {
            UnivariateBezier._basisBuffer = PascalCoefficients_1.PascalCoefficients.getBezierBasisValues(order, u, UnivariateBezier._basisBuffer);
            f = 0;
            for (let i = 0; i < order; i++)
                f += coffs[i] * UnivariateBezier._basisBuffer[i];
            UnivariateBezier._basisBuffer1 = PascalCoefficients_1.PascalCoefficients.getBezierBasisValues(orderD, u, UnivariateBezier._basisBuffer1);
            df = 0;
            for (let i = 0; i < orderD; i++)
                df += (coffs[i + 1] - coffs[i]) * UnivariateBezier._basisBuffer1[i];
            df *= derivativeFactor;
            if (Math.abs(f) > bigStep * Math.abs(df))
                return undefined;
            const du = f / df;
            if (Math.abs(du) < tolerance) {
                numConverged++;
                if (numConverged >= 2)
                    return u - du;
            }
            else {
                numConverged = 0;
            }
            u -= du;
        }
        return undefined;
    }
    // Deflation table.  b0, b1 are coefficients of term being divided out
    // Pascal coffs for b0,b1 are just 1.
    // Each ai is a coefficient of the (known) input, with its Pascal coefficient blended in.
    // each ci is a coefficient of the (unknown) result, with its coefficient blended in.
    // note b0, b1 are both nonzero, so the divisions are safe.
    // within the products, each c[i]*b0 pairs with c[i-1]*b1 (above and right diagonally) to make a[i]
    // first and last c0*b0 and c[orderC-1]*b1 make a0 and a[orderA-1]
    // |    |  b0    | b1      |   equivalence               | solve moving down
    // | c0 | c0* b0 | c0 * b1 |    a0 = c0 * b0             | c0 = a0 / b0
    // | c1 | c1* b0 | c1 * b1 |    a1 = c1 * b0 + c0 * b1   | c1 = (a1 - c0 * b1) / b0
    // | c2 | c2* b0 | c2 * b1
    // Each internal ci = (ai - c[i-1] * b1) /b0
    // first c0*b0 = a0
    // last c[orderC-1]*b1 = a[orderA-1]
    static deflateRoots01(bezier) {
        const roots = [];
        const coffs = bezier.coffs;
        let a0, a1, segmentFraction, globalStartFraction, newtonFraction;
        while (bezier.order > 1) {
            const order = bezier.order;
            // Find any crossing
            if (coffs[0] === 0.0) {
                bezier.deflateLeft();
                roots.push(0.0);
                continue;
            }
            let numCrossing = 0;
            let numNewtonOK = 0;
            for (let i = 1; i < order; i++) {
                a0 = coffs[i - 1];
                a1 = coffs[i];
                if (a0 * a1 <= 0.0) {
                    numCrossing++;
                    segmentFraction = -a0 / (a1 - a0);
                    globalStartFraction = (i - 1 + segmentFraction) / (order - 1);
                    newtonFraction = bezier.runNewton(globalStartFraction, 1.0e-10);
                    if (newtonFraction !== undefined) {
                        roots.push(newtonFraction);
                        bezier.deflateRoot(newtonFraction);
                        numNewtonOK++;
                        break;
                    }
                }
            }
            if (numNewtonOK)
                continue;
            // if any crossing was found and led to a good newton, the "continue" jumped past this.
            // if no crossings found, there are no roots to be had -- accept
            if (numCrossing === 0)
                return roots;
            // reach here if there were crossings but not roots.
            // is this just a local min?  or maybe a big problem?   Whatever, accept it
            return roots;
        }
        return roots;
    }
}
exports.UnivariateBezier = UnivariateBezier;
/** Bezier polynomial specialized to order 2 (2 coefficients, straight line function) */
class Order2Bezier extends BezierCoffs {
    constructor(f0 = 0.0, f1 = 0.0) {
        super(2);
        this.coffs[0] = f0;
        this.coffs[1] = f1;
    }
    /** return an Order2Bezier (linear) with the two coefficients from this Order2Bezier */
    clone() {
        return new Order2Bezier(this.coffs[0], this.coffs[1]);
    }
    /** normally, return fractional coordinate where bezier (a0,a1) has a root.
     * but if the fraction would exceed Geometry.largeFractionResult, return undefined.
     */
    static solveCoffs(a0, a1) {
        return Geometry_1.Geometry.conditionalDivideFraction(-a0, (a1 - a0));
    }
    /** evaluate the basis fucntions at specified u.
     * @param u bezier parameter for evaluation.
     * @returns Return a (newly allocated) array of basis function values.
     */
    basisFunctions(u, result) {
        if (!result)
            result = new Float64Array(2);
        result[0] = 1.0 - u;
        result[1] = u;
        return result;
    }
    /** evaluate the basis fucntions at specified u.   Sum multidimensional control points with basis weights.
     * @param u bezier parameter for evaluation.
     * @param n dimension of control points.
     * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.
     * @param result optional destination for values.   ASSUMED size `order`
     * @returns Return a (newly allocated) array of basis function values.
     */
    sumBasisFunctions(u, polygon, n, result) {
        if (!result)
            result = new Float64Array(n);
        const v = 1.0 - u;
        for (let i = 0; i < n; i++) {
            result[i] = v * polygon[i] + u * polygon[i + n];
        }
        return result;
    }
    /** evaluate the blocked derivative at u.
     * @param u bezier parameter for evaluation.
     * @param n dimension of control points.
     * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.
     * @param result optional destination for values.   ASSUMED size `order`
     * @returns Return a (newly allocated) array of basis function values.
     */
    sumBasisFunctionDerivatives(_u, polygon, n, result) {
        if (!result)
            result = new Float64Array(n);
        for (let i = 0; i < n; i++) {
            result[i] = polygon[i + n] - polygon[i];
        }
        return result;
    }
    /**
     * Evaluate the bezier function at a parameter value.  (i.e. summ the basis functions times coefficients)
     * @param u parameter for evaluation
     */
    evaluate(u) {
        return (1.0 - u) * this.coffs[0] + u * this.coffs[1];
    }
    // "just like" roots() but never creates an array.
    solve(rightHandSide) {
        const df = this.coffs[1] - this.coffs[0];
        return Geometry_1.Geometry.conditionalDivideFraction(rightHandSide - this.coffs[0], df);
    }
    /**
     * Concrete implementation of the abstract roots method
     * @param targetValue target function value.
     * @param restrictTo01 flag for optional second step to eliminate root outside 0..1.
     * @returns If no roots, return undefined.  If single root, return an array with the root.
     */
    roots(targetValue, restrictTo01) {
        const x = this.solve(targetValue);
        if (x === undefined)
            return undefined;
        if (!restrictTo01 || Geometry_1.Geometry.isIn01(x))
            return [x];
        return undefined;
    }
}
exports.Order2Bezier = Order2Bezier;
/** Bezier polynomial specialized to order 3 (3 coefficients, paraboloa  function) */
class Order3Bezier extends BezierCoffs {
    constructor(f0 = 0, f1 = 0, f2 = 0) {
        super(3);
        this.coffs[0] = f0;
        this.coffs[1] = f1;
        this.coffs[2] = f2;
    }
    clone() {
        return new Order3Bezier(this.coffs[0], this.coffs[1], this.coffs[2]);
    }
    /** evaluate the basis fucntions at specified u.
     * @param u bezier parameter for evaluation.
     * @returns Return a (newly allocated) array of basis function values.
     */
    basisFunctions(u, result) {
        if (!result)
            result = new Float64Array(3);
        const v = 1.0 - u;
        result[0] = v * v;
        result[1] = 2.0 * u * v;
        result[2] = u * u;
        return result;
    }
    /** evaluate the basis fucntions at specified u.   Sum multidimensional control points with basis weights.
     * @param u bezier parameter for evaluation.
     * @param n dimension of control points.
     * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.
     * @param result optional destination for values.   ASSUMED size `order`
     * @returns Return a (newly allocated) array of basis function values.
     */
    sumBasisFunctions(u, polygon, n, result) {
        if (!result)
            result = new Float64Array(n);
        const v = 1 - u;
        const b0 = v * v;
        const b1 = 2 * u * v;
        const b2 = u * u;
        for (let i = 0; i < n; i++) {
            result[i] = b0 * polygon[i] + b1 * polygon[i + n] + b2 * polygon[i + 2 * n];
        }
        return result;
    }
    /** evaluate the blocked derivative at u.
     * @param u bezier parameter for evaluation.
     * @param n dimension of control points.
     * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.
     * @param result optional destination for values.   ASSUMED size `order`
     * @returns Return a (newly allocated) array of basis function values.
     */
    sumBasisFunctionDerivatives(u, polygon, n, result) {
        if (!result)
            result = new Float64Array(n);
        const f0 = 2 * (1 - u);
        const f1 = 2 * u;
        const n2 = 2 * n;
        for (let i = 0; i < n; i++) {
            const q = polygon[i + n];
            result[i] = f0 * (q - polygon[i]) + f1 * (polygon[i + n2] - q);
        }
        return result;
    }
    /**
     * Add the square of a linear bezier.
     * @param f0 linear factor value at u=0.
     * @param f1 linear factor value at u=1.
     * @param a  scale factor.
     */
    addSquareLinear(f0, f1, a) {
        this.coffs[0] += a * f0 * f0;
        this.coffs[1] += a * f0 * f1;
        this.coffs[2] += a * f1 * f1;
    }
    roots(targetValue, restrictTo01) {
        const a0 = this.coffs[0] - targetValue;
        const a1 = this.coffs[1] - targetValue;
        const a2 = this.coffs[2] - targetValue;
        const a01 = a1 - a0;
        const a12 = a2 - a1;
        const a012 = a12 - a01;
        const roots = Polynomials_1.Degree2PowerPolynomial.solveQuadratic(a012, 2.0 * a01, a0);
        return super.filter01(roots, restrictTo01);
    }
    /**
     * Evaluate the bezier function at a parameter value.  (i.e. summ the basis functions times coefficients)
     * @param u parameter for evaluation
     */
    evaluate(u) {
        const v = 1.0 - u;
        return this.coffs[0] * v * v + u * (2.0 * this.coffs[1] * v + this.coffs[2] * u);
    }
}
exports.Order3Bezier = Order3Bezier;
/** Bezier polynomial specialized to order 4 (4 coefficients, cubic  function) */
class Order4Bezier extends BezierCoffs {
    constructor(f0 = 0, f1 = 0, f2 = 0, f3 = 0) {
        super(4);
        this.coffs[0] = f0;
        this.coffs[1] = f1;
        this.coffs[2] = f2;
        this.coffs[3] = f3;
    }
    clone() {
        return new Order4Bezier(this.coffs[0], this.coffs[1], this.coffs[2], this.coffs[3]);
    }
    static createProductOrder3Order2(factorA, factorB) {
        return new Order4Bezier(factorA.coffs[0] * factorB.coffs[0], (factorA.coffs[0] * factorB.coffs[1] + 2.0 * factorA.coffs[1] * factorB.coffs[0]) / 3.0, (2.0 * factorA.coffs[1] * factorB.coffs[1] + factorA.coffs[2] * factorB.coffs[0]) / 3.0, factorA.coffs[2] * factorB.coffs[1]);
    }
    /** evaluate the basis fucntions at specified u.
     * @param u bezier parameter for evaluation.
     * @returns Return a (newly allocated) array of basis function values.
     */
    basisFunctions(u, result) {
        if (!result)
            result = new Float64Array(4);
        const v = 1.0 - u;
        const uu = u * u;
        const vv = v * v;
        result[0] = vv * v;
        result[1] = 3.0 * vv * u;
        result[2] = 3.0 * v * uu;
        result[3] = u * uu;
        return result;
    }
    /** evaluate the basis fucntions at specified u.   Sum multidimensional control points with basis weights.
     * @param u bezier parameter for evaluation.
     * @param n dimension of control points.
     * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.
     * @param result optional destination for values.   ASSUMED size `order`
     * @returns Return a (newly allocated) array of basis function values.
     */
    sumBasisFunctions(u, polygon, n, result) {
        if (!result)
            result = new Float64Array(n);
        const v = 1 - u;
        const uu = u * u;
        const vv = v * v;
        const b0 = v * vv;
        const b1 = 3 * u * vv;
        const b2 = 3 * uu * v;
        const b3 = u * uu;
        for (let i = 0; i < n; i++) {
            result[i] = b0 * polygon[i] + b1 * polygon[i + n] + b2 * polygon[i + 2 * n] + b3 * polygon[i + 3 * n];
        }
        return result;
    }
    /** evaluate the blocked derivative at u.
     * @param u bezier parameter for evaluation.
     * @param n dimension of control points.
     * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.
     * @param result optional destination for values.   ASSUMED size `order`
     * @returns Return a (newly allocated) array of basis function values.
     */
    sumBasisFunctionDerivatives(u, polygon, n, result) {
        if (!result)
            result = new Float64Array(n);
        const v = 1 - u;
        // QUADRATIC basis functions applied to differences ... (with factor 3 for derivative)
        const f0 = 3 * (v * v);
        const f1 = 6 * u * v;
        const f2 = 3 * u * u;
        for (let i = 0; i < n; i++) {
            const q0 = polygon[i];
            const q1 = polygon[i + n];
            const q2 = polygon[i + 2 * n];
            const q3 = polygon[i + 3 * n];
            result[i] = f0 * (q1 - q0) + f1 * (q2 - q1) + f2 * (q3 - q2);
        }
        return result;
    }
    /**
     * Evaluate the bezier function at a parameter value.  (i.e. summ the basis functions times coefficients)
     * @param u parameter for evaluation
     */
    evaluate(u) {
        const v1 = 1.0 - u;
        const v2 = v1 * v1;
        const v3 = v2 * v1;
        return this.coffs[0] * v3
            + u * (3.0 * this.coffs[1] * v2
                + u * (3.0 * this.coffs[2] * v1
                    + u * this.coffs[3]));
    }
    /**
     * convert a power polynomial to bezier
     */
    static createFromDegree3PowerPolynomial(source) {
        const f0 = source.evaluate(0.0);
        const d0 = source.evaluateDerivative(0.0);
        const d1 = source.evaluateDerivative(1.0);
        const f1 = source.evaluate(1.0);
        const a = 3.0;
        return new Order4Bezier(f0, f0 + d0 / a, f1 - d1 / a, f1);
    }
    // Find solutions (u values) of the bezier-form cubic
    // y0 (1-u)^3 + 3 y1 u(1-u)^2 + 3 y2 u^2 (1-u) + y3 u^3= e
    // i.e. y0, y1, y2, y3 are coefficients of bezier-basis polynomial, e is y level whose crossings
    // are needed.
    //
    realRoots(e, restrictTo01, roots) {
        // Get direct solutions in standard basis
        roots.clear();
        const cc = new Float64Array(4);
        const y0 = this.coffs[0];
        const y1 = this.coffs[1];
        const y2 = this.coffs[2];
        const y3 = this.coffs[3];
        const yMax = Math.max(y0, y1, y2, y3);
        const yMin = Math.min(y0, y1, y2, y3);
        const smallValue = Geometry_1.Geometry.smallMetricDistance;
        if (yMin > smallValue)
            return undefined;
        if (yMax < -smallValue)
            return undefined;
        if (yMin >= -smallValue && yMax < smallValue) {
            // all 4 are near zero . ..
            roots.push(0);
            roots.push(1.0 / 3.0);
            roots.push(2.0 / 3.0);
            roots.push(1.0);
            return; // p(x) == 0 has infinite roots .... return 4, which is a red flag for cubic
        }
        cc[0] = (y0 - e);
        cc[1] = 3.0 * (y1 - y0);
        cc[2] = 3.0 * (y0 - 2.0 * y1 + y2);
        cc[3] = -y0 + 3.0 * y1 - 3.0 * y2 + y3;
        Polynomials_1.AnalyticRoots.appendCubicRoots(cc, roots); // can't have zero solutions after passing minmax conditions . . .
        if (restrictTo01)
            roots.reassign(0, 1);
        return;
    }
}
exports.Order4Bezier = Order4Bezier;
/** Bezier polynomial specialized to order 5 (5 coefficients, quartic  function) */
class Order5Bezier extends BezierCoffs {
    constructor(f0 = 0, f1 = 0, f2 = 0, f3 = 0, f4 = 0) {
        super(5);
        this.coffs[0] = f0;
        this.coffs[1] = f1;
        this.coffs[2] = f2;
        this.coffs[3] = f3;
        this.coffs[4] = f4;
    }
    /**
     * @returns Return a clone of this bezier.
     */
    clone() {
        return new Order5Bezier(this.coffs[0], this.coffs[1], this.coffs[2], this.coffs[3], this.coffs[4]);
    }
    /**
     * convert a power polynomial to bezier
     */
    static createFromDegree4PowerPolynomial(source) {
        const f0 = source.evaluate(0.0);
        const d0 = source.evaluateDerivative(0.0);
        const d4 = source.evaluateDerivative(1.0);
        const f4 = source.evaluate(1.0);
        const a = 0.25;
        const d0a = a * d0;
        const fa = f0 + d0a;
        const fm = 2.0 * fa - f0 + source.coffs[2] / 6.0;
        return new Order5Bezier(f0, fa, fm, f4 - d4 * a, f4);
    }
    /** evaluate the basis fucntions at specified u.
     * @param u bezier parameter for evaluation.
     * @returns Return a (newly allocated) array of basis function values.
     */
    basisFunctions(u, result) {
        if (!result)
            result = new Float64Array(5);
        const v = 1.0 - u;
        const uu = u * u;
        const uuu = uu * u;
        const vv = v * v;
        const vvv = vv * v;
        result[0] = vv * vv;
        result[1] = 4.0 * vvv * u;
        result[2] = 6.0 * vv * uu;
        result[3] = 4.0 * v * uuu;
        result[4] = uu * uu;
        return result;
    }
    /** evaluate the basis fucntions at specified u.   Sum multidimensional control points with basis weights.
     * @param u bezier parameter for evaluation.
     * @param n dimension of control points.
     * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.
     * @param result optional destination for values.   ASSUMED size `order`
     * @returns Return a (newly allocated) array of basis function values.
     */
    sumBasisFunctions(u, polygon, n, result) {
        if (!result)
            result = new Float64Array(n);
        const v = 1.0 - u;
        const uu = u * u;
        const uuu = uu * u;
        const vv = v * v;
        const vvv = vv * v;
        const b0 = vv * vv;
        const b1 = 4.0 * vvv * u;
        const b2 = 6.0 * vv * uu;
        const b3 = 4.0 * v * uuu;
        const b4 = uu * uu;
        for (let i = 0; i < n; i++) {
            result[i] = b0 * polygon[i] + b1 * polygon[i + n] + b2 * polygon[i + 2 * n] + b3 * polygon[i + 3 * n] + b4 * polygon[i + 4 * n];
        }
        return result;
    }
    /** evaluate the blocked derivative at u.
     * @param u bezier parameter for evaluation.
     * @param n dimension of control points.
     * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.
     * @param result optional destination for values.   ASSUMED size `order`
     * @returns Return a (newly allocated) array of basis function values.
     */
    sumBasisFunctionDerivatives(u, polygon, n, result) {
        if (!result)
            result = new Float64Array(n);
        const v = 1 - u;
        // CUBIC basis functions applied to differences ...
        const uu = u * u;
        const vv = v * v;
        const f0 = 4 * v * vv;
        const f1 = 12 * u * vv;
        const f2 = 12 * uu * v;
        const f3 = 4 * u * uu;
        for (let i = 0; i < n; i++) {
            const q0 = polygon[i];
            const q1 = polygon[i + n];
            const q2 = polygon[i + 2 * n];
            const q3 = polygon[i + 3 * n];
            const q4 = polygon[i + 4 * n];
            result[i] = f0 * (q1 - q0) + f1 * (q2 - q1) + f2 * (q3 - q2) + f3 * (q4 - q3);
        }
        return result;
    }
    /**
     * Evaluate the bezier function at a parameter value.  (i.e. summ the basis functions times coefficients)
     * @param u parameter for evaluation
     */
    evaluate(u) {
        const v1 = 1.0 - u;
        const v2 = v1 * v1;
        const v3 = v2 * v1;
        const v4 = v2 * v2;
        return this.coffs[0] * v4
            + u * (4.0 * this.coffs[1] * v3
                + u * (6.0 * this.coffs[2] * v2
                    + u * (4.0 * this.coffs[3] * v1
                        + u * this.coffs[4])));
    }
    addProduct(f, g, a) {
        this.coffs[0] += a * f.coffs[0] * g.coffs[0];
        this.coffs[1] += a * (f.coffs[0] * g.coffs[1] + f.coffs[1] * g.coffs[0]) * 0.5;
        this.coffs[2] += a * (f.coffs[0] * g.coffs[2] + 4.0 * f.coffs[1] * g.coffs[1] + f.coffs[2] * g.coffs[0]) / 6.0;
        this.coffs[3] += a * (f.coffs[1] * g.coffs[2] + f.coffs[2] * g.coffs[1]) * 0.5;
        this.coffs[4] += a * f.coffs[2] * g.coffs[2];
    }
    addConstant(a) {
        for (let i = 0; i < 5; i++)
            this.coffs[i] += a;
    }
    // Find solutions (u values) of the bezier-form quartic
    // y0 (1-u)u^4 + etc = e
    //
    realRoots(e, restrictTo01, roots) {
        roots.clear();
        const y0 = this.coffs[0] - e;
        const y1 = this.coffs[1] - e;
        const y2 = this.coffs[2] - e;
        const y3 = this.coffs[3] - e;
        const y4 = this.coffs[4] - e;
        // Get direct solutions in standard basis
        const yMax = Math.max(y0, y1, y2, y3, y4);
        const yMin = Math.min(y0, y1, y2, y3, y4);
        const smallValue = Geometry_1.Geometry.smallMetricDistance;
        if (yMin > smallValue)
            return undefined;
        if (yMax < -smallValue)
            return undefined;
        if (yMin >= -smallValue && yMax < smallValue) {
            // all 4 are near zero . ..
            roots.push(0);
            roots.push(0.25);
            roots.push(0.5);
            roots.push(0.75);
            roots.push(1.0);
            return; // p(x) == 0 has infinite roots .... return 5, which is a red flag for cubic ...
        }
        const cc = new Float64Array(5);
        cc[0] = (y0 - e);
        cc[1] = 4.0 * (-y0 + y1);
        cc[2] = 6.0 * (y0 - 2.0 * y1 + y2);
        cc[3] = 4.0 * (-y0 + 3.0 * y1 - 3.0 * y2 + y3);
        cc[4] = (y0 - 4.0 * y1 + 6.0 * y2 - 4.0 * y3 + y4);
        Polynomials_1.AnalyticRoots.appendQuarticRoots(cc, roots);
        if (restrictTo01)
            roots.reassign(0, 1);
        return;
    }
}
exports.Order5Bezier = Order5Bezier;


/***/ }),

/***/ "./lib/numerics/ClusterableArray.js":
/*!******************************************!*\
  !*** ./lib/numerics/ClusterableArray.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Numerics */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const GrowableBlockedArray_1 = __webpack_require__(/*! ../geometry3d/GrowableBlockedArray */ "./lib/geometry3d/GrowableBlockedArray.js");
const GrowableXYZArray_1 = __webpack_require__(/*! ../geometry3d/GrowableXYZArray */ "./lib/geometry3d/GrowableXYZArray.js");
class ClusterableArray extends GrowableBlockedArray_1.GrowableBlockedArray {
    /**
     * @param numCoordinatePerPoint number of coordinates per point
     * @param  numExtraDataPerPoint of extra data values per point.
     * @param initialBlockCapacity predicted number of points.  (This does not have to be accurate)
     */
    constructor(numCoordinatePerPoint, numExtraDataPerPoint, initialBlockCapacity) {
        super(1 + numCoordinatePerPoint + numExtraDataPerPoint, initialBlockCapacity);
        this._numExtraDataPerPoint = numExtraDataPerPoint;
        this._numCoordinatePerPoint = numCoordinatePerPoint;
    }
    static sortVectorComponent(index) {
        let c = 1.0;
        for (let i = 1; i < index; i++)
            c *= ClusterableArray._vectorFactor;
        return c;
    }
    /** load a block, placing data[i] at block[i+1] to allow sort coordinate first.
     * @param data array of numDataPerBlock values.
     */
    addBlock(data) {
        const i0 = this.newBlockIndex() + 1;
        const n = Math.min(this.numPerBlock - 1, data.length);
        for (let i = 0; i < n; i++)
            this._data[i0 + i] = data[i];
    }
    /** add a block with directly 2 to 5 listed content parameters.
     * This assumes numDataPerPoint is sufficient for the parameters provided.
     */
    addDirect(x0, x1, x2, x3, x4) {
        const i0 = this.newBlockIndex();
        this._data[i0 + 1] = x0;
        this._data[i0 + 2] = x1;
        if (x2 !== undefined)
            this._data[i0 + 3] = x2;
        if (x3 !== undefined)
            this._data[i0 + 4] = x3;
        if (x4 !== undefined)
            this._data[i0 + 5] = x4;
    }
    /** add a block with directly from a Point2d with 0 to 3 extras
     * This assumes numDataPerPoint is sufficient for the parameters provided.
     */
    addPoint2d(xy, a, b, c) {
        const i0 = this.newBlockIndex();
        this._data[i0 + 1] = xy.x;
        this._data[i0 + 2] = xy.y;
        if (a !== undefined)
            this._data[i0 + 3] = a;
        if (b !== undefined)
            this._data[i0 + 4] = b;
        if (c !== undefined)
            this._data[i0 + 5] = c;
    }
    /** add a block with directly from a Point2d with 0 to 3 extras
     * This assumes numDataPerPoint is sufficient for the parameters provided.
     */
    addPoint3d(xyz, a, b, c) {
        const i0 = this.newBlockIndex();
        this._data[i0 + 1] = xyz.x;
        this._data[i0 + 2] = xyz.y;
        this._data[i0 + 3] = xyz.z;
        if (a !== undefined)
            this._data[i0 + 4] = a;
        if (b !== undefined)
            this._data[i0 + 5] = b;
        if (c !== undefined)
            this._data[i0 + 6] = c;
    }
    getPoint2d(blockIndex, result) {
        const i0 = this.blockIndexToDoubleIndex(blockIndex);
        return Point2dVector2d_1.Point2d.create(this._data[i0 + 1], this._data[i0 + 2], result);
    }
    getPoint3d(blockIndex, result) {
        const i0 = this.blockIndexToDoubleIndex(blockIndex);
        return Point3dVector3d_1.Point3d.create(this._data[i0 + 1], this._data[i0 + 2], this._data[i0 + 3], result);
    }
    /** Return a single extra data value */
    getExtraData(blockIndex, i) {
        const i0 = this.blockIndexToDoubleIndex(blockIndex);
        return this._data[i0 + 1 + this._numCoordinatePerPoint + i];
    }
    /** Return a single data value */
    getData(blockIndex, i) {
        const i0 = this.blockIndexToDoubleIndex(blockIndex);
        return this._data[i0 + i];
    }
    /** Set a single extra data value */
    setExtraData(blockIndex, i, value) {
        const i0 = this.blockIndexToDoubleIndex(blockIndex);
        this._data[i0 + 1 + this._numCoordinatePerPoint + i] = value;
    }
    static isClusterTerminator(x) { return x === ClusterableArray.clusterTerminator; }
    /** Return an array giving clusters of blocks with similar coordinates.
     *
     * * The contents of each block is assumed to be set up so the primary sort coordinate is first.
     *
     * ** simple coordinate blocks (x,y) or (x,y,z) would work fine but have occasional performance problems because points with same x would generate big blocks of
     * candidates for clusters.
     * ** The usual solution is to u value which is a dot product along some skew direction and have the blocks contain (u,x,y) or (u,x,y,z) for 2d versus 3d.
     * ** apply setupPrimaryClusterSort to prepare that!!!
     * * After a simple lexical sort, consecutive blocks that are within tolerance in the 0 component
     * are inspected.  Within that candidate set, all blocks that are within tolerance for ALL components are clustered.
     * * In the output cluster array, clusters are terminated a invalid index. Test for the invalid index with GrowableBlockArray.isClusterTerminator (x)
     */
    clusterIndicesLexical(clusterTolerance = Geometry_1.Geometry.smallMetricDistance) {
        // install primary sort key
        this.setupPrimaryClusterSort();
        // presort by all coordinates ....
        const firstSort = this.sortIndicesLexical();
        const clusterIndices = new Uint32Array(2 * firstSort.length); // worst case: no duplicates, each index goes in followed by terminator.
        let m = 0; // number of cluster indices
        const n = this.numBlocks; // and this must match firstSort.length !!
        let clusterStartBlockIndex = 0;
        let candidateBlockIndex = 0;
        let barrierU = 0.0;
        let i = 0;
        let j = 0;
        const k0 = 1; // beginning of active column for distance
        const k1 = 1 + this._numCoordinatePerPoint;
        for (i = 0; i < n; i++) {
            clusterStartBlockIndex = firstSort[i];
            if (!ClusterableArray.isClusterTerminator(clusterStartBlockIndex)) {
                // unused block, so it becomes a cluster...
                clusterIndices[m++] = clusterStartBlockIndex;
                barrierU = this.component(clusterStartBlockIndex, 0) + clusterTolerance;
                firstSort[i] = ClusterableArray.clusterTerminator;
                for (j = i + 1; j < n; j++) {
                    candidateBlockIndex = firstSort[j];
                    if (candidateBlockIndex === ClusterableArray.clusterTerminator)
                        continue; // nearby in sort direction but already in a cluster.
                    if (this.component(candidateBlockIndex, 0) >= barrierU)
                        break;
                    if (this.distanceBetweenSubBlocks(clusterStartBlockIndex, candidateBlockIndex, k0, k1) < clusterTolerance) {
                        clusterIndices[m++] = candidateBlockIndex; // The candidate is in the block
                        firstSort[j] = ClusterableArray.clusterTerminator; // and it will not be reused as future block base
                    }
                }
                clusterIndices[m++] = ClusterableArray.clusterTerminator;
            }
        }
        // Alas, the clusterIndices array has fluff at the end.  So it has to be copied.
        return clusterIndices.slice(0, m);
    }
    /** setup (overwrite!!) the "0" component with the dot product of numClusterCoordinate later components with a non-axis aligned vector.
     * This is normally called before clusterIndicesLexical.
     */
    setupPrimaryClusterSort() {
        const nb = this.numBlocks;
        const nc = this._numCoordinatePerPoint;
        const vector = new Float64Array(nc);
        vector[0] = 1.0;
        for (let c = 1; c < nc; c++)
            vector[c] = vector[c - 1] * ClusterableArray._vectorFactor;
        let k = 0;
        let dot = 0.0;
        const data = this._data;
        for (let b = 0; b < nb; b++) {
            k = this.blockIndexToDoubleIndex(b);
            dot = 0.0;
            for (let c = 0; c < nc; c++) {
                dot += vector[c] * data[k + 1 + c];
            }
            data[k] = dot;
        }
    }
    ToJSON() {
        const result = [];
        for (let b = 0; b < this.numBlocks; b++) {
            let i = this.blockIndexToDoubleIndex(b);
            const chunk = [b, this._data[i++]];
            const coordinates = [];
            for (let c = 0; c < this._numCoordinatePerPoint; c++)
                coordinates.push(this._data[i++]);
            chunk.push(coordinates);
            for (let c = 0; c < this._numExtraDataPerPoint; c++)
                chunk.push(this._data[i++]);
            result.push(chunk);
        }
        return result;
    }
    /**
     * @returns Return an array of indices from block index to cluster index.
     * @param clusteredBlocks clusters of block indices followed by separators.
     */
    createIndex_blockToClusterIndex(clusteredBlocks) {
        const numBlocks = this.numBlocks;
        const blockToCluster = new Uint32Array(numBlocks);
        blockToCluster.fill(ClusterableArray.clusterTerminator);
        let numCluster = 0;
        for (const b of clusteredBlocks) {
            if (b >= numBlocks) {
                numCluster++;
            }
            else {
                blockToCluster[b] = numCluster;
            }
        }
        return blockToCluster;
    }
    /**
     * @returns Return an array of indices from block index to index of its cluster's start in the cluster index array.
     * @param clusteredBlocks clusters of block indices followed by separators.
     */
    createIndex_blockToClusterStart(clusteredBlocks) {
        const n = clusteredBlocks.length;
        const numBlocks = this.numBlocks;
        const blockToClusterStart = new Uint32Array(numBlocks);
        const terminator = ClusterableArray.clusterTerminator;
        blockToClusterStart.fill(terminator);
        let clusterStart = 0;
        for (let i = 0; i < n; i++) {
            const k = clusteredBlocks[i];
            if (k > numBlocks) {
                clusterStart = i + 1;
            }
            else {
                blockToClusterStart[k] = clusterStart;
            }
        }
        return blockToClusterStart;
    }
    /** count the clusters in the clusteredBlocks array. */
    countClusters(clusteredBlocks) {
        let numClusters = 0;
        const terminator = ClusterableArray.clusterTerminator;
        for (const b of clusteredBlocks) {
            if (b === terminator)
                numClusters++;
        }
        return numClusters;
    }
    /** create a reverse index: given a cluster index k, clusterToClusterStart[k] is the place
     * the cluster's block indices appear in clusterBlocks
     */
    createIndex_clusterToClusterStart(clusteredBlocks) {
        let numCluster = this.countClusters(clusteredBlocks);
        const clusterToClusterStart = new Uint32Array(numCluster);
        const terminator = ClusterableArray.clusterTerminator;
        clusterToClusterStart.fill(terminator);
        const n = clusteredBlocks.length;
        let clusterStart = 0;
        for (let i = 0; i < n; i++) {
            const k = clusteredBlocks[i];
            if (k === terminator) {
                clusterStart = i + 1;
            }
            else if (i === clusterStart) {
                clusterToClusterStart[numCluster++] = clusterStart;
            }
        }
        return clusterToClusterStart;
    }
    /**
     * Sort terminator-delimited subsets of an array of indices into the table, using a single extraData index as sort key.
     * @param blockedIndices [in] indices, organized as blocks of good indices terminated by the clusterTerminator.
     * @param extraDataIndex index of the extra data key.
     */
    sortSubsetsBySingleKey(blockedIndices, dataIndex) {
        const dataOffset = 1 + dataIndex;
        let kBegin = 0;
        let swap;
        let key0, key1;
        const numK = blockedIndices.length;
        for (let kEnd = 0; kEnd < numK; kEnd++) {
            if (blockedIndices[kEnd] === ClusterableArray.clusterTerminator) {
                // sort blockedIndices[kBegin ,= k < kEnd].
                //  (search for minimum remaining, swap  . . )
                for (let k0 = kBegin; k0 + 1 < kEnd; k0++) {
                    key0 = this.getWithinBlock(blockedIndices[k0], dataOffset);
                    for (let k1 = k0 + 1; k1 < kEnd; k1++) {
                        key1 = this.getWithinBlock(blockedIndices[k1], dataOffset);
                        if (key1 < key0) {
                            swap = blockedIndices[k0];
                            blockedIndices[k0] = blockedIndices[k1];
                            blockedIndices[k1] = swap;
                            key0 = key1;
                        }
                    }
                }
                kBegin = kEnd + 1;
            }
        }
    }
    /**
     * @returns packed points with indices mapping old to new.
     * @param data points to cluster.
     */
    static clusterPoint3dArray(data, tolerance = Geometry_1.Geometry.smallMetricDistance) {
        const clusterArray = new ClusterableArray(3, 0, data.length);
        data.forEach((p) => {
            clusterArray.addDirect(p.x, p.y, p.z);
        });
        const order = clusterArray.clusterIndicesLexical(tolerance);
        const result = new PackedPointsWithIndex(data.length);
        let currentClusterIndex = 0;
        let numThisCluster = 0;
        order.forEach((k) => {
            if (ClusterableArray.isClusterTerminator(k)) {
                currentClusterIndex++;
                numThisCluster = 0;
            }
            else {
                if (numThisCluster === 0)
                    result.packedPoints.push(data[k].clone());
                result.oldToNew[k] = currentClusterIndex;
                numThisCluster++;
            }
        });
        return result;
    }
    /**
     * @returns packed points with indices mapping old to new.
     * @param data points to cluster.
     */
    static clusterGrowablePoint3dArray(source, tolerance = Geometry_1.Geometry.smallMetricDistance) {
        const clusterArray = new ClusterableArray(3, 0, source.length);
        const p = Point3dVector3d_1.Point3d.create();
        const numSourcePoint = source.length;
        for (let i = 0; i < numSourcePoint; i++) {
            source.getPoint3dAt(i, p);
            clusterArray.addDirect(p.x, p.y, p.z);
        }
        const order = clusterArray.clusterIndicesLexical(tolerance);
        const result = new PackedPointsWithIndex(source.length);
        const numPackedPoints = clusterArray.countClusters(order);
        result.growablePackedPoints = new GrowableXYZArray_1.GrowableXYZArray(numPackedPoints);
        let currentClusterIndex = 0;
        let numThisCluster = 0;
        order.forEach((k) => {
            if (ClusterableArray.isClusterTerminator(k)) {
                currentClusterIndex++;
                numThisCluster = 0;
            }
            else {
                if (numThisCluster === 0) // This is the first encounter with a new cluster
                    result.growablePackedPoints.pushFromGrowableXYZArray(source, k);
                result.oldToNew[k] = currentClusterIndex;
                numThisCluster++;
            }
        });
        return result;
    }
}
ClusterableArray._vectorFactor = 0.8732; // use 1.0 to rig easy tests.
/** this value is used as cluster terminator in the Uint232rray of indcies. */
ClusterableArray.clusterTerminator = 0xFFffFFff;
exports.ClusterableArray = ClusterableArray;
/**
 * Data carrier class for
 * * packedPoints = an array of Point3d
 * * oldToNew = array of indices from some prior Point3d[] to the packed points.
 */
class PackedPointsWithIndex {
    /** construct a PackedPoints object with
     * * empty packedPoints array
     * * oldToNew indices all initialized to PackedPoints.invalidIndex
     */
    constructor(numOldIndexEntry) {
        this.packedPoints = [];
        this.oldToNew = new Uint32Array(numOldIndexEntry);
        for (let i = 0; i < numOldIndexEntry; i++) {
            this.oldToNew[i] = PackedPointsWithIndex.invalidIndex;
        }
    }
    /**
     * Use the oldToNew array to update an array of "old" indices.
     * @param indices array of indices into prepacked array.
     * @returns true if all input indices were valid for the oldToNew array.
     */
    updateIndices(indices) {
        let numErrors = 0;
        indices.forEach((value, i, data) => {
            if (value < this.oldToNew.length) {
                data[i] = this.oldToNew[value];
            }
            else
                numErrors++;
        });
        return numErrors === 0;
    }
}
PackedPointsWithIndex.invalidIndex = 0xFFFFffff;
exports.PackedPointsWithIndex = PackedPointsWithIndex;


/***/ }),

/***/ "./lib/numerics/Complex.js":
/*!*********************************!*\
  !*** ./lib/numerics/Complex.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Numerics */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Angle_1 = __webpack_require__(/*! ../geometry3d/Angle */ "./lib/geometry3d/Angle.js");
class Complex {
    set x(value) { this._myX = value; }
    get x() { return this._myX; }
    set y(value) { this._myY = value; }
    get y() { return this._myY; }
    constructor(x = 0, y = 0) { this._myX = x; this._myY = y; }
    set(x = 0, y = 0) { this.x = x; this.y = y; }
    setFrom(other) { this.x = other.x; this.y = other.y; }
    clone() { return new Complex(this.x, this.y); }
    isAlmostEqual(other) { return Geometry_1.Geometry.isAlmostEqualNumber(this.x, other.x) && Geometry_1.Geometry.isAlmostEqualNumber(this.x, other.x); }
    static create(x = 0, y = 0, result) {
        if (result) {
            result.x = x;
            result.y = y;
            return result;
        }
        return new Complex(x, y);
    }
    plus(other, result) { return Complex.create(this.x + other.x, this.y + other.y, result); }
    minus(other, result) { return Complex.create(this.x - other.x, this.y - other.y, result); }
    times(other, result) {
        return Complex.create(this.x * other.x - this.y * other.y, this.x * other.y + this.y * other.x, result);
    }
    /** multiply {this * x+i*y}. That is, the second Complex value exists via the args without being formally created as an instance. */
    timesXY(x, y, result) {
        return Complex.create(this.x * x - this.y * y, this.x * y + this.y * x, result);
    }
    magnitude() { return Math.hypot(this.x, this.y); }
    angle() { return Angle_1.Angle.createAtan2(this.y, this.x); }
    distance(other) {
        return Math.hypot(this.x - other.x, this.y - other.y);
    }
    magnitudeSquared() { return this.x * this.x + this.y * this.y; }
    divide(other, result) {
        const bb = other.magnitudeSquared();
        if (bb === 0.0)
            return undefined;
        const divbb = 1.0 / bb;
        return Complex.create((this.x * other.x + this.y * other.y) * divbb, (this.y * other.x - this.x * other.y) * divbb, result);
    }
    sqrt(result) {
        if ((this.x === 0.0) && (this.y === 0.0))
            return Complex.create(0, 0, result);
        const x = Math.abs(this.x);
        const y = Math.abs(this.y);
        let r = 0;
        let w = 0;
        if (x >= y) {
            r = y / x;
            w = Math.sqrt(x) * Math.sqrt(0.5 * (1.0 + Math.sqrt(1.0 + r * r)));
        }
        else {
            r = x / y;
            w = Math.sqrt(y) * Math.sqrt(0.5 * (r + Math.sqrt(1.0 + r * r)));
        }
        if (this.x >= 0.0) {
            return Complex.create(w, this.y / (2.0 * w), result);
        }
        else {
            const y1 = (this.y >= 0) ? w : -w;
            return Complex.create(this.y / (2.0 * y1), y1, result);
        }
    }
    setFromJSON(json) {
        if (Array.isArray(json) && json.length > 1) {
            this.set(json[0], json[1]);
        }
        else if (json && json.x && json.y) {
            this.set(json.x, json.y);
        }
        else {
            this.set(0, 0);
        }
    }
    static fromJSON(json) { const result = new Complex(); result.setFromJSON(json); return result; }
    /**
     * Convert an Complex to a JSON object.
     * @return {*} [x,y]
     */
    toJSON() { return [this.x, this.y]; }
}
exports.Complex = Complex;


/***/ }),

/***/ "./lib/numerics/ConvexPolygon2d.js":
/*!*****************************************!*\
  !*** ./lib/numerics/ConvexPolygon2d.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Numerics */
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Range_1 = __webpack_require__(/*! ../geometry3d/Range */ "./lib/geometry3d/Range.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
class Ray2d {
    constructor(origin, direction) {
        this._origin = origin;
        this._direction = direction;
    }
    static createOriginAndTarget(origin, target) {
        return new Ray2d(origin.clone(), origin.vectorTo(target));
    }
    static createOriginAndDirection(origin, direction) {
        return new Ray2d(origin.clone(), direction.clone());
    }
    static createOriginAndDirectionCapture(origin, direction) {
        return new Ray2d(origin, direction);
    }
    get origin() { return this._origin; }
    get direction() { return this._direction; }
    /**
     *  Return a ray that is parallel at distance to the left, specified as fraction of the ray's direction vector.
     */
    parallelRay(leftFraction) {
        return new Ray2d(this._origin.addForwardLeft(0.0, leftFraction, this._direction), this._direction);
    }
    CCWPerpendicularRay() {
        return new Ray2d(this._origin, this._direction.rotate90CCWXY());
    }
    CWPerpendicularRay() {
        return new Ray2d(this._origin, this._direction.rotate90CWXY());
    }
    normalizeDirectionInPlace() {
        if (this._direction.normalize(this._direction)) {
            return true;
        }
        else {
            this._direction.x = 1.0;
            this._direction.y = 0.0;
            // magnitude = 0.0;
            return false;
        }
    }
    /**
     * Intersect this ray (ASSUMED NORMALIZED) with unbounded line defined by points.
     *  (The normalization assumption affects test for parallel vectors.)
     *  Fraction and dhds passed as number[] to use by reference... Sticking to return of true and false in the case fraction is zero after
     *  a true safe divide
     */
    intersectUnboundedLine(linePointA, linePointB, fraction, dhds) {
        const lineDirection = linePointA.vectorTo(linePointB);
        const vector0 = linePointA.vectorTo(this._origin);
        const h0 = vector0.crossProduct(lineDirection);
        dhds[0] = this._direction.crossProduct(lineDirection);
        // h = h0 + s * dh
        const ff = Geometry_1.Geometry.conditionalDivideFraction(-h0, dhds[0]);
        if (ff !== undefined) {
            fraction[0] = ff;
            return true;
        }
        else {
            fraction[0] = 0.0;
            return false;
        }
    }
    /** return the ray fraction where point projects to the ray */
    projectionFraction(point) {
        return this._origin.vectorTo(point).fractionOfProjectionToVector(this._direction);
    }
    /** return the fraction of projection to the perpendicular ray */
    perpendicularProjectionFraction(point) {
        const uv = this._direction.crossProduct(this._origin.vectorTo(point));
        const uu = this._direction.magnitudeSquared();
        // Want zero returned if failure case, not undefined
        return Geometry_1.Geometry.safeDivideFraction(uv, uu, 0.0);
    }
    /** Return point from origin plus a scaled vector */
    fractionToPoint(f) {
        return this._origin.plusScaled(this._direction, f);
    }
}
exports.Ray2d = Ray2d;
class ConvexPolygon2d {
    constructor(points) {
        this._hullPoints = [];
        // Deep copy of points array given
        for (const point of points) {
            this._hullPoints.push(point);
        }
    }
    /** Create the hull */
    static createHull(points) {
        return new ConvexPolygon2d(ConvexPolygon2d.computeConvexHull(points));
    }
    /** Create the hull. First try to use the points as given. */
    static createHullIsValidCheck(points) {
        if (ConvexPolygon2d.isValidConvexHull(points))
            return new ConvexPolygon2d(points);
        else
            return new ConvexPolygon2d(ConvexPolygon2d.computeConvexHull(points));
    }
    /** Return a reference of the hull points. */
    get points() {
        return this._hullPoints;
    }
    /** Test if hull points are a convex, CCW polygon */
    static isValidConvexHull(points) {
        if (points.length < 3)
            return false;
        const n = points.length;
        for (let i = 0; i < n; i++) {
            const i1 = (i + 1) % n;
            const i2 = (i + 2) % n;
            if (points[i].crossProductToPoints(points[i1], points[i2]) < 0.0)
                return false;
        }
        return true;
    }
    /** Return true if the convex hull (to the left of the edges) contains the test point */
    containsPoint(point) {
        let xy0 = this._hullPoints[this._hullPoints.length - 1];
        // double tol = -1.0e-20;  negative tol!!
        for (const i of this._hullPoints) {
            const xy1 = i;
            const c = xy0.crossProductToPoints(xy1, point);
            if (c < 0.0)
                return false;
            xy0 = i;
        }
        return true;
    }
    /** Return the largest outside. (return 0 if in or on) */
    distanceOutside(xy) {
        let maxDistance = 0.0;
        const n = this._hullPoints.length;
        let xy0 = this._hullPoints[n - 1];
        // double tol = -1.0e-20;  // negative tol!!
        for (let i = 0; i < n; i++) {
            const xy1 = this._hullPoints[i];
            const c = xy0.crossProductToPoints(xy1, xy);
            if (c < 0.0) {
                const ray = Ray2d.createOriginAndTarget(xy0, xy1);
                const s = ray.projectionFraction(xy);
                let d = 0.0;
                if (s < 0.0)
                    d = xy0.distance(xy);
                else if (s > 1.0)
                    d = xy1.distance(xy);
                else
                    d = xy.distance(ray.fractionToPoint(s));
                if (d > maxDistance)
                    maxDistance = d;
            }
            xy0 = this._hullPoints[i];
        }
        return maxDistance;
    }
    /** Offset the entire hull (in place) by distance.
     * Returns false if an undefined occurred from normalizing (could occur after changing some hull points already)
     */
    offsetInPlace(distance) {
        const n = this._hullPoints.length;
        if (n >= 3) {
            const hullPoint0 = this._hullPoints[0];
            let edgeA = this._hullPoints[n - 1].vectorTo(hullPoint0);
            edgeA = edgeA.normalize();
            if (edgeA === undefined) {
                return false;
            }
            let perpA = edgeA.rotate90CWXY();
            let edgeB;
            let perpB;
            for (let i = 0; i < n; i++) {
                const j = i + 1;
                edgeB = this._hullPoints[i].vectorTo(j < n ? this._hullPoints[j] : hullPoint0);
                edgeB = edgeB.normalize();
                if (edgeB === undefined) {
                    return false;
                }
                perpB = edgeB.rotate90CWXY();
                const offsetBisector = Point2dVector2d_1.Vector2d.createOffsetBisector(perpA, perpB, distance);
                if (offsetBisector === undefined) {
                    return false;
                }
                this._hullPoints[i] = this._hullPoints[i].plus(offsetBisector);
                // PerpA takes up reference to perpB, as perpB will die in new iteration
                perpA = perpB;
            }
        }
        return true;
    }
    /**
     * Return 2 distances bounding the intersection of the ray with a convex hull.
     * ASSUME (for tolerancing) the ray has normalized direction vector.
     * Both negative and positive distances along the ray are possible.
     * Returns range with extremities if less than 3 points, distanceA > distanceB, or if cross product < 0
     */
    clipRay(ray) {
        let distanceA = -Number.MAX_VALUE;
        let distanceB = Number.MAX_VALUE;
        const n = this._hullPoints.length;
        if (n < 3)
            return Range_1.Range1d.createNull();
        let xy0 = this._hullPoints[n - 1];
        for (const xy1 of this._hullPoints) {
            const distance = [];
            const dhds = [];
            if (ray.intersectUnboundedLine(xy0, xy1, distance, dhds)) {
                if (dhds[0] > 0.0) {
                    if (distance[0] < distanceB)
                        distanceB = distance[0];
                }
                else {
                    if (distance[0] > distanceA)
                        distanceA = distance[0];
                }
                if (distanceA > distanceB)
                    return Range_1.Range1d.createNull();
            }
            else {
                // ray is parallel to the edge.
                // Any single point out classifies it all . ..
                if (xy0.crossProductToPoints(xy1, ray.origin) < 0.0)
                    return Range_1.Range1d.createNull();
            }
            // xy1 is reassigned with each new loop
            xy0 = xy1;
        }
        const range = Range_1.Range1d.createNull();
        range.extendX(distanceA);
        range.extendX(distanceB);
        return range;
    }
    /** Return the range of (fractional) ray postions for projections of all points from the arrays. */
    rangeAlongRay(ray) {
        const range = Range_1.Range1d.createNull();
        for (const xy1 of this._hullPoints)
            range.extendX(ray.projectionFraction(xy1));
        return range;
    }
    /** Return the range of (fractional) ray postions for projections of all points from the arrays. */
    rangePerpendicularToRay(ray) {
        const range = Range_1.Range1d.createNull();
        for (const xy1 of this._hullPoints)
            range.extendX(ray.perpendicularProjectionFraction(xy1));
        return range;
    }
    /** Computes the hull of a convex polygon from points given. Returns the hull as a new Point2d array.
     *  Returns an empty hull if less than 3 points are given.
     */
    static computeConvexHull(points) {
        const hull = [];
        const n = points.length;
        if (n < 3)
            return hull;
        // Get deep copy
        const xy1 = points.slice(0, n);
        xy1.sort(Geometry_1.Geometry.lexicalXYLessThan);
        hull.push(xy1[0]); // This is sure to stay
        hull.push(xy1[1]); // This one can be removed in loop.
        // First sweep creates upper hull
        for (let i = 2; i < n; i++) {
            const candidate = xy1[i];
            let top = hull.length - 1;
            while (top > 0 && hull[top - 1].crossProductToPoints(hull[top], candidate) <= 0.0) {
                top--;
                hull.pop();
            }
            hull.push(candidate);
        }
        // Second sweep creates lower hull right to left
        const i0 = hull.length - 1;
        // xy1.back () is already on stack.
        hull.push(xy1[n - 2]);
        for (let i = n - 2; i-- > 0;) {
            const candidate = xy1[i];
            let top = hull.length - 1;
            while (top > i0 && hull[top - 1].crossProductToPoints(hull[top], candidate) <= 0.0) {
                top--;
                hull.pop();
            }
            if (i > 0) // don't replicate start point!!!
                hull.push(candidate);
        }
        return hull;
    }
}
exports.ConvexPolygon2d = ConvexPolygon2d;


/***/ }),

/***/ "./lib/numerics/Newton.js":
/*!********************************!*\
  !*** ./lib/numerics/Newton.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Numerics */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Plane3dByOriginAndVectors_1 = __webpack_require__(/*! ../geometry3d/Plane3dByOriginAndVectors */ "./lib/geometry3d/Plane3dByOriginAndVectors.js");
const Polynomials_1 = __webpack_require__(/*! ./Polynomials */ "./lib/numerics/Polynomials.js");
/** base class for Newton iterations in various dimensions.
 * Dimension-specific classes carry all dimension-related data and answer generalized queries
 * from this base class.
 */
class AbstractNewtonIterator {
    /**
     * @param stepSizeTarget tolerance to consider a single step converged.
     * This number should be "moderately" strict.   Because 2 successive convergences are required,
     * it is expected that a first "accept" for (say) 10 to 14 digit step will be followed by another
     * iteration.   A well behaved newton would then hypothetically double the number of digits to
     * 20 to 28.  Since the IEEE double only carries 16 digits, this second-convergence step will
     * typically achieve full precision.
     * @param successiveConvergenceTarget number of successive convergences required for acceptance.
     * @param maxIterations max number of iterations.   A typical newton step converges in 3 to 6 iterations.
     *     Allow 15 to 20 to catch difficult cases.
     */
    constructor(stepSizeTolerance = 1.0e-11, successiveConvergenceTarget = 2, maxIterations = 15) {
        this._numAccepted = 0;
        this.numIterations = 0;
        this._stepSizeTolerance = stepSizeTolerance;
        this._successiveConvergenceTarget = successiveConvergenceTarget;
        this._maxIterations = maxIterations;
    }
    testConvergence(delta) {
        if (Math.abs(delta) < this._stepSizeTolerance) {
            this._numAccepted++;
            return this._numAccepted >= this._successiveConvergenceTarget;
        }
        this._numAccepted = 0;
        return false;
    }
    runIterations() {
        this._numAccepted = 0;
        this.numIterations = 0;
        while (this.numIterations++ < this._maxIterations && this.computeStep()) {
            if (this.testConvergence(this.currentStepSize())
                && this.applyCurrentStep(true)) {
                return true;
            }
            this.applyCurrentStep(false);
        }
        return false;
    }
}
exports.AbstractNewtonIterator = AbstractNewtonIterator;
/** object to evaluate a newton function.  The object must retain most-recent function and derivative
 * values for immediate query.
 */
class NewtonEvaluatorRtoRD {
}
exports.NewtonEvaluatorRtoRD = NewtonEvaluatorRtoRD;
class Newton1dUnbounded extends AbstractNewtonIterator {
    constructor(func) {
        super();
        this._func = func;
        this.setTarget(0);
    }
    setX(x) { this._currentX = x; return true; }
    getX() { return this._currentX; }
    setTarget(y) { this._target = y; }
    applyCurrentStep() { return this.setX(this._currentX - this._currentStep); }
    /** Univariate newton step : */
    computeStep() {
        if (this._func.evaluate(this._currentX)) {
            const dx = Geometry_1.Geometry.conditionalDivideFraction(this._func.currentF - this._target, this._func.currentdFdX);
            if (dx !== undefined) {
                this._currentStep = dx;
                return true;
            }
        }
        return false;
    }
    currentStepSize() {
        return Math.abs(this._currentStep / (1.0 + Math.abs(this._currentX)));
    }
}
exports.Newton1dUnbounded = Newton1dUnbounded;
/** object to evaluate a newton function (without derivative).  The object must retain most-recent function value.
 */
class NewtonEvaluatorRtoR {
}
exports.NewtonEvaluatorRtoR = NewtonEvaluatorRtoR;
/** Newton iteration for a univariate function, using approximate derivatives. */
class Newton1dUnboundedApproximateDerivative extends AbstractNewtonIterator {
    constructor(func) {
        super();
        this._func = func;
        this.derivativeH = 1.0e-8;
    }
    setX(x) { this._currentX = x; return true; }
    getX() { return this._currentX; }
    applyCurrentStep() { return this.setX(this._currentX - this._currentStep); }
    /** Univariate newton step : */
    computeStep() {
        if (this._func.evaluate(this._currentX)) {
            const fA = this._func.currentF;
            if (this._func.evaluate(this._currentX + this.derivativeH)) {
                const fB = this._func.currentF;
                const dx = Geometry_1.Geometry.conditionalDivideFraction(fA, (fB - fA) / this.derivativeH);
                if (dx !== undefined) {
                    this._currentStep = dx;
                    return true;
                }
            }
        }
        return false;
    }
    currentStepSize() {
        return Math.abs(this._currentStep / (1.0 + Math.abs(this._currentX)));
    }
}
exports.Newton1dUnboundedApproximateDerivative = Newton1dUnboundedApproximateDerivative;
/** object to evaluate a 2-parameter newton function (with derivatives!!).
 */
class NewtonEvaluatorRRtoRRD {
    /**
     * constructor.
     * * This creates a crrentF object to (repeatedly) receive function and derivatives.
     */
    constructor() {
        this.currentF = Plane3dByOriginAndVectors_1.Plane3dByOriginAndVectors.createXYPlane();
    }
}
exports.NewtonEvaluatorRRtoRRD = NewtonEvaluatorRRtoRRD;
/**
 * Implement evaluation steps for newton iteration in 2 dimensions.
 */
class Newton2dUnboundedWithDerivative extends AbstractNewtonIterator {
    constructor(func) {
        super();
        this._func = func;
        this._currentStep = Point2dVector2d_1.Vector2d.createZero();
        this._currentUV = Point2dVector2d_1.Point2d.createZero();
    }
    setUV(x, y) { this._currentUV.set(x, y); return true; }
    getU() { return this._currentUV.x; }
    getV() { return this._currentUV.y; }
    applyCurrentStep() { return this.setUV(this._currentUV.x - this._currentStep.x, this._currentUV.y - this._currentStep.y); }
    /** Univariate newton step : */
    computeStep() {
        if (this._func.evaluate(this._currentUV.x, this._currentUV.y)) {
            const fA = this._func.currentF;
            if (Polynomials_1.SmallSystem.linearSystem2d(fA.vectorU.x, fA.vectorV.x, fA.vectorU.y, fA.vectorV.y, fA.origin.x, fA.origin.y, this._currentStep))
                return true;
        }
        return false;
    }
    /**
     * @returns the largest relative step of the x,y, components of the current step.
     */
    currentStepSize() {
        return Geometry_1.Geometry.maxAbsXY(this._currentStep.x / (1.0 + Math.abs(this._currentUV.x)), this._currentStep.y / (1.0 + Math.abs(this._currentUV.y)));
    }
}
exports.Newton2dUnboundedWithDerivative = Newton2dUnboundedWithDerivative;


/***/ }),

/***/ "./lib/numerics/PascalCoefficients.js":
/*!********************************************!*\
  !*** ./lib/numerics/PascalCoefficients.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/**
 * PascalCoeffients class has static methods which return rows of the PascalTriangle.
 *
 */
class PascalCoefficients {
    /**
     * * return a row of the pascal table.
     * * The contents must not be altered by the user !!!
     * * Hypothetically the request row can be any integer.
     * * BUT in practice, values 60 create integer entries that are too big for IEEE double.
     */
    static getRow(row) {
        const allRows = PascalCoefficients._allRows;
        if (allRows.length === 0) {
            // seed the table . . .
            allRows.push(new Float64Array([1]));
            allRows.push(new Float64Array([1, 1]));
            allRows.push(new Float64Array([1, 2, 1]));
            allRows.push(new Float64Array([1, 3, 3, 1]));
            allRows.push(new Float64Array([1, 4, 6, 4, 1]));
            allRows.push(new Float64Array([1, 5, 10, 10, 5, 1]));
            allRows.push(new Float64Array([1, 6, 15, 20, 15, 6, 1]));
            allRows.push(new Float64Array([1, 7, 21, 35, 35, 21, 7, 1]));
        }
        while (allRows.length <= row) {
            const k = allRows.length;
            const oldRow = allRows[k - 1];
            const newRow = new Float64Array(k + 1);
            newRow[0] = 1.0;
            for (let i = 1; i < k; i++)
                newRow[i] = oldRow[i - 1] + oldRow[i];
            newRow[k] = 1.0;
            allRows.push(newRow);
        }
        return allRows[row];
    }
    /** Return an array with Bezier weighted pascal coefficients
     * @param row row index in the pascal triangle.  (`row+1` entries)
     * @param u parameter value
     * @param result optional destination array.
     * @note if the destination array is undefined or too small, a new Float64Array is allocated.
     * @note if the destination array is larger than needed, its leading `row+1` values are filled,
     *     and the array is returned.
     */
    static getBezierBasisValues(order, u, result) {
        const row = order - 1;
        const pascalRow = PascalCoefficients.getRow(row);
        if (result === undefined || result.length < order)
            result = new Float64Array(order);
        for (let i = 0; i < order; i++)
            result[i] = pascalRow[i];
        // multiply by increasing powers of u ...
        let p = u;
        for (let i = 1; i < order; i++, p *= u) {
            result[i] *= p;
        }
        // multiply by powers of (1-u), working from right
        const v = 1.0 - u;
        p = v;
        for (let i = order - 2; i >= 0; i--, p *= v) {
            result[i] *= p;
        }
        return result;
    }
    /** Return an array with derivatives of Bezier weighted pascal coefficients
     * @param row row index in the pascal triangle.  (`row+1` entries)
     * @param u parameter value
     * @param result optional destination array.
     * @note if the destination array is undefined or too small, a new Float64Array is allocated.
     * @note if the destination array is larger than needed, its leading `row+1` values are filled,
     *     and the array is returned.
     */
    static getBezierBasisDerivatives(order, u, result) {
        result = this.getBezierBasisValues(order - 1, u, result);
        // derivative is df/du = (order-1 ) * sum ( q[i+1] - q[i])   summed on 0 <= i < order - 1.\
        // evaluate lower order basis, overwrite in place from right to left
        const f = order - 1;
        result[order - 1] = f * result[order - 2];
        for (let k = order - 2; k > 0; k--) {
            result[k] = f * (result[k - 1] - result[k]);
        }
        result[0] = -f * result[0];
        return result;
    }
}
PascalCoefficients._allRows = [];
exports.PascalCoefficients = PascalCoefficients;


/***/ }),

/***/ "./lib/numerics/Polynomials.js":
/*!*************************************!*\
  !*** ./lib/numerics/Polynomials.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Numerics */
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
// import { Angle, AngleSweep, Geometry } from "../Geometry";
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const GrowableFloat64Array_1 = __webpack_require__(/*! ../geometry3d/GrowableFloat64Array */ "./lib/geometry3d/GrowableFloat64Array.js");
// import { Arc3d } from "../curve/Arc3d";
/* tslint:disable:variable-name*/
class Degree2PowerPolynomial {
    constructor(c0 = 0, c1 = 0, c2 = 0) {
        this.coffs = [c0, c1, c2];
    }
    /**
     * * Return 2 duplicate roots in double root case.
     * @returns 0, 1, or 2 solutions of the usual quadratic (a*x*x + b * x + c = 0)
     */
    static solveQuadratic(a, b, c) {
        const b1 = Geometry_1.Geometry.conditionalDivideFraction(b, a);
        const c1 = Geometry_1.Geometry.conditionalDivideFraction(c, a);
        if (b1 !== undefined && c1 !== undefined) {
            // now solving xx + b1*x + c1 = 0 -- i.e. implied "a" coefficient is 1 . .
            const q = b1 * b1 - 4 * c1;
            if (q > 0) {
                const e = Math.sqrt(q);
                // e is positive, so this sorts algebraically
                return [0.5 * (-b1 - e), 0.5 * (-b1 + e)];
            }
            if (q < 0)
                return undefined;
            const root = -0.5 * b1;
            return [root, root];
        }
        // "divide by a" failed.  solve bx + c = 0
        const x = Geometry_1.Geometry.conditionalDivideFraction(-c, b);
        if (x !== undefined)
            return [x];
        return undefined;
    }
    addConstant(a) {
        this.coffs[0] += a;
    }
    // Add s * (a + b*x)^2 to the quadratic coefficients
    addSquaredLinearTerm(a, b, s = 1) {
        this.coffs[0] += s * (a * a);
        this.coffs[1] += s * (2.0 * a * b);
        this.coffs[2] += s * (b * b);
    }
    realRoots() {
        const ss = Degree2PowerPolynomial.solveQuadratic(this.coffs[2], this.coffs[1], this.coffs[0]);
        if (ss && ss.length > 1) {
            if (ss[0] > ss[1]) {
                const temp = ss[0];
                ss[0] = ss[1];
                ss[1] = temp;
            }
        }
        return ss;
    }
    /**
     * Evaluate the quadratic at x.
     */
    evaluate(x) {
        return this.coffs[0] + x * (this.coffs[1] + x * this.coffs[2]);
    }
    /**
     * Evaluate the bezier function at a parameter value.  (i.e. summ the basis functions times coefficients)
     * @param u parameter for evaluation
     */
    evaluateDerivative(x) {
        return this.coffs[1] + 2 * x * this.coffs[2];
    }
    // Factor the polyonmial as c0 + c1 * x + c2 * x*x = y0 + c2 * (x-x0)^2
    tryGetVertexFactorization() {
        const x = Geometry_1.Geometry.conditionalDivideFraction(-this.coffs[1], 2.0 * this.coffs[2]);
        if (x !== undefined) {
            const y = this.evaluate(x);
            return { c: this.coffs[2], x0: x, y0: y };
        }
        return undefined;
    }
    static fromRootsAndC2(root0, root1, c2 = 1) {
        return new Degree2PowerPolynomial(c2 * root0 * root1, -c2 * (root0 + root1), c2);
    }
}
exports.Degree2PowerPolynomial = Degree2PowerPolynomial;
class Degree3PowerPolynomial {
    constructor(c0 = 0, c1 = 0, c2 = 0, c3 = 1) {
        this.coffs = [c0, c1, c2, c3];
    }
    addConstant(a) {
        this.coffs[0] += a;
    }
    // Add s * (a + b*x)^2 to the quadratic coefficients
    addSquaredLinearTerm(a, b, s = 1) {
        this.coffs[0] += s * (a * a);
        this.coffs[1] += s * (2.0 * a * b);
        this.coffs[2] += s * (b * b);
    }
    /**
     * Evaluate the polynomial at x
     * @param u parameter for evaluation
     */
    evaluate(x) {
        return this.coffs[0] + x * (this.coffs[1] + x * (this.coffs[2] + x * this.coffs[3]));
    }
    /**
     * Evaluate the polynomial derivative
     * @param u parameter for evaluation
     */
    evaluateDerivative(x) {
        return this.coffs[1] + x * (2.0 * this.coffs[2] + x * 3.0 * this.coffs[3]);
    }
    static fromRootsAndC3(root0, root1, root2, c3 = 1.0) {
        return new Degree3PowerPolynomial(-c3 * root0 * root1 * root2, c3 * (root0 * root1 + root1 * root2 + root0 * root2), -c3 * (root0 + root1 + root2), c3);
    }
}
exports.Degree3PowerPolynomial = Degree3PowerPolynomial;
class Degree4PowerPolynomial {
    constructor(c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0) {
        this.coffs = [c0, c1, c2, c3, c4];
    }
    addConstant(a) {
        this.coffs[0] += a;
    }
    /**
     * Evaluate the polynomial
     * @param x x coordinate for evaluation
     */
    evaluate(x) {
        return this.coffs[0] + x * (this.coffs[1] + x * (this.coffs[2] + x * (this.coffs[3] + x * this.coffs[4])));
    }
    /**
     * Evaluate the derivative
     * @param x x coordinate for evaluation
     */
    evaluateDerivative(x) {
        return (this.coffs[1] + x * (2.0 * this.coffs[2] + x * (3.0 * this.coffs[3] + x * 4.0 * this.coffs[4])));
    }
    static fromRootsAndC4(root0, root1, root2, root3, c4 = 1) {
        return new Degree4PowerPolynomial(c4 * (root0 * root1 * root2 * root3), -c4 * (root0 * root1 * root2 + root0 * root1 * root3 + root0 * root2 * root3 + root1 * root2 * root3), c4 * (root0 * root1 + root0 * root2 + root0 * root3 + root1 * root2 + root1 * root3 + root2 * root3), -c4 * (root0 + root1 + root2 + root3), c4);
    }
}
exports.Degree4PowerPolynomial = Degree4PowerPolynomial;
class TorusImplicit {
    constructor(majorRadiusR, minorRadiusr) {
        this.majorRadius = majorRadiusR;
        this.minorRadius = minorRadiusr;
    }
    // Return size of box (e.g. for use as scale factor)
    boxSize() {
        return (Math.abs(this.majorRadius) + Math.abs(this.minorRadius));
    }
    /** @returns a scale factor appropriate to control the magnitude of the implicit function. */
    implicitFunctionScale() {
        const a = this.boxSize();
        if (a === 0.0)
            return 1.0;
        return 1.0 / (a * a * a * a);
    }
    // Implicit equation for the torus is ...
    // (x^2+y^2+z^2+(R^2-r^2))^2 = 4 R^2(x^2+y^2)
    // x,y,z are weighted,
    // (x^2+y^2+z^2+(R^2-r^2)w^2)^2 = 4 R^2 w^2 (x^2+y^2)
    evaluateImplicitFunctionXYZ(x, y, z) {
        const rho2 = x * x + y * y;
        const z2 = z * z;
        const R2 = this.majorRadius * this.majorRadius;
        const r2 = this.minorRadius * this.minorRadius;
        const f = rho2 + z2 + (R2 - r2);
        const g = 4.0 * R2 * rho2;
        return (f * f - g) * this.implicitFunctionScale();
    }
    evaluateImplicitFunctionPoint(xyz) {
        return this.evaluateImplicitFunctionXYZ(xyz.x, xyz.y, xyz.z);
    }
    evaluateImplicitFunctionXYZW(x, y, z, w) {
        const rho2 = x * x + y * y;
        const z2 = z * z;
        const w2 = w * w;
        const R2 = this.majorRadius * this.majorRadius;
        const r2 = this.minorRadius * this.minorRadius;
        const f = rho2 + z2 + w2 * (R2 - r2);
        const g = w2 * 4.0 * R2 * rho2;
        return (f * f - g) * this.implicitFunctionScale();
    }
    // public intersectRay(ray: Ray3d, rayFractions: number, points: Point3d, maxHit: number) {}
    evaluateThetaPhi(theta, phi) {
        const c = Math.cos(theta);
        const s = Math.sin(theta);
        // theta=0 point
        const x0 = this.majorRadius + this.minorRadius * Math.cos(phi);
        const z0 = this.minorRadius * Math.sin(phi);
        return Point3dVector3d_1.Point3d.create(c * x0, s * x0, z0);
    }
    evaluateDerivativesThetaPhi(theta, phi, dxdTheta, dxdPhi) {
        const cTheta = Math.cos(theta);
        const sTheta = Math.sin(theta);
        const bx = this.minorRadius * Math.cos(phi);
        const bz = this.minorRadius * Math.sin(phi);
        const x0 = this.majorRadius + bx;
        Point3dVector3d_1.Vector3d.create(-x0 * sTheta, x0 * cTheta, 0.0, dxdTheta);
        Point3dVector3d_1.Vector3d.create(-cTheta * bz, -sTheta * bz, bx, dxdPhi);
    }
    evaluateThetaPhiDistance(theta, phi, distance) {
        const c = Math.cos(theta);
        const s = Math.sin(theta);
        // theta=0 point
        const x0 = this.majorRadius + distance * Math.cos(phi);
        const z0 = distance * Math.sin(phi);
        return Point3dVector3d_1.Point3d.create(c * x0, s * x0, z0);
    }
    /** Given an xyz coordinate in the local system of the toroid, compute the torus parametrization
     * * theta = angular coordinate in xy plane
     * * phi = angular coordinate in minor circle.
     * * distance = distance from major circle
     * * rho = distance from origin to xy part of the input.
     * @param xyz space point in local coordinates.
     * @return object with properties theta, phi, distance, rho
     */
    XYZToThetaPhiDistance(xyz) {
        const rho = xyz.magnitudeXY();
        const majorRadiusFactor = Geometry_1.Geometry.conditionalDivideFraction(this.majorRadius, rho);
        let safeMajor;
        let majorCirclePoint;
        if (majorRadiusFactor) {
            safeMajor = true;
            majorCirclePoint = Point3dVector3d_1.Point3d.create(majorRadiusFactor * xyz.x, majorRadiusFactor * xyz.y, 0.0);
        }
        else {
            safeMajor = false;
            majorCirclePoint = Point3dVector3d_1.Point3d.create(xyz.x, xyz.y, 0.0);
        }
        const theta = safeMajor ? Math.atan2(xyz.y, xyz.x) : 0.0;
        const vectorFromMajorCircle = Point3dVector3d_1.Vector3d.createStartEnd(majorCirclePoint, xyz);
        const distance = vectorFromMajorCircle.magnitude();
        const drho = rho - this.majorRadius;
        let safePhi;
        let phi;
        if (xyz.z === 0.0 && drho === 0.0) {
            phi = 0.0;
            safePhi = false;
        }
        else {
            phi = Math.atan2(xyz.z, drho);
            safePhi = true;
        }
        return { theta: (theta), phi: (phi), distance: (distance), rho: (rho), safePhi: safeMajor && safePhi };
    }
}
exports.TorusImplicit = TorusImplicit;
/**
 * evaluation methods for an implicit sphere `x*x + y*y + z*z - r*r = 0`.
 */
class SphereImplicit {
    constructor(r) { this.radius = r; }
    // Evaluate the implicit function at space point
    // @param [in] xyz coordinates
    evaluateImplicitFunction(x, y, z) {
        return x * x + y * y + z * z - this.radius * this.radius;
    }
    // Evaluate the implicit function at weighted space point (wx, wy, wz, w)
    // @param [in] wx (preweighted) x coordinate
    // @param [in] wy (preweighted) y coordinate
    // @param [in] wz (preweighted) z coordinate
    // @param [in] w  weight
    evaluateImplicitFunctionXYZW(wx, wy, wz, w) {
        return (wx * wx + wy * wy + wz * wz) - this.radius * this.radius * w * w;
    }
    XYZToThetaPhiR(xyz) {
        const rhoSquared = xyz.x * xyz.x + xyz.y * xyz.y;
        const rho = Math.sqrt(rhoSquared);
        const r = Math.sqrt(rhoSquared + xyz.z * xyz.z);
        let theta;
        let phi;
        let valid;
        if (r === 0.0) {
            theta = phi = 0.0;
            valid = false;
        }
        else {
            phi = Math.atan2(xyz.z, rho); // At least one of these is nonzero
            if (rhoSquared !== 0.0) {
                theta = Math.atan2(xyz.y, xyz.x);
                valid = true;
            }
            else {
                theta = 0.0;
                valid = false;
            }
        }
        return { theta: (theta), phi: (phi), r: (r), valid: (valid) };
    }
    // public intersectRay(ray: Ray3d, maxHit: number): {rayFractions: number, points: Point3d} {
    //   const q = new Degree2PowerPolynomial();
    //   // Ray is (origin.x + s * direction.x, etc)
    //   // squared distance from origin is (origin.x + s*direction.x)^2 + etc
    //   // sphere radius in local system is 1.
    //   q.addSquaredLinearTerm(ray.origin.x, ray.direction.x);
    //   q.addSquaredLinearTerm(ray.origin.y, ray.direction.y);
    //   q.addSquaredLinearTerm(ray.origin.z, ray.direction.z);
    //   q.addConstant(-this.radius * this.radius);
    //   let ss = [];
    //   let n = q.realRoots(ss);
    //   if (n > maxHit)
    //     n = maxHit;
    //   let rayFractions;
    //   let points;
    //   for (let i = 0; i < n; i++) {
    //     rayFractions[i] = ss[i];
    //     points[i] = Point3d. // What is the equivalent of FromSumOf in TS?
    //   }
    // Compute the point on the surface at specified angles
    // @param [in] theta major circle angle.
    // @param [in] phi minor circle angle.
    // @return point on surface
    evaluateThetaPhi(thetaRadians, phiRadians) {
        const rc = this.radius * Math.cos(thetaRadians);
        const rs = this.radius * Math.sin(thetaRadians);
        const cosPhi = Math.cos(phiRadians);
        const sinPhi = Math.sin(phiRadians);
        return Point3dVector3d_1.Point3d.create(rc * cosPhi, rs * cosPhi, this.radius * sinPhi);
    }
    // Compute derivatives of the point on the surface at specified angles
    // @param [in] theta major circle angle.
    // @param [in] phi minor circle angle.
    // @param [out] dXdTheta derivative wrt theta
    // @param [out] dXdPhi derivative wrt phi
    evaluateDerivativesThetaPhi(theta, phi, dxdTheta, dxdPhi) {
        const rc = this.radius * Math.cos(theta);
        const rs = this.radius * Math.sin(theta);
        const cosPhi = Math.cos(phi);
        const sinPhi = Math.sin(phi);
        Point3dVector3d_1.Vector3d.create(-rs * cosPhi, rc * cosPhi, 0.0, dxdTheta);
        Point3dVector3d_1.Vector3d.create(-rc * sinPhi, -rs * sinPhi, this.radius * cosPhi, dxdPhi);
    }
}
exports.SphereImplicit = SphereImplicit;
/** AnalyticRoots has static methods for solving quadratic, cubic, and quartic equations.
 *
 */
class AnalyticRoots {
    /** Absolute zero test with a tolerance that has worked well for the analytic root use case . . . */
    static IsZero(x) {
        return Math.abs(x) < this.EQN_EPS;
    }
    /** Without actually doing a division, test if (x/y) is small.
     * @param x numerator
     * @param y denominator
     * @param abstol absolute tolerance
     * @param reltol relative tolerance
     */
    static isSmallRatio(x, y, abstol = 1.0e-9, reltol = 8.0e-16) {
        return Math.abs(x) <= abstol || Math.abs(x) < reltol * Math.abs(y);
    }
    // @returns the principal (always real) cube root of x.
    static cbrt(x) {
        return ((x) > 0.0
            ? Math.pow((x), 1.0 / 3.0)
            : ((x) < 0.0
                ? -Math.pow(-(x), 1.0 / 3.0)
                : 0.0));
    }
    /**
     * Try to divide `numerator/denominator` and place the result (or defaultValue) in `values[offset]`
     * @param values array of values.  `values[offset]` will be replaced.
     * @param numerator numerator for division.
     * @param denominator denominator for division.
     * @param defaultValue value to save if denominator is too small to divide.
     * @param offset index of value to replace.
     */
    static SafeDivide(values, numerator, denominator, defaultValue = 0.0, offset) {
        if (Math.abs(denominator) > (this.s_safeDivideFactor * Math.abs(numerator))) {
            values[offset] = numerator / denominator;
            return true;
        }
        values[offset] = defaultValue;
        return false;
    }
    // Used in NewtonMethod for testing if a root has been adjusted past its bounding region
    static checkRootProximity(roots, i) {
        if (i === 0) { // Case 1: Beginning Root (check root following it)
            return roots.at(i) < roots.at(i + 1);
        }
        else if (i > 0 && i + 1 < roots.length) { // Case 2: Middle Root (check roots before and after)
            return (roots.at(i) > roots.at(i - 1)) && (roots.at(i) < roots.at(i + 1));
        }
        else { // Case 3: End root (check preceding root)
            return (roots.at(i) > roots.at(i - 1));
        }
    }
    static NewtonMethodAdjustment(coffs, root, order) {
        if (order === 3) {
            const f = coffs[0] + root * (coffs[1] + root * (coffs[2] + root * coffs[3]));
            const df = coffs[1] + root * (2.0 * coffs[2] + root * 3.0 * coffs[3]);
            return f / df;
        }
        else if (order === 4) {
            const f = coffs[0] + root * (coffs[1] + root * (coffs[2] + root * (coffs[3] + root * coffs[4])));
            const df = coffs[1] + root * (2.0 * coffs[2] + root * (3.0 * coffs[3] + root * 4.0 * coffs[4]));
            return f / df;
        }
        else {
            return 0;
        }
    }
    static improveSortedRoots(coffs, degree, roots) {
        const relTol = 1.0e-10;
        // Loop through each root
        for (let i = 0; i < roots.length; i++) {
            let dx = this.NewtonMethodAdjustment(coffs, roots.at(i), degree);
            if (!dx)
                continue; // skip if newton step had divide by zero.
            const originalValue = roots.at(i);
            let counter = 0;
            let convergenceCounter = 0;
            // Loop through applying changes to found root until dx is diminished or counter is hit
            while (dx !== 0 && (counter < 10)) {
                // consider it converged if two successive iterations satisfy the (not too demanding) tolerance.
                if (Math.abs(dx) < relTol * (1.0 + Math.abs(roots.at(i)))) {
                    if (++convergenceCounter > 1)
                        break;
                }
                else {
                    convergenceCounter = 0;
                }
                const rootDX = roots.at(i) - dx;
                roots.reassign(i, rootDX);
                // If root is thrown past one of its neighboring roots, unstable condition is assumed.. revert
                // to originally found root
                if (!this.checkRootProximity(roots, i)) {
                    roots.reassign(i, originalValue);
                    break;
                }
                dx = this.NewtonMethodAdjustment(coffs, roots.at(i), degree);
                counter++;
            }
        }
    }
    /**
     * Append (if defined) value to results.
     * @param value optional value to append
     * @param results growning array
     */
    static appendSolution(value, results) {
        if (value !== undefined) {
            results.push(value);
        }
    }
    /**
     * Append 2 solutions -- note that both are required args, no option of omitting as in single solution case
     * @param value1
     * @param value2
     * @param results
     */
    static append2Solutions(valueA, valueB, results) {
        results.push(valueA);
        results.push(valueB);
    }
    /**
     * If `co/c1` is a safed division, append it to the values array.
     * @param c0 numerator
     * @param c1 denominaotr
     * @param values array to expand
     */
    static appendLinearRoot(c0, c1, values) {
        AnalyticRoots.appendSolution(Geometry_1.Geometry.conditionalDivideFraction(-c0, c1), values);
    }
    // Search an array for the value which is farthest from the average of all the values.
    static mostDistantFromMean(data) {
        if (!data || data.length === 0)
            return 0;
        let a = 0.0; // to become the sum and finally the average.
        for (let i = 0; i < data.length; i++)
            a += data.at(i);
        a /= data.length;
        let dMax = 0.0;
        let result = data.at(0);
        for (let i = 0; i < data.length; i++) {
            const d = Math.abs(data.at(i) - a);
            if (d > dMax) {
                dMax = d;
                result = data.at(i);
            }
        }
        return result;
    }
    /**
     * Append 0, 1, or 2 solutions of a quadratic to the values array.
     * @param c array of coefficients for quadratic `c[0] + c[1] * x + c[2] * x*x`
     * @param values array to be expanded.
     */
    static appendQuadraticRoots(c, values) {
        // Normal form: x^2 + 2px + q = 0
        const divFactor = Geometry_1.Geometry.conditionalDivideFraction(1.0, c[2]);
        if (!divFactor) {
            this.appendLinearRoot(c[0], c[1], values);
            return;
        }
        const p = 0.5 * c[1] * divFactor;
        const q = c[0] * divFactor;
        const D = p * p - q;
        if (this.IsZero(D)) {
            this.appendSolution(-p, values);
            return;
        }
        else if (D < 0) {
            return;
        }
        else if (D > 0) {
            const sqrt_D = Math.sqrt(D);
            this.append2Solutions(sqrt_D - p, -sqrt_D - p, values);
            return;
        }
        return;
    }
    static addConstant(value, data) {
        for (let i = 0; i < data.length; i++)
            data.reassign(i, data.at(i) + value);
    }
    /** return roots of a cubic c0 + c1 *x + c2 * x^2 + c2 * x3.
     * In the usual case where c0 is non-zero, there are either 1 or 3 roots.
     * But if c0 is zero the (0, 1, or 2) roots of the lower order equation
     */
    static appendCubicRootsUnsorted(c, results) {
        let A;
        let B;
        let C;
        let sq_A;
        let p;
        let q;
        let cb_p;
        let D;
        // normal form: x^3 + Ax^2 + Bx + C = 0
        const scaleFactor = Geometry_1.Geometry.conditionalDivideFraction(1.0, c[3]);
        if (!scaleFactor) {
            this.appendQuadraticRoots(c, results);
            return;
        }
        // It is a real cubic.  There MUST be at least one real solution . . .
        A = c[2] * scaleFactor;
        B = c[1] * scaleFactor;
        C = c[0] * scaleFactor;
        /*  substitute x = y - A/3 to eliminate quadric term:
            f = y^3 +3py + 2q = 0
            f' = 3y^2 + p
                local min/max at Y = +-sqrt (-p)
                f(+Y) = -p sqrt(-p) + 3p sqrt (-p) + 2q = 2 p sqrt (-p) + 2q
        */
        sq_A = A * A;
        p = (3.0 * B - sq_A) / 9.0;
        q = 1.0 / 2 * (2.0 / 27 * A * sq_A - 1.0 / 3 * A * B + C);
        // Use Cardano's formula
        cb_p = p * p * p;
        D = q * q + cb_p;
        const origin = A / (-3.0);
        if (D >= 0.0 && this.IsZero(D)) {
            if (this.IsZero(q)) {
                // One triple solution
                results.push(origin);
                results.push(origin);
                results.push(origin);
                return;
            }
            else {
                // One single and one double solution
                const u = this.cbrt(-q);
                if (u < 0) {
                    results.push(origin + 2 * u);
                    results.push(origin - u);
                    results.push(origin - u);
                    return;
                }
                else {
                    results.push(origin - u);
                    results.push(origin - u);
                    results.push(origin + 2 * u);
                    return;
                }
            }
        }
        else if (D <= 0) { // Causes irreducibilis: three real solutions
            const phi = 1.0 / 3 * Math.acos(-q / Math.sqrt(-cb_p));
            const t = 2 * Math.sqrt(-p);
            results.push(origin + t * Math.cos(phi));
            results.push(origin - t * Math.cos(phi + Math.PI / 3));
            results.push(origin - t * Math.cos(phi - Math.PI / 3));
            this.improveSortedRoots(c, 3, results);
            return;
        }
        else { // One real solution
            const sqrt_D = Math.sqrt(D);
            const u = this.cbrt(sqrt_D - q);
            const v = -(this.cbrt(sqrt_D + q));
            results.push(origin + u + v);
            this.improveSortedRoots(c, 3, results);
            return;
        }
    }
    static appendCubicRoots(c, results) {
        this.appendCubicRootsUnsorted(c, results);
        results.sort();
    }
    static appendQuarticRoots(c, results) {
        const coeffs = new Float64Array(4); // at various times .. coefficients of quadratic an cubic intermediates.
        let u;
        let v;
        let A;
        let B;
        let C;
        let D;
        let sq_A;
        let p;
        let q;
        let r;
        // normal form: x^4 + Ax^3 + Bx^2 + Cx + D = 0
        const coffScale = new Float64Array(1);
        if (!this.SafeDivide(coffScale, 1.0, c[4], 0.0, 0)) {
            this.appendCubicRoots(c, results);
            return;
        }
        A = c[3] * coffScale[0];
        B = c[2] * coffScale[0];
        C = c[1] * coffScale[0];
        D = c[0] * coffScale[0];
        const origin = -0.25 * A;
        /*  substitute x = y - A/4 to eliminate cubic term:
            x^4 + px^2 + qx + r = 0 */
        sq_A = A * A;
        p = -3.0 / 8 * sq_A + B;
        q = 0.125 * sq_A * A - 0.5 * A * B + C;
        r = -3.0 / 256 * sq_A * sq_A + 1.0 / 16 * sq_A * B - 1.0 / 4 * A * C + D;
        const tempStack = new GrowableFloat64Array_1.GrowableFloat64Array();
        if (this.IsZero(r)) {
            // no absolute term: y(y^3 + py + q) = 0
            coeffs[0] = q;
            coeffs[1] = p;
            coeffs[2] = 0;
            coeffs[3] = 1;
            this.appendCubicRootsUnsorted(coeffs, results);
            results.push(0); // APPLY ORIGIN ....
            this.addConstant(origin, results);
            return;
        }
        else {
            // Solve the resolvent cubic
            coeffs[0] = 1.0 / 2 * r * p - 1.0 / 8 * q * q;
            coeffs[1] = -r;
            coeffs[2] = -1.0 / 2 * p;
            coeffs[3] = 1;
            this.appendCubicRootsUnsorted(coeffs, tempStack);
            const z = this.mostDistantFromMean(tempStack);
            // ... to build two quadric equations
            u = z * z - r;
            v = 2 * z - p;
            if (this.isSmallRatio(u, r)) {
                u = 0;
            }
            else if (u > 0) {
                u = Math.sqrt(u);
            }
            else {
                return;
            }
            if (this.isSmallRatio(v, p)) {
                v = 0;
            }
            else if (v > 0) {
                v = Math.sqrt(v);
            }
            else {
                for (let i = 0; i < tempStack.length; i++) {
                    results.push(tempStack.at(i));
                }
                return;
            }
            coeffs[0] = z - u;
            coeffs[1] = ((q < 0) ? (-v) : (v));
            coeffs[2] = 1;
            this.appendQuadraticRoots(coeffs, results);
            coeffs[0] = z + u;
            coeffs[1] = ((q < 0) ? (v) : (-v));
            coeffs[2] = 1;
            this.appendQuadraticRoots(coeffs, results);
        }
        // resubstitute
        this.addConstant(origin, results);
        results.sort();
        this.improveSortedRoots(c, 4, results);
        return;
    }
    static appendCosSinRadians(c, s, cosValues, sinValues, radiansValues) {
        if (cosValues)
            cosValues.push(c);
        if (sinValues)
            sinValues.push(s);
        if (radiansValues)
            radiansValues.push(Math.atan2(s, c));
    }
    /*-----------------------------------------------------------------
     Solve the simultaneous equations
     <pre>
                   alpha + beta*c + gamma*s = 0
                   c*c + s*s = 1
  
     @param c1P OUT x cosine component of first solution point
     @param s1P OUT y sine component of first solution point
     @param c2P OUT x cosine component of second solution point
     @param s2P OUT y sine component of second solution point
     @param solutionType OUT One of the following values:
    <pre>
        -2 -- all coefficients identically 0.   The entire c,s plane -- and therefore
            the entire unit circle -- is a solution.
        -1 -- beta,gamma are zero, alpha is not.   There is no line defined.  There are
            no solutions.
        0 -- the line is well defined, but passes completely outside the unit circle.
                In this case, (c1,s1) is the circle point closest to the line
                and (c2,s2) is the line point closest to the circle.
        1 -- the line is tangent to the unit circle.  As tangency is identified at
                numerical precision, faithful interpretation of the coefficients
                may allow for some distance from line to circle. (c1,s1) is returned
                as the closest circle point, (c2,s2) the line point.  These are
                nominally the same but may differ due to the tolerance
                decision.
        2 -- two simple intersections.
    </pre>
  
      @param alpha => constant coefficient on line
     @param beta => x cosine coefficient on line
     @param gamma => y sine coefficient on line
     @param reltol => relative tolerance for tangencies
     @return the (nonnegative) solution count.
  
    @remarks Here is an example of the tangible meaning of the coefficients and
    the cryptic 5-way solution type separation.
    Point X on a 3D ellipse at parameter space angle theta is given by
        X = C + U cos(theta) + V sin(theta)
    where C,U,V are (respectively) center, 0 degree, and 90 degree vectors.
    A plane has normal N and is at distance a from the origin.  X is on the plane if
        X.N = a
    i.e.
        C.N + U.N cos(theta) + V.N sin(theta) = a
    i.e.
        C.N - a + U.N cos(theta) + V.N sin(theta) = 0
    i.e.
        alpha = C.N - a
        beta =  U.N
        gamma = V.N
    If the ellipse is parallel to the plane, both beta and gamma are zero.  These are
    the two degenerat cases.  If alpha is also zero the entire ellipse is completely
    in the plane.   If alpha is nonzero the ellipse is completely out of plane.
  
    If the ellipse plane is NOT parallel, there are zero, one, or two solutions according as
    the ellipse is completly on one side, tangent or is properly split by the plane.
  
     @bsihdr                                       EarlinLutz      12/97
    +---------------+---------------+---------------+---------------+------*/
    static appendImplicitLineUnitCircleIntersections(alpha, beta, gamma, cosValues, sinValues, radiansValues, reltol = 1.0e-14) {
        let twoTol;
        const delta2 = beta * beta + gamma * gamma;
        const alpha2 = alpha * alpha;
        let solutionType = 0;
        if (reltol < 0.0) {
            twoTol = 0.0;
        }
        else {
            twoTol = 2.0 * reltol;
        }
        if (delta2 <= 0.0) {
            solutionType = (alpha === 0) ? -2 : -1;
        }
        else {
            const lambda = -alpha / delta2;
            const a2 = alpha2 / delta2;
            const D2 = 1.0 - a2;
            if (D2 < -twoTol) {
                const delta = Math.sqrt(delta2);
                const iota = (alpha < 0) ? (1.0 / delta) : (-1.0 / delta);
                this.appendCosSinRadians(lambda * beta, lambda * gamma, cosValues, sinValues, radiansValues);
                this.appendCosSinRadians(beta * iota, gamma * iota, cosValues, sinValues, radiansValues);
                solutionType = 0;
            }
            else if (D2 < twoTol) {
                const delta = Math.sqrt(delta2);
                const iota = (alpha < 0) ? (1.0 / delta) : (-1.0 / delta);
                this.appendCosSinRadians(lambda * beta, lambda * gamma, cosValues, sinValues, radiansValues);
                this.appendCosSinRadians(beta * iota, gamma * iota, cosValues, sinValues, radiansValues);
                solutionType = 1;
            }
            else {
                const mu = Math.sqrt(D2 / delta2);
                /* c0,s0 = closest approach of line to origin */
                const c0 = lambda * beta;
                const s0 = lambda * gamma;
                this.appendCosSinRadians(c0 - mu * gamma, s0 + mu * beta, cosValues, sinValues, radiansValues);
                this.appendCosSinRadians(c0 + mu * gamma, s0 - mu * beta, cosValues, sinValues, radiansValues);
                solutionType = 2;
            }
        }
        return solutionType;
    }
}
AnalyticRoots.EQN_EPS = 1.0e-9;
AnalyticRoots.s_safeDivideFactor = 1.0e-14;
AnalyticRoots.s_quadricRelTol = 1.0e-14;
AnalyticRoots.sTestWindow = 1.0e-6;
exports.AnalyticRoots = AnalyticRoots;
class PowerPolynomial {
    // Evaluate a standard basis polynomial.
    static degreeKnownEvaluate(coff, degree, x) {
        if (degree < 0) {
            return 0.0;
        }
        let p = coff[degree];
        for (let i = degree - 1; i >= 0; i--)
            p = x * p + coff[i];
        return p;
    }
    // Evaluate a standard basis polynomial
    static Evaluate(coff, x) {
        const degree = coff.length - 1;
        return this.degreeKnownEvaluate(coff, degree, x);
    }
    // Accumulate Q*scale into P.  Both are treated as full degree.
    //         (Expect Address exceptions if P is smaller than Q)
    // Returns degree of result as determined by comparing leading coefficients to zero
    static Accumulate(coffP, coffQ, scaleQ) {
        let degreeP = coffP.length - 1;
        const degreeQ = coffQ.length - 1;
        for (let i = 0; i <= degreeQ; i++) {
            coffP[i] += scaleQ * coffQ[i];
        }
        while (degreeP >= 0 && coffP[degreeP] === 0.0) {
            degreeP--;
        }
        return degreeP;
    }
    // Zero all coefficients in a polynomial
    static Zero(coff) {
        for (let i = 0; i < coff.length; i++) {
            coff[i] = 0.0;
        }
    }
}
exports.PowerPolynomial = PowerPolynomial;
class TrigPolynomial {
    /// Solve a polynomial created from trigonometric condition using
    /// Trig.S, Trig.C, Trig.W.  Solution logic includes inferring angular roots
    /// corresponding zero leading coefficients (roots at infinity)
    /// <param name="coff">Coefficients</param>
    /// <param name="nominalDegree">degree of the polynomial under most complex
    ///     root case.  If there are any zero coefficients up to this degree, a single root
    ///     "at infinity" is recorded as its corresponding angular parameter at negative pi/2
    /// <param name="referenceCoefficient">A number which represents the size of coefficients
    ///     at various stages of computation.  A small fraction of this will be used as a zero
    ///     tolerance</param>
    /// <param name="angles">Roots are placed here. Assumed preallocated with adequate size.</param>
    /// <param name="numRoots">Number of roots  .  Zero roots is possible. (Passed as array of size
    /// one to pass-by-reference)</param>
    /// Returns false if equation is all zeros.   This usually means any angle is a solution.
    // ------------------------------------------------------------------------------------------------
    // Solve a standard basis polynomial.   Immediately use the roots as ordinates
    //            in rational polynomials for sine and cosine, and convert to angle via arctan
    static SolveAngles(coff, nominalDegree, referenceCoefficient, radians) {
        let maxCoff = Math.abs(referenceCoefficient);
        let a;
        radians.length = 0;
        const relTol = this.SmallAngle;
        for (let i = 0; i <= nominalDegree; i++) {
            a = Math.abs(coff[i]);
            if (a > maxCoff) {
                maxCoff = a;
            }
        }
        const coffTol = relTol * maxCoff;
        let degree = nominalDegree;
        while (degree > 0 && (Math.abs(coff[degree]) <= coffTol)) {
            degree--;
        }
        // let bstat = false;
        const roots = new GrowableFloat64Array_1.GrowableFloat64Array();
        if (degree === -1) {
            // Umm.   Dunno.   Nothing there.
            // bstat = false;
        }
        else {
            // bstat = true;
            if (degree === 0) {
                // p(t) is a nonzero constant
                // No roots, but not degenerate.
                // bstat = true;
            }
            else if (degree === 1) {
                // p(t) = coff[1] * t + coff[0]...
                roots.push(-coff[0] / coff[1]);
            }
            else if (degree === 2) {
                AnalyticRoots.appendQuadraticRoots(coff, roots);
            }
            else if (degree === 3) {
                AnalyticRoots.appendCubicRoots(coff, roots);
            }
            else if (degree === 4) {
                AnalyticRoots.appendQuarticRoots(coff, roots);
            }
            else {
                // TODO: WILL WORK WITH BEZIER SOLVER
                // bstat = false;
            }
            if (roots.length > 0) {
                // Each solution t represents an angle with
                //  Math.Cos(theta)=C(t)/W(t),  ,sin(theta)=S(t)/W(t)
                // Division by W has no effect on Atan2 calculations, so we just compute S(t),C(t)
                for (let i = 0; i < roots.length; i++) {
                    const ss = PowerPolynomial.Evaluate(this.S, roots.at(i));
                    const cc = PowerPolynomial.Evaluate(this.C, roots.at(i));
                    radians.push(Math.atan2(ss, cc));
                }
                // Each leading zero at the front of the coefficients corresponds to a root at -PI/2.
                // Only make one entry....
                // for (int i = degree; i < nominalDegree; i++)
                if (degree < nominalDegree) {
                    radians.push(-0.5 * Math.PI);
                }
            }
        }
        return radians.length > 0;
    }
    /// <summary> Compute intersections of unit circle x^2 + y 2 = 1 with general quadric
    ///         axx*x^2 + axy*x*y + ayy*y^2 + ax * x + ay * y + a1 = 0
    /// Solutions are returned as angles. Sine and Cosine of the angles are the x,y results.
    /// <param name="axx">Coefficient of x^2</param>
    /// <param name="axy">Coefficient of xy</param>
    /// <param name="ayy">Coefficient of y^2</param>
    /// <param name="ax">Coefficient of x</param>
    /// <param name="ay">Coefficient of y</param>
    /// <param name="a1">Constant coefficient</param>
    /// <param name="angles">solution angles</param>
    /// <param name="numAngle">number of solution angles (Passed as array to make changes to reference)</param>
    static SolveUnitCircleImplicitQuadricIntersection(axx, axy, ayy, ax, ay, a1, radians) {
        const Coffs = new Float64Array(5);
        PowerPolynomial.Zero(Coffs);
        let degree = 2;
        if (Math.hypot(axx, axy, ayy) > TrigPolynomial.coeffientRelTol * Math.hypot(ax, ay, a1)) {
            PowerPolynomial.Accumulate(Coffs, this.CW, ax);
            PowerPolynomial.Accumulate(Coffs, this.SW, ay);
            PowerPolynomial.Accumulate(Coffs, this.WW, a1);
            PowerPolynomial.Accumulate(Coffs, this.SS, ayy);
            PowerPolynomial.Accumulate(Coffs, this.CC, axx);
            PowerPolynomial.Accumulate(Coffs, this.SC, axy);
            degree = 4;
        }
        else {
            PowerPolynomial.Accumulate(Coffs, this.C, ax);
            PowerPolynomial.Accumulate(Coffs, this.S, ay);
            PowerPolynomial.Accumulate(Coffs, this.W, a1);
            degree = 2;
        }
        let maxCoff = 0.0;
        maxCoff = Math.max(maxCoff, Math.abs(axx), Math.abs(ayy), Math.abs(axy), Math.abs(ax), Math.abs(ay), Math.abs(a1));
        const b = this.SolveAngles(Coffs, degree, maxCoff, radians);
        /*
        for (const theta of angles) {
          const c = theta.cos();
          const s = theta.sin();
          console.log({
            angle: theta, co: c, si: s,
            f: axx * c * c + axy * c * s + ayy * s * s + ax * c + ay * s + a1});
      } */
        return b;
    }
    /// <summary> Compute intersections of unit circle x^2 + y 2 = 1 with the ellipse
    ///         (x,y) = (cx + ux Math.Cos + vx sin, cy + uy Math.Cos + vy sin)
    /// Solutions are returned as angles in the ellipse space.
    /// <param name="cx">center x</param>
    /// <param name="cy">center y</param>
    /// <param name="ux">0 degree vector x</param>
    /// <param name="uy">0 degree vector y</param>
    /// <param name="vx">90 degree vector x</param>
    /// <param name="vy">90 degree vector y</param>
    /// <param name="ellipseAngles">solution angles in ellipse parameter space</param>
    /// <param name="circleAngles">solution angles in circle parameter space</param>
    /// <param name="numAngle">number of solution angles (passed as an array to change reference)</param>
    static SolveUnitCircleEllipseIntersection(cx, cy, ux, uy, vx, vy, ellipseRadians, circleRadians) {
        circleRadians.length = 0;
        const acc = ux * ux + uy * uy;
        const acs = 2.0 * (ux * vx + uy * vy);
        const ass = vx * vx + vy * vy;
        const ac = 2.0 * (ux * cx + uy * cy);
        const asi = 2.0 * (vx * cx + vy * cy);
        const a = cx * cx + cy * cy - 1.0;
        const boolstat = this.SolveUnitCircleImplicitQuadricIntersection(acc, acs, ass, ac, asi, a, ellipseRadians);
        for (const radians of ellipseRadians) {
            const cc = Math.cos(radians);
            const ss = Math.sin(radians);
            const x = cx + ux * cc + vx * ss;
            const y = cy + uy * cc + vy * ss;
            circleRadians.push(Math.atan2(y, x));
        }
        return boolstat;
    }
    /// <summary> Compute intersections of unit circle x^2 + y 2 = w^2 with the ellipse
    ///         (x,y) = (cx + ux Math.Cos + vx sin, cy + uy Math.Cos + vy sin)/ (cw + uw Math.Cos + vw * Math.Sin)
    /// Solutions are returned as angles in the ellipse space.
    /// <param name="cx">center x</param>
    /// <param name="cy">center y</param>
    /// <param name="cw">center w</param>
    /// <param name="ux">0 degree vector x</param>
    /// <param name="uy">0 degree vector y</param>
    /// <param name="uw">0 degree vector w</param>
    /// <param name="vx">90 degree vector x</param>
    /// <param name="vy">90 degree vector y</param>
    /// <param name="vw">90 degree vector w</param>
    /// <param name="ellipseAngles">solution angles in ellipse parameter space</param>
    /// <param name="circleAngles">solution angles in circle parameter space</param>
    /// <param name="numAngle">number of solution angles (passed as an array to change reference)</param>
    static SolveUnitCircleHomogeneousEllipseIntersection(cx, cy, cw, ux, uy, uw, vx, vy, vw, ellipseRadians, circleRadians) {
        circleRadians.length = 0;
        const acc = ux * ux + uy * uy - uw * uw;
        const acs = 2.0 * (ux * vx + uy * vy - uw * vw);
        const ass = vx * vx + vy * vy - vw * vw;
        const ac = 2.0 * (ux * cx + uy * cy - uw * cw);
        const asi = 2.0 * (vx * cx + vy * cy - vw * cw);
        const a = cx * cx + cy * cy - cw * cw;
        const boolstat = this.SolveUnitCircleImplicitQuadricIntersection(acc, acs, ass, ac, asi, a, ellipseRadians);
        for (const radians of ellipseRadians) {
            const cc = Math.cos(radians);
            const ss = Math.sin(radians);
            const x = cx + ux * cc + vx * ss;
            const y = cy + uy * cc + vy * ss;
            circleRadians.push(Math.atan2(y, x));
        }
        return boolstat;
    }
}
// Constants taken from Angle.cpp (may be later moved to a constants module)
TrigPolynomial.SmallAngle = 1.0e-11;
// Standard Basis coefficients for rational sine numerator.
TrigPolynomial.S = Float64Array.from([0.0, 2.0, -2.0]);
// Standard Basis coefficients for rational cosine numerator.
TrigPolynomial.C = Float64Array.from([1.0, -2.0]);
// Standard Basis coefficients for rational denominator.
TrigPolynomial.W = Float64Array.from([1.0, -2.0, 2.0]);
// Standard Basis coefficients for cosine*weight numerator
TrigPolynomial.CW = Float64Array.from([1.0, -4.0, 6.0, -4.0]);
// Standard Basis coefficients for sine*weight numerator
TrigPolynomial.SW = Float64Array.from([0.0, 2.0, -6.0, 8.0, -4.0]);
// Standard Basis coefficients for sine*cosine numerator
TrigPolynomial.SC = Float64Array.from([0.0, 2.0, -6.0, 4.0]);
// Standard Basis coefficients for sine^2 numerator
TrigPolynomial.SS = Float64Array.from([0.0, 0.0, 4.0, -8.0, 4.0]);
// Standard Basis coefficients for cosine^2 numerator
TrigPolynomial.CC = Float64Array.from([1.0, -4.0, 4.0]);
// Standard Basis coefficients for weight^2
TrigPolynomial.WW = Float64Array.from([1.0, -4.0, 8.0, -8.0, 4.0]);
// Standard Basis coefficients for (Math.Cos^2 - sine^2) numerator
TrigPolynomial.CCminusSS = Float64Array.from([1.0, -4.0, 0.0, 8.0, -4.0]);
TrigPolynomial.coeffientRelTol = 1.0e-12;
exports.TrigPolynomial = TrigPolynomial;
class SmallSystem {
    /**
     * Return true if lines (a0,a1) to (b0, b1) have a simple intersection.
     * Return the fractional (not xy) coordinates in result.x, result.y
     * @param a0 start point of line a
     * @param a1  end point of line a
     * @param b0  start point of line b
     * @param b1 end point of line b
     * @param result point to receive fractional coordinates of intersection.   result.x is fraction on line a. result.y is fraction on line b.
     */
    static lineSegment2dXYTransverseIntersectionUnbounded(a0, a1, b0, b1, result) {
        const ux = a1.x - a0.x;
        const uy = a1.y - a0.y;
        const vx = b1.x - b0.x;
        const vy = b1.y - b0.y;
        const cx = b0.x - a0.x;
        const cy = b0.y - a0.y;
        const uv = Geometry_1.Geometry.crossProductXYXY(ux, uy, vx, vy);
        const cv = Geometry_1.Geometry.crossProductXYXY(cx, cy, vx, vy);
        const cu = Geometry_1.Geometry.crossProductXYXY(ux, uy, cx, cy);
        const s = Geometry_1.Geometry.conditionalDivideFraction(cv, uv);
        const t = Geometry_1.Geometry.conditionalDivideFraction(cu, uv);
        if (s !== undefined && t !== undefined) {
            result.set(s, -t);
            return true;
        }
        result.set(0, 0);
        return false;
    }
    /**
     * Return true if lines (a0,a1) to (b0, b1) have a simple intersection using only xy parts
     * Return the fractional (not xy) coordinates in result.x, result.y
     * @param a0 start point of line a
     * @param a1  end point of line a
     * @param b0  start point of line b
     * @param b1 end point of line b
     * @param result point to receive fractional coordinates of intersection.   result.x is fraction on line a. result.y is fraction on line b.
     */
    static lineSegment3dXYTransverseIntersectionUnbounded(a0, a1, b0, b1, result) {
        const ux = a1.x - a0.x;
        const uy = a1.y - a0.y;
        const vx = b1.x - b0.x;
        const vy = b1.y - b0.y;
        const cx = b0.x - a0.x;
        const cy = b0.y - a0.y;
        const uv = Geometry_1.Geometry.crossProductXYXY(ux, uy, vx, vy);
        const cv = Geometry_1.Geometry.crossProductXYXY(cx, cy, vx, vy);
        const cu = Geometry_1.Geometry.crossProductXYXY(ux, uy, cx, cy);
        const s = Geometry_1.Geometry.conditionalDivideFraction(cv, uv);
        const t = Geometry_1.Geometry.conditionalDivideFraction(cu, uv);
        if (s !== undefined && t !== undefined) {
            result.set(s, -t);
            return true;
        }
        result.set(0, 0);
        return false;
    }
    /**
     * Return true if lines (a0,a1) to (b0, b1) have a simple intersection using only xy parts of WEIGHTED 4D Points
     * Return the fractional (not xy) coordinates in result.x, result.y
     * @param hA0 homogeneous start point of line a
     * @param hA1 homogeneous end point of line a
     * @param hB0 homogeneous start point of line b
     * @param hB1 homogeneous end point of line b
     * @param result point to receive fractional coordinates of intersection.   result.x is fraction on line a. result.y is fraction on line b.
     */
    static lineSegment3dHXYTransverseIntersectionUnbounded(hA0, hA1, hB0, hB1, result) {
        // Considering only x,y,w parts....
        // Point Q along B is (in full homogeneous)  `(1-lambda) B0 + lambda 1`
        // PointQ is colinear with A0,A1 when the determinat det (A0,A1,Q) is zero.  (Each column takes xyw parts)
        const alpha0 = Geometry_1.Geometry.tripleProduct(hA0.x, hA1.x, hB0.x, hA0.y, hA1.y, hB0.y, hA0.w, hA1.w, hB0.w);
        const alpha1 = Geometry_1.Geometry.tripleProduct(hA0.x, hA1.x, hB1.x, hA0.y, hA1.y, hB1.y, hA0.w, hA1.w, hB1.w);
        const fractionB = Geometry_1.Geometry.conditionalDivideFraction(-alpha0, alpha1 - alpha0);
        if (fractionB !== undefined) {
            const beta0 = Geometry_1.Geometry.tripleProduct(hB0.x, hB1.x, hA0.x, hB0.y, hB1.y, hA0.y, hB0.w, hB1.w, hA0.w);
            const beta1 = Geometry_1.Geometry.tripleProduct(hB0.x, hB1.x, hA1.x, hB0.y, hB1.y, hA1.y, hB0.w, hB1.w, hA1.w);
            const fractionA = Geometry_1.Geometry.conditionalDivideFraction(-beta0, beta1 - beta0);
            if (fractionA !== undefined)
                return Point2dVector2d_1.Vector2d.create(fractionA, fractionB, result);
        }
        return undefined;
    }
    /**
     * Return the line fraction at which the (homogeneous) line is closest to a space point as viewed in xy only.
     * @param hA0 homogeneous start point of line a
     * @param hA1 homogeneous end point of line a
     * @param spacePoint homogeneous point in space
     */
    static lineSegment3dHXYClosestPointUnbounded(hA0, hA1, spacePoint) {
        // Considering only x,y,w parts....
        // weighted difference of (A1 w0 - A0 w1) is (cartesian) tangent vector along the line as viewed.
        // The perpendicular (pure vector) W = (-y,x) flip is the direction of projection
        // Point Q along A is (in full homogeneous)  `(1-lambda) A0 + lambda 1 A1`
        // PointQ is colinear with spacePoint and and W when the xyw homogeneous determinant | Q W spacePoint | is zero.
        const tx = hA1.x * hA0.w - hA0.x * hA1.w;
        const ty = hA1.y * hA0.w - hA0.y * hA1.w;
        const det0 = Geometry_1.Geometry.tripleProduct(hA0.x, -ty, spacePoint.x, hA0.y, tx, spacePoint.y, hA0.w, 0, spacePoint.w);
        const det1 = Geometry_1.Geometry.tripleProduct(hA1.x, -ty, spacePoint.x, hA1.y, tx, spacePoint.y, hA1.w, 0, spacePoint.w);
        return Geometry_1.Geometry.conditionalDivideFraction(-det0, det1 - det0);
    }
    /**
     * Return the line fraction at which the line is closest to a space point as viewed in xy only.
     * @param pointA0 start point
     * @param pointA1 end point
     * @param spacePoint homogeneous point in space
     */
    static lineSegment3dXYClosestPointUnbounded(pointA0, pointA1, spacePoint) {
        // Considering only x,y parts....
        const ux = pointA1.x - pointA0.x;
        const uy = pointA1.y - pointA0.y;
        const uu = ux * ux + uy * uy;
        const vx = spacePoint.x - pointA0.x;
        const vy = spacePoint.y - pointA0.y;
        const uv = ux * vx + uy * vy;
        return Geometry_1.Geometry.conditionalDivideFraction(uv, uu);
    }
    /**
     * Return true if lines (a0,a1) to (b0, b1) have closest approach (go by each other) in 3d
     * Return the fractional (not xy) coordinates in result.x, result.y
     * @param a0 start point of line a
     * @param a1  end point of line a
     * @param b0  start point of line b
     * @param b1 end point of line b
     * @param result point to receive fractional coordinates of intersection.   result.x is fraction on line a. result.y is fraction on line b.
     */
    static lineSegment3dClosestApproachUnbounded(a0, a1, b0, b1, result) {
        const ux = a1.x - a0.x;
        const uy = a1.y - a0.y;
        const uz = a1.z - a0.z;
        const vx = b1.x - b0.x;
        const vy = b1.y - b0.y;
        const vz = b1.z - b0.z;
        const cx = b0.x - a0.x;
        const cy = b0.y - a0.y;
        const cz = b0.z - a0.z;
        const uu = Geometry_1.Geometry.dotProductXYZXYZ(ux, uy, uz, ux, uy, uz);
        const vv = Geometry_1.Geometry.dotProductXYZXYZ(vx, vy, vz, vx, vy, vz);
        const uv = Geometry_1.Geometry.dotProductXYZXYZ(ux, uy, uz, vx, vy, vz);
        const cu = Geometry_1.Geometry.dotProductXYZXYZ(cx, cy, cz, ux, uy, uz);
        const cv = Geometry_1.Geometry.dotProductXYZXYZ(cx, cy, cz, vx, vy, vz);
        return SmallSystem.linearSystem2d(uu, -uv, uv, -vv, cu, cv, result);
    }
    static linearSystem2d(ux, vx, // first row of matrix
    uy, vy, // second row of matrix
    cx, cy, // right side
    result) {
        const uv = Geometry_1.Geometry.crossProductXYXY(ux, uy, vx, vy);
        const cv = Geometry_1.Geometry.crossProductXYXY(cx, cy, vx, vy);
        const cu = Geometry_1.Geometry.crossProductXYXY(ux, uy, cx, cy);
        const s = Geometry_1.Geometry.conditionalDivideFraction(cv, uv);
        const t = Geometry_1.Geometry.conditionalDivideFraction(cu, uv);
        if (s !== undefined && t !== undefined) {
            result.set(s, t);
            return true;
        }
        result.set(0, 0);
        return false;
    }
    /**
     * Solve a linear system
     * * x equation: `ux *u * vx * v + wx * w = cx`
     * * y equation: `uy *u * vy * v + wy * w = cy`
     * * z equation: `uz *u * vz * v + wz * w = cz`
     * @param axx row 0, column 0 coefficient
     * @param axy row 0, column 1 coefficient
     * @param axz row 0, column 1 coefficient
     * @param ayx row 1, column 0 coefficient
     * @param ayy row 1, column 1 coefficient
     * @param ayz row 1, column 2 coefficient
     * @param azx row 2, column 0 coefficient
     * @param azy row 2, column 1 coefficient
     * @param azz row 2, column 2 coefficient
     * @param cx right hand side row 0 coefficient
     * @param cy right hand side row 1 coefficient
     * @param cz right hand side row 2 coeficient
     * @param result optional result.
     */
    static linearSystem3d(axx, axy, axz, // first row of matrix
    ayx, ayy, ayz, // second row of matrix
    azx, azy, azz, // second row of matrix
    cx, cy, cz, // right side
    result) {
        // determinants of various combinations of columns ...
        const detXYZ = Geometry_1.Geometry.tripleProduct(axx, ayx, azx, axy, ayy, azy, axz, ayz, azz);
        const detCYZ = Geometry_1.Geometry.tripleProduct(cx, cy, cz, axy, ayy, azy, axz, ayz, azz);
        const detXCZ = Geometry_1.Geometry.tripleProduct(axx, ayx, azx, cx, cy, cz, axz, ayz, azz);
        const detXYC = Geometry_1.Geometry.tripleProduct(cx, cy, cz, axy, ayy, azy, cx, cy, cz);
        const s = Geometry_1.Geometry.conditionalDivideFraction(detCYZ, detXYZ);
        const t = Geometry_1.Geometry.conditionalDivideFraction(detXCZ, detXYZ);
        const u = Geometry_1.Geometry.conditionalDivideFraction(detXYC, detXYZ);
        if (s !== undefined && t !== undefined && t !== undefined) {
            return Point3dVector3d_1.Vector3d.create(s, t, u, result);
        }
        return undefined;
    }
}
exports.SmallSystem = SmallSystem;


/***/ }),

/***/ "./lib/numerics/Quadrature.js":
/*!************************************!*\
  !*** ./lib/numerics/Quadrature.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Numerics */
/** Support class for quadrature -- approximate integrals by summing weighted function values.
 * These are filled with x and weight for quadrature between xA and xB
 *
 * Since quadrature is done in side tight loops, these methods are structured for minimum object
 * allocation.
 * For methods names setupGauss<N> (where N is a smallish integer), the CALLER creates arrays xMapped and wMapped
 * The method installs particular x and weight values.
 */
class Quadrature {
    /**
     * Given points and weights in a reference interval (usually 0 to 1):
     *
     * * map each xRef[i] to xA + h * xRef[i];
     * * scale each weight wRef[i] to h * wRef[i]
     * * all arrays are assumed to have xRef.length entries.
     * * the return value is xRef.length
     * @param xA beginning of target interval
     * @param h length of target interval
     * @param xRef x coordinates in reference interval
     * @param wRef weights for integration in the reference interval
     * @param xMapped x coordinates to evaluate integrands
     * @param wMapped weights for evaluated integrands
     */
    static mapWeights(xA, h, xRef, wRef, xMapped, wMapped) {
        const n = xRef.length;
        for (let i = 0; i < n; i++) {
            xMapped[i] = xA + h * xRef[i];
            wMapped[i] = h * wRef[i];
        }
        return n;
    }
    /* Install 1 (ONE) x and weight values for quadrature from xA to xB. */
    static setupGauss1(xA, xB, xMapped, wMapped) {
        return Quadrature.mapWeights(xA, xB - xA, Quadrature.gaussX1Interval01, Quadrature.gaussW1Interval01, xMapped, wMapped);
    }
    /* Install 2 (TWO) x and weight values for quadrature from xA to xB. */
    static setupGauss2(xA, xB, xMapped, wMapped) {
        return Quadrature.mapWeights(xA, xB - xA, Quadrature.gaussX2Interval01, Quadrature.gaussW2Interval01, xMapped, wMapped);
        /*  // exact formulas for interval xA..xB:
            const x0 = 0.5 * (xA + xB);
                const h = 0.5 * (xB - xA);
                const dx = h / Math.sqrt(3);
                xMapped[0] = x0 - dx; xMapped[1] = x0 + dx;
                wMapped[0] = wMapped[1] = h;
                */
    }
    /* Install 3 (THREE) x and weight values for quadrature from xA to xB. */
    static setupGauss3(xA, xB, xMapped, wMapped) {
        return Quadrature.mapWeights(xA, xB - xA, Quadrature.gaussX3Interval01, Quadrature.gaussW3Interval01, xMapped, wMapped);
        /*  // exact formulas for interval xA..xB:
        const x0 = 0.5 * (xA + xB);
        const h = 0.5 * (xB - xA);
        const a = Math.sqrt(0.6);
        const b = h * 5.0 / 9.0;
        const dx = a * h;
        xMapped[0] = x0 - dx; xMapped[1] = x0; xMapped[2] = x0 + dx;
        wMapped[0] = wMapped[2] = b;
        wMapped[1] = h * 8.0 / 9.0;
        return 3;
        */
    }
    /** Caller allocates and passes Float6dArray of length
     * These are filled with x and weight for quadrature between xA and xB
     */
    static setupGauss5(xA, xB, xMapped, wMapped) {
        return Quadrature.mapWeights(xA, xB - xA, Quadrature.gaussX5Interval01, Quadrature.gaussW5Interval01, xMapped, wMapped);
        /*  // exact formulas for interval xA..xB:
        const x0 = 0.5 * (xA + xB);
        const h = 0.5 * (xB - xA);
        const q = 2.0 * Math.sqrt(10.0 / 7.0);
        const b = 13.0 * Math.sqrt(70.0);
        const a1 = h * Math.sqrt(5.0 - q) / 3.0;
        const a2 = h * Math.sqrt(5.0 + q) / 3.0;
        const w1 = h * (322.0 + b) / 900.0;
        const w2 = h * (322.0 - b) / 900;
        const w0 = h * 128.0 / 225.0;
        xMapped[0] = x0 - a2; xMapped[1] = x0 - a1; xMapped[2] = x0; xMapped[3] = x0 + a1; xMapped[4] = x0 + a2;
        wMapped[0] = w2; wMapped[1] = w1; wMapped[2] = w0; wMapped[3] = w1; wMapped[4] = w2;
        return 5;
        */
    }
    static setupGauss4(xA, xB, xMapped, wMapped) {
        return Quadrature.mapWeights(xA, xB - xA, Quadrature.gaussX4Interval01, Quadrature.gaussW4Interval01, xMapped, wMapped);
        /*  // exact formulas for interval xA..xB:
    const x0 = 0.5 * (xA + xB);
    const h = 0.5 * (xB - xA);
    const q = 2.0 * Math.sqrt(6.0 / 5.0);
    const r = Math.sqrt(30.0);
    const a1 = h * Math.sqrt((3 - q) / 7.0);
    const w1 = h * (18.0 + r) / 36.0;
    const a2 = h * Math.sqrt((3 + q) / 7.0);
    const w2 = h * (18.0 - r) / 36.0;
    xMapped[0] = x0 - a2; xMapped[1] = x0 - a1; xMapped[2] = x0 + a1; xMapped[3] = x0 + a2;
    wMapped[0] = w2; wMapped[1] = w1; wMapped[2] = w1; wMapped[3] = w2;
    return 4;
    */
    }
    /** Sum function values with given weghts and x values. */
    static sum1(xx, ww, n, f) {
        let sum = 0;
        for (let i = 0; i < n; i++)
            sum += ww[i] * f(xx[i]);
        return sum;
    }
}
Quadrature.gaussX1Interval01 = new Float64Array([0.5]);
Quadrature.gaussW1Interval01 = new Float64Array([1.0]);
Quadrature.gaussX2Interval01 = new Float64Array([0.21132486540518708, 0.7886751345948129]);
Quadrature.gaussW2Interval01 = new Float64Array([0.5, 0.5]);
Quadrature.gaussX3Interval01 = new Float64Array([0.1127016653792583, 0.5, 0.8872983346207417]);
Quadrature.gaussW3Interval01 = new Float64Array([0.2777777777777778, 0.4444444444444444, 0.2777777777777778]);
Quadrature.gaussX4Interval01 = new Float64Array([0.06943184420297371, 0.33000947820757187, 0.6699905217924281, 0.9305681557970262]);
Quadrature.gaussW4Interval01 = new Float64Array([0.17392742256872692, 0.3260725774312731, 0.3260725774312731, 0.17392742256872692]);
Quadrature.gaussX5Interval01 = new Float64Array([0.04691007703066802, 0.23076534494715845, 0.5, 0.7692346550528415, 0.9530899229693319]);
Quadrature.gaussW5Interval01 = new Float64Array([0.11846344252809454, 0.23931433524968324, 0.28444444444444444, 0.23931433524968324, 0.11846344252809454]);
exports.Quadrature = Quadrature;


/***/ }),

/***/ "./lib/numerics/Range1dArray.js":
/*!**************************************!*\
  !*** ./lib/numerics/Range1dArray.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Numerics */
const Range_1 = __webpack_require__(/*! ../geometry3d/Range */ "./lib/geometry3d/Range.js");
const GrowableFloat64Array_1 = __webpack_require__(/*! ../geometry3d/GrowableFloat64Array */ "./lib/geometry3d/GrowableFloat64Array.js");
/**
 * A Range1d array is a set of intervals, such as occur when a line is clipped to a (nonconvex) polygon
 */
class Range1dArray {
    /** Internal step: Caller supplies rangeA = interval from left operand of set difference {A - B}
     *  ib = lowest possible index of overlapping interval of {B}
     *  Output live parts of rangeA, advancing B over intervals that do not extend beyond {rangeA}
     *  iB is advanced to the first interval whose high is to the right of {rangeA.high}
     */
    static advanceIntervalDifference(rangeA, dataB, iB, retVal) {
        const nB = dataB.length;
        let low = rangeA.low;
        let high = rangeA.high;
        while (iB < nB) {
            const rangeB = dataB[iB];
            if (rangeB.high < low) {
                iB++;
            }
            else if (rangeB.high <= high) {
                if (rangeB.low > low)
                    retVal.push(Range_1.Range1d.createXX(low, rangeB.low));
                low = rangeB.high;
                iB++;
            }
            else {
                // B ends beyond rangeA...
                if (rangeB.low < high)
                    high = rangeB.low;
                break;
            }
        }
        if (low < high)
            retVal.push(Range_1.Range1d.createXX(low, high));
        return retVal;
    }
    /** Intersect intervals in two pre-sorted sets. Output may NOT be the same as either input. */
    static differenceSorted(dataA, dataB) {
        const nA = dataA.length;
        const iB = 0;
        const retVal = [];
        for (let iA = 0; iA < nA; iA++) {
            Range1dArray.advanceIntervalDifference(dataA[iA], dataB, iB, retVal);
        }
        return retVal;
    }
    /** Internal step: Caller ensures rangeA is the "lower" interval.
     *  Look rangeB to decide (a) what output interval to create and (b) which read index to advance.
     *  Returns true or false to indicate whether the value associated with rangeA or rangeB should be incremented after this function returns
     */
    static advanceIntervalIntersection(rangeA, rangeB, retVal) {
        if (rangeB.low > rangeA.high) {
            return true;
        }
        else if (rangeB.high >= rangeA.high) {
            retVal.push(Range_1.Range1d.createXX(rangeB.low, rangeA.high));
            return true;
        }
        else {
            retVal.push(Range_1.Range1d.createXX(rangeB.low, rangeB.high));
            return false;
        }
    }
    static intersectSorted(dataA, dataB) {
        let iA = 0;
        let iB = 0;
        const nA = dataA.length;
        const nB = dataB.length;
        const retVal = [];
        while (iA < nA && iB < nB) {
            const rangeA = dataA[iA];
            const rangeB = dataB[iB];
            if (rangeA.low <= rangeB.low) {
                if (Range1dArray.advanceIntervalIntersection(rangeA, rangeB, retVal))
                    iA++;
                else
                    iB++;
            }
            else {
                if (Range1dArray.advanceIntervalIntersection(rangeB, rangeA, retVal))
                    iB++;
                else
                    iA++;
            }
        }
        return retVal;
    }
    /** Internal step: Read an interval from the array.
     *  If it overlaps the work interval, advance the work interval, and return true to notify caller to increment readindex.
     */
    static advanceIntervalUnion(workRange, source, readIndex) {
        if (readIndex >= source.length)
            return false;
        const candidate = source[readIndex];
        if (candidate.low > workRange.high)
            return false;
        if (candidate.high > workRange.high)
            workRange.high = candidate.high;
        return true;
    }
    static unionSorted(dataA, dataB) {
        const nA = dataA.length;
        const nB = dataB.length;
        let iA = 0;
        let iB = 0;
        const retVal = [];
        while (iA < nA && iB < nB) {
            const rangeA = dataA[iA];
            const rangeB = dataB[iB];
            let workRange;
            // Pull from the lower of rangeA and rangeB. This always advances exactly one of the indices -- progress towards getting out.
            if (rangeA.low <= rangeB.low) {
                workRange = rangeA.clone();
                iA++;
            }
            else {
                workRange = rangeB.clone();
                iB++;
            }
            let toLoop = true;
            do {
                const resultA = Range1dArray.advanceIntervalUnion(workRange, dataA, iA);
                const resultB = Range1dArray.advanceIntervalUnion(workRange, dataB, iB);
                if (resultA)
                    iA++;
                if (resultB)
                    iB++;
                if (!(resultA || resultB))
                    toLoop = false;
            } while (toLoop);
            retVal.push(workRange);
        }
        while (iA < nA)
            retVal.push(dataA[iA++]);
        while (iB < nB)
            retVal.push(dataB[iB++]);
        return retVal;
    }
    static paritySorted(dataA, dataB) {
        // Combine the two arrays, and then perform a simplification using simplifySortParity function
        const retVal = [];
        for (const range of dataA)
            retVal.push(range.clone());
        for (const range of dataB)
            retVal.push(range.clone());
        // Sort the array
        retVal.sort(compareRange1dLexicalLowHigh);
        Range1dArray.simplifySortParity(retVal, true);
        return retVal;
    }
    /** Uses the Range1d specific compare function for sorting the array of ranges */
    static sort(data) {
        data.sort(compareRange1dLexicalLowHigh);
    }
    /** Cleans up the array, compressing any overlapping ranges. If removeZeroLengthRanges is set to true, will also remove any Ranges in the form (x, x) */
    static simplifySortUnion(data, removeZeroLengthRanges = false) {
        if (data.length < 2)
            return;
        data.sort(compareRange1dLexicalLowHigh);
        let currIdx = 0;
        let toInsert = false;
        for (let i = 0; i < data.length; i++) {
            if (i === data.length - 1) {
                if (toInsert) {
                    if (!removeZeroLengthRanges || data[i].low !== data[i].high)
                        data[currIdx++] = data[i];
                }
                break;
            }
            if (data[i + 1].low > data[i].high) {
                if (!removeZeroLengthRanges || data[i].low !== data[i].high)
                    data[currIdx++] = data[i];
                continue;
            }
            else {
                data[i + 1].low = data[i].low;
                data[i + 1].high = Math.max(data[i].high, data[i + 1].high);
                toInsert = true;
            }
        }
        data.length = currIdx;
    }
    static simplifySortParity(data, removeZeroLengthRanges = false) {
        const numData = [];
        for (const range of data) {
            if (range.low !== range.high) {
                numData.push(range.low);
                numData.push(range.high);
            }
        }
        const n = numData.length;
        numData.sort((a, b) => {
            if (a < b)
                return -1;
            if (a > b)
                return 1;
            return 0;
        });
        let currIdx = 0;
        let x0;
        let x1;
        for (let i = 0; i < n; i += 2) {
            x0 = numData[i];
            x1 = numData[i + 1];
            if (!removeZeroLengthRanges) {
                Range_1.Range1d.createXX(x0, x1, data[currIdx++]);
            }
            else {
                // coalesce intervals that share end and start:
                while (i + 2 < n && numData[i + 2] === x1) {
                    i += 2;
                    x1 = numData[i + 1];
                }
                if (x1 > x0)
                    Range_1.Range1d.createXX(x0, x1, data[currIdx++]);
            }
        }
        data.length = currIdx;
    }
    /** test if value is "in" by union rules.
     * * This considers all intervals-- i.e. does not expect or take advantage of sorting.
     */
    static testUnion(data, value) {
        return this.countContainingRanges(data, value) > 0;
    }
    /** test if value is "in" by parity rules.
     * * This considers all intervals-- i.e. does not expect or take advantage of sorting.
     */
    static testParity(data, value) {
        let inside = false;
        for (const range of data) {
            if (range.containsX(value))
                inside = !inside;
        }
        return inside;
    }
    /** linear search to count number of intervals which contain `value`.
     */
    static countContainingRanges(data, value) {
        let n = 0;
        for (const range of data) {
            if (range.containsX(value))
                n++;
        }
        return n;
    }
    /** return an array with all the low and high values of all the ranges.
     * @param data array of ranges.
     * @param sort optionally request immediate sort.
     * @param compress optionally request removal of duplicates.
     */
    static getBreaks(data, result, sort = false, compress = false) {
        if (!result)
            result = new GrowableFloat64Array_1.GrowableFloat64Array(2 * data.length);
        result.clear();
        for (const range of data) {
            result.push(range.low);
            result.push(range.high);
        }
        if (sort)
            result.sort();
        if (compress)
            result.compressAdjcentDuplicates();
        return result;
    }
    /** sum the lengths of all ranges */
    static sumLengths(data) {
        let sum = 0.0;
        for (const range of data) {
            sum += range.length();
        }
        return sum;
    }
    /**
     * Test if the low,high values are sorted with no overlap.
     * @param data array of ranges.
     * @param strict if true, consider exact high-to-low match as overlap.
     */
    static isSorted(data, strict = true) {
        const n = data.length;
        if (strict) {
            for (let i = 0; i + 1 < n; i++) {
                if (data[i].high >= data[i + 1].low)
                    return false;
            }
        }
        else {
            for (let i = 0; i + 1 < n; i++) {
                if (data[i].high > data[i + 1].low)
                    return false;
            }
        }
        return true;
    }
}
exports.Range1dArray = Range1dArray;
/** Checks low's first, then high's */
function compareRange1dLexicalLowHigh(a, b) {
    if (a.low < b.low)
        return -1;
    if (a.low > b.low)
        return 1;
    if (a.high < b.high)
        return -1;
    if (a.high > b.high)
        return 1;
    return 0;
}
exports.compareRange1dLexicalLowHigh = compareRange1dLexicalLowHigh;


/***/ }),

/***/ "./lib/numerics/TriDiagonalSystem.js":
/*!*******************************************!*\
  !*** ./lib/numerics/TriDiagonalSystem.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Numerics */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
// Enumerated type lies outside of TriDiagonalSystem, as TSLint prevented declaration within class
var DataState;
(function (DataState) {
    DataState[DataState["RawMatrix"] = 0] = "RawMatrix";
    DataState[DataState["FactorOK"] = 1] = "FactorOK";
    DataState[DataState["FactorFailed"] = 2] = "FactorFailed";
})(DataState || (DataState = {}));
class TriDiagonalSystem {
    constructor(n) {
        this._aLeft = new Float64Array(n);
        this._aDiag = new Float64Array(n);
        this._aRight = new Float64Array(n);
        this._b = new Float64Array(n);
        this._x = new Float64Array(n);
        this.Reset();
    }
    // Reset to RawMatrix state with all coefficients zero
    Reset() {
        this._dataState = DataState.RawMatrix;
        const n = this._aDiag.length;
        for (let i = 0; i < n; i++) {
            this._aLeft[i] = this._aRight[i] = this._aDiag[i] = this._b[i] = this._x[i] = 0.0;
        }
    }
    // Install data in a row of the matrix
    SetRow(row, left, diag, right) {
        this._aLeft[row] = left;
        this._aDiag[row] = diag;
        this._aRight[row] = right;
    }
    // Add to row of matrix
    AddToRow(row, left, diag, right) {
        this._aLeft[row] += left;
        this._aDiag[row] += diag;
        this._aRight[row] += right;
    }
    // Install data in the right side (B) vector
    SetB(row, bb) {
        this._b[row] = bb;
    }
    // Add to an entry in the right side (B) vector
    AddToB(row, bb) {
        this._b[row] += bb;
    }
    // Access data from the right side (B) vector
    GetB(row) {
        return this._b[row];
    }
    // Install data in the solution (X) vector
    SetX(row, xx) {
        this._x[row] = xx;
    }
    // Access data frin the solution (X) vector
    GetX(row) {
        return this._x[row];
    }
    // Get method for matrix and vector order
    Order() {
        return this._aDiag.length;
    }
    // Compute product of AX and save as B
    MultiplyAX() {
        if (this._dataState === DataState.FactorFailed) {
            return false;
        }
        else if (this._dataState === DataState.FactorOK) {
            const n = this._aDiag.length;
            const nm1 = n - 1;
            for (let i = 0; i < nm1; i++) {
                this._b[i] = this._aDiag[i] * this._x[i] + this._aRight[i] * this._x[i + 1];
            }
            this._b[nm1] = this._aDiag[nm1] * this._x[nm1];
            for (let i = nm1; i > 0; i--) {
                this._b[i] += this._aLeft[i] * this._b[i - 1];
            }
            return true;
        }
        else {
            const n = this._aDiag.length;
            const nm1 = n - 1;
            this._b[0] = this._aDiag[0] * this._x[0] + this._aRight[0] * this._x[1];
            let i;
            for (i = 1; i < nm1; i++) {
                this._b[i] = this._aLeft[i] * this._x[i - 1] + this._aDiag[i] * this._x[i] + this._aRight[i] * this._x[i + 1];
            }
            this._b[nm1] = this._aLeft[nm1] * this._x[n - 2] + this._aDiag[i] * this._x[nm1];
            return true;
        }
    }
    // Compute product of AX and save as B
    MultiplyAXPoints(pointX, pointB) {
        pointB.length = 0;
        while (pointB.length < pointX.length)
            pointB.push(Point3dVector3d_1.Point3d.create());
        pointB.length = pointX.length;
        if (this._dataState === DataState.FactorFailed) {
            return false;
        }
        else if (this._dataState === DataState.FactorOK) {
            const n = this._aDiag.length;
            const nm1 = n - 1;
            for (let i = 0; i < nm1; i++) {
                Point3dVector3d_1.Point3d.createAdd2Scaled(pointX[i], this._aDiag[i], pointX[i + 1], this._aRight[i], pointB[i]);
            }
            Point3dVector3d_1.Point3d.createScale(pointX[nm1], this._aDiag[nm1], pointB[nm1]);
            for (let i = nm1; i > 0; i--) {
                pointB[i].plusScaled(pointB[i - 1], this._aLeft[i], pointB[i]);
            }
            return true;
        }
        else {
            const n = this._aDiag.length;
            const nm1 = n - 1;
            Point3dVector3d_1.Point3d.createAdd2Scaled(pointX[0], this._aDiag[0], pointX[1], this._aRight[0], pointB[0]);
            let i;
            for (i = 1; i < nm1; i++) {
                Point3dVector3d_1.Point3d.createAdd3Scaled(pointX[i - 1], this._aLeft[i], pointX[i], this._aDiag[i], pointX[i + 1], this._aRight[i], pointB[i]);
            }
            Point3dVector3d_1.Point3d.createAdd2Scaled(pointX[n - 2], this._aLeft[nm1], pointX[nm1], this._aDiag[nm1], pointB[nm1]);
            return true;
        }
    }
    // Multiply the stored factors together to return to plain matrix form
    Defactor() {
        if (this._dataState === DataState.RawMatrix) {
            return true;
        }
        if (this._dataState === DataState.FactorFailed) {
            return false;
        }
        const n = this._aDiag.length;
        const nm1 = n - 1;
        for (let i = nm1; i > 0; i--) {
            this._aDiag[i] += this._aLeft[i] * this._aRight[i - 1];
            this._aLeft[i] *= this._aDiag[i - 1];
        }
        this._dataState = DataState.RawMatrix;
        return true;
    }
    // Factor the tridiagonal matrix to LU parts. b, x, not altered
    Factor() {
        if (this._dataState === DataState.FactorOK) {
            return true;
        }
        if (this._dataState !== DataState.RawMatrix) {
            return false;
        }
        this._dataState = DataState.FactorFailed;
        const n1 = this._aDiag.length - 1; // Last pivot index
        // Eliminate in subdiagonal.
        for (let i = 0; i < n1; i++) {
            const r = Geometry_1.Geometry.conditionalDivideFraction(this._aLeft[i + 1], this._aDiag[i]);
            if (!r)
                return false;
            this._aLeft[i + 1] = r;
            this._aDiag[i + 1] -= r * this._aRight[i];
        }
        this._dataState = DataState.FactorOK;
        return true;
    }
    // Solve AX=B. A is left in factored state. B unchanged.
    FactorAndBackSubstitute() {
        const n = this._aDiag.length;
        const n1 = n - 1;
        if (!this.Factor())
            return false;
        // Apply Linv to B, same sequence as was done to A:
        for (let i = 0; i < n; i++) {
            this._x[i] = this._b[i];
        }
        for (let i = 1; i < n; i++) {
            this._x[i] -= this._aLeft[i] * this._x[i - 1];
        }
        // Print ("LU  LinvB B");
        // overwrite X with solution of U * X = Linv B, where RHS is already in X...
        // All diagonals are known to be nonzero. Really.  Really???
        this._x[n1] /= this._aDiag[n1];
        for (let i = n1 - 1; i >= 0; i--) {
            this._x[i] = (this._x[i] - this._aRight[i] * this._x[i + 1]) / this._aDiag[i];
        }
        return true;
    }
    // Solve AX=B. A is left in factored state. B unchanged. vectorB and vectorX may be the same array
    FactorAndBackSubstitutePointArrays(vectorB, vectorX) {
        const n = this._aDiag.length;
        if (vectorB.length < n)
            return false;
        while (vectorX.length < n)
            vectorX.push(Point3dVector3d_1.Point3d.create(0, 0, 0));
        vectorX.length = n;
        const n1 = n - 1;
        if (!this.Factor())
            return false;
        // Apply Linv to B, same sequence as was done to A:
        if (vectorB !== vectorX) {
            for (let i = 0; i < n; i++) {
                vectorX[i].setFrom(vectorB[i]);
            }
        }
        let a;
        let b;
        for (let i = 1; i < n; i++) {
            a = this._aLeft[i];
            vectorX[i].x -= a * vectorX[i - 1].x;
            vectorX[i].y -= a * vectorX[i - 1].y;
            vectorX[i].z -= a * vectorX[i - 1].z;
        }
        // Print ("LU  LinvB B");
        // overwrite X with solution of U * X = Linv B, where RHS is already in X...
        // All diagonals are known to be nonzero. Really.  Really???
        b = 1.0 / this._aDiag[n1];
        vectorX[n1].x *= b;
        vectorX[n1].y *= b;
        vectorX[n1].z *= b;
        for (let i = n1 - 1; i >= 0; i--) {
            a = this._aRight[i];
            b = 1.0 / this._aDiag[i];
            vectorX[i].x = (vectorX[i].x - a * vectorX[i + 1].x) * b;
            vectorX[i].y = (vectorX[i].y - a * vectorX[i + 1].y) * b;
            vectorX[i].z = (vectorX[i].z - a * vectorX[i + 1].z) * b;
        }
        return true;
    }
    // Allocate a complete copy
    Copy() {
        const n = this._aDiag.length;
        const B = new TriDiagonalSystem(n);
        for (let i = 0; i < n; i++) {
            B._aLeft[i] = this._aLeft[i];
            B._aDiag[i] = this._aDiag[i];
            B._aRight[i] = this._aRight[i];
            B._x[i] = this._x[i];
            B._b[i] = this._b[i];
        }
        B._dataState = this._dataState;
        return B;
    }
    // return an array form that may be useful for display ...
    flatten() {
        const n = this._aDiag.length;
        const data = [];
        for (let i = 0; i < n; i++) {
            data.push([i, [this._aLeft[i], this._aDiag[i], this._aRight[i]], this._x[i], this._b[i]]);
        }
        return data;
    }
    // return an array form that may be useful for display ...
    flattenWithPoints(xyzB) {
        const n = this._aDiag.length;
        const data = [];
        for (let i = 0; i < n; i++) {
            data.push([i, [this._aLeft[i], this._aDiag[i], this._aRight[i]], this._x[i], xyzB[i].toJSON()]);
        }
        return data;
    }
}
exports.TriDiagonalSystem = TriDiagonalSystem;


/***/ }),

/***/ "./lib/polyface/BoxTopology.js":
/*!*************************************!*\
  !*** ./lib/polyface/BoxTopology.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Polyface */
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
//
//      2------------------3
//      | \     F4       / |
//      |   6----------7   |
//      |   |          |   |   (BOTTOM = F0)
//      |F5 |   F1     |F3 |
//      |   |          |   |
//      |   4----------5   |
//      | /     F2       \ |
//      0------------------1
//
class BoxTopology {
}
/**
 * static readonly array with the coordinates of the 8 unit cube corners in standard order, which is:
 * x varies fastest
 * * The point indices for the x edges are (0 to 1), (2 to 3), (4 to 5), (6 to 7)
 * * The point indices for the y edges are (0 to 2), (1 to 3), (4 to 6), (5 to 7)
 * * The point indices for the z edges are (0 to 4), (1 to 5), (2 to 6), (3 to 7)
 */
BoxTopology.points = [
    Point3dVector3d_1.Point3d.create(0, 0, 0),
    Point3dVector3d_1.Point3d.create(1, 0, 0),
    Point3dVector3d_1.Point3d.create(0, 1, 0),
    Point3dVector3d_1.Point3d.create(1, 1, 0),
    Point3dVector3d_1.Point3d.create(0, 0, 1),
    Point3dVector3d_1.Point3d.create(1, 0, 1),
    Point3dVector3d_1.Point3d.create(0, 1, 1),
    Point3dVector3d_1.Point3d.create(1, 1, 1),
];
BoxTopology.primaryCapId = -1;
// cornerIndexCCW[face][*] = vertices around face
BoxTopology.cornerIndexCCW = [
    [1, 0, 2, 3],
    [4, 5, 7, 6],
    [0, 1, 5, 4],
    [1, 3, 7, 5],
    [3, 2, 6, 7],
    [2, 0, 4, 6]
];
// [partnerFace[faceIndex][*] = adjacent face indices.
BoxTopology.partnerFace = [
    [5, 4, 3, 2],
    [2, 3, 4, 5],
    [0, 3, 1, 5],
    [0, 4, 1, 2],
    [0, 5, 1, 3],
    [0, 2, 1, 4],
];
BoxTopology.faceId = [
    [BoxTopology.primaryCapId, 0],
    [BoxTopology.primaryCapId, 1],
    [0, 0],
    [0, 1],
    [0, 2],
    [0, 3]
];
// faceDirections[faceIndex] =[[edge0AxisIndex, edge1AxisIndex, normalAxisIndex],[direction sign for along the axis]
BoxTopology.faceDirections = [
    [[0, 1, 2], [-1, 1, -1]],
    [[0, 1, 2], [1, 1, 1]],
    [[0, 2, 1], [1, -1, 1]],
    [[1, 2, 0], [1, 1, 1]],
    [[0, 2, 1], [-1, 1, 1]],
    [[1, 2, 0], [-1, 1, -1]]
];
// axisEdgeVertex[axisIndex][edgeIndex 0..3][*] = vertex index at end of edge in axisIndex direction.
BoxTopology.axisEdgeVertex = [
    [[0, 1], [2, 3], [4, 5], [6, 7]],
    [[0, 2], [1, 3], [4, 6], [5, 7]],
    [[0, 4], [1, 5], [2, 6], [3, 7]]
];
exports.BoxTopology = BoxTopology;


/***/ }),

/***/ "./lib/polyface/Polyface.js":
/*!**********************************!*\
  !*** ./lib/polyface/Polyface.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Polyface */
// import { Point2d } from "./Geometry2d";
/* tslint:disable:variable-name jsdoc-format no-empty*/
// import { Geometry } from "./Geometry";
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Range_1 = __webpack_require__(/*! ../geometry3d/Range */ "./lib/geometry3d/Range.js");
const PointHelpers_1 = __webpack_require__(/*! ../geometry3d/PointHelpers */ "./lib/geometry3d/PointHelpers.js");
const GrowableFloat64Array_1 = __webpack_require__(/*! ../geometry3d/GrowableFloat64Array */ "./lib/geometry3d/GrowableFloat64Array.js");
const GeometryQuery_1 = __webpack_require__(/*! ../curve/GeometryQuery */ "./lib/curve/GeometryQuery.js");
const PolyfaceData_1 = __webpack_require__(/*! ./PolyfaceData */ "./lib/polyface/PolyfaceData.js");
/**
 * Check validity of indices into a data array.
 * * It is valid to have  both indices and data undeinfed.
 * * It is NOT valid for just one to be defined.
 * * Index values at indices[indexPositionA <= i < indexPositionB] must be valid indices to the data array.
 * @param indices array of indices.
 * @param indexPositionA first index to test
 * @param indexPositionB one past final index to test
 * @param data data array.  Only its length is referenced.
 */
function areIndicesValid(indices, indexPositionA, indexPositionB, data) {
    if (indices === undefined && data === undefined)
        return true;
    if (!indices || !data)
        return false;
    const dataLength = data.length;
    if (indexPositionA < 0 || indexPositionA >= indices.length)
        return false;
    if (indexPositionB < indexPositionA || indexPositionB > indices.length)
        return false;
    for (let i = indexPositionA; i < indexPositionB; i++)
        if (indices[i] < 0 || indices[i] >= dataLength)
            return false;
    return true;
}
function allDefined(valueA, valueB, valueC) {
    return valueA !== undefined && valueB !== undefined && valueC !== undefined;
}
/**
 * Data for a face in a polyface containing facets.
 * This is built up cooperatively by the PolyfaceBuilder and its
 * callers, and stored as a FaceData array in PolyfaceData.
 */
class FacetFaceData {
    get paramDistanceRange() { return this._paramDistanceRange; }
    get paramRange() { return this._paramRange; }
    constructor(distanceRange, paramRange) {
        this._paramDistanceRange = distanceRange;
        this._paramRange = paramRange;
    }
    /** Create a FacetFaceData with null ranges. */
    static createNull() {
        return new FacetFaceData(Range_1.Range2d.createNull(), Range_1.Range2d.createNull());
    }
    /** Create a deep copy of this FacetFaceData object. */
    clone(result) {
        if (result) {
            this._paramDistanceRange.clone(result._paramDistanceRange);
            this._paramRange.clone(result._paramRange);
            return result;
        }
        return new FacetFaceData(this._paramDistanceRange.clone(), this._paramRange.clone());
    }
    /** Restore this FacetFaceData to its null constructor state. */
    null() {
        this._paramDistanceRange.setNull();
        this._paramRange.setNull();
    }
    /** Return distance-based parameter from stored parameter value. */
    convertParamToDistance(param, result) {
        result = result ? result : Point2dVector2d_1.Point2d.create();
        const paramDelta = this._paramRange.high.minus(this._paramRange.low);
        result.x = (0 === paramDelta.x) ? param.x : (this._paramDistanceRange.low.x + (param.x - this._paramRange.low.x)
            * (this._paramDistanceRange.high.x - this._paramDistanceRange.low.x) / paramDelta.x);
        result.y = (0.0 === paramDelta.y) ? param.y : (this.paramDistanceRange.low.y + (param.y - this._paramRange.low.y)
            * (this._paramDistanceRange.high.y - this._paramDistanceRange.low.y) / paramDelta.y);
        return result;
    }
    /** Return normalized (0-1) parameter from stored parameter value. */
    convertParamToNormalized(param, result) {
        result = result ? result : Point2dVector2d_1.Point2d.create();
        const paramDelta = this._paramRange.high.minus(this._paramRange.low);
        result.x = (0.0 === paramDelta.x) ? param.x : ((param.x - this._paramRange.low.x) / paramDelta.x);
        result.y = (0.0 === paramDelta.y) ? param.y : ((param.y - this._paramRange.low.y) / paramDelta.y);
        return result;
    }
    /** Scale distance paramaters. */
    scaleDistances(distanceScale) {
        this._paramDistanceRange.low.x *= distanceScale;
        this._paramDistanceRange.low.y *= distanceScale;
        this._paramDistanceRange.high.x *= distanceScale;
        this._paramDistanceRange.high.y *= distanceScale;
    }
    /**
     * Sets the paramDistance range of this FacetFaceData based on the newly terminated facets that make it up.
     * Takes the polyface itself, the first and last indexes of the facets to be included in the face.
     * Returns true on success, false otherwise.
     */
    setParamDistanceRangeFromNewFaceData(polyface, facetStart, facetEnd) {
        const dSTotal = Point2dVector2d_1.Point2d.create();
        const dSSquaredTotal = Point2dVector2d_1.Point2d.create();
        let aveTotal = 0;
        const visitor = IndexedPolyfaceVisitor.create(polyface, 0);
        if (!visitor.moveToReadIndex(facetStart))
            return false;
        do {
            const numPointsInFacet = visitor.numEdgesThisFacet;
            const visitorPoints = visitor.point;
            const trianglePointIndexes = [];
            const visitorParams = visitor.param;
            const triangleParamIndexes = [];
            if (!visitorParams)
                return false;
            for (let k = 0; k < numPointsInFacet; k++) {
                trianglePointIndexes[2] = k;
                triangleParamIndexes[2] = k;
                if (k > 1) {
                    const dUV0 = visitorParams[triangleParamIndexes[0]].minus(visitorParams[triangleParamIndexes[1]]);
                    const dUV1 = visitorParams[triangleParamIndexes[1]].minus(visitorParams[triangleParamIndexes[2]]);
                    const delta0 = visitorPoints.getPoint3dAt(trianglePointIndexes[0]).minus(visitorPoints.getPoint3dAt(trianglePointIndexes[1]));
                    const delta1 = visitorPoints.getPoint3dAt(trianglePointIndexes[1]).minus(visitorPoints.getPoint3dAt(trianglePointIndexes[2]));
                    const uvCross = Math.abs(dUV0.x * dUV1.y - dUV1.x * dUV0.y);
                    if (uvCross) {
                        const dwDu = Point3dVector3d_1.Point3d.createFrom(delta0);
                        dwDu.scaleInPlace(dUV1.y);
                        dwDu.addScaledInPlace(delta1, -dUV0.y);
                        const dwDv = Point3dVector3d_1.Point3d.createFrom(delta1);
                        dwDv.scaleInPlace(dUV0.x);
                        dwDv.addScaledInPlace(delta0, -dUV1.x);
                        const dS = Point2dVector2d_1.Point2d.create(dwDu.magnitude() / uvCross, dwDv.magnitude() / uvCross);
                        dSTotal.x += dS.x;
                        dSTotal.y += dS.y;
                        dSSquaredTotal.x += dS.x * dS.x;
                        dSSquaredTotal.y += dS.y * dS.y;
                        aveTotal++;
                    }
                }
                triangleParamIndexes[0] = triangleParamIndexes[1];
                triangleParamIndexes[1] = triangleParamIndexes[2];
                trianglePointIndexes[0] = trianglePointIndexes[1];
                trianglePointIndexes[1] = trianglePointIndexes[2];
            }
        } while (visitor.moveToNextFacet() && visitor.currentReadIndex() < facetEnd);
        if (aveTotal !== 0) {
            const dS = Point2dVector2d_1.Point2d.create(dSTotal.x / aveTotal, dSTotal.y / aveTotal);
            const standardDeviation = Point2dVector2d_1.Point2d.create(Math.sqrt(Math.abs((dSSquaredTotal.x / aveTotal) - dS.x * dS.x)), Math.sqrt(Math.abs((dSSquaredTotal.y / aveTotal) - dS.y * dS.y)));
            // TR# 268980 - Add standard deviation to match QV....
            this._paramDistanceRange.low.set(0, 0);
            this._paramDistanceRange.high.set((dS.x + standardDeviation.x) * (this._paramRange.high.x - this._paramRange.low.x), (dS.y + standardDeviation.y) * (this._paramRange.high.y - this._paramRange.low.y));
        }
        return true;
    }
}
exports.FacetFaceData = FacetFaceData;
/** The data types of [[AuxChannel]].  The scalar types are used to produce thematic  vertex colors. */
var AuxChannelDataType;
(function (AuxChannelDataType) {
    /** General scalar type - no scaling is applied if associated [[Polyface]] is transformed. */
    AuxChannelDataType[AuxChannelDataType["Scalar"] = 0] = "Scalar";
    /** Distance (scalar) scaling is applied if associated [[Polyface]] is scaled. 3 Data values (x,y.z) per entry. */
    AuxChannelDataType[AuxChannelDataType["Distance"] = 1] = "Distance";
    /** Displacement added to  vertex position.  Transformed and scaled with associated [[Polyface]]. 3 Data values (x,y.z) per entry.,*/
    AuxChannelDataType[AuxChannelDataType["Vector"] = 2] = "Vector";
    /** Normal -- replaces vertex normal.  Rotated with associated [[Polyface]] transformation. 3 Data values (x,y.z) per entry. */
    AuxChannelDataType[AuxChannelDataType["Normal"] = 3] = "Normal";
})(AuxChannelDataType = exports.AuxChannelDataType || (exports.AuxChannelDataType = {}));
/**  Represents the [[AuxChannel]] data at a single input value. */
class AuxChannelData {
    /** Construct a new [[AuxChannelData]] from input value and vertex values. */
    constructor(input, values) {
        this.input = input;
        this.values = values;
    }
    copyValues(other, thisIndex, otherIndex, blockSize) {
        for (let i = 0; i < blockSize; i++)
            this.values[thisIndex * blockSize + i] = other.values[otherIndex * blockSize + i];
    }
    clone() {
        return new AuxChannelData(this.input, this.values.slice());
    }
    isAlmostEqual(other, tol) {
        const tolerance = tol ? tol : 1.0E-8;
        return Math.abs(this.input - other.input) < tolerance && PointHelpers_1.NumberArray.isAlmostEqual(this.values, other.values, tolerance);
    }
}
exports.AuxChannelData = AuxChannelData;
/**  Represents a single [[PolyfaceAuxData]] channel. A channel  may represent a single scalar value such as stress or temperature or may represent displacements from vertex position or replacements for normals. */
class AuxChannel {
    /** create a [[AuxChannel]] */
    constructor(data, dataType, name, inputName) {
        this.data = data;
        this.dataType = dataType;
        this.name = name;
        this.inputName = inputName;
    }
    clone() {
        const clonedData = [];
        for (const data of this.data)
            clonedData.push(data.clone());
        return new AuxChannel(clonedData, this.dataType, this.name, this.inputName);
    }
    isAlmostEqual(other, tol) {
        if (this.dataType !== other.dataType ||
            this.name !== other.name ||
            this.inputName !== other.inputName ||
            this.data.length !== other.data.length)
            return false;
        for (let i = 0; i < this.data.length; i++)
            if (!this.data[i].isAlmostEqual(other.data[i], tol))
                return false;
        return true;
    }
    /** return true if the data for this channel is of scalar type (single data entry per value) */
    get isScalar() { return this.dataType === AuxChannelDataType.Distance || this.dataType === AuxChannelDataType.Scalar; }
    /** return the number of data values per entry (1 for scalar, 3 for point or vector */
    get entriesPerValue() { return this.isScalar ? 1 : 3; }
    /** return value count */
    get valueCount() { return 0 === this.data.length ? 0 : this.data[0].values.length / this.entriesPerValue; }
    /** return the range of the scalar data. (undefined if not scalar) */
    get scalarRange() {
        if (!this.isScalar)
            return undefined;
        const range = Range_1.Range1d.createNull();
        for (const data of this.data) {
            range.extendArray(data.values);
        }
        return range;
    }
}
exports.AuxChannel = AuxChannel;
/**  The `PolyfaceAuxData` structure contains one or more analytical data channels for each vertex of a `Polyface`.
 * Typically a `Polyface` will contain only vertex data required for its basic display,the vertex position, normal
 * and possibly texture parameter.  The `PolyfaceAuxData` structure contains supplemental data that is generally computed
 *  in an analysis program or other external data source.  This can be scalar data used to either overide the vertex colors through *Thematic Colorization* or
 *  XYZ data used to deform the mesh by adjusting the vertex postions or normals.
 */
class PolyfaceAuxData {
    constructor(channels, indices) {
        this.channels = channels;
        this.indices = indices;
    }
    clone() {
        const clonedChannels = [];
        for (const channel of this.channels)
            clonedChannels.push(channel.clone());
        return new PolyfaceAuxData(clonedChannels, this.indices.slice());
    }
    isAlmostEqual(other, tol) {
        if (!PointHelpers_1.NumberArray.isExactEqual(this.indices, other.indices) || this.channels.length !== other.channels.length)
            return false;
        for (let i = 0; i < this.channels.length; i++)
            if (!this.channels[i].isAlmostEqual(other.channels[i], tol))
                return false;
        return true;
    }
    createForVisitor() {
        const visitorChannels = [];
        for (const parentChannel of this.channels) {
            const visitorChannelData = [];
            for (const parentChannelData of parentChannel.data) {
                visitorChannelData.push(new AuxChannelData(parentChannelData.input, []));
            }
            visitorChannels.push(new AuxChannel(visitorChannelData, parentChannel.dataType, parentChannel.name, parentChannel.inputName));
        }
        return new PolyfaceAuxData(visitorChannels, []);
    }
}
exports.PolyfaceAuxData = PolyfaceAuxData;
/**
 * A Polyface is n abstract mesh structure (of unspecified implementation) that provides a PolyfaceVisitor
 * to iterate over its facets.
 */
class Polyface extends GeometryQuery_1.GeometryQuery {
    constructor(data) {
        super();
        this._twoSided = false;
        this.data = data;
    }
    get twoSided() { return this._twoSided; }
    set twoSided(value) { this._twoSided = value; }
}
exports.Polyface = Polyface;
class IndexedPolyface extends Polyface {
    isSameGeometryClass(other) { return other instanceof IndexedPolyface; }
    /** Tests for equivalence between two IndexedPolyfaces. */
    isAlmostEqual(other) {
        if (other instanceof IndexedPolyface) {
            return this.data.isAlmostEqual(other.data) && PointHelpers_1.NumberArray.isExactEqual(this._facetStart, other._facetStart) &&
                PointHelpers_1.NumberArray.isExactEqual(this._facetToFaceData, other._facetToFaceData);
        }
        return false;
    }
    tryTransformInPlace(transform) {
        if (this.data.tryTransformInPlace(transform)) {
            const determinant = transform.matrix.determinant();
            if (determinant < 0) {
                this.reverseIndices();
                this.reverseNormals();
            }
        }
        return false;
    }
    clone() {
        return new IndexedPolyface(this.data.clone(), this._facetStart.slice(), this._facetToFaceData.slice());
    }
    cloneTransformed(transform) {
        const result = this.clone();
        result.tryTransformInPlace(transform);
        return result;
    }
    reverseIndices() { this.data.reverseIndices(this._facetStart); }
    reverseNormals() { this.data.reverseNormals(); }
    /** return face data using a facet index. This is the REFERENCE to the FacetFaceData, not a copy. Returns undefined if none found. */
    tryGetFaceData(i) {
        const faceIndex = this._facetToFaceData[i];
        if (faceIndex >= this.data.face.length)
            return undefined;
        return this.data.face[faceIndex];
    }
    constructor(data, facetStart, facetToFaceData) {
        super(data);
        if (facetStart)
            this._facetStart = facetStart.slice();
        else {
            this._facetStart = [];
            this._facetStart.push(0);
        }
        if (facetToFaceData)
            this._facetToFaceData = facetToFaceData.slice();
        else
            this._facetToFaceData = [];
    }
    /**
     * * Add facets from source to this polyface.
     * * optionally reverse the facets.
     * * optionally apply a transform to points.
     * * will only copy param, normal, color, and face data if we are already tracking them AND/OR the source contains them
     */
    addIndexedPolyface(source, reversed, transform) {
        const copyParams = allDefined(this.data.param, source.data.param, source.data.paramIndex);
        const copyNormals = allDefined(this.data.normal, source.data.normal, source.data.normalIndex);
        // Add point data
        const sourceToDestPointIndex = new GrowableFloat64Array_1.GrowableFloat64Array();
        sourceToDestPointIndex.ensureCapacity(source.data.pointCount);
        const sourcePoints = source.data.point;
        const xyz = Point3dVector3d_1.Point3d.create();
        for (let i = 0, n = source.data.point.length; i < n; i++) {
            sourcePoints.getPoint3dAt(i, xyz);
            if (transform) {
                transform.multiplyPoint3d(xyz, xyz);
                sourceToDestPointIndex.push(this.addPoint(xyz));
            }
            else
                sourceToDestPointIndex.push(this.addPoint(xyz));
        }
        // Add point index and facet data
        const numSourceFacets = source._facetStart.length - 1;
        for (let i = 0; i < numSourceFacets; i++) {
            const i0 = source._facetStart[i];
            const i1 = source._facetStart[i + 1];
            if (reversed) {
                for (let j = i1; j-- > i0;) {
                    this.addPointIndex(sourceToDestPointIndex.at(source.data.pointIndex[j]), source.data.edgeVisible[j]);
                }
            }
            else {
                for (let j = i0; j < i1; j++) {
                    this.addPointIndex(sourceToDestPointIndex.at(source.data.pointIndex[j]), source.data.edgeVisible[j]);
                }
            }
            this.terminateFacet(false);
        }
        // Add param and param index data
        if (copyParams) {
            const startOfNewParams = this.data.param.length;
            for (const param of source.data.param) {
                const sourceParam = param.clone();
                if (transform) {
                    // TODO: Perform transformation
                    this.addParam(sourceParam);
                }
                else {
                    this.addParam(sourceParam);
                }
            }
            for (let i = 0; i < source._facetStart.length; i++) { // Expect facet start and ends for points to match normals
                const i0 = source._facetStart[i];
                const i1 = source._facetStart[i + 1];
                if (reversed) {
                    for (let j = i1; j-- > i0;)
                        this.addParamIndex(startOfNewParams + source.data.paramIndex[j - 1]);
                }
                else {
                    for (let j = i0; j < i1; j++)
                        this.addParamIndex(startOfNewParams + source.data.paramIndex[j]);
                }
            }
        }
        // Add normal and normal index data
        if (copyNormals) {
            const startOfNewNormals = this.data.normal.length;
            for (const normal of source.data.normal) {
                const sourceNormal = normal.clone();
                if (transform) {
                    transform.multiplyVector(sourceNormal, sourceNormal);
                    this.addNormal(sourceNormal);
                }
                else {
                    this.addNormal(sourceNormal);
                }
            }
            for (let i = 0; i < source._facetStart.length; i++) { // Expect facet start and ends for points to match normals
                const i0 = source._facetStart[i];
                const i1 = source._facetStart[i + 1];
                if (reversed) {
                    for (let j = i1; j-- > i0;)
                        this.addNormalIndex(startOfNewNormals + source.data.normalIndex[j - 1]);
                }
                else {
                    for (let j = i0; j < i1; j++)
                        this.addNormalIndex(startOfNewNormals + source.data.normalIndex[j]);
                }
            }
        }
        // Add color and color index data
        if (this.data.color && source.data.color && source.data.colorIndex) {
            const startOfNewColors = this.data.color.length;
            for (const sourceColor of source.data.color) {
                this.addColor(sourceColor);
            }
            for (let i = 0; i < source._facetStart.length; i++) { // Expect facet start and ends for points to match colors
                const i0 = source._facetStart[i];
                const i1 = source._facetStart[i + 1];
                if (reversed) {
                    for (let j = i1; j-- > i0;)
                        this.addColorIndex(startOfNewColors + source.data.colorIndex[j - 1]);
                }
                else {
                    for (let j = i0; j < i1; j++)
                        this.addColorIndex(startOfNewColors + source.data.colorIndex[j]);
                }
            }
        }
        // Add face and facetToFace index data
        if (source.data.face.length !== 0) {
            const startOfNewFaceData = this.data.face.length;
            for (const face of source.data.face) {
                const sourceFaceData = face.clone();
                this.data.face.push(sourceFaceData);
            }
            for (const facetToFaceIdx of source._facetToFaceData) {
                this._facetToFaceData.push(startOfNewFaceData + facetToFaceIdx);
            }
        }
    }
    /** @returns Return the total number of param indices in zero-terminated style, which includes
     * * all the indices in the packed zero-based table
     * * one additional index for the zero-terminator of each facet.
     * @note Note that all index arrays (point, normal, param, color) have the same counts, so there
     * is not a separate query for each of them.
     */
    get zeroTerminatedIndexCount() { return this.data.pointIndex.length + this._facetStart.length - 1; }
    static create(needNormals = false, needParams = false, needColors = false) {
        return new IndexedPolyface(new PolyfaceData_1.PolyfaceData(needNormals, needParams, needColors));
    }
    /** add (a clone of ) a point. return its 0 based index.
     * @returns Returns the zero-based index of the added point.
     */
    addPoint(point) { this.data.point.pushXYZ(point.x, point.y, point.z); return this.data.point.length - 1; }
    /** add a point.
     * @returns Returns the zero-based index of the added point.
     */
    addPointXYZ(x, y, z) { this.data.point.push(Point3dVector3d_1.Point3d.create(x, y, z)); return this.data.point.length - 1; }
    addParam(param) {
        if (!this.data.param)
            this.data.param = [];
        this.data.param.push(param.clone());
        return this.data.param.length - 1;
    }
    addParamXY(x, y) {
        if (!this.data.param)
            this.data.param = [];
        this.data.param.push(Point2dVector2d_1.Point2d.create(x, y));
        return this.data.param.length - 1;
    }
    addNormal(normal) {
        if (!this.data.normal)
            this.data.normal = [];
        this.data.normal.push(normal.clone());
        return this.data.normal.length - 1;
    }
    addNormalXYZ(x, y, z) {
        if (!this.data.normal)
            this.data.normal = [];
        this.data.normal.push(Point3dVector3d_1.Vector3d.create(x, y, z));
        return this.data.normal.length - 1;
    }
    addColor(color) {
        if (!this.data.color)
            this.data.color = [];
        this.data.color.push(color);
        return this.data.color.length - 1;
    }
    addPointIndex(index, visible = true) { this.data.pointIndex.push(index); this.data.edgeVisible.push(visible); }
    addNormalIndex(index) {
        if (!this.data.normalIndex)
            this.data.normalIndex = [];
        this.data.normalIndex.push(index);
    }
    addParamIndex(index) {
        if (!this.data.paramIndex)
            this.data.paramIndex = [];
        this.data.paramIndex.push(index);
    }
    addColorIndex(index) {
        if (!this.data.colorIndex)
            this.data.colorIndex = [];
        this.data.colorIndex.push(index);
    }
    /** clean up the open facet.  return the returnValue (so caller can easily return cleanupOpenFacet("message")) */
    cleanupOpenFacet() {
        this.data.trimAllIndexArrays(this.data.pointIndex.length);
    }
    /** announce the end of construction of a facet.
     *
     * * The "open" facet is checked for:
     *
     * **  Same number of indices among all active index arrays --  point, normal, param, color
     * **  All indices are within bounds of the respective data arrays.
     * *  in error cases, all index arrays are trimmed back to the size when previous facet was terminated.
     * *  "undefined" return is normal.   Any other return is a description of an error.
     */
    terminateFacet(validateAllIndices = true) {
        const numFacets = this._facetStart.length - 1;
        const lengthA = this._facetStart[numFacets]; // number of indices in accepted facets
        const lengthB = this.data.pointIndex.length; // number of indices including the open facet
        if (validateAllIndices) {
            const messages = [];
            if (lengthB < lengthA + 2)
                messages.push("Less than 3 indices in open facet");
            if (this.data.normalIndex && this.data.normalIndex.length !== lengthB)
                messages.push("normalIndex count must match pointIndex count");
            if (this.data.paramIndex && this.data.paramIndex.length !== lengthB)
                messages.push("paramIndex count must equal pointIndex count");
            if (this.data.colorIndex && this.data.colorIndex.length !== lengthB)
                messages.push("colorIndex count must equal pointIndex count");
            if (this.data.edgeVisible.length !== lengthB)
                messages.push("visibleIndex count must equal pointIndex count");
            if (!areIndicesValid(this.data.normalIndex, lengthA, lengthB, this.data.normal))
                messages.push("invalid normal indices in open facet");
            if (messages.length > 0) {
                this.cleanupOpenFacet();
                return messages;
            }
        }
        // appending to facetStart accepts the facet !!!
        this._facetStart.push(lengthB);
        return undefined;
    }
    /**
     * All terminated facets added since the declaration of the previous face
     * will be grouped into a new face with their own 2D range.
     */
    /** (read-only property) number of facets */
    get facetCount() { return this._facetStart.length - 1; }
    /** (read-only property) number of faces */
    get faceCount() { return this.data.faceCount; }
    /** (read-only property) number of points */
    get pointCount() { return this.data.pointCount; }
    /** (read-only property) number of colors */
    get colorCount() { return this.data.colorCount; }
    /** (read-only property) number of parameters */
    get paramCount() { return this.data.paramCount; }
    /** (read-only property) number of normals */
    get normalCount() { return this.data.normalCount; }
    numEdgeInFacet(facetIndex) {
        if (this.isValidFacetIndex(facetIndex))
            return this._facetStart[facetIndex + 1] - this._facetStart[facetIndex];
        return 0;
    }
    isValidFacetIndex(index) { return index >= 0 && index + 1 < this._facetStart.length; }
    /** ASSUME valid facet index . .. return its start index in index arrays. */
    facetIndex0(index) { return this._facetStart[index]; }
    /** ASSUME valid facet index . .. return its end index in index arrays. */
    facetIndex1(index) { return this._facetStart[index + 1]; }
    /** create a visitor for this polyface */
    createVisitor(numWrap = 0) { return IndexedPolyfaceVisitor.create(this, numWrap); }
    range(transform, result) { return this.data.range(result, transform); }
    extendRange(range, transform) { this.data.range(range, transform); }
    /** Given the index of a facet, return the data pertaining to the face it is a part of. */
    getFaceDataByFacetIndex(facetIndex) {
        return this.data.face[this._facetToFaceData[facetIndex]];
    }
    /** Given the index of a face, return the range of that face. */
    getFaceDataByFaceIndex(faceIndex) {
        return this.data.face[faceIndex];
    }
    /**
     * All terminated facets since the last face declaration will be mapped to a single new FacetFaceData object
     * using facetToFaceData[]. FacetFaceData holds the 2D range of the face. Returns true if successful, false otherwise.
     */
    setNewFaceData(endFacetIndex = 0) {
        const facetStart = this._facetToFaceData.length;
        if (facetStart >= this._facetStart.length)
            return false;
        if (0 === endFacetIndex) // The default for endFacetIndex is really the last facet
            endFacetIndex = this._facetStart.length; // Last facetStart index corresponds to the next facet if we were to create one
        const faceData = FacetFaceData.createNull();
        const visitor = IndexedPolyfaceVisitor.create(this, 0);
        if (!visitor.moveToReadIndex(facetStart)) { // Move visitor to first facet of new face
            return false;
        }
        // If parameter range is provided (by the polyface planeset clipper) then use it
        const paramDefined = this.data.param !== undefined;
        const setParamRange = faceData.paramRange.isNull && paramDefined;
        do {
            for (let i = 0; i < visitor.numEdgesThisFacet; i++) {
                if (setParamRange && visitor.param !== undefined)
                    faceData.paramRange.extendPoint(visitor.param[i]);
            }
        } while (visitor.moveToNextFacet() && visitor.currentReadIndex() < endFacetIndex);
        if (paramDefined && !(this.data.param.length === 0) && faceData.paramDistanceRange.isNull)
            faceData.setParamDistanceRangeFromNewFaceData(this, facetStart, endFacetIndex);
        this.data.face.push(faceData);
        const faceDataIndex = this.data.face.length - 1;
        for (let i = this._facetToFaceData.length; i < endFacetIndex; i++)
            this._facetToFaceData.push(0 === this._facetStart[i] ? 0 : faceDataIndex);
        return true;
    }
    /** TODO: IMPLEMENT */
    checkIfClosedByEdgePairing() {
        return false;
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleIndexedPolyface(this);
    }
}
exports.IndexedPolyface = IndexedPolyface;
class IndexedPolyfaceVisitor extends PolyfaceData_1.PolyfaceData {
    // to be called from static factory method that validates the polyface ...
    constructor(facets, numWrap) {
        super(facets.data.normalCount > 0, facets.data.paramCount > 0, facets.data.colorCount > 0);
        this._polyface = facets;
        this._numWrap = numWrap;
        if (facets.data.auxData)
            this.auxData = facets.data.auxData.createForVisitor();
        this.reset();
        this._numEdges = 0;
        this._nextFacetIndex = 0;
        this._currentFacetIndex = -1;
    }
    get numEdgesThisFacet() { return this._numEdges; }
    static create(polyface, numWrap) {
        return new IndexedPolyfaceVisitor(polyface, numWrap);
    }
    moveToReadIndex(facetIndex) {
        if (!this._polyface.isValidFacetIndex(facetIndex))
            return false;
        this._currentFacetIndex = facetIndex;
        this._nextFacetIndex = facetIndex + 1;
        this._numEdges = this._polyface.numEdgeInFacet(facetIndex);
        this.resizeAllDataArrays(this._numEdges + this._numWrap);
        this.gatherIndexedData(this._polyface.data, this._polyface.facetIndex0(this._currentFacetIndex), this._polyface.facetIndex1(this._currentFacetIndex), this._numWrap);
        return true;
    }
    moveToNextFacet() {
        if (this._nextFacetIndex !== this._currentFacetIndex)
            return this.moveToReadIndex(this._nextFacetIndex);
        this._nextFacetIndex++;
        return true;
    }
    reset() {
        this.moveToReadIndex(0);
        this._nextFacetIndex = 0; // so immediate moveToNextFacet stays here.
    }
    /**
     * Attempts to extract the distance parameter for the face of a given point index.
     * Returns the distance parameter as a point. Returns undefined on failure.
     */
    tryGetDistanceParameter(index, result) {
        if (index >= this.numEdgesThisFacet)
            return undefined;
        if (this.param === undefined || this._polyface.data.face.length === 0)
            return undefined;
        const faceData = this._polyface.tryGetFaceData(this._currentFacetIndex);
        if (!faceData)
            return undefined;
        return faceData.convertParamToDistance(this.param[index], result);
    }
    /**
     * Attempts to extract the normalized parameter (0,1) for the face of a given point index.
     * Returns the normalized parameter as a point. Returns undefined on failure.
     */
    tryGetNormalizedParameter(index, result) {
        if (index >= this.numEdgesThisFacet)
            return undefined;
        if (this.param === undefined || this._polyface.data.face.length === 0)
            return undefined;
        const faceData = this._polyface.tryGetFaceData(this._currentFacetIndex);
        if (!faceData)
            return undefined;
        return faceData.convertParamToNormalized(this.param[index], result);
    }
    currentReadIndex() { return this._currentFacetIndex; }
    clientPointIndex(i) { return this.pointIndex[i]; }
    clientParamIndex(i) { return this.paramIndex ? this.paramIndex[i] : -1; }
    clientNormalIndex(i) { return this.normalIndex ? this.normalIndex[i] : -1; }
    clientColorIndex(i) { return this.colorIndex ? this.colorIndex[i] : -1; }
    clientAuxIndex(i) { return this.auxData ? this.auxData.indices[i] : -1; }
}
exports.IndexedPolyfaceVisitor = IndexedPolyfaceVisitor;


/***/ }),

/***/ "./lib/polyface/PolyfaceBuilder.js":
/*!*****************************************!*\
  !*** ./lib/polyface/PolyfaceBuilder.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Polyface */
// import { Geometry, AxisOrder, Angle, AngleSweep, BSIJSONValues } from "./Geometry";
const Polyface_1 = __webpack_require__(/*! ./Polyface */ "./lib/polyface/Polyface.js");
const GrowableFloat64Array_1 = __webpack_require__(/*! ../geometry3d/GrowableFloat64Array */ "./lib/geometry3d/GrowableFloat64Array.js");
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const Matrix3d_1 = __webpack_require__(/*! ../geometry3d/Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const BoxTopology_1 = __webpack_require__(/*! ./BoxTopology */ "./lib/polyface/BoxTopology.js");
const StrokeOptions_1 = __webpack_require__(/*! ../curve/StrokeOptions */ "./lib/curve/StrokeOptions.js");
const CurveCollection_1 = __webpack_require__(/*! ../curve/CurveCollection */ "./lib/curve/CurveCollection.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const LineString3d_1 = __webpack_require__(/*! ../curve/LineString3d */ "./lib/curve/LineString3d.js");
const Graph_1 = __webpack_require__(/*! ../topology/Graph */ "./lib/topology/Graph.js");
const GeometryHandler_1 = __webpack_require__(/*! ../geometry3d/GeometryHandler */ "./lib/geometry3d/GeometryHandler.js");
/**
 *
 * * Simple construction for strongly typed GeometryQuery objects:
 *
 * ** Create a builder with `builder = PolyfaceBuilder.create()`
 * ** Add GeemotryQuery objects:
 *
 * *** `builder.addGeometryQuery(g: GeometryQuery)`
 * *** `builder.addCone(cone: Cone)`
 * *** `builder.addTorusPipe(surface: TorusPipe)`
 * *** `builder.addLinearSweepLineStrings(surface: LinearSweep)`
 * *** `builder.addRotationalSweep(surface: RotatationalSweep)`
 * *** `builder.addLinearSweep(surface: LinearSweep)`
 * *** `builder.addRuledSweep(surface: RuledSweep)`
 * *** `builder.addSphere(sphere: Sphere)`
 * *** `builder.addBox(box: Box)`
 * *** `buidler.addIndexedPolyface(polyface)`
 * **  Extract with `builder.claimPolyface (true)`
 *
 * * Simple construction for ephemeral constructive data:
 *
 * ** Create a builder with `builder = PolyfaceBuilder.create()`
 * ** Add from fragmentary data:
 *
 * *** `builder.addBetweenLineStrings (linestringA, linestringB, addClosure)`
 * *** `builder.addBetweenTransformedLineStrings (curves, transformA, transformB, addClosure)`
 * *** `builder.addBetweenStroked (curveA, curveB)`
 * *** `builder.addLinearSweepLineStrigns (contour, vector)`
 * *** `builder.addPolygon (points, numPointsToUse)`
 * *** `builder.addTransformedUnitBox (transform)`
 * *** `builder.addTriangleFan (conePoint, linestring, toggleOrientation)`
 * *** `builder.addTrianglesInUnchedkedPolygon (linestring, toggle)`
 * *** `builder.addUVGrid(surface,numU, numV, createFanInCaps)`
 * *** `builder.addGraph(Graph, acceptFaceFunction)`
 * **  Extract with `builder.claimPolyface(true)`
 *
 * * Low-level detail construction -- direct use of indices
 *
 * ** Create a builder with `builder = PolyfaceBuilder.create()`
 * ** Add GeometryQuery objects
 *
 * *** `builder.findOrAddPoint(point)`
 * *** `builder.findOrAddPointInLineString (linestring, index)`
 * *** `builder.findorAddTransformedPointInLineString(linestring, index, transform)`
 * *** `builder.findOrAddPointXYZ(x,y,z)`
 * *** `builder.addTriangleFanFromIndex0(indexArray, toggle)`
 * *** `builder.addTriangle (point0, point1, point2)`
 * *** `builder.addQuad (point0, point1, point2, point3)`
 * *** `builder.addOneBasedPointIndex (index)`
 */
class PolyfaceBuilder extends GeometryHandler_1.NullGeometryHandler {
    constructor(options) {
        super();
        this._options = options ? options : StrokeOptions_1.StrokeOptions.createForFacets();
        this._polyface = Polyface_1.IndexedPolyface.create(this._options.needNormals, this._options.needParams, this._options.needColors);
        this._reversed = false;
    }
    get options() { return this._options; }
    /** extract the polyface. */
    claimPolyface(compress = true) {
        if (compress)
            this._polyface.data.compress();
        return this._polyface;
    }
    toggleReversedFacetFlag() { this._reversed = !this._reversed; }
    static create(options) {
        return new PolyfaceBuilder(options);
    }
    /** add facets for a transformed unit box. */
    addTransformedUnitBox(transform) {
        const pointIndex0 = this._polyface.data.pointCount;
        // these will have sequential indices starting at pointIndex0 . . .
        for (const p of BoxTopology_1.BoxTopology.points)
            this._polyface.addPoint(transform.multiplyPoint3d(p));
        for (const facet of BoxTopology_1.BoxTopology.cornerIndexCCW) {
            for (const pointIndex of facet)
                this._polyface.addPointIndex(pointIndex0 + pointIndex);
            this._polyface.terminateFacet();
        }
    }
    /** Add triangles from points[0] to each far edge.
     * @param ls linestring with point coordinates
     * @param reverse if true, wrap the triangle creation in toggleReversedFacetFlag.
     */
    addTriangleFan(conePoint, ls, toggle) {
        const n = ls.numPoints();
        if (n > 2) {
            if (toggle)
                this.toggleReversedFacetFlag();
            const index0 = this.findOrAddPoint(conePoint);
            let index1 = this.findOrAddPointInLineString(ls, 0);
            let index2 = 0;
            for (let i = 1; i < n; i++) {
                index2 = this.findOrAddPointInLineString(ls, i);
                this.addIndexedTrianglePointIndexes(index0, index1, index2);
                index1 = index2;
            }
            if (toggle)
                this.toggleReversedFacetFlag();
        }
    }
    /** Add triangles from points[0] to each far edge.
     * @param ls linestring with point coordinates
     * @param reverse if true, wrap the triangle creation in toggleReversedFacetFlag.
     */
    addTrianglesInUncheckedPolygon(ls, toggle) {
        const n = ls.numPoints();
        if (n > 2) {
            if (toggle)
                this.toggleReversedFacetFlag();
            const index0 = this.findOrAddPointInLineString(ls, 0);
            let index1 = this.findOrAddPointInLineString(ls, 1);
            let index2 = 0;
            for (let i = 2; i < n; i++) {
                index2 = this.findOrAddPointInLineString(ls, i);
                this.addIndexedTrianglePointIndexes(index0, index1, index2);
                index1 = index2;
            }
            if (toggle)
                this.toggleReversedFacetFlag();
        }
    }
    /** Add triangles from points[0] to each far edge.
     * @param ls linestring with point coordinates
     * @param reverse if true, wrap the triangle creation in toggleReversedFacetFlag.
     */
    addTriangleFanFromIndex0(index, toggle, needNormals = false, needParams = false) {
        const n = index.length;
        if (n > 2) {
            if (toggle)
                this.toggleReversedFacetFlag();
            const index0 = index.at(0);
            let index1 = index.at(1);
            let index2 = 0;
            for (let i = 2; i < n; i++) {
                index2 = index.at(i);
                this.addIndexedTrianglePointIndexes(index0, index1, index2);
                if (needNormals)
                    this.addIndexedTriangleNormalIndexes(index0, index1, index2);
                if (needParams)
                    this.addIndexedTriangleParamIndexes(index0, index1, index2);
                index1 = index2;
            }
            if (toggle)
                this.toggleReversedFacetFlag();
        }
    }
    /**
     * Announce point coordinates.  The implemetation is free to either create a new point or (if known) return indxex of a prior point with the same coordinates.
     */
    findOrAddPoint(xyz) {
        return this._polyface.addPoint(xyz);
    }
    /**
     * Announce point coordinates.  The implemetation is free to either create a new param or (if known) return indxex of a prior param with the same coordinates.
     */
    findOrAddParamXY(x, y) {
        return this._polyface.addParamXY(x, y);
    }
    /**
     * Announce point coordinates.  The implemetation is free to either create a new point or (if knonw) return indxex of a prior point with the same coordinates.
     * @returns Returns the point index in the Polyface.
     * @param index Index of the point in the linestring.
     */
    findOrAddPointInLineString(ls, index, transform) {
        const q = ls.pointAt(index, PolyfaceBuilder._workPointFindOrAdd);
        if (q) {
            if (transform)
                transform.multiplyPoint3d(q, q);
            return this._polyface.addPoint(q);
        }
        return undefined;
    }
    /**
     * Announce point coordinates.  The implemetation is free to either create a new point or (if known) return index of a prior point with the same coordinates.
     */
    findOrAddPointXYZ(x, y, z) {
        return this._polyface.addPointXYZ(x, y, z);
    }
    /** Returns a transform who can be applied to points on a triangular facet in order to obtain UV parameters. */
    getUVTransformForTriangleFacet(pointA, pointB, pointC) {
        const vectorAB = pointA.vectorTo(pointB);
        const vectorAC = pointA.vectorTo(pointC);
        const unitAxes = Matrix3d_1.Matrix3d.createRigidFromColumns(vectorAB, vectorAC, 0 /* XYZ */);
        const localToWorld = Transform_1.Transform.createOriginAndMatrix(pointA, unitAxes);
        return localToWorld.inverse();
    }
    /** Returns the normal to a triangular facet. */
    getNormalForTriangularFacet(pointA, pointB, pointC) {
        const vectorAB = pointA.vectorTo(pointB);
        const vectorAC = pointA.vectorTo(pointC);
        let normal = vectorAB.crossProduct(vectorAC).normalize();
        normal = normal ? normal : Point3dVector3d_1.Vector3d.create();
        return normal;
    }
    // ###: Consider case where normals will be reversed and point through the other end of the facet
    /**
     * Add a quad to the polyface given its points in order around the edges.
     * Optionally provide params and the plane normal, otherwise they will be calculated without reference data.
     * Optionally mark this quad as the last piece of a face in this polyface.
     */
    addQuadFacet(points, params, normals) {
        // If params and/or normals are needed, calculate them first
        const needParams = this.options.needParams;
        const needNormals = this.options.needNormals;
        let param0, param1, param2, param3;
        let normal0, normal1, normal2, normal3;
        if (needParams) {
            if (params !== undefined && params.length > 3) {
                param0 = params[0];
                param1 = params[1];
                param2 = params[2];
                param3 = params[3];
            }
            else {
                const paramTransform = this.getUVTransformForTriangleFacet(points[0], points[1], points[2]);
                if (paramTransform === undefined) {
                    param0 = param1 = param2 = param3 = Point2dVector2d_1.Point2d.createZero();
                }
                else {
                    param0 = Point2dVector2d_1.Point2d.createFrom(paramTransform.multiplyPoint3d(points[0]));
                    param1 = Point2dVector2d_1.Point2d.createFrom(paramTransform.multiplyPoint3d(points[1]));
                    param2 = Point2dVector2d_1.Point2d.createFrom(paramTransform.multiplyPoint3d(points[2]));
                    param3 = Point2dVector2d_1.Point2d.createFrom(paramTransform.multiplyPoint3d(points[3]));
                }
            }
        }
        if (needNormals) {
            if (normals !== undefined && normals.length > 3) {
                normal0 = normals[0];
                normal1 = normals[1];
                normal2 = normals[2];
                normal3 = normals[3];
            }
            else {
                normal0 = this.getNormalForTriangularFacet(points[0], points[1], points[2]);
                normal1 = this.getNormalForTriangularFacet(points[0], points[1], points[2]);
                normal2 = this.getNormalForTriangularFacet(points[0], points[1], points[2]);
                normal3 = this.getNormalForTriangularFacet(points[0], points[1], points[2]);
            }
        }
        if (this._options.shouldTriangulate) {
            // Add as two triangles, with a diagonal along the shortest distance
            const vectorAC = points[0].vectorTo(points[2]);
            const vectorBD = points[1].vectorTo(points[3]);
            // Note: We pass along any values for normals or params that we calculated
            if (vectorAC.magnitude() >= vectorBD.magnitude()) {
                this.addTriangleFacet([points[0], points[1], points[2]], needParams ? [param0, param1, param2] : undefined, needNormals ? [normal0, normal1, normal2] : undefined);
                this.addTriangleFacet([points[0], points[2], points[3]], needParams ? [param0, param2, param3] : undefined, needNormals ? [normal0, normal2, normal3] : undefined);
            }
            else {
                this.addTriangleFacet([points[0], points[1], points[3]], needParams ? [param0, param1, param3] : undefined, needNormals ? [normal0, normal1, normal3] : undefined);
                this.addTriangleFacet([points[1], points[2], points[3]], needParams ? [param1, param2, param3] : undefined, needNormals ? [normal1, normal2, normal3] : undefined);
            }
            return;
        }
        let idx0, idx1, idx2, idx3;
        // Add params if needed
        if (needParams) {
            idx0 = this._polyface.addParam(param0);
            idx1 = this._polyface.addParam(param1);
            idx2 = this._polyface.addParam(param2);
            idx3 = this._polyface.addParam(param3);
            this.addIndexedQuadParamIndexes(idx0, idx1, idx3, idx2);
        }
        // Add normals if needed
        if (needNormals) {
            idx0 = this._polyface.addNormal(normal0);
            idx1 = this._polyface.addNormal(normal1);
            idx2 = this._polyface.addNormal(normal2);
            idx3 = this._polyface.addNormal(normal3);
            this.addIndexedQuadNormalIndexes(idx0, idx1, idx3, idx2);
        }
        // Add point and point indexes last (terminates the facet)
        idx0 = this.findOrAddPoint(points[0]);
        idx1 = this.findOrAddPoint(points[1]);
        idx2 = this.findOrAddPoint(points[2]);
        idx3 = this.findOrAddPoint(points[3]);
        this.addIndexedQuadPointIndexes(idx0, idx1, idx3, idx2);
    }
    /** Announce a single quad facet's point indexes.
     *
     * * The actual quad may be reversed or trianglulated based on builder setup.
     * *  indexA0 and indexA1 are in the forward order at the "A" end of the quad
     * *  indexB0 and indexB1 are in the forward order at the "B" end of the quad.
     */
    addIndexedQuadPointIndexes(indexA0, indexA1, indexB0, indexB1) {
        if (this._reversed) {
            this._polyface.addPointIndex(indexA0);
            this._polyface.addPointIndex(indexB0);
            this._polyface.addPointIndex(indexB1);
            this._polyface.addPointIndex(indexA1);
            this._polyface.terminateFacet();
        }
        else {
            this._polyface.addPointIndex(indexA0);
            this._polyface.addPointIndex(indexA1);
            this._polyface.addPointIndex(indexB1);
            this._polyface.addPointIndex(indexB0);
            this._polyface.terminateFacet();
        }
    }
    /** For a single quad facet, add the indexes of the corresponding param points. */
    addIndexedQuadParamIndexes(indexA0, indexA1, indexB0, indexB1) {
        if (this._reversed) {
            this._polyface.addParamIndex(indexA0);
            this._polyface.addParamIndex(indexB0);
            this._polyface.addParamIndex(indexB1);
            this._polyface.addParamIndex(indexA1);
        }
        else {
            this._polyface.addParamIndex(indexA0);
            this._polyface.addParamIndex(indexA1);
            this._polyface.addParamIndex(indexB1);
            this._polyface.addParamIndex(indexB0);
        }
    }
    /** For a single quad facet, add the indexes of the corresponding normal vectors. */
    addIndexedQuadNormalIndexes(indexA0, indexA1, indexB0, indexB1) {
        if (this._reversed) {
            this._polyface.addNormalIndex(indexA0);
            this._polyface.addNormalIndex(indexB0);
            this._polyface.addNormalIndex(indexB1);
            this._polyface.addNormalIndex(indexA1);
        }
        else {
            this._polyface.addNormalIndex(indexA0);
            this._polyface.addNormalIndex(indexA1);
            this._polyface.addNormalIndex(indexB1);
            this._polyface.addNormalIndex(indexB0);
        }
    }
    // ### TODO: Consider case where normals will be reversed and point through the other end of the facet
    /**
     * Add a triangle to the polyface given its points in order around the edges.
     * * Optionally provide params and triangle normals, otherwise they will be calculated without reference data.
     */
    addTriangleFacet(points, params, normals) {
        let idx0;
        let idx1;
        let idx2;
        // Add params if needed
        if (this._options.needParams) {
            if (params && params.length >= 3) { // Params were given
                idx0 = this._polyface.addParam(params[0]);
                idx1 = this._polyface.addParam(params[1]);
                idx2 = this._polyface.addParam(params[2]);
            }
            else { // Compute params
                const paramTransform = this.getUVTransformForTriangleFacet(points[0], points[1], points[2]);
                idx0 = this._polyface.addParam(Point2dVector2d_1.Point2d.createFrom(paramTransform ? paramTransform.multiplyPoint3d(points[0]) : undefined));
                idx1 = this._polyface.addParam(Point2dVector2d_1.Point2d.createFrom(paramTransform ? paramTransform.multiplyPoint3d(points[1]) : undefined));
                idx2 = this._polyface.addParam(Point2dVector2d_1.Point2d.createFrom(paramTransform ? paramTransform.multiplyPoint3d(points[2]) : undefined));
            }
            this.addIndexedTriangleParamIndexes(idx0, idx1, idx2);
        }
        // Add normals if needed
        if (this._options.needNormals) {
            if (normals !== undefined && normals.length > 2) { // Normals were given
                idx0 = this._polyface.addNormal(normals[0]);
                idx1 = this._polyface.addNormal(normals[1]);
                idx2 = this._polyface.addNormal(normals[2]);
            }
            else { // Compute normals
                const normal = this.getNormalForTriangularFacet(points[0], points[1], points[2]);
                idx0 = this._polyface.addNormal(normal);
                idx1 = this._polyface.addNormal(normal);
                idx2 = this._polyface.addNormal(normal);
            }
            this.addIndexedTriangleNormalIndexes(idx0, idx1, idx2);
        }
        // Add point and point indexes last (terminates the facet)
        idx0 = this.findOrAddPoint(points[0]);
        idx1 = this.findOrAddPoint(points[1]);
        idx2 = this.findOrAddPoint(points[2]);
        this.addIndexedTrianglePointIndexes(idx0, idx1, idx2);
    }
    /** Announce a single triangle facet's point indexes.
     *
     * * The actual quad may be reversed or trianglulated based on builder setup.
     * *  indexA0 and indexA1 are in the forward order at the "A" end of the quad
     * *  indexB0 and indexB1 are in the forward order at the "B" end of hte quad.
     */
    addIndexedTrianglePointIndexes(indexA, indexB, indexC) {
        if (indexA === indexB || indexB === indexC || indexC === indexA)
            return;
        if (!this._reversed) {
            this._polyface.addPointIndex(indexA);
            this._polyface.addPointIndex(indexB);
            this._polyface.addPointIndex(indexC);
            this._polyface.terminateFacet();
        }
        else {
            this._polyface.addPointIndex(indexA);
            this._polyface.addPointIndex(indexC);
            this._polyface.addPointIndex(indexB);
            this._polyface.terminateFacet();
        }
    }
    /** For a single triangle facet, add the indexes of the corresponding params. */
    addIndexedTriangleParamIndexes(indexA, indexB, indexC) {
        if (indexA === indexB || indexB === indexC || indexC === indexA)
            return;
        if (!this._reversed) {
            this._polyface.addParamIndex(indexA);
            this._polyface.addParamIndex(indexB);
            this._polyface.addParamIndex(indexC);
        }
        else {
            this._polyface.addParamIndex(indexA);
            this._polyface.addParamIndex(indexC);
            this._polyface.addParamIndex(indexB);
        }
    }
    /** For a single triangle facet, add the indexes of the corresponding params. */
    addIndexedTriangleNormalIndexes(indexA, indexB, indexC) {
        if (indexA === indexB || indexB === indexC || indexC === indexA)
            return;
        if (!this._reversed) {
            this._polyface.addNormalIndex(indexA);
            this._polyface.addNormalIndex(indexB);
            this._polyface.addNormalIndex(indexC);
        }
        else {
            this._polyface.addNormalIndex(indexA);
            this._polyface.addNormalIndex(indexC);
            this._polyface.addNormalIndex(indexB);
        }
    }
    /** Add facets betwee lineStrings with matched point counts.
     *
     * * Facets are announced to addIndexedQuad.
     * * addIndexedQuad is free to apply reversal or triangulation options.
     */
    addBetweenLineStrings(lineStringA, lineStringB, addClosure = false) {
        const pointA = lineStringA.points;
        const pointB = lineStringB.points;
        const numPoints = pointA.length;
        if (numPoints < 2 || numPoints !== pointB.length)
            return;
        let indexA0 = this.findOrAddPoint(pointA[0]);
        let indexB0 = this.findOrAddPoint(pointB[0]);
        const indexA00 = indexA0;
        const indexB00 = indexB0;
        let indexA1 = 0;
        let indexB1 = 0;
        for (let i = 1; i < numPoints; i++) {
            indexA1 = this.findOrAddPoint(pointA[i]);
            indexB1 = this.findOrAddPoint(pointB[i]);
            this.addIndexedQuadPointIndexes(indexA0, indexA1, indexB0, indexB1);
            indexA0 = indexA1;
            indexB0 = indexB1;
        }
        if (addClosure)
            this.addIndexedQuadPointIndexes(indexA0, indexA00, indexB0, indexB00);
    }
    /** Add facets betwee lineStrings with matched point counts.
     *
     * * Facets are announced to addIndexedQuad.
     * * addIndexedQuad is free to apply reversal or triangulation options.
     */
    addBetweenTransformedLineStrings(curves, transformA, transformB, addClosure = false) {
        if (curves instanceof LineString3d_1.LineString3d) {
            const pointA = curves.points;
            const numPoints = pointA.length;
            let indexA0 = this.findOrAddPointInLineString(curves, 0, transformA);
            let indexB0 = this.findOrAddPointInLineString(curves, 0, transformB);
            const indexA00 = indexA0;
            const indexB00 = indexB0;
            let indexA1 = 0;
            let indexB1 = 0;
            for (let i = 1; i < numPoints; i++) {
                indexA1 = this.findOrAddPointInLineString(curves, i, transformA);
                indexB1 = this.findOrAddPointInLineString(curves, i, transformB);
                this.addIndexedQuadPointIndexes(indexA0, indexA1, indexB0, indexB1);
                indexA0 = indexA1;
                indexB0 = indexB1;
            }
            if (addClosure)
                this.addIndexedQuadPointIndexes(indexA0, indexA00, indexB0, indexB00);
        }
        else {
            const children = curves.children;
            // just send the children individually -- final compres will fix things??
            if (children)
                for (const c of children) {
                    this.addBetweenTransformedLineStrings(c, transformA, transformB);
                }
        }
    }
    addBetweenStroked(dataA, dataB) {
        if (dataA instanceof LineString3d_1.LineString3d && dataB instanceof LineString3d_1.LineString3d) {
            this.addBetweenLineStrings(dataA, dataB, false);
        }
        else if (dataA instanceof CurveCollection_1.CurveChain && dataB instanceof CurveCollection_1.CurveChain) {
            const chainA = dataA.children;
            const chainB = dataB.children;
            if (chainA.length === chainB.length) {
                for (let i = 0; i < chainA.length; i++) {
                    const cpA = chainA[i];
                    const cpB = chainB[i];
                    if (cpA instanceof LineString3d_1.LineString3d && cpB instanceof LineString3d_1.LineString3d) {
                        this.addBetweenLineStrings(cpA, cpB);
                    }
                }
            }
        }
    }
    /**
     *
     * @param cone cone to facet
     * @param strokeCount number of strokes around the cone.  If omitted, use the strokeOptions previously supplied to the builder.
     */
    addCone(cone, strokeCount) {
        // assume cone strokes consistently at both ends ....
        const lineStringA = cone.strokeConstantVSection(0.0, strokeCount ? strokeCount : this._options);
        const lineStringB = cone.strokeConstantVSection(1.0, strokeCount ? strokeCount : this._options);
        this.addBetweenLineStrings(lineStringA, lineStringB, false);
        if (cone.capped) {
            this.addTrianglesInUncheckedPolygon(lineStringA, true); // lower triangles flip
            this.addTrianglesInUncheckedPolygon(lineStringB, false); // upper triangles to not flip.
        }
    }
    /**
     *
     * @param surface TorusPipe to facet
     * @param strokeCount number of strokes around the cone.  If omitted, use the strokeOptions previously supplied to the builder.
     */
    addTorusPipe(surface, phiStrokeCount, thetaStrokeCount) {
        this.toggleReversedFacetFlag();
        this.addUVGrid(surface, phiStrokeCount ? phiStrokeCount : 8, thetaStrokeCount ? thetaStrokeCount : Math.ceil(16 * surface.getThetaFraction()), surface.capped);
        this.toggleReversedFacetFlag();
    }
    /**
     *
     * @param vector sweep vector
     * @param contour contour which contains only linestrings
     */
    addLinearSweepLineStrings(contour, vector) {
        if (contour instanceof LineString3d_1.LineString3d) {
            const ls = contour;
            let pointA = Point3dVector3d_1.Point3d.create();
            let pointB = Point3dVector3d_1.Point3d.create();
            let indexA0 = 0;
            let indexA1 = 0;
            let indexB0 = 0;
            let indexB1 = 0;
            const n = ls.numPoints();
            for (let i = 0; i < n; i++) {
                pointA = ls.pointAt(i, pointA);
                pointB = pointA.plus(vector, pointB);
                indexA1 = this.findOrAddPoint(pointA);
                indexB1 = this.findOrAddPoint(pointB);
                if (i > 0) {
                    this.addIndexedQuadPointIndexes(indexA0, indexA1, indexB0, indexB1);
                }
                indexA0 = indexA1;
                indexB0 = indexB1;
            }
        }
        else if (contour instanceof CurveCollection_1.CurveChain) {
            for (const ls of contour.children) {
                this.addLinearSweepLineStrings(ls, vector);
            }
        }
    }
    addRotationalSweep(surface) {
        const strokes = surface.getCurves().cloneStroked();
        const numStep = StrokeOptions_1.StrokeOptions.applyAngleTol(this._options, 1, surface.getSweep().radians, undefined);
        const transformA = Transform_1.Transform.createIdentity();
        const transformB = Transform_1.Transform.createIdentity();
        for (let i = 1; i <= numStep; i++) {
            surface.getFractionalRotationTransform(i / numStep, transformB);
            this.addBetweenTransformedLineStrings(strokes, transformA, transformB);
            transformA.setFrom(transformB);
        }
        if (surface.capped) {
            const contour = surface.getSweepContourRef();
            contour.emitFacets(this, true, undefined);
            contour.emitFacets(this, false, transformB);
        }
    }
    /**
     *
     * @param cone cone to facet
     */
    addLinearSweep(surface) {
        const baseStrokes = surface.getCurvesRef().cloneStroked();
        this.addLinearSweepLineStrings(baseStrokes, surface.cloneSweepVector());
        if (surface.capped) {
            const contour = surface.getSweepContourRef();
            contour.emitFacets(this, true, undefined);
            contour.emitFacets(this, false, Transform_1.Transform.createTranslation(surface.cloneSweepVector()));
        }
    }
    /**
     *
     * @param cone cone to facet
     */
    addRuledSweep(surface) {
        const contours = surface.sweepContoursRef();
        let stroke0;
        let stroke1;
        for (let i = 0; i < contours.length; i++) {
            stroke1 = contours[i].curves.cloneStroked();
            if (i > 0 && stroke0 && stroke1)
                this.addBetweenStroked(stroke0, stroke1);
            stroke0 = stroke1;
        }
        contours[0].emitFacets(this, true, undefined);
        contours[contours.length - 1].emitFacets(this, false, undefined);
    }
    addSphere(sphere, strokeCount) {
        const numLongitudeStroke = strokeCount ? strokeCount : this._options.defaultCircleStrokes;
        const numLatitudeStroke = Geometry_1.Geometry.clampToStartEnd(numLongitudeStroke * 0.5, 4, 32);
        let lineStringA = sphere.strokeConstantVSection(0.0, numLongitudeStroke);
        if (sphere.capped && !Geometry_1.Geometry.isSmallMetricDistance(lineStringA.quickLength()))
            this.addTrianglesInUncheckedPolygon(lineStringA, true); // lower triangles flip
        for (let i = 1; i <= numLatitudeStroke; i++) {
            const lineStringB = sphere.strokeConstantVSection(i / numLatitudeStroke, numLongitudeStroke);
            this.addBetweenLineStrings(lineStringA, lineStringB);
            lineStringA = lineStringB;
        }
        if (sphere.capped && !Geometry_1.Geometry.isSmallMetricDistance(lineStringA.quickLength()))
            this.addTrianglesInUncheckedPolygon(lineStringA, true); // upper triangles do not flip
    }
    addBox(box) {
        const lineStringA = box.strokeConstantVSection(0.0);
        const lineStringB = box.strokeConstantVSection(1.0);
        this.addBetweenLineStrings(lineStringA, lineStringB);
        if (box.capped) {
            this.addTrianglesInUncheckedPolygon(lineStringA, true); // lower triangles flip
            this.addTrianglesInUncheckedPolygon(lineStringB, false); // upper triangles to not flip.
        }
    }
    /** Add a polygon to the evolving facets.
     *
     * * Add points to the polyface
     * * indices are added (in reverse order if indicated by the builder state)
     * @param points array of points.  This may contain extra points not to be used in the polygon
     * @param numPointsToUse number of points to use.
     */
    addPolygon(points, numPointsToUse) {
        // don't use trailing points that match start point.
        if (numPointsToUse === undefined)
            numPointsToUse = points.length;
        while (numPointsToUse > 1 && points[numPointsToUse - 1].isAlmostEqual(points[0]))
            numPointsToUse--;
        let index = 0;
        if (!this._reversed) {
            for (let i = 0; i < numPointsToUse; i++) {
                index = this.findOrAddPoint(points[i]);
                this._polyface.addPointIndex(index);
            }
        }
        else {
            for (let i = numPointsToUse; --i >= 0;) {
                index = this.findOrAddPoint(points[i]);
                this._polyface.addPointIndex(index);
            }
        }
        this._polyface.terminateFacet();
    }
    /** Add a polyface, with optional reverse and transform. */
    addIndexedPolyface(source, reversed, transform) {
        this._polyface.addIndexedPolyface(source, reversed, transform);
    }
    /**
     * Produce a new FacetFaceData for all terminated facets since construction of the previous face.
     * Each facet number/index is mapped to the FacetFaceData through the faceToFaceData array.
     * Returns true if successful, and false otherwise.
     */
    endFace() {
        return this._polyface.setNewFaceData();
    }
    // -------------------- double dispatch methods ---------------------------
    handleCone(g) { return this.addCone(g); }
    handleTorusPipe(g) { return this.addTorusPipe(g); }
    handleSphere(g) { return this.addSphere(g); }
    handleBox(g) { return this.addBox(g); }
    handleLinearSweep(g) { return this.addLinearSweep(g); }
    handleRotationalSweep(g) { return this.addRotationalSweep(g); }
    handleRuledSweep(g) { return this.addRuledSweep(g); }
    addGeometryQuery(g) { g.dispatchToGeometryHandler(this); }
    /**
     *
     * * Visit all faces
     * * Test each face with f(node) for any node on the face.
     * * For each face that passes, pass its coordinates to the builder.
     * * Rely on the builder's compress step to find common vertex coordinates
     */
    addGraph(graph, needParams, acceptFaceFunction = Graph_1.HalfEdge.testNodeMaskNotExterior) {
        let index = 0;
        graph.announceFaceLoops((_graph, seed) => {
            if (acceptFaceFunction(seed)) {
                let node = seed;
                do {
                    index = this.findOrAddPointXYZ(node.x, node.y, node.z);
                    this._polyface.addPointIndex(index);
                    if (needParams) {
                        index = this.findOrAddParamXY(node.x, node.y);
                        this._polyface.addParamIndex(index);
                    }
                    node = node.faceSuccessor;
                } while (node !== seed);
                this._polyface.terminateFacet();
            }
            return true;
        });
    }
    static graphToPolyface(graph, options, acceptFaceFunction = Graph_1.HalfEdge.testNodeMaskNotExterior) {
        const builder = PolyfaceBuilder.create(options);
        builder.addGraph(graph, builder.options.needParams, acceptFaceFunction);
        builder.endFace();
        return builder.claimPolyface();
    }
    /**
     * Given a 2-dimensional grid of points and optional corresponding params and normals, add the grid to the polyface as a series of quads.
     * Each facet in the grid should either be made up of 3 or 4 edges. Optionally specify that this quad is the last piece of a face.
     */
    addGrid(pointArray, paramArray, normalArray, endFace = false) {
        for (let i = 0; i < pointArray.length; i++) {
            const params = paramArray ? paramArray[i] : undefined;
            const normals = normalArray ? normalArray[i] : undefined;
            if (pointArray[i].length === 3)
                this.addTriangleFacet(pointArray[i], params, normals);
            else if (pointArray[i].length === 4)
                this.addQuadFacet(pointArray[i], params, normals);
        }
        if (endFace)
            this.endFace();
    }
    addUVGrid(surface, numU, numV, createFanInCaps) {
        let index0 = PolyfaceBuilder._index0;
        let index1 = PolyfaceBuilder._index1;
        let indexSwap;
        index0.ensureCapacity(numU);
        index1.ensureCapacity(numU);
        const xyz = Point3dVector3d_1.Point3d.create();
        const du = 1.0 / numU;
        const dv = 1.0 / numV;
        for (let v = 0; v <= numV; v++) {
            // evaluate new points ....
            index1.clear();
            for (let u = 0; u <= numU; u++) {
                const uFrac = u * du;
                const vFrac = v * dv;
                if (this._options.needParams) {
                    const plane = surface.UVFractionToPointAndTangents(uFrac, vFrac);
                    this._polyface.addNormal(plane.vectorU.crossProduct(plane.vectorV));
                    index1.push(this.findOrAddPoint(plane.origin.clone()));
                }
                else {
                    surface.UVFractionToPoint(uFrac, vFrac, xyz);
                    index1.push(this.findOrAddPoint(xyz));
                }
                if (this._options.needParams) {
                    this._polyface.addParam(new Point2dVector2d_1.Point2d(uFrac, vFrac));
                }
            }
            if (createFanInCaps && (v === 0 || v === numV)) {
                this.addTriangleFanFromIndex0(index1, v === 0, true, true);
            }
            if (v > 0) {
                for (let u = 0; u < numU; u++) {
                    this.addIndexedQuadPointIndexes(index0.at(u), index0.at(u + 1), index1.at(u), index1.at(u + 1));
                    if (this._options.needParams)
                        this.addIndexedQuadNormalIndexes(index0.at(u), index0.at(u + 1), index1.at(u), index1.at(u + 1));
                    if (this._options.needParams)
                        this.addIndexedQuadParamIndexes(index0.at(u), index0.at(u + 1), index1.at(u), index1.at(u + 1));
                }
            }
            indexSwap = index1;
            index1 = index0;
            index0 = indexSwap;
        }
        index0.clear();
        index1.clear();
    }
}
PolyfaceBuilder._workPointFindOrAdd = Point3dVector3d_1.Point3d.create();
PolyfaceBuilder._index0 = new GrowableFloat64Array_1.GrowableFloat64Array();
PolyfaceBuilder._index1 = new GrowableFloat64Array_1.GrowableFloat64Array();
exports.PolyfaceBuilder = PolyfaceBuilder;


/***/ }),

/***/ "./lib/polyface/PolyfaceData.js":
/*!**************************************!*\
  !*** ./lib/polyface/PolyfaceData.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Polyface */
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Range_1 = __webpack_require__(/*! ../geometry3d/Range */ "./lib/geometry3d/Range.js");
const PointHelpers_1 = __webpack_require__(/*! ../geometry3d/PointHelpers */ "./lib/geometry3d/PointHelpers.js");
const GrowableXYZArray_1 = __webpack_require__(/*! ../geometry3d/GrowableXYZArray */ "./lib/geometry3d/GrowableXYZArray.js");
const ClusterableArray_1 = __webpack_require__(/*! ../numerics/ClusterableArray */ "./lib/numerics/ClusterableArray.js");
/**
 * PolyfaceData carries data arrays for point, normal, param, color and their indices.
 *
 * * IndexedPolyface carries a PolyfaceData as a member. (NOT as a base class -- it already has GeometryQuery as base)
 * * IndexedPolyfaceVisitor uses PolyfaceData as a base class.
 */
class PolyfaceData {
    constructor(needNormals = false, needParams = false, needColors = false) {
        this.point = new GrowableXYZArray_1.GrowableXYZArray();
        this.pointIndex = [];
        this.edgeVisible = [];
        this.face = [];
        if (needNormals) {
            this.normal = [];
            this.normalIndex = [];
        }
        if (needParams) {
            this.param = [];
            this.paramIndex = [];
        }
        if (needColors) {
            this.color = [];
            this.colorIndex = [];
        }
    }
    clone() {
        const result = new PolyfaceData();
        result.point = this.point.clone();
        result.pointIndex = this.pointIndex.slice();
        result.edgeVisible = this.edgeVisible.slice();
        result.face = this.face.slice();
        if (this.normal)
            result.normal = PointHelpers_1.Vector3dArray.cloneVector3dArray(this.normal);
        if (this.param)
            result.param = PointHelpers_1.Point2dArray.clonePoint2dArray(this.param);
        if (this.color)
            result.color = this.color.slice();
        if (this.normalIndex)
            result.normalIndex = this.normalIndex.slice();
        if (this.paramIndex)
            result.paramIndex = this.paramIndex.slice();
        if (this.colorIndex)
            result.colorIndex = this.colorIndex.slice();
        if (this.auxData)
            result.auxData = this.auxData.clone();
        return result;
    }
    isAlmostEqual(other) {
        if (!GrowableXYZArray_1.GrowableXYZArray.isAlmostEqual(this.point, other.point))
            return false;
        if (!PointHelpers_1.NumberArray.isExactEqual(this.pointIndex, other.pointIndex))
            return false;
        if (!PointHelpers_1.Vector3dArray.isAlmostEqual(this.normal, other.normal))
            return false;
        if (!PointHelpers_1.NumberArray.isExactEqual(this.normalIndex, other.normalIndex))
            return false;
        if (!PointHelpers_1.Point2dArray.isAlmostEqual(this.param, other.param))
            return false;
        if (!PointHelpers_1.NumberArray.isExactEqual(this.paramIndex, other.paramIndex))
            return false;
        if (!PointHelpers_1.NumberArray.isExactEqual(this.color, other.color))
            return false;
        if (!PointHelpers_1.NumberArray.isExactEqual(this.colorIndex, other.colorIndex))
            return false;
        if (!PointHelpers_1.NumberArray.isExactEqual(this.edgeVisible, other.edgeVisible))
            return false;
        return true;
    }
    get requireNormals() { return undefined !== this.normal; }
    get pointCount() { return this.point.length; }
    get normalCount() { return this.normal ? this.normal.length : 0; }
    get paramCount() { return this.param ? this.param.length : 0; }
    get colorCount() { return this.color ? this.color.length : 0; }
    get indexCount() { return this.pointIndex.length; } // ALWAYS INDEXED ... all index vectors must have same length.
    /** Will return 0 if no faces were specified during construction. */
    get faceCount() { return this.face.length; }
    /** return indexed point. This is a copy of the coordinates, not a reference. */
    getPoint(i) { return this.point.getPoint3dAt(i); }
    /** return indexed normal. This is the REFERENCE to the normal, not a copy. */
    getNormal(i) { return this.normal ? this.normal[i] : Point3dVector3d_1.Vector3d.create(); }
    /** return indexed param. This is the REFERENCE to the param, not a copy. */
    getParam(i) { return this.param ? this.param[i] : Point2dVector2d_1.Point2d.create(); }
    /** return indexed color */
    getColor(i) { return this.color ? this.color[i] : 0; }
    /** return indexed visibility */
    getEdgeVisible(i) { return this.edgeVisible[i]; }
    /** Copy the contents (not pointer) of point[i] into dest. */
    copyPointTo(i, dest) { this.point.getPoint3dAt(i, dest); }
    /** Copy the contents (not pointer) of normal[i] into dest. */
    copyNormalTo(i, dest) { if (this.normal)
        dest.setFrom(this.normal[i]); }
    /** Copy the contents (not pointer) of param[i] into dest. */
    copyParamTo(i, dest) { if (this.param)
        dest.setFrom(this.param[i]); }
    /**
     * * Copy data from other to this.
     * * This is the essense of transfering coordinates spread throughout a large polyface into a visitor's single facet.
     * * "other" is the large polyface
     * * "this" is the visitor
     * * does NOT copy face data - visitors reference the FacetFaceData array for the whole polyface!!
     * @param other polyface data being mined.
     * @param index0 start index in other's index arrays
     * @param index1 end index (one beyond last data accessed0 in other's index arrays
     * @param numWrap number of points to replicate as wraparound.
     */
    gatherIndexedData(other, index0, index1, numWrap) {
        const numEdge = index1 - index0;
        const numTotal = numEdge + numWrap;
        this.resizeAllDataArrays(numTotal);
        // copy wrapped points
        for (let i = 0; i < numEdge; i++)
            this.point.transferFromGrowableXYZArray(i, other.point, other.pointIndex[index0 + i]);
        for (let i = 0; i < numWrap; i++)
            this.point.transferFromGrowableXYZArray(numEdge + i, this.point, i);
        // copy wrapped pointIndex
        for (let i = 0; i < numEdge; i++)
            this.pointIndex[i] = other.pointIndex[index0 + i];
        for (let i = 0; i < numWrap; i++)
            this.pointIndex[numEdge + i] = this.pointIndex[i];
        // copy wrapped edge visibility
        for (let i = 0; i < numEdge; i++)
            this.edgeVisible[i] = other.edgeVisible[index0 + i];
        for (let i = 0; i < numWrap; i++)
            this.edgeVisible[numEdge + i] = this.edgeVisible[i];
        if (this.normal && this.normalIndex && other.normal && other.normalIndex) {
            for (let i = 0; i < numEdge; i++)
                this.normal[i].setFrom(other.normal[other.normalIndex[index0 + i]]);
            for (let i = 0; i < numWrap; i++)
                this.normal[numEdge + i].setFrom(this.normal[i]);
            for (let i = 0; i < numEdge; i++)
                this.normalIndex[i] = other.normalIndex[index0 + i];
            for (let i = 0; i < numWrap; i++)
                this.normalIndex[numEdge + i] = this.normalIndex[i];
        }
        if (this.param && this.paramIndex && other.param && other.paramIndex) {
            for (let i = 0; i < numEdge; i++)
                this.param[i].setFrom(other.param[other.paramIndex[index0 + i]]);
            for (let i = 0; i < numWrap; i++)
                this.param[numEdge + i].setFrom(this.param[i]);
            for (let i = 0; i < numEdge; i++)
                this.paramIndex[i] = other.paramIndex[index0 + i];
            for (let i = 0; i < numWrap; i++)
                this.paramIndex[numEdge + i] = this.paramIndex[i];
        }
        if (this.color && this.colorIndex && other.color && other.colorIndex) {
            for (let i = 0; i < numEdge; i++)
                this.color[i] = other.color[this.colorIndex[index0 + i]];
            for (let i = 0; i < numWrap; i++)
                this.color[numEdge + i] = this.color[i];
            for (let i = 0; i < numEdge; i++)
                this.colorIndex[i] = other.colorIndex[index0 + i];
            for (let i = 0; i < numWrap; i++)
                this.colorIndex[numEdge + i] = this.colorIndex[i];
        }
        if (this.auxData && other.auxData && this.auxData.channels.length === other.auxData.channels.length) {
            for (let iChannel = 0; iChannel < this.auxData.channels.length; iChannel++) {
                const thisChannel = this.auxData.channels[iChannel];
                const otherChannel = other.auxData.channels[iChannel];
                const blockSize = thisChannel.entriesPerValue;
                if (thisChannel.data.length === otherChannel.data.length) {
                    for (let iData = 0; iData < thisChannel.data.length; iData++) {
                        const thisData = thisChannel.data[iData];
                        const otherData = otherChannel.data[iData];
                        for (let i = 0; i < numEdge; i++)
                            thisData.copyValues(otherData, i, index0 + i, blockSize);
                        for (let i = 0; i < numWrap; i++)
                            thisData.copyValues(thisData, numEdge + i, i, blockSize);
                    }
                }
            }
            for (let i = 0; i < numEdge; i++)
                this.auxData.indices[i] = other.auxData.indices[index0 + i];
            for (let i = 0; i < numWrap; i++)
                this.auxData.indices[numEdge + i] = this.auxData.indices[i];
        }
    }
    static trimArray(data, length) { if (data && length < data.length)
        data.length = length; }
    trimAllIndexArrays(length) {
        PolyfaceData.trimArray(this.pointIndex, length);
        PolyfaceData.trimArray(this.paramIndex, length);
        PolyfaceData.trimArray(this.normalIndex, length);
        PolyfaceData.trimArray(this.colorIndex, length);
        PolyfaceData.trimArray(this.edgeVisible, length);
        if (this.auxData) {
            PolyfaceData.trimArray(this.auxData.indices, length);
            for (const channel of this.auxData.channels) {
                for (const data of channel.data)
                    PolyfaceData.trimArray(data.values, channel.entriesPerValue * length);
            }
        }
    }
    resizeAllDataArrays(length) {
        if (length > this.point.length) {
            while (this.point.length < length)
                this.point.push(Point3dVector3d_1.Point3d.create());
            while (this.pointIndex.length < length)
                this.pointIndex.push(-1);
            while (this.edgeVisible.length < length)
                this.edgeVisible.push(false);
            if (this.normal)
                while (this.normal.length < length)
                    this.normal.push(Point3dVector3d_1.Vector3d.create());
            if (this.param)
                while (this.param.length < length)
                    this.param.push(Point2dVector2d_1.Point2d.create());
            if (this.color)
                while (this.color.length < length)
                    this.color.push(0);
            if (this.auxData) {
                for (const channel of this.auxData.channels) {
                    for (const channelData of channel.data) {
                        while (channelData.values.length < length * channel.entriesPerValue)
                            channelData.values.push(0);
                    }
                }
            }
        }
        else if (length < this.point.length) {
            this.point.resize(length);
            this.edgeVisible.length = length;
            this.pointIndex.length = length;
            if (this.normal)
                this.normal.length = length;
            if (this.param)
                this.param.length = length;
            if (this.color)
                this.color.length = length;
            if (this.auxData) {
                for (const channel of this.auxData.channels) {
                    for (const channelData of channel.data) {
                        channelData.values.length = length * channel.entriesPerValue;
                    }
                }
            }
        }
    }
    range(result, transform) {
        result = result ? result : Range_1.Range3d.createNull();
        result.extendArray(this.point, transform);
        return result;
    }
    /** reverse indices facet-by-facet, with the given facetStartIndex array delimiting faces.
     *
     * * facetStartIndex[0] == 0 always -- start of facet zero.
     * * facet k has indices from facetStartIndex[k] <= i < facetStartIndex[k+1]
     * * hence for "internal" k, facetStartIndex[k] is both the upper limit of facet k-1 and the start of facet k.
     * *
     */
    reverseIndices(facetStartIndex) {
        if (facetStartIndex && PolyfaceData.isValidFacetStartIndexArray(facetStartIndex)) {
            PolyfaceData.reverseIndices(facetStartIndex, this.pointIndex, true);
            PolyfaceData.reverseIndices(facetStartIndex, this.normalIndex, true);
            PolyfaceData.reverseIndices(facetStartIndex, this.paramIndex, true);
            PolyfaceData.reverseIndices(facetStartIndex, this.colorIndex, true);
            PolyfaceData.reverseIndices(facetStartIndex, this.edgeVisible, false);
        }
    }
    reverseNormals() {
        if (this.normal)
            for (const normal of this.normal)
                normal.scaleInPlace(-1.0);
    }
    // This base class is just a data carrier.  It does not know if the index order and normal directions have special meaning.
    // 1) Caller must reverse normals if semanitically needed.
    // 2) Caller must reverse indices if semantically needed.
    tryTransformInPlace(transform) {
        const inverseTranspose = transform.matrix.inverse();
        this.point.transformInPlace(transform);
        if (inverseTranspose) {
            // apply simple Matrix3d to normals ...
            if (this.normal) {
                inverseTranspose.multiplyVectorArrayInPlace(this.normal);
            }
        }
        return true;
    }
    compress() {
        const packedData = ClusterableArray_1.ClusterableArray.clusterGrowablePoint3dArray(this.point);
        this.point = packedData.growablePackedPoints;
        packedData.updateIndices(this.pointIndex);
        //    if (this.paramIndex)  // Tracking uv params
        //      packedData.updateIndices(this.paramIndex);
        //    if (this.normalIndex) // Tracking normals
        //      packedData.updateIndices(this.normalIndex);
    }
    /**
     * Test if facetStartIndex is (minimally!) valid:
     * * length must be nonzero (recall that for "no facets" the facetStartIndexArray still must contain a 0)
     * * Each entry must be strictly smaller than the one that follows.
     * @param facetStartIndex array of facetStart data.  facet `i` has indices at `facetsStartIndex[i]` to (one before) `facetStartIndex[i+1]`
     */
    static isValidFacetStartIndexArray(facetStartIndex) {
        // facetStartIndex for empty facets has a single entry "0" -- empty array is not allowed
        if (facetStartIndex.length === 0)
            return false;
        for (let i = 0; i + 1 < facetStartIndex.length; i++)
            if (facetStartIndex[i] >= facetStartIndex[i + 1])
                return false;
        return true;
    }
    static reverseIndices(facetStartIndex, indices, preserveStart) {
        if (!indices || indices.length === 0)
            return true; // empty case
        if (indices.length > 0) {
            if (facetStartIndex[facetStartIndex.length - 1] === indices.length) {
                for (let i = 0; i + 1 < facetStartIndex.length; i++) {
                    let index0 = facetStartIndex[i];
                    let index1 = facetStartIndex[i + 1];
                    if (preserveStart) {
                        // leave [index0] as is so reversed facet starts at same vertex
                        while (index1 > index0 + 2) {
                            index1--;
                            index0++;
                            const a = indices[index0];
                            indices[index0] = indices[index1];
                            indices[index1] = a;
                        }
                    }
                    else {
                        // reverse all
                        while (index1 > index0 + 1) {
                            index1--;
                            const a = indices[index0];
                            indices[index0] = indices[index1];
                            indices[index1] = a;
                            index0++;
                        }
                    }
                }
                return true;
            }
        }
        return false;
    }
}
// <ul
// <li>optional arrays (normal, uv, color) must be indicated at constructor time.
// <li>all arrays are (independently) indexed.
// <li>with regret, the point, param, normal, and color arrays are exposed publicly.
// <li>getX methods are "trusting" -- no bounds check
// <li>getX methods return references to X.
// <li> EXCEPT -- for optional arrays, the return 000.
// <li>copyX methods move data to caller-supplied result..
// </ul>
PolyfaceData.planarityLocalRelTol = 1.0e-13;
exports.PolyfaceData = PolyfaceData;


/***/ }),

/***/ "./lib/polyface/PolyfaceQuery.js":
/*!***************************************!*\
  !*** ./lib/polyface/PolyfaceQuery.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Polyface */
// import { Point2d } from "./Geometry2d";
/* tslint:disable:variable-name jsdoc-format no-empty*/
// import { Point3d, Vector3d, Point2d } from "./PointVector";
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Polyface_1 = __webpack_require__(/*! ./Polyface */ "./lib/polyface/Polyface.js");
const Matrix4d_1 = __webpack_require__(/*! ../geometry4d/Matrix4d */ "./lib/geometry4d/Matrix4d.js");
const CurveCollection_1 = __webpack_require__(/*! ../curve/CurveCollection */ "./lib/curve/CurveCollection.js");
const Loop_1 = __webpack_require__(/*! ../curve/Loop */ "./lib/curve/Loop.js");
const LineString3d_1 = __webpack_require__(/*! ../curve/LineString3d */ "./lib/curve/LineString3d.js");
const PointHelpers_1 = __webpack_require__(/*! ../geometry3d/PointHelpers */ "./lib/geometry3d/PointHelpers.js");
const MomentData_1 = __webpack_require__(/*! ../geometry4d/MomentData */ "./lib/geometry4d/MomentData.js");
/** PolyfaceQuery is a static class whose methods implement queries on a polyface or polyface visitor provided as a parameter to each mtehod. */
class PolyfaceQuery {
    /** copy the points from a visitor into a Linestring3d in a Loop object */
    static VisitorToLoop(visitor) {
        const ls = LineString3d_1.LineString3d.createPoints(visitor.point.getPoint3dArray());
        return Loop_1.Loop.create(ls);
    }
    /** Create a linestring loop for each facet of the polyface. */
    static IndexedPolyfaceToLoops(polyface) {
        const result = CurveCollection_1.BagOfCurves.create();
        const visitor = polyface.createVisitor(1);
        while (visitor.moveToNextFacet()) {
            const loop = PolyfaceQuery.VisitorToLoop(visitor);
            result.tryAddChild(loop);
        }
        return result;
    }
    /** @returns Return the sum of all facets areas. */
    static sumFacetAreas(source) {
        let s = 0;
        if (source instanceof Polyface_1.Polyface)
            return PolyfaceQuery.sumFacetAreas(source.createVisitor(1));
        const visitor = source;
        visitor.reset();
        while (visitor.moveToNextFacet()) {
            s += PointHelpers_1.PolygonOps.sumTriangleAreas(visitor.point.getPoint3dArray());
        }
        return s;
    }
    /** sum volumes of tetrahedra from origin to all facets.
     * * if origin is omitted, the first point encountered (by the visitor) is used as origin.
     * * If the mesh is closed, this sum is the volume.
     * * If the mesh is not closed, this sum is the volume of a mesh with various additional facets
     * from the origin to facets.
    */
    static sumTetrahedralVolumes(source, origin) {
        let s = 0;
        if (source instanceof Polyface_1.Polyface)
            return PolyfaceQuery.sumTetrahedralVolumes(source.createVisitor(0), origin);
        let myOrigin = origin;
        const visitor = source;
        const facetOrigin = Point3dVector3d_1.Point3d.create();
        const targetA = Point3dVector3d_1.Point3d.create();
        const targetB = Point3dVector3d_1.Point3d.create();
        visitor.reset();
        while (visitor.moveToNextFacet()) {
            if (myOrigin === undefined)
                myOrigin = visitor.point.getPoint3dAt(0);
            visitor.point.getPoint3dAt(0, facetOrigin);
            for (let i = 1; i + 1 < visitor.point.length; i++) {
                visitor.point.getPoint3dAt(i, targetA);
                visitor.point.getPoint3dAt(i + 1, targetB);
                s += myOrigin.tripleProductToPoints(facetOrigin, targetA, targetB);
            }
        }
        return s / 6.0;
    }
    /** Return the inertia products [xx,xy,xz,xw, yw, etc] integrated over all facets. */
    static SumFacetSecondAreaMomentProducts(source, origin) {
        if (source instanceof Polyface_1.Polyface)
            return PolyfaceQuery.SumFacetSecondAreaMomentProducts(source.createVisitor(0), origin);
        const products = Matrix4d_1.Matrix4d.createZero();
        const visitor = source;
        visitor.reset();
        while (visitor.moveToNextFacet()) {
            PointHelpers_1.PolygonOps.addSecondMomentAreaProducts(visitor.point, origin, products);
        }
        return products;
    }
    /** Compute area moments for the mesh. In the returned MomentData:
     * * origin is the centroid.
     * * localToWorldMap has the origin and principal directions
     * * radiiOfGyration radii for rotation aroud the x,y,z axes.
     */
    static computePrincipalAreaMoments(source) {
        const origin = source.data.getPoint(0);
        if (!origin)
            return undefined;
        const inertiaProducts = PolyfaceQuery.SumFacetSecondAreaMomentProducts(source, origin);
        return MomentData_1.MomentData.inertiaProductsToPrincipalAxes(origin, inertiaProducts);
    }
}
exports.PolyfaceQuery = PolyfaceQuery;


/***/ }),

/***/ "./lib/serialization/DeepCompare.js":
/*!******************************************!*\
  !*** ./lib/serialization/DeepCompare.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Serialization */
/* tslint:disable: object-literal-key-quotes */
/** Comparison utilities */
class DeepCompare {
    constructor(numberRelTol = 1.0e-12) {
        this.numberRelTol = numberRelTol;
        this.typeCounts = {
            "numbers": 0,
            "arrays": 0,
            "functions": 0,
            "objects": 0,
            "strings": 0,
            "booleans": 0,
            "undefined": 0,
        };
        this.propertyCounts = {};
        this.errorTracker = [];
    }
    // Function specifying the way two numbers will be compared (may be changed by user)
    compareNumber(_a, _b) {
        if (Math.abs(_b - _a) < this.numberRelTol * (1 + Math.abs(_a) + Math.abs(_b))) {
            return this.announce(true);
        }
        else {
            this.errorTracker.unshift(_b);
            this.errorTracker.unshift(_a);
            this.errorTracker.unshift("In " + this.errorTracker[this.errorTracker.length - 1] + " property: Mismatched values");
            return this.announce(false);
        }
    }
    compareArray(a, b) {
        if (a.length !== b.length) {
            const aCounter = {};
            const bCounter = {};
            // Append object to tracker that counts the properties of each array element (which is an object) in b, ONLY AT THIS LEVEL
            for (const i of b) {
                if (typeof i === "object" && typeof i !== "function" && !Array.isArray(i)) {
                    for (const property in i) {
                        if (i.hasOwnProperty(property)) {
                            // Add property to counter if not already there
                            if (!bCounter.hasOwnProperty(property))
                                bCounter[property] = 0;
                            bCounter[property]++;
                        }
                    }
                }
            }
            this.errorTracker.unshift(bCounter);
            // Append object to tracker that counts the properties of each array element (which is an object) in a, ONLY AT THIS LEVEL
            for (const i of a) {
                if (typeof i === "object" && typeof i !== "function" && !Array.isArray(i)) {
                    for (const property in i) {
                        if (i.hasOwnProperty(property)) {
                            // Add property to counter if not already there
                            if (!aCounter.hasOwnProperty(property))
                                aCounter[property] = 0;
                            aCounter[property]++;
                        }
                    }
                }
            }
            this.errorTracker.unshift(aCounter);
            this.errorTracker.unshift("Mismatched array lengths a: [" + a.length + "] b: [" + b.length + "]");
            return this.announce(false);
        }
        // Keep track of result for each element of array
        let toReturn = true;
        for (let i = 0; i < a.length; i++) {
            toReturn = toReturn && this.compareInternal(a[i], b[i]);
            // If false, break the loop
            if (!toReturn) {
                this.errorTracker.unshift("[" + i.toString() + "]");
                break;
            }
        }
        return this.announce(toReturn);
    }
    compareObject(a, b) {
        // Check that both objects contain the same amount of properties
        if (a == null && b == null)
            return this.announce(true);
        if ((Object.keys(a)).length !== (Object.keys(b)).length) {
            this.errorTracker.unshift("Mismatched property lists [" + (Object.keys(a)) + "][" + (Object.keys(b)) + "]");
            return this.announce(false);
        }
        // Keep track of result for each property of object
        let toReturn = true;
        for (const property in a) {
            // Only check non-generic object properties
            if (a.hasOwnProperty(property)) {
                // If property does not exist in propertyCounter, add it
                if (!this.propertyCounts.hasOwnProperty(property)) {
                    this.propertyCounts[property] = 0;
                }
                this.propertyCounts[property]++;
                // Check that same property exists in b
                if (!(b.hasOwnProperty(property))) {
                    this.errorTracker.unshift("Property " + property + " of A not in B");
                    this.errorTracker.unshift(a);
                    this.errorTracker.unshift(b);
                    return this.announce(false);
                }
                toReturn = toReturn && this.compareInternal(a[property], b[property]);
                // If not true, push property and break the loop
                if (!toReturn) {
                    this.errorTracker.unshift(property);
                    break;
                }
            }
        }
        return this.announce(toReturn);
    }
    // this is a convenient place for a breakpoint on failures in areSameStructure.
    announce(value) {
        if (value)
            return true;
        return false;
    }
    // Clears out the member objects, then calls the recursive compare function
    compare(a, b, tolerance) {
        if (tolerance !== undefined)
            this.numberRelTol = tolerance;
        this.errorTracker.length = 0;
        this.typeCounts.numbers = this.typeCounts.arrays = this.typeCounts.functions = this.typeCounts.objects = this.typeCounts.strings = this.typeCounts.booleans = this.typeCounts.undefined = 0;
        this.propertyCounts = {};
        return this.compareInternal(a, b);
    }
    // Recursive function for comparing any two nodes in a json object "tree"
    compareInternal(a, b) {
        if (typeof a !== typeof b) {
            return this.announce(false);
        }
        if ((typeof a === "number") && (typeof b === "number")) {
            this.typeCounts.numbers++;
            return this.compareNumber(a, b);
        }
        else if (Array.isArray(a) && Array.isArray(b)) {
            this.typeCounts.arrays++;
            return this.compareArray(a, b);
        }
        else if (typeof a === "function" && typeof b === "function") {
            // No current necessity to check functions
            this.typeCounts.functions++;
            return true;
        }
        else if (typeof a === "object" && typeof b === "object") {
            // Argument is object but not array or function
            this.typeCounts.objects++;
            return (a === b) ? true : this.compareObject(a, b);
        }
        else if (typeof a === "string" && typeof b === "string") {
            this.typeCounts.strings++;
            return a === b;
        }
        else if (typeof a === "boolean" && typeof b === "boolean") {
            this.typeCounts.booleans++;
            return a === b;
        }
        else if (typeof a === "undefined" && typeof b === "undefined") {
            // As long as both are undefined, return true
            this.typeCounts.undefined++;
            return true;
        }
        else {
            // Unsupported type
            return this.announce(false);
        }
    }
}
exports.DeepCompare = DeepCompare;


/***/ }),

/***/ "./lib/serialization/IModelJsonSchema.js":
/*!***********************************************!*\
  !*** ./lib/serialization/IModelJsonSchema.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Serialization */
// import { Geometry, Angle, AxisOrder, BSIJSONValues } from "../Geometry";
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const AngleSweep_1 = __webpack_require__(/*! ../geometry3d/AngleSweep */ "./lib/geometry3d/AngleSweep.js");
const Angle_1 = __webpack_require__(/*! ../geometry3d/Angle */ "./lib/geometry3d/Angle.js");
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Segment1d_1 = __webpack_require__(/*! ../geometry3d/Segment1d */ "./lib/geometry3d/Segment1d.js");
const YawPitchRollAngles_1 = __webpack_require__(/*! ../geometry3d/YawPitchRollAngles */ "./lib/geometry3d/YawPitchRollAngles.js");
const Matrix3d_1 = __webpack_require__(/*! ../geometry3d/Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const GeometryQuery_1 = __webpack_require__(/*! ../curve/GeometryQuery */ "./lib/curve/GeometryQuery.js");
const CoordinateXYZ_1 = __webpack_require__(/*! ../curve/CoordinateXYZ */ "./lib/curve/CoordinateXYZ.js");
const TransitionSpiral_1 = __webpack_require__(/*! ../curve/TransitionSpiral */ "./lib/curve/TransitionSpiral.js");
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const UnionRegion_1 = __webpack_require__(/*! ../curve/UnionRegion */ "./lib/curve/UnionRegion.js");
const CurveCollection_1 = __webpack_require__(/*! ../curve/CurveCollection */ "./lib/curve/CurveCollection.js");
const ParityRegion_1 = __webpack_require__(/*! ../curve/ParityRegion */ "./lib/curve/ParityRegion.js");
const Loop_1 = __webpack_require__(/*! ../curve/Loop */ "./lib/curve/Loop.js");
const Path_1 = __webpack_require__(/*! ../curve/Path */ "./lib/curve/Path.js");
const Polyface_1 = __webpack_require__(/*! ../polyface/Polyface */ "./lib/polyface/Polyface.js");
const BSplineCurve_1 = __webpack_require__(/*! ../bspline/BSplineCurve */ "./lib/bspline/BSplineCurve.js");
const BSplineSurface_1 = __webpack_require__(/*! ../bspline/BSplineSurface */ "./lib/bspline/BSplineSurface.js");
const Sphere_1 = __webpack_require__(/*! ../solid/Sphere */ "./lib/solid/Sphere.js");
const Cone_1 = __webpack_require__(/*! ../solid/Cone */ "./lib/solid/Cone.js");
const Box_1 = __webpack_require__(/*! ../solid/Box */ "./lib/solid/Box.js");
const TorusPipe_1 = __webpack_require__(/*! ../solid/TorusPipe */ "./lib/solid/TorusPipe.js");
const LinearSweep_1 = __webpack_require__(/*! ../solid/LinearSweep */ "./lib/solid/LinearSweep.js");
const RotationalSweep_1 = __webpack_require__(/*! ../solid/RotationalSweep */ "./lib/solid/RotationalSweep.js");
const RuledSweep_1 = __webpack_require__(/*! ../solid/RuledSweep */ "./lib/solid/RuledSweep.js");
const Ray3d_1 = __webpack_require__(/*! ../geometry3d/Ray3d */ "./lib/geometry3d/Ray3d.js");
const GeometryHandler_1 = __webpack_require__(/*! ../geometry3d/GeometryHandler */ "./lib/geometry3d/GeometryHandler.js");
const LineString3d_1 = __webpack_require__(/*! ../curve/LineString3d */ "./lib/curve/LineString3d.js");
const PointString3d_1 = __webpack_require__(/*! ../curve/PointString3d */ "./lib/curve/PointString3d.js");
const Arc3d_1 = __webpack_require__(/*! ../curve/Arc3d */ "./lib/curve/Arc3d.js");
const LineSegment3d_1 = __webpack_require__(/*! ../curve/LineSegment3d */ "./lib/curve/LineSegment3d.js");
const BSplineCurve3dH_1 = __webpack_require__(/*! ../bspline/BSplineCurve3dH */ "./lib/bspline/BSplineCurve3dH.js");
const Point4d_1 = __webpack_require__(/*! ../geometry4d/Point4d */ "./lib/geometry4d/Point4d.js");
/* tslint:disable: object-literal-key-quotes no-console*/
var IModelJson;
(function (IModelJson) {
    /** parser servoces for "iModelJson" schema
     * * 1: create a reader with `new ImodelJsonReader`
     * * 2: parse json fragment to strongly typed geometry: `const g = reader.parse (fragment)`
     */
    class Reader {
        constructor() {
        }
        static parseVector3dProperty(json, propertyName, defaultValue) {
            if (json.hasOwnProperty(propertyName)) {
                const value = json[propertyName];
                if (Geometry_1.Geometry.isNumberArray(value, 3))
                    return Point3dVector3d_1.Vector3d.create(value[0], value[1], value[2]);
                if (Point3dVector3d_1.XYZ.isXAndY(value))
                    return Point3dVector3d_1.Vector3d.fromJSON(value);
            }
            return defaultValue;
        }
        static parsePoint3dProperty(json, propertyName, defaultValue) {
            if (json.hasOwnProperty(propertyName)) {
                const value = json[propertyName];
                if (Geometry_1.Geometry.isNumberArray(value, 3))
                    return Point3dVector3d_1.Point3d.create(value[0], value[1], value[2]);
                if (Point3dVector3d_1.XYZ.isXAndY(value))
                    return Point3dVector3d_1.Point3d.fromJSON(value);
            }
            return defaultValue;
        }
        static parseSegment1dProperty(json, propertyName, defaultValue) {
            if (json.hasOwnProperty(propertyName)) {
                const value = json[propertyName];
                if (Geometry_1.Geometry.isNumberArray(value, 2))
                    return Segment1d_1.Segment1d.create(value[0], value[1]);
            }
            return defaultValue;
        }
        static parseNumberProperty(json, propertyName, defaultValue) {
            if (json.hasOwnProperty(propertyName)) {
                const value = json[propertyName];
                if (Number.isFinite(value))
                    return value;
            }
            return defaultValue;
        }
        /* ==============
            private static parseNumberArrayProperty(json: any, propertyName: string, minValues: number, maxValues: number, defaultValue?: number[] | undefined): number[] | undefined {
              if (json.hasOwnProperty(propertyName)) {
                const value = json[propertyName];
                if (Array.isArray(value)
                  && value.length >= minValues && value.length <= maxValues) {
                  const result = [];
                  for (const a of value) {
                    result.push(a);
                  }
                  return result;
                }
              }
              return defaultValue;
            }
        */
        static parseAngleProperty(json, propertyName, defaultValue) {
            if (json.hasOwnProperty(propertyName)) {
                const value = json[propertyName];
                return Angle_1.Angle.fromJSON(value);
            }
            return defaultValue;
        }
        /**
         * @param defaultFunction function to call if needed to produce a default value
         */
        static parseAngleSweepProps(json, propertyName, defaultFunction) {
            if (json.hasOwnProperty(propertyName)) {
                const value = json[propertyName];
                return AngleSweep_1.AngleSweep.fromJSON(value);
            }
            if (defaultFunction === undefined)
                return undefined;
            return defaultFunction();
        }
        static parseBooleanProperty(json, propertyName, defaultValue) {
            if (json.hasOwnProperty(propertyName)) {
                const value = json[propertyName];
                if (value === true)
                    return true;
                if (value === false)
                    return false;
            }
            return defaultValue;
        }
        static loadContourArray(json, propertyName) {
            if (json.hasOwnProperty(propertyName)) {
                const value = json[propertyName];
                if (Array.isArray(value)) {
                    const result = [];
                    for (const contourData of value) {
                        const contour = Reader.parse(contourData);
                        if (contour instanceof CurveCollection_1.CurveCollection) {
                            result.push(contour);
                        }
                    }
                    if (result.length > 0)
                        return result;
                }
            }
            return undefined;
        }
        static parseYawPitchRollAngles(json) {
            const ypr = YawPitchRollAngles_1.YawPitchRollAngles.fromJSON(json);
            return ypr.toMatrix3d();
        }
        static parseStringProperty(json, propertyName, defaultValue) {
            if (json.hasOwnProperty(propertyName)) {
                const value = json[propertyName];
                if (value.type === "string")
                    return value;
            }
            return defaultValue;
        }
        static parseAxesFromVectors(json, axisOrder, createDefaultIdentity) {
            if (Array.isArray(json) && json.length === 2) {
                const xVector = Point3dVector3d_1.Vector3d.fromJSON(json[0]);
                const yVector = Point3dVector3d_1.Vector3d.fromJSON(json[1]);
                const matrix = Matrix3d_1.Matrix3d.createRigidFromColumns(xVector, yVector, axisOrder);
                if (matrix)
                    return matrix;
            }
            if (createDefaultIdentity)
                return Matrix3d_1.Matrix3d.createIdentity();
            return undefined;
        }
        /**
         * Look for orientation data and convert to Matrix3d.
         * * Search order is:
         * * * yawPitchRollAngles
         * * * xyVectors
         * * * zxVectors
         * @param json [in] json source data
         * @param createDefaultIdentity [in] If true and no orientation is present, return an identity matrix.  If false and no orientation is present, return undefined.
         */
        static parseOrientation(json, createDefaultIdentity) {
            if (json.yawPitchRollAngles) {
                return Reader.parseYawPitchRollAngles(json.yawPitchRollAngles);
            }
            else if (json.xyVectors) {
                return Reader.parseAxesFromVectors(json.xyVectors, 0 /* XYZ */, createDefaultIdentity);
            }
            else if (json.zxVectors) {
                return Reader.parseAxesFromVectors(json.zxVectors, 2 /* ZXY */, createDefaultIdentity);
            }
            if (createDefaultIdentity)
                return Matrix3d_1.Matrix3d.createIdentity();
            return undefined;
        }
        static parseArcByVectorProps(data) {
            if (data
                && data.center !== undefined
                && data.vectorX !== undefined
                && data.vectorY !== undefined
                && data.sweepStartEnd !== undefined) {
                return Arc3d_1.Arc3d.create(Point3dVector3d_1.Point3d.fromJSON(data.center), Point3dVector3d_1.Vector3d.fromJSON(data.vectorX), Point3dVector3d_1.Vector3d.fromJSON(data.vectorY), AngleSweep_1.AngleSweep.fromJSON(data.sweepStartEnd));
            }
            return undefined;
        }
        // remark: Returns LineString3d as last default when give points are colinear.
        static parseArcBy3Points(data) {
            if (Array.isArray(data) && data.length > 2) {
                const pointA = Point3dVector3d_1.Point3d.fromJSON(data[0]);
                const pointB = Point3dVector3d_1.Point3d.fromJSON(data[1]);
                const pointC = Point3dVector3d_1.Point3d.fromJSON(data[2]);
                return Arc3d_1.Arc3d.createCircularStartMiddleEnd(pointA, pointB, pointC);
            }
            return undefined;
        }
        static parseArcObject(data) {
            let arc = Reader.parseArcByVectorProps(data);
            if (arc)
                return arc;
            arc = Reader.parseArcBy3Points(data);
            return arc; // possibly undefined.
        }
        static parseCoordinate(data) {
            const point = Point3dVector3d_1.Point3d.fromJSON(data);
            if (point)
                return CoordinateXYZ_1.CoordinateXYZ.create(point);
            return undefined;
        }
        static parseTransitionSpiral(data) {
            const axes = Reader.parseOrientation(data, true);
            const origin = Reader.parsePoint3dProperty(data, "origin");
            // the create method will juggle any 4 out of these 5 inputs to define the other ..
            const startBearing = Reader.parseAngleProperty(data, "startBearing");
            const endBearing = Reader.parseAngleProperty(data, "endBearing");
            const startRadius = Reader.parseNumberProperty(data, "startRadius");
            const endRadius = Reader.parseNumberProperty(data, "endRadius");
            const length = Reader.parseNumberProperty(data, "curveLength", undefined);
            const interval = Reader.parseSegment1dProperty(data, "fractionInterval", undefined);
            const spiralType = Reader.parseStringProperty(data, "spiralType", "clothoid");
            if (origin)
                return TransitionSpiral_1.TransitionSpiral3d.create(spiralType, startRadius, endRadius, startBearing, endBearing, length, interval, Transform_1.Transform.createOriginAndMatrix(origin, axes));
            return undefined;
        }
        static parseBcurve(data) {
            if (Array.isArray(data.points) && Array.isArray(data.knots) && Number.isFinite(data.order) && data.closed !== undefined) {
                if (data.points[0].length === 4) {
                    const hPoles = [];
                    for (const p of data.points)
                        hPoles.push(Point4d_1.Point4d.fromJSON(p));
                    const knots = [];
                    for (const knot of data.knots)
                        knots.push(knot);
                    // TODO -- wrap poles and knots for closed case !!
                    if (data.closed) {
                        for (let i = 0; i + 1 < data.order; i++) {
                            hPoles.push(hPoles[i].clone());
                        }
                    }
                    const newCurve = BSplineCurve3dH_1.BSplineCurve3dH.create(hPoles, knots, data.order);
                    if (newCurve) {
                        if (data.closed === true)
                            newCurve.setWrappable(true);
                        return newCurve;
                    }
                }
                else if (data.points[0].length === 3 || data.points[0].length === 2) {
                    const poles = [];
                    for (const p of data.points)
                        poles.push(Point3dVector3d_1.Point3d.fromJSON(p));
                    const knots = [];
                    for (const knot of data.knots)
                        knots.push(knot);
                    // TODO -- wrap poles and knots for closed case !!
                    if (data.closed) {
                        for (let i = 0; i + 1 < data.order; i++) {
                            poles.push(poles[i].clone());
                        }
                    }
                    const newCurve = BSplineCurve_1.BSplineCurve3d.create(poles, knots, data.order);
                    if (newCurve) {
                        if (data.closed === true)
                            newCurve.setWrappable(true);
                        return newCurve;
                    }
                }
            }
            return undefined;
        }
        static parseArray(data) {
            if (Array.isArray(data)) {
                const myArray = [];
                let c;
                for (c of data) {
                    const g = Reader.parse(c);
                    if (g !== undefined)
                        myArray.push(g);
                }
                return myArray;
            }
            return undefined;
        }
        // For each nonzero index, Announce Math.abs (value) -1
        static addZeroBasedIndicesFromSignedOneBased(data, f) {
            if (data && Geometry_1.Geometry.isNumberArray(data)) {
                for (const value of data) {
                    if (value !== 0)
                        f(Math.abs(value) - 1);
                }
            }
        }
        static parsePolyfaceAuxData(data) {
            if (!Array.isArray(data.channels) || !Array.isArray(data.indices))
                return undefined;
            const outChannels = [];
            for (const inChannel of data.channels) {
                if (Array.isArray(inChannel.data) && inChannel.hasOwnProperty("dataType")) {
                    const outChannelData = [];
                    for (const inChannelData of inChannel.data) {
                        if (inChannelData.hasOwnProperty("input") && Array.isArray(inChannelData.values))
                            outChannelData.push(new Polyface_1.AuxChannelData(inChannelData.input, inChannelData.values));
                    }
                    outChannels.push(new Polyface_1.AuxChannel(outChannelData, inChannel.dataType, inChannel.name, inChannel.inputName));
                }
            }
            const auxData = new Polyface_1.PolyfaceAuxData(outChannels, []);
            Reader.addZeroBasedIndicesFromSignedOneBased(data.indices, (x) => { auxData.indices.push(x); });
            return auxData;
        }
        static parseIndexedMesh(data) {
            // {Coord:[[x,y,z],. . . ],   -- simple xyz for each ponit
            // CoordIndex[1,2,3,0]    -- zero-terminated, one based !!!
            if (data.hasOwnProperty("point") && Array.isArray(data.point)
                && data.hasOwnProperty("pointIndex") && Array.isArray(data.pointIndex)) {
                const polyface = Polyface_1.IndexedPolyface.create();
                if (data.hasOwnProperty("normal") && Array.isArray(data.normal)) {
                    for (const uvw of data.normal) {
                        if (Geometry_1.Geometry.isNumberArray(uvw, 3))
                            polyface.addNormal(Point3dVector3d_1.Vector3d.create(uvw[0], uvw[1], uvw[2]));
                    }
                }
                if (data.hasOwnProperty("param") && Array.isArray(data.param)) {
                    for (const uv of data.param) {
                        if (Geometry_1.Geometry.isNumberArray(uv, 2))
                            polyface.addParam(Point2dVector2d_1.Point2d.create(uv[0], uv[1]));
                    }
                }
                if (data.hasOwnProperty("color") && Array.isArray(data.color)) {
                    for (const c of data.color) {
                        polyface.addColor(c);
                    }
                }
                for (const p of data.point)
                    polyface.addPoint(Point3dVector3d_1.Point3d.fromJSON(p));
                for (const p of data.pointIndex) {
                    if (p === 0)
                        polyface.terminateFacet(false); // we are responsible for index checking !!!
                    else {
                        const p0 = Math.abs(p) - 1;
                        polyface.addPointIndex(p0, p > 0);
                    }
                }
                if (data.hasOwnProperty("normalIndex")) {
                    Reader.addZeroBasedIndicesFromSignedOneBased(data.normalIndex, (x) => { polyface.addNormalIndex(x); });
                }
                if (data.hasOwnProperty("paramIndex")) {
                    Reader.addZeroBasedIndicesFromSignedOneBased(data.paramIndex, (x) => { polyface.addParamIndex(x); });
                }
                if (data.hasOwnProperty("colorIndex")) {
                    Reader.addZeroBasedIndicesFromSignedOneBased(data.colorIndex, (x) => { polyface.addColorIndex(x); });
                }
                if (data.hasOwnProperty("auxData"))
                    polyface.data.auxData = Reader.parsePolyfaceAuxData(data.auxData);
                return polyface;
            }
            return undefined;
        }
        static parseCurveCollectionMembers(result, data) {
            if (data && Array.isArray(data)) {
                for (const c of data) {
                    const g = Reader.parse(c);
                    if (g !== undefined)
                        result.tryAddChild(g);
                }
                return result;
            }
            return undefined;
        }
        static parseBsurf(data) {
            if (data.hasOwnProperty("uKnots") && Array.isArray(data.uKnots)
                && data.hasOwnProperty("vKnots") && Array.isArray(data.vKnots)
                && data.hasOwnProperty("orderU") && Number.isFinite(data.orderU)
                && data.hasOwnProperty("orderV") && Number.isFinite(data.orderV)
                && data.hasOwnProperty("points") && Array.isArray(data.points)) {
                const orderU = data.orderU;
                const orderV = data.orderV;
                if (Array.isArray(data.points[0]) && Array.isArray(data.points[0][0])) {
                    const d = data.points[0][0].length;
                    /** xyz surface (no weights) */
                    if (d === 3) {
                        return BSplineSurface_1.BSplineSurface3d.createGrid(data.points, orderU, data.uKnots, orderV, data.vKnots);
                    }
                    /** xyzw surface (weights already applied) */
                    if (d === 4) {
                        return BSplineSurface_1.BSplineSurface3dH.createGrid(data.points, BSplineSurface_1.WeightStyle.WeightsAlreadyAppliedToCoordinates, orderU, data.uKnots, orderV, data.vKnots);
                    }
                }
            }
            return undefined;
        }
        /**
         * Create a cone with data from a `ConeByCCRRV`.
         */
        static parseConeProps(json) {
            const axes = Reader.parseOrientation(json, false);
            const start = Reader.parsePoint3dProperty(json, "start");
            const end = Reader.parsePoint3dProperty(json, "end");
            const startRadius = Reader.parseNumberProperty(json, "startRadius");
            const endRadius = Reader.parseNumberProperty(json, "endRadius", startRadius);
            const capped = Reader.parseBooleanProperty(json, "capped", false);
            if (start
                && end
                && startRadius !== undefined
                && endRadius !== undefined) {
                if (axes === undefined) {
                    const axisVector = Point3dVector3d_1.Vector3d.createStartEnd(start, end);
                    const frame = Matrix3d_1.Matrix3d.createRigidHeadsUp(axisVector, 2 /* ZXY */);
                    const vectorX = frame.columnX();
                    const vectorY = frame.columnY();
                    return Cone_1.Cone.createBaseAndTarget(start, end, vectorX, vectorY, startRadius, endRadius, capped);
                }
                else {
                    return Cone_1.Cone.createBaseAndTarget(start, end, axes.columnX(), axes.columnY(), startRadius, endRadius, capped);
                }
            }
            return undefined;
        }
        /**
         * Create a cylinder.
         */
        static parseCylinderProps(json) {
            const start = Reader.parsePoint3dProperty(json, "start");
            const end = Reader.parsePoint3dProperty(json, "end");
            const radius = Reader.parseNumberProperty(json, "radius");
            const capped = Reader.parseBooleanProperty(json, "capped", false);
            if (start
                && end
                && radius !== undefined) {
                return Cone_1.Cone.createAxisPoints(start, end, radius, radius, capped);
            }
            return undefined;
        }
        static parseLineSegmentProps(value) {
            if (Array.isArray(value) && value.length > 1)
                return LineSegment3d_1.LineSegment3d.create(Point3dVector3d_1.Point3d.fromJSON(value[0]), Point3dVector3d_1.Point3d.fromJSON(value[1]));
        }
        static parseLinearSweep(json) {
            const contour = Reader.parse(json.contour);
            const capped = Reader.parseBooleanProperty(json, "capped");
            const extrusionVector = Reader.parseVector3dProperty(json, "vector");
            if (contour
                && capped !== undefined
                && extrusionVector) {
                return LinearSweep_1.LinearSweep.create(contour, extrusionVector, capped);
            }
            return undefined;
        }
        static parseRotationalSweep(json) {
            const contour = Reader.parse(json.contour);
            const capped = Reader.parseBooleanProperty(json, "capped");
            const axisVector = Reader.parseVector3dProperty(json, "axis");
            const center = Reader.parsePoint3dProperty(json, "center");
            const sweepDegrees = Reader.parseNumberProperty(json, "sweepAngle");
            if (contour
                && sweepDegrees !== undefined
                && capped !== undefined
                && axisVector
                && center) {
                return RotationalSweep_1.RotationalSweep.create(contour, Ray3d_1.Ray3d.createCapture(center, axisVector), Angle_1.Angle.createDegrees(sweepDegrees), capped);
            }
            return undefined;
        }
        static parseBox(json) {
            const capped = Reader.parseBooleanProperty(json, "capped", false);
            const baseOrigin = Reader.parsePoint3dProperty(json, "baseOrigin");
            const baseX = Reader.parseNumberProperty(json, "baseX");
            const baseY = Reader.parseNumberProperty(json, "baseY", baseX);
            let topOrigin = Reader.parsePoint3dProperty(json, "topOrigin");
            const topX = Reader.parseNumberProperty(json, "topX", baseX);
            const topY = Reader.parseNumberProperty(json, "topY", baseY);
            const height = Reader.parseNumberProperty(json, "height", baseX);
            const axes = Reader.parseOrientation(json, true);
            if (baseOrigin && !topOrigin)
                topOrigin = Matrix3d_1.Matrix3d.XYZMinusMatrixTimesXYZ(baseOrigin, axes, Point3dVector3d_1.Vector3d.create(0, 0, height));
            if (capped !== undefined
                && baseX !== undefined
                && baseY !== undefined
                && topY !== undefined
                && topX !== undefined
                && axes
                && baseOrigin
                && topOrigin) {
                return Box_1.Box.createDgnBoxWithAxes(baseOrigin, axes, topOrigin, baseX, baseY, topX, topY, capped);
            }
            return undefined;
        }
        static parseSphere(json) {
            const center = Reader.parsePoint3dProperty(json, "center");
            // optional unqualified radius . . .
            const radius = Reader.parseNumberProperty(json, "radius");
            // optional specific X
            const radiusX = Reader.parseNumberProperty(json, "radiusX", radius);
            // missing Y and Z both pick up radiusX  (which may have already been defaulted from unqualified radius)
            const radiusY = Reader.parseNumberProperty(json, "radiusX", radiusX);
            const radiusZ = Reader.parseNumberProperty(json, "radiusX", radiusX);
            const latitudeStartEnd = Reader.parseAngleSweepProps(json, "latitudeStartEnd"); // this may be undfined!!
            const axes = Reader.parseOrientation(json, true);
            const capped = Reader.parseBooleanProperty(json, "capped", false);
            if (center !== undefined
                && radiusX !== undefined
                && radiusY !== undefined
                && radiusZ !== undefined
                && capped !== undefined) {
                return Sphere_1.Sphere.createFromAxesAndScales(center, axes, radiusX, radiusY, radiusZ, latitudeStartEnd, capped);
            }
            return undefined;
        }
        static parseRuledSweep(json) {
            const capped = Reader.parseBooleanProperty(json, "capped", false);
            const contours = this.loadContourArray(json, "contour");
            if (contours !== undefined
                && capped !== undefined) {
                return RuledSweep_1.RuledSweep.create(contours, capped);
            }
            return undefined;
        }
        static parseTorusPipe(json) {
            const axes = Reader.parseOrientation(json, true);
            const center = Reader.parsePoint3dProperty(json, "center");
            const radiusA = Reader.parseNumberProperty(json, "majorRadius");
            const radiusB = Reader.parseNumberProperty(json, "minorRadius");
            const sweepAngle = Reader.parseAngleProperty(json, "sweepAngle", undefined);
            const capped = Reader.parseBooleanProperty(json, "capped", false);
            if (center
                && radiusA !== undefined
                && radiusB !== undefined) {
                return TorusPipe_1.TorusPipe.createDgnTorusPipe(center, axes.columnX(), axes.columnY(), radiusA, radiusB, sweepAngle ? sweepAngle : Angle_1.Angle.createDegrees(360), capped);
            }
            return undefined;
        }
        static parsePointArray(json) {
            const points = [];
            if (json && Array.isArray(json)) {
                for (const member of json) {
                    if (Point3dVector3d_1.XYZ.isXAndY(member)) {
                        points.push(Point3dVector3d_1.Point3d.fromJSON(member));
                    }
                    else if (Geometry_1.Geometry.isNumberArray(member, 2)) {
                        points.push(Point3dVector3d_1.Point3d.fromJSON(member));
                    }
                }
            }
            return points;
        }
        static parse(json) {
            if (json !== undefined && json) {
                if (json.lineSegment !== undefined) {
                    return Reader.parseLineSegmentProps(json.lineSegment);
                }
                else if (json.lineString !== undefined) {
                    return LineString3d_1.LineString3d.create(Reader.parsePointArray(json.lineString));
                }
                else if (json.arc !== undefined) {
                    return Reader.parseArcObject(json.arc);
                }
                else if (json.hasOwnProperty("point")) {
                    return Reader.parseCoordinate(json.point);
                }
                else if (json.hasOwnProperty("bcurve")) {
                    return Reader.parseBcurve(json.bcurve);
                }
                else if (json.hasOwnProperty("path")) {
                    return Reader.parseCurveCollectionMembers(new Path_1.Path(), json.path);
                }
                else if (json.hasOwnProperty("loop")) {
                    return Reader.parseCurveCollectionMembers(new Loop_1.Loop(), json.loop);
                }
                else if (json.hasOwnProperty("parityRegion")) {
                    return Reader.parseCurveCollectionMembers(new ParityRegion_1.ParityRegion(), json.parityRegion);
                }
                else if (json.hasOwnProperty("unionRegion")) {
                    return Reader.parseCurveCollectionMembers(new UnionRegion_1.UnionRegion(), json.unionRegion);
                }
                else if (json.hasOwnProperty("bagOfCurves")) {
                    return Reader.parseCurveCollectionMembers(new CurveCollection_1.BagOfCurves(), json.bagOfCurves);
                }
                else if (json.hasOwnProperty("indexedMesh")) {
                    return Reader.parseIndexedMesh(json.indexedMesh);
                }
                else if (json.hasOwnProperty("bsurf")) {
                    return Reader.parseBsurf(json.bsurf);
                }
                else if (json.hasOwnProperty("cone")) {
                    return Reader.parseConeProps(json.cone);
                }
                else if (json.hasOwnProperty("cylinder")) {
                    return Reader.parseCylinderProps(json.cylinder);
                }
                else if (json.hasOwnProperty("sphere")) {
                    return Reader.parseSphere(json.sphere);
                }
                else if (json.hasOwnProperty("linearSweep")) {
                    return Reader.parseLinearSweep(json.linearSweep);
                }
                else if (json.hasOwnProperty("box")) {
                    return Reader.parseBox(json.box);
                }
                else if (json.hasOwnProperty("rotationalSweep")) {
                    return Reader.parseRotationalSweep(json.rotationalSweep);
                }
                else if (json.hasOwnProperty("ruledSweep")) {
                    return Reader.parseRuledSweep(json.ruledSweep);
                }
                else if (json.hasOwnProperty("torusPipe")) {
                    return Reader.parseTorusPipe(json.torusPipe);
                }
                else if (json.hasOwnProperty("pointString")) {
                    return PointString3d_1.PointString3d.create(Reader.parsePointArray(json.pointString));
                }
                else if (json.hasOwnProperty("transitionSpiral")) {
                    return Reader.parseTransitionSpiral(json.transitionSpiral);
                }
                else if (Array.isArray(json))
                    return Reader.parseArray(json);
            }
            return undefined;
        }
    }
    IModelJson.Reader = Reader;
    // ISSUE: include 3d in names?
    // ISSUE: would like shorter term than lineSegment
    // ISSUE: is arc clear?
    // ISSUE: label center, vectorX, vector90 on arc?
    // ISSUE: sweep data on arc -- serialize as AngleSweep?
    class Writer extends GeometryHandler_1.GeometryHandler {
        handleLineSegment3d(data) {
            return { "lineSegment": [data.point0Ref.toJSON(), data.point1Ref.toJSON()] };
        }
        handleCoordinateXYZ(data) {
            return { "point": data.point.toJSON() };
        }
        handleArc3d(data) {
            return {
                "arc": {
                    "center": data.center.toJSON(),
                    "vectorX": data.vector0.toJSON(),
                    "vectorY": data.vector90.toJSON(),
                    "sweepStartEnd": [data.sweep.startDegrees, data.sweep.endDegrees],
                },
            };
        }
        /**
         * Insert orientation description to a data object.
         * @param matrix matrix with orientation
         * @param omitIfIdentity omit the axis data if the matrix is an identity.
         * @param data AxesProps object to be annotated.
         */
        static insertOrientationFromMatrix(data, matrix, omitIfIdentity) {
            if (omitIfIdentity) {
                if (matrix === undefined)
                    return;
                if (matrix.isIdentity)
                    return;
            }
            if (matrix)
                data.xyVectors = [matrix.columnX().toJSON(), matrix.columnY().toJSON()];
            else
                data.xyVectors = [[1, 0, 0], [0, 1, 0]];
        }
        static isIdentityXY(xVector, yVector) {
            return xVector.isAlmostEqualXYZ(1, 0, 0) && yVector.isAlmostEqualXYZ(0, 1, 0);
        }
        /**
         * Insert orientation description to a data object.
         * @param matrix matrix with orientation
         * @param omitIfIdentity omit the axis data if the matrix is an identity.
         * @param data AxesProps object to be annotated.
         */
        static insertOrientationFromXYVectors(data, vectorX, vectorY, omitIfIdentity) {
            if (omitIfIdentity && Writer.isIdentityXY(vectorX, vectorY))
                return;
            data.xyVectors = [vectorX.toJSON(), vectorY.toJSON()];
        }
        /**
         * Insert orientation description to a data object, with orientation defined by u and v direction
         * vectors.
         * @param vectorX u direction
         * @param vectorV v direction
         * @param omitIfIdentity omit the axis data if the vectorU and vectorV are global x and y vectors.
         * @param data AxesProps object to be annotated.
         */
        static insertXYOrientation(data, vectorU, vectorV, omitIfIdentity) {
            if (omitIfIdentity) {
                if (vectorU.isAlmostEqualXYZ(1, 0, 0) && vectorV.isAlmostEqualXYZ(0, 1, 0))
                    return;
            }
            data.xyVectors = [vectorU.toJSON(), vectorV.toJSON()];
        }
        handleTransitionSpiral(data) {
            // TODO: HANDLE NONRIGID TRANSFORM !!
            // the spiral may have indication of how it was defined.  If so, use defined/undefined state of the orignial data
            // as indication of what current data to use.  (Current data may have changed due to transforms.)
            const originalProperties = data.originalProperties;
            const value = {
                origin: data.localToWorld.origin.toJSON(),
                type: data.getSpiralType(),
            };
            Writer.insertOrientationFromMatrix(value, data.localToWorld.matrix, true);
            if (!data.activeFractionInterval.isExact01)
                value.fractionInterval = [data.activeFractionInterval.x0, data.activeFractionInterval.x1];
            // Object.defineProperty(value, "fractionInterval", { value: [data.activeFractionInterval.x0, data.activeFractionInterval.x1] });
            // if possible, do selective output of defining data (omit exactly one out of the 5, matching original definition)
            if (originalProperties !== undefined && originalProperties.numDefinedProperties() === 4) {
                if (originalProperties.radius0 !== undefined)
                    value.startRadius = data.radius01.x0;
                if (originalProperties.radius1 !== undefined)
                    value.endRadius = data.radius01.x1;
                if (originalProperties.bearing0 !== undefined)
                    value.startBearing = data.bearing01.startAngle.toJSON();
                if (originalProperties.bearing1 !== undefined)
                    value.endBearing = data.bearing01.endAngle.toJSON();
                if (originalProperties.curveLength !== undefined)
                    value.curveLength = data.curveLength();
            }
            else {
                // uh oh ... no original data, but the spiral itself knows all 5 values.  We don't know which to consider primary.
                // DECISION -- put everything out, let readers make sense if they can. (It should be consistent ?)
                value.startRadius = data.radius01.x0;
                value.endRadius = data.radius01.x1;
                value.startBearing = data.bearing01.startAngle.toJSON();
                value.endBearing = data.bearing01.endAngle.toJSON();
                value.curveLength = data.curveLength();
            }
            return { "transitionSpiral": value };
        }
        handleCone(data) {
            const radiusA = data.getRadiusA();
            const radiusB = data.getRadiusB();
            const centerA = data.getCenterA();
            const centerB = data.getCenterB();
            const vectorX = data.getVectorX();
            const vectorY = data.getVectorY();
            const axisVector = Point3dVector3d_1.Vector3d.createStartEnd(centerA, centerB);
            if (Geometry_1.Geometry.isSameCoordinate(radiusA, radiusB)
                && vectorX.isPerpendicularTo(axisVector)
                && vectorY.isPerpendicularTo(axisVector)
                && Geometry_1.Geometry.isSameCoordinate(vectorX.magnitude(), 1.0)
                && Geometry_1.Geometry.isSameCoordinate(vectorY.magnitude(), 1.0)) {
                return {
                    "cylinder": {
                        "capped": data.capped,
                        "start": data.getCenterA().toJSON(),
                        "end": data.getCenterB().toJSON(),
                        "radius": radiusA,
                    },
                };
            }
            else {
                const coneProps = {
                    "capped": data.capped,
                    "start": data.getCenterA().toJSON(),
                    "end": data.getCenterB().toJSON(),
                    "startRadius": data.getRadiusA(),
                    "endRadius": data.getRadiusB(),
                };
                Writer.insertOrientationFromXYVectors(coneProps, vectorX, vectorY, false);
                return { "cone": coneProps };
            }
        }
        handleSphere(data) {
            const xData = data.cloneVectorX().normalizeWithLength();
            const yData = data.cloneVectorY().normalizeWithLength();
            const zData = data.cloneVectorZ().normalizeWithLength();
            const latitudeSweep = data.cloneLatitudeSweep();
            const rX = xData.mag;
            const rY = yData.mag;
            const rZ = zData.mag;
            if (xData.v && zData.v) {
                const value = {
                    "center": data.cloneCenter().toJSON(),
                };
                if (!(data.getConstructiveFrame()).matrix.isIdentity)
                    value.zxVectors = [zData.v.toJSON(), xData.v.toJSON()];
                const fullSweep = latitudeSweep.isFullLatitudeSweep;
                if (data.capped && !fullSweep)
                    value.capped = data.capped;
                if (Geometry_1.Geometry.isSameCoordinate(rX, rY) && Geometry_1.Geometry.isSameCoordinate(rX, rZ))
                    value.radius = rX;
                else {
                    value.radiusX = rX;
                    value.radiusY = rY;
                    value.radiusZ = rZ;
                }
                if (!fullSweep)
                    value.latitudeStartEnd = latitudeSweep.toJSON();
                return { "sphere": value };
            }
            return undefined;
        }
        handleTorusPipe(data) {
            const vectorX = data.cloneVectorX();
            const vectorY = data.cloneVectorY();
            const radiusA = data.getMajorRadius();
            const radiusB = data.getMinorRadius();
            const sweep = data.getSweepAngle();
            if (data.getIsReversed()) {
                vectorY.scaleInPlace(-1.0);
                sweep.setRadians(-sweep.radians);
            }
            const value = {
                "center": data.cloneCenter().toJSON(),
                "majorRadius": radiusA,
                "minorRadius": radiusB,
                "xyVectors": [vectorX.toJSON(), vectorY.toJSON()],
            };
            if (!sweep.isFullCircle) {
                value.sweepAngle = sweep.degrees;
                value.capped = data.capped;
            }
            return { "torusPipe": value };
        }
        handleLineString3d(data) {
            const pointsA = data.points;
            const pointsB = [];
            if (pointsA)
                for (const p of pointsA)
                    pointsB.push(p.toJSON());
            return { "lineString": pointsB };
        }
        handlePointString3d(data) {
            const pointsA = data.points;
            const pointsB = [];
            if (pointsA)
                for (const p of pointsA)
                    pointsB.push(p.toJSON());
            return { "pointString": pointsB };
        }
        handlePath(data) {
            return { "path": this.collectChildren(data) };
        }
        handleLoop(data) {
            return { "loop": this.collectChildren(data) };
        }
        handleParityRegion(data) {
            return { "parityRegion": this.collectChildren(data) };
        }
        handleUnionRegion(data) {
            return { "unionRegion": this.collectChildren(data) };
        }
        handleBagOfCurves(data) {
            return { "bagOfCurves": this.collectChildren(data) };
        }
        collectChildren(data) {
            const children = [];
            if (data.children && Array.isArray(data.children)) {
                for (const child of data.children) {
                    const cdata = child.dispatchToGeometryHandler(this);
                    if (cdata)
                        children.push(cdata);
                }
            }
            return children;
        }
        handleLinearSweep(data) {
            const extrusionVector = data.cloneSweepVector();
            const curves = data.getCurvesRef();
            const capped = data.capped;
            if (extrusionVector
                && curves
                && capped !== undefined) {
                return {
                    "linearSweep": {
                        "contour": curves.dispatchToGeometryHandler(this),
                        "capped": capped,
                        "vector": extrusionVector.toJSON(),
                    },
                };
            }
            return undefined;
        }
        handleRuledSweep(data) {
            const contours = data.cloneContours();
            const capped = data.capped;
            if (contours
                && contours.length > 1
                && capped !== undefined) {
                const jsonContours = [];
                for (const c of contours) {
                    jsonContours.push(this.emit(c));
                }
                return {
                    "ruledSweep": {
                        "contour": jsonContours,
                        "capped": capped,
                    },
                };
            }
            return undefined;
        }
        handleRotationalSweep(data) {
            const axisRay = data.cloneAxisRay();
            const curves = data.getCurves();
            const capped = data.capped;
            const sweepAngle = data.getSweep();
            return {
                "rotationalSweep": {
                    "axis": axisRay.direction.toJSON(),
                    "contour": curves.dispatchToGeometryHandler(this),
                    "capped": capped,
                    "center": axisRay.origin.toJSON(),
                    "sweepAngle": sweepAngle.degrees,
                },
            };
        }
        handleBox(box) {
            const out = {
                "box": {
                    "baseOrigin": box.getBaseOrigin().toJSON(),
                    "baseX": box.getBaseX(),
                    "baseY": box.getBaseY(),
                    "capped": box.capped,
                    "topOrigin": box.getTopOrigin().toJSON(),
                },
            };
            Writer.insertXYOrientation(out.box, box.getVectorX(), box.getVectorY(), true);
            if (!Geometry_1.Geometry.isSameCoordinate(box.getTopX(), box.getBaseX()))
                out.box.topX = box.getTopX();
            if (!Geometry_1.Geometry.isSameCoordinate(box.getTopY(), box.getBaseY()))
                out.box.topY = box.getTopY();
            return out;
        }
        handlePolyfaceAuxData(auxData, pf) {
            const contents = {};
            contents.indices = [];
            const visitor = pf.createVisitor(0);
            if (!visitor.auxData)
                return;
            while (visitor.moveToNextFacet()) {
                for (let i = 0; i < visitor.indexCount; i++) {
                    contents.indices.push(visitor.auxData.indices[i] + 1);
                }
                contents.indices.push(0); // facet terminator.
            }
            contents.channels = [];
            for (const inChannel of auxData.channels) {
                const outChannel = {};
                outChannel.dataType = inChannel.dataType;
                outChannel.name = inChannel.name;
                outChannel.inputName = inChannel.inputName;
                outChannel.data = [];
                for (const inData of inChannel.data) {
                    const outData = {};
                    outData.input = inData.input;
                    outData.values = inData.values.slice(0);
                    outChannel.data.push(outData);
                }
                contents.channels.push(outChannel);
            }
            return contents;
        }
        handleIndexedPolyface(pf) {
            const points = [];
            const pointIndex = [];
            const normals = [];
            const params = [];
            const colors = [];
            const p = Point3dVector3d_1.Point3d.create();
            for (let i = 0; pf.data.point.atPoint3dIndex(i, p); i++)
                points.push(p.toJSON());
            if (pf.data.normal) {
                for (const value of pf.data.normal)
                    normals.push(value.toJSON());
            }
            if (pf.data.param) {
                for (const value of pf.data.param)
                    params.push(value.toJSON());
            }
            if (pf.data.color) {
                for (const value of pf.data.color)
                    colors.push(value);
            }
            const visitor = pf.createVisitor(0);
            let indexCounter = 0;
            const normalIndex = [];
            const paramIndex = [];
            const colorIndex = [];
            let n;
            while (visitor.moveToNextFacet()) {
                n = visitor.indexCount;
                // All meshes have point and point index ...
                for (let i = 0; i < n; i++) {
                    // Change sign of value to be pushed based on whether or not the edge was originally visible or not
                    const toPush = pf.data.edgeVisible[indexCounter + i] ? visitor.pointIndex[i] + 1 : -(visitor.clientPointIndex(i) + 1);
                    pointIndex.push(toPush);
                }
                pointIndex.push(0); // facet terminator.
                indexCounter += visitor.indexCount;
                if (visitor.normalIndex) {
                    for (let i = 0; i < n; i++)
                        normalIndex.push(1 + visitor.clientNormalIndex(i));
                    normalIndex.push(0);
                }
                if (visitor.paramIndex) {
                    for (let i = 0; i < n; i++)
                        paramIndex.push(1 + visitor.clientParamIndex(i));
                    paramIndex.push(0);
                }
                if (visitor.colorIndex) {
                    for (let i = 0; i < n; i++)
                        colorIndex.push(1 + visitor.clientColorIndex(i));
                    colorIndex.push(0);
                }
            }
            // assemble the contents in alphabetical order.
            const contents = {};
            if (pf.data.auxData)
                contents.auxData = this.handlePolyfaceAuxData(pf.data.auxData, pf);
            if (pf.data.color)
                contents.color = colors;
            if (pf.data.colorIndex)
                contents.colorIndex = colorIndex;
            if (pf.data.normal)
                contents.normal = normals;
            if (pf.data.normalIndex)
                contents.normalIndex = normalIndex;
            if (pf.data.param)
                contents.param = params;
            if (pf.data.paramIndex)
                contents.paramIndex = paramIndex;
            contents.point = points;
            contents.pointIndex = pointIndex;
            return { "indexedMesh": contents };
        }
        handleBSplineCurve3d(curve) {
            // ASSUME -- if the curve originated "closed" the knot and pole replication are unchanged,
            // so first and last knots can be re-assigned, and last (degree - 1) poles can be deleted.
            if (curve.isClosable) {
                const knots = curve.copyKnots(true);
                const poles = curve.copyPoints();
                const degree = curve.degree;
                for (let i = 0; i < degree; i++)
                    poles.pop();
                // knots have replicated first and last.  Change the values to be periodic.
                const leftIndex = degree;
                const rightIndex = knots.length - degree - 1;
                const knotPeriod = knots[rightIndex] - knots[leftIndex];
                knots[0] = knots[rightIndex - degree] - knotPeriod;
                knots[knots.length - 1] = knots[leftIndex + degree] + knotPeriod;
                return {
                    "bcurve": {
                        "points": poles,
                        "knots": knots,
                        "closed": true,
                        "order": curve.order,
                    },
                };
            }
            else {
                return {
                    "bcurve": {
                        "points": curve.copyPoints(),
                        "knots": curve.copyKnots(true),
                        "closed": false,
                        "order": curve.order,
                    },
                };
            }
        }
        handleBezierCurve3d(curve) {
            const knots = [];
            const order = curve.order;
            for (let i = 0; i < order; i++)
                knots.push(0.0);
            for (let i = 0; i < order; i++)
                knots.push(1.0);
            return {
                "bcurve": {
                    "points": curve.copyPolesAsJsonArray(),
                    "knots": knots,
                    "closed": false,
                    "order": curve.order,
                },
            };
        }
        handleBSplineCurve3dH(curve) {
            // ASSUME -- if the curve originated "closed" the knot and pole replication are unchanged,
            // so first and last knots can be re-assigned, and last (degree - 1) poles can be deleted.
            if (curve.isClosable) {
                const knots = curve.copyKnots(true);
                const poles = curve.copyPoints();
                const degree = curve.degree;
                for (let i = 0; i < degree; i++)
                    poles.pop();
                // knots have replicated first and last.  Change the values to be periodic.
                const leftIndex = degree;
                const rightIndex = knots.length - degree - 1;
                const knotPeriod = knots[rightIndex] - knots[leftIndex];
                knots[0] = knots[rightIndex - degree] - knotPeriod;
                knots[knots.length - 1] = knots[leftIndex + degree] + knotPeriod;
                return {
                    "bcurve": {
                        "points": poles,
                        "knots": knots,
                        "closed": true,
                        "order": curve.order,
                    },
                };
            }
            else {
                return {
                    "bcurve": {
                        "points": curve.copyPoints(),
                        "knots": curve.copyKnots(true),
                        "closed": false,
                        "order": curve.order,
                    },
                };
            }
        }
        handleBSplineSurface3d(surface) {
            // ASSUME -- if the curve originated "closed" the knot and pole replication are unchanged,
            // so first and last knots can be re-assigned, and last (degree - 1) poles can be deleted.
            const periodicU = surface.isClosable(0);
            const periodicV = surface.isClosable(1);
            if (periodicU || periodicV) {
                let numUPoles = surface.numPolesUV(0);
                let numVPoles = surface.numPolesUV(1);
                if (periodicU)
                    numUPoles -= surface.degreeUV(0);
                if (periodicV)
                    numVPoles -= surface.degreeUV(1);
                const xyz = Point3dVector3d_1.Point3d.create();
                const grid = [];
                for (let j = 0; j < numVPoles; j++) {
                    const stringer = [];
                    for (let i = 0; i < numUPoles; i++) {
                        surface.getPoint3dPole(i, j, xyz);
                        stringer.push([xyz.x, xyz.y, xyz.z]);
                    }
                    grid.push(stringer);
                }
                return {
                    "bsurf": {
                        "points": grid,
                        "uKnots": surface.copyKnots(0, true),
                        "vKnots": surface.copyKnots(1, true),
                        "orderU": surface.orderUV(0),
                        "orderV": surface.orderUV(1),
                        "closedU": periodicU,
                        "closedV": periodicV,
                    },
                };
            }
            else {
                return {
                    "bsurf": {
                        "points": surface.getPointArray(false),
                        "uKnots": surface.copyKnots(0, true),
                        "vKnots": surface.copyKnots(1, true),
                        "orderU": surface.orderUV(0),
                        "orderV": surface.orderUV(1),
                    },
                };
            }
        }
        handleBezierCurve3dH(curve) {
            const knots = [];
            const order = curve.order;
            for (let i = 0; i < order; i++)
                knots.push(0.0);
            for (let i = 0; i < order; i++)
                knots.push(1.0);
            return {
                "bcurve": {
                    "points": curve.copyPolesAsJsonArray(),
                    "knots": knots,
                    "closed": false,
                    "order": curve.order,
                },
            };
        }
        handleBSplineSurface3dH(surface) {
            const data = surface.getPointGridJSON();
            return {
                "bsurf": {
                    "points": data.points,
                    "uKnots": surface.copyKnots(0, true),
                    "vKnots": surface.copyKnots(1, true),
                    "orderU": surface.orderUV(0),
                    "orderV": surface.orderUV(1),
                },
            };
        }
        emitArray(data) {
            const members = [];
            for (const c of data) {
                const toPush = this.emit(c);
                members.push(toPush);
            }
            return members;
        }
        emit(data) {
            if (Array.isArray(data))
                return this.emitArray(data);
            if (data instanceof GeometryQuery_1.GeometryQuery) {
                return data.dispatchToGeometryHandler(this);
            }
            return undefined;
        }
        /** One-step static method to create a writer and emit a json object */
        static toIModelJson(data) {
            const writer = new Writer();
            return writer.emit(data);
        }
    }
    IModelJson.Writer = Writer;
})(IModelJson = exports.IModelJson || (exports.IModelJson = {}));


/***/ }),

/***/ "./lib/solid/Box.js":
/*!**************************!*\
  !*** ./lib/solid/Box.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Solid */
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const SolidPrimitive_1 = __webpack_require__(/*! ./SolidPrimitive */ "./lib/solid/SolidPrimitive.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Loop_1 = __webpack_require__(/*! ../curve/Loop */ "./lib/curve/Loop.js");
const LineString3d_1 = __webpack_require__(/*! ../curve/LineString3d */ "./lib/curve/LineString3d.js");
/**
 */
class Box extends SolidPrimitive_1.SolidPrimitive {
    constructor(map, baseX, baseY, topX, topY, capped) {
        super(capped);
        this._localToWorld = map;
        this._baseX = baseX;
        this._baseY = baseY;
        this._topX = topX;
        this._topY = topY;
    }
    clone() {
        return new Box(this._localToWorld.clone(), this._baseX, this._baseY, this._topX, this._topY, this.capped);
    }
    /** Return a coordinate frame (right handed unit vectors)
     * * origin lower left of box
     * * x direction on base rectangle x edge
     * * y direction in base rectangle
     * * z direction perpenedicular
     */
    getConstructiveFrame() {
        return this._localToWorld.cloneRigid();
    }
    tryTransformInPlace(transform) {
        transform.multiplyTransformTransform(this._localToWorld, this._localToWorld);
        return true;
    }
    cloneTransformed(transform) {
        const result = this.clone();
        transform.multiplyTransformTransform(result._localToWorld, result._localToWorld);
        return result;
    }
    /**
     * @param baseOrigin Origin of base rectangle
     * @param vectorX  Direction for base rectangle
     * @param vectorY Direction for base rectangle
     * @param topOrigin origin of top rectangle
     * @param baseX size factor for base rectangle (multiplies vectorX)
     * @param baseY size factor for base rectangle (multiplies vectorY)
     * @param topX size factor for top rectangle (multiplies vectorX)
     * @param topY size factor for top rectangle (multiplies vectorY)
     * @param capped true to define top and bottom closure caps
     */
    static createDgnBox(baseOrigin, vectorX, vectorY, topOrigin, baseX, baseY, topX, topY, capped) {
        const vectorZ = baseOrigin.vectorTo(topOrigin);
        const localToWorld = Transform_1.Transform.createOriginAndMatrixColumns(baseOrigin, vectorX, vectorY, vectorZ);
        return new Box(localToWorld, baseX, baseY, topX, topY, capped);
    }
    /**
     * @param baseOrigin Origin of base rectangle
     * @param vectorX  Direction for base rectangle
     * @param vectorY Direction for base rectangle
     * @param topOrigin origin of top rectangle
     * @param baseX size factor for base rectangle (multiplies vectorX)
     * @param baseY size factor for base rectangle (multiplies vectorY)
     * @param topX size factor for top rectangle (multiplies vectorX)
     * @param topY size factor for top rectangle (multiplies vectorY)
     * @param capped true to define top and bottom closure caps
     */
    static createDgnBoxWithAxes(baseOrigin, axes, topOrigin, baseX, baseY, topX, topY, capped) {
        return Box.createDgnBox(baseOrigin, axes.columnX(), axes.columnY(), topOrigin, baseX, baseY, topX, topY, capped);
    }
    /**
     * @param range range corners Origin of base rectangle
     * @param capped true to define top and bottom closure caps
     */
    static createRange(range, capped) {
        if (!range.isNull) {
            const lowPoint = range.low;
            const xSize = range.xLength();
            const ySize = range.yLength();
            const zPoint = range.low.clone();
            zPoint.z = zPoint.z + range.zLength();
            return Box.createDgnBox(lowPoint, Point3dVector3d_1.Vector3d.unitX(), Point3dVector3d_1.Vector3d.unitY(), zPoint, xSize, ySize, xSize, ySize, capped);
        }
        return undefined;
    }
    getBaseX() { return this._baseX; }
    getBaseY() { return this._baseY; }
    getTopX() { return this._topX; }
    getTopY() { return this._topY; }
    getBaseOrigin() { return this._localToWorld.multiplyXYZ(0, 0, 0); }
    getTopOrigin() { return this._localToWorld.multiplyXYZ(0, 0, 1); }
    getVectorX() { return this._localToWorld.matrix.columnX(); }
    getVectorY() { return this._localToWorld.matrix.columnY(); }
    getVectorZ() { return this._localToWorld.matrix.columnZ(); }
    isSameGeometryClass(other) { return other instanceof Box; }
    isAlmostEqual(other) {
        if (other instanceof Box) {
            if (this.capped !== other.capped)
                return false;
            if (!this._localToWorld.isAlmostEqual(other._localToWorld))
                return false;
            return Geometry_1.Geometry.isSameCoordinate(this._baseX, other._baseX)
                && Geometry_1.Geometry.isSameCoordinate(this._baseY, other._baseY)
                && Geometry_1.Geometry.isSameCoordinate(this._topX, other._topX)
                && Geometry_1.Geometry.isSameCoordinate(this._topY, other._topY);
        }
        return false;
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleBox(this);
    }
    strokeConstantVSection(zFraction) {
        const ax = Geometry_1.Geometry.interpolate(this._baseX, zFraction, this._topX);
        const ay = Geometry_1.Geometry.interpolate(this._baseY, zFraction, this._topY);
        const result = LineString3d_1.LineString3d.create();
        const transform = this._localToWorld;
        const workPoint = Point3dVector3d_1.Point3d.create();
        transform.multiplyXYZ(0, 0, zFraction, workPoint);
        result.addPoint(workPoint);
        transform.multiplyXYZ(ax, 0, zFraction, workPoint);
        result.addPoint(workPoint);
        transform.multiplyXYZ(ax, ay, zFraction, workPoint);
        result.addPoint(workPoint);
        transform.multiplyXYZ(0, ay, zFraction, workPoint);
        result.addPoint(workPoint);
        transform.multiplyXYZ(0, 0, zFraction, workPoint);
        result.addPoint(workPoint);
        return result;
    }
    constantVSection(zFraction) {
        const ls = this.strokeConstantVSection(zFraction);
        return Loop_1.Loop.create(ls);
    }
    extendRange(range, transform) {
        const boxTransform = this._localToWorld;
        const ax = this._baseX;
        const ay = this._baseY;
        const bx = this._topX;
        const by = this._topY;
        if (transform) {
            range.extendTransformTransformedXYZ(transform, boxTransform, 0, 0, 0);
            range.extendTransformTransformedXYZ(transform, boxTransform, ax, 0, 0);
            range.extendTransformTransformedXYZ(transform, boxTransform, 0, ay, 0);
            range.extendTransformTransformedXYZ(transform, boxTransform, ax, ay, 0);
            range.extendTransformTransformedXYZ(transform, boxTransform, 0, 0, 1);
            range.extendTransformTransformedXYZ(transform, boxTransform, bx, 0, 1);
            range.extendTransformTransformedXYZ(transform, boxTransform, 0, by, 1);
            range.extendTransformTransformedXYZ(transform, boxTransform, bx, by, 1);
        }
        else {
            range.extendTransformedXYZ(boxTransform, 0, 0, 0);
            range.extendTransformedXYZ(boxTransform, ax, 0, 0);
            range.extendTransformedXYZ(boxTransform, 0, ay, 0);
            range.extendTransformedXYZ(boxTransform, ax, ay, 0);
            range.extendTransformedXYZ(boxTransform, 0, 0, 1);
            range.extendTransformedXYZ(boxTransform, bx, 0, 1);
            range.extendTransformedXYZ(boxTransform, 0, by, 1);
            range.extendTransformedXYZ(boxTransform, bx, by, 1);
        }
    }
}
exports.Box = Box;


/***/ }),

/***/ "./lib/solid/Cone.js":
/*!***************************!*\
  !*** ./lib/solid/Cone.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const Matrix3d_1 = __webpack_require__(/*! ../geometry3d/Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const SolidPrimitive_1 = __webpack_require__(/*! ./SolidPrimitive */ "./lib/solid/SolidPrimitive.js");
const StrokeOptions_1 = __webpack_require__(/*! ../curve/StrokeOptions */ "./lib/curve/StrokeOptions.js");
const Loop_1 = __webpack_require__(/*! ../curve/Loop */ "./lib/curve/Loop.js");
const Plane3dByOriginAndVectors_1 = __webpack_require__(/*! ../geometry3d/Plane3dByOriginAndVectors */ "./lib/geometry3d/Plane3dByOriginAndVectors.js");
const Arc3d_1 = __webpack_require__(/*! ../curve/Arc3d */ "./lib/curve/Arc3d.js");
const LineString3d_1 = __webpack_require__(/*! ../curve/LineString3d */ "./lib/curve/LineString3d.js");
/**
 * A cone with axis along the z axis of a (possibly skewed) local coordinate system.
 *
 * * In local coordinates, the sections at z=0 and z=1 are circles of radius r0 and r1.
 * * Either one individually  may be zero, but they may not both be zero.
 * * The stored matrix has unit vectors in the xy columns, and full-length z column.
 * *
 */
class Cone extends SolidPrimitive_1.SolidPrimitive {
    constructor(map, radiusA, radiusB, capped) {
        super(capped);
        this._localToWorld = map;
        this._radiusA = radiusA;
        this._radiusB = radiusB;
        this._maxRadius = Math.max(this._radiusA, this._radiusB); // um... should resolve elliptical sections
    }
    clone() {
        return new Cone(this._localToWorld.clone(), this._radiusA, this._radiusB, this.capped);
    }
    /** Return a coordinate frame (right handed unit vectors)
     * * origin at center of the base circle.
     * * base circle in the xy plane
     * * z axis by right hand rule.
     */
    getConstructiveFrame() {
        return this._localToWorld.cloneRigid();
    }
    tryTransformInPlace(transform) {
        transform.multiplyTransformTransform(this._localToWorld, this._localToWorld);
        return true;
    }
    cloneTransformed(transform) {
        const result = this.clone();
        transform.multiplyTransformTransform(result._localToWorld, result._localToWorld);
        return result;
    }
    /** create a cylinder or cone from two endpoints and their radii.   The circular cross sections are perpendicular to the axis line
     * from start to end point.
     */
    static createAxisPoints(centerA, centerB, radiusA, radiusB, capped) {
        const zDirection = centerA.vectorTo(centerB);
        const a = zDirection.magnitude();
        if (Geometry_1.Geometry.isSmallMetricDistance(a))
            return undefined;
        // force near-zero radii to true zero
        radiusA = Math.abs(Geometry_1.Geometry.correctSmallMetricDistance(radiusA));
        radiusB = Math.abs(Geometry_1.Geometry.correctSmallMetricDistance(radiusB));
        // cone tip may not be "within" the z range.
        if (radiusA * radiusB < 0.0)
            return undefined;
        // at least one must be nonzero.
        if (radiusA + radiusB === 0.0)
            return undefined;
        const matrix = Matrix3d_1.Matrix3d.createRigidHeadsUp(zDirection);
        matrix.scaleColumns(1.0, 1.0, a, matrix);
        const localToWorld = Transform_1.Transform.createOriginAndMatrix(centerA, matrix);
        return new Cone(localToWorld, radiusA, radiusB, capped);
    }
    /** create a cylinder or cone from axis start and end with cross section defined by vectors that do not need to be perpendicular to each other or
     * to the axis.
     */
    static createBaseAndTarget(centerA, centerB, vectorX, vectorY, radiusA, radiusB, capped) {
        radiusA = Math.abs(Geometry_1.Geometry.correctSmallMetricDistance(radiusA));
        radiusB = Math.abs(Geometry_1.Geometry.correctSmallMetricDistance(radiusB));
        const vectorZ = centerA.vectorTo(centerB);
        const localToWorld = Transform_1.Transform.createOriginAndMatrixColumns(centerA, vectorX, vectorY, vectorZ);
        return new Cone(localToWorld, radiusA, radiusB, capped);
    }
    getCenterA() { return this._localToWorld.multiplyXYZ(0, 0, 0); }
    getCenterB() { return this._localToWorld.multiplyXYZ(0, 0, 1); }
    getVectorX() { return this._localToWorld.matrix.columnX(); }
    getVectorY() { return this._localToWorld.matrix.columnY(); }
    getRadiusA() { return this._radiusA; }
    getRadiusB() { return this._radiusB; }
    getMaxRadius() { return this._maxRadius; }
    vFractionToRadius(v) { return Geometry_1.Geometry.interpolate(this._radiusA, v, this._radiusB); }
    isSameGeometryClass(other) { return other instanceof Cone; }
    isAlmostEqual(other) {
        if (other instanceof Cone) {
            if (this.capped !== other.capped)
                return false;
            if (!this._localToWorld.isAlmostEqual(other._localToWorld))
                return false;
            return Geometry_1.Geometry.isSameCoordinate(this._radiusA, other._radiusA)
                && Geometry_1.Geometry.isSameCoordinate(this._radiusB, other._radiusB);
        }
        return false;
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleCone(this);
    }
    /**
     *  return strokes for a cross-section (elliptic arc) at specified fraction v along the axis.
     * @param v fractional position along the cone axis
     * @param strokes stroke count or options.
     */
    strokeConstantVSection(v, strokes) {
        let strokeCount = 16;
        if (strokes === undefined) {
            // accept the default above.
        }
        else if (strokes instanceof Number) {
            strokeCount = strokes;
        }
        else if (strokes instanceof StrokeOptions_1.StrokeOptions) {
            strokeCount = strokes.defaultCircleStrokes; // NEEDS WORK -- get circle stroke count with this.maxRadius !!!
        }
        strokeCount = Geometry_1.Geometry.clampToStartEnd(strokeCount, 4, 64);
        const r = this.vFractionToRadius(v);
        const result = LineString3d_1.LineString3d.create();
        const deltaRadians = Math.PI * 2.0 / strokeCount;
        let radians = 0;
        const transform = this._localToWorld;
        for (let i = 0; i <= strokeCount; i++) {
            if (i * 2 <= strokeCount)
                radians = i * deltaRadians;
            else
                radians = (i - strokeCount) * deltaRadians;
            const xyz = transform.multiplyXYZ(r * Math.cos(radians), r * Math.sin(radians), v);
            result.addPoint(xyz);
        }
        return result;
    }
    /**
     * @returns Return the Arc3d section at vFraction
     * @param vFraction fractional position along the sweep direction
     */
    constantVSection(vFraction) {
        const r = this.vFractionToRadius(vFraction);
        const transform = this._localToWorld;
        const center = transform.multiplyXYZ(0, 0, vFraction);
        const vector0 = transform.matrix.multiplyXYZ(r, 0, 0);
        const vector90 = transform.matrix.multiplyXYZ(0, r, 0);
        return Loop_1.Loop.create(Arc3d_1.Arc3d.create(center, vector0, vector90));
    }
    extendRange(range, transform) {
        const arc0 = this.constantVSection(0.0);
        const arc1 = this.constantVSection(1.0);
        arc0.extendRange(range, transform);
        arc1.extendRange(range, transform);
    }
    UVFractionToPoint(uFraction, vFraction, result) {
        const theta = uFraction * Math.PI * 2.0;
        const r = Geometry_1.Geometry.interpolate(this._radiusA, vFraction, this._radiusB);
        const cosTheta = Math.cos(theta);
        const sinTheta = Math.sin(theta);
        return this._localToWorld.multiplyXYZ(r * cosTheta, r * sinTheta, vFraction, result);
    }
    UVFractionToPointAndTangents(uFraction, vFraction, result) {
        const theta = uFraction * Math.PI * 2.0;
        const r = Geometry_1.Geometry.interpolate(this._radiusA, vFraction, this._radiusB);
        const drdv = this._radiusB - this._radiusA;
        const cosTheta = Math.cos(theta);
        const sinTheta = Math.sin(theta);
        const fTheta = 2.0 * Math.PI;
        return Plane3dByOriginAndVectors_1.Plane3dByOriginAndVectors.createOriginAndVectors(this._localToWorld.multiplyXYZ(r * cosTheta, r * sinTheta, vFraction), this._localToWorld.multiplyVectorXYZ(-r * sinTheta * fTheta, r * cosTheta * fTheta, 0), this._localToWorld.multiplyVectorXYZ(drdv * cosTheta, drdv * sinTheta, 1.0), result);
    }
}
exports.Cone = Cone;


/***/ }),

/***/ "./lib/solid/LinearSweep.js":
/*!**********************************!*\
  !*** ./lib/solid/LinearSweep.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const Loop_1 = __webpack_require__(/*! ../curve/Loop */ "./lib/curve/Loop.js");
const Path_1 = __webpack_require__(/*! ../curve/Path */ "./lib/curve/Path.js");
const LineString3d_1 = __webpack_require__(/*! ../curve/LineString3d */ "./lib/curve/LineString3d.js");
const PointHelpers_1 = __webpack_require__(/*! ../geometry3d/PointHelpers */ "./lib/geometry3d/PointHelpers.js");
const SweepContour_1 = __webpack_require__(/*! ./SweepContour */ "./lib/solid/SweepContour.js");
const SolidPrimitive_1 = __webpack_require__(/*! ./SolidPrimitive */ "./lib/solid/SolidPrimitive.js");
/**
 * A LinearSweep is
 *
 * * A planar contour (any Loop, Path, or parityRegion)
 * * A sweep vector
 */
class LinearSweep extends SolidPrimitive_1.SolidPrimitive {
    constructor(contour, direction, capped) {
        super(capped);
        this._contour = contour;
        this._direction = direction;
    }
    static create(contour, direction, capped) {
        const sweepable = SweepContour_1.SweepContour.createForLinearSweep(contour, direction);
        if (!sweepable)
            return undefined;
        return new LinearSweep(sweepable, direction, capped);
    }
    /** Create a z-direction sweep of the polyline or polygon given as xy linestring values.
     * * If not capped, the xyPoints array is always used unchanged.
     * * If capped but the xyPoints array does not close, exact closure will be enforced by one of these:
     * * * If the final point is almost equal to the first, it is replaced by the exact first point.
     * * * if the final point is not close to the first an extra point is added.
     * * If capped, the point order will be reversed if necessary to produce positive volume.
     * @param xyPoints array of xy coordinates
     * @param z z value to be used for all coordinates
     * @param zSweep the sweep distance in the z direction.
     * @param capped true if caps are to be added.
     */
    static createZSweep(xyPoints, z, zSweep, capped) {
        const xyz = LineString3d_1.LineString3d.createXY(xyPoints, z, capped);
        if (capped) {
            const area = PointHelpers_1.PolygonOps.areaXY(xyz.points);
            if (area * zSweep < 0.0)
                xyz.points.reverse();
        }
        const contour = capped ? Loop_1.Loop.create(xyz) : Path_1.Path.create(xyz);
        return LinearSweep.create(contour, Point3dVector3d_1.Vector3d.create(0, 0, zSweep), capped);
    }
    getCurvesRef() { return this._contour.curves; }
    getSweepContourRef() { return this._contour; }
    cloneSweepVector() { return this._direction.clone(); }
    isSameGeometryClass(other) { return other instanceof LinearSweep; }
    clone() {
        return new LinearSweep(this._contour.clone(), this._direction.clone(), this.capped);
    }
    tryTransformInPlace(transform) {
        if (this._contour.tryTransformInPlace(transform)) {
            transform.multiplyVector(this._direction, this._direction);
        }
        return false;
    }
    /** Return a coordinate frame (right handed unit vectors)
     * * origin on base contour
     * * x, y directions from base contour.
     * * z direction perpenedicular
     */
    getConstructiveFrame() {
        return this._contour.localToWorld.cloneRigid();
    }
    cloneTransformed(transform) {
        const result = this.clone();
        result.tryTransformInPlace(transform);
        return result;
    }
    isAlmostEqual(other) {
        if (other instanceof LinearSweep) {
            return this._contour.isAlmostEqual(other._contour)
                && this._direction.isAlmostEqual(other._direction)
                && this.capped === other.capped;
        }
        return false;
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleLinearSweep(this);
    }
    /**
     * @returns Return the curves of a constant-v section of the solid.
     * @param vFraction fractional position along the sweep direction
     */
    constantVSection(vFraction) {
        const section = this._contour.curves.clone();
        if (section && vFraction !== 0.0)
            section.tryTransformInPlace(Transform_1.Transform.createTranslation(this._direction.scale(vFraction)));
        return section;
    }
    extendRange(range, transform) {
        const contourRange = this._contour.curves.range(transform);
        range.extendRange(contourRange);
        if (transform) {
            const transformedDirection = transform.multiplyVector(this._direction);
            contourRange.low.addInPlace(transformedDirection);
            contourRange.high.addInPlace(transformedDirection);
        }
        else {
            contourRange.low.addInPlace(this._direction);
            contourRange.high.addInPlace(this._direction);
        }
        range.extendRange(contourRange);
    }
}
exports.LinearSweep = LinearSweep;


/***/ }),

/***/ "./lib/solid/RotationalSweep.js":
/*!**************************************!*\
  !*** ./lib/solid/RotationalSweep.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const Matrix3d_1 = __webpack_require__(/*! ../geometry3d/Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Angle_1 = __webpack_require__(/*! ../geometry3d/Angle */ "./lib/geometry3d/Angle.js");
const SweepContour_1 = __webpack_require__(/*! ./SweepContour */ "./lib/solid/SweepContour.js");
const SolidPrimitive_1 = __webpack_require__(/*! ./SolidPrimitive */ "./lib/solid/SolidPrimitive.js");
class RotationalSweep extends SolidPrimitive_1.SolidPrimitive {
    constructor(contour, normalizedAxis, sweepAngle, capped) {
        super(capped);
        this._contour = contour;
        this._normalizedAxis = normalizedAxis;
        this.capped = capped;
        this._sweepAngle = sweepAngle;
    }
    static create(contour, axis, sweepAngle, capped) {
        if (!axis.direction.normalizeInPlace())
            return undefined;
        const sweepable = SweepContour_1.SweepContour.createForRotation(contour, axis);
        if (!sweepable)
            return undefined;
        return new RotationalSweep(sweepable, axis, sweepAngle.clone(), capped);
    }
    /** Return a coordinate frame (right handed unit vectors)
     * * origin at origin of rotation ray
     * * z direction along the rotation ray.
     * * y direction perpendicular to the base contour plane
     */
    getConstructiveFrame() {
        const contourPerpendicular = this._contour.localToWorld.matrix.columnZ();
        const axes = Matrix3d_1.Matrix3d.createRigidFromColumns(contourPerpendicular, this._normalizedAxis.direction, 1 /* YZX */);
        if (axes) {
            return Transform_1.Transform.createOriginAndMatrix(this._normalizedAxis.origin, axes);
        }
        return undefined;
    }
    cloneAxisRay() { return this._normalizedAxis.clone(); }
    getCurves() { return this._contour.curves; }
    getSweepContourRef() { return this._contour; }
    getSweep() { return this._sweepAngle.clone(); }
    isSameGeometryClass(other) { return other instanceof RotationalSweep; }
    isAlmostEqual(other) {
        if (other instanceof RotationalSweep) {
            return this._contour.isAlmostEqual(other._contour)
                && this._normalizedAxis.isAlmostEqual(other._normalizedAxis)
                && this.capped === other.capped;
        }
        return false;
    }
    clone() {
        return new RotationalSweep(this._contour.clone(), this._normalizedAxis.clone(), this._sweepAngle.clone(), this.capped);
    }
    tryTransformInPlace(transform) {
        if (this._contour.tryTransformInPlace(transform)) {
            this._normalizedAxis.transformInPlace(transform);
            return this._normalizedAxis.direction.normalizeInPlace();
        }
        return false;
    }
    cloneTransformed(transform) {
        const result = this.clone();
        result.tryTransformInPlace(transform);
        return result;
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleRotationalSweep(this);
    }
    getFractionalRotationTransform(vFraction, result) {
        const radians = this._sweepAngle.radians * vFraction;
        const rotation = Transform_1.Transform.createOriginAndMatrix(this._normalizedAxis.origin, Matrix3d_1.Matrix3d.createRotationAroundVector(this._normalizedAxis.direction, Angle_1.Angle.createRadians(radians), result ? result.matrix : undefined));
        return rotation;
    }
    /**
     * @returns Return the curves of a constant-v section of the solid.
     * @param vFraction fractional position along the sweep direction
     */
    constantVSection(vFraction) {
        const section = this._contour.curves.clone();
        if (section) {
            section.tryTransformInPlace(this.getFractionalRotationTransform(vFraction));
        }
        return section;
    }
    extendRange(range) {
        const strokes = this._contour.curves.cloneStroked();
        const numStep = Geometry_1.Geometry.stepCount(22.5, this._sweepAngle.degrees, 4, 16);
        for (let i = 0; i <= numStep; i++)
            strokes.extendRange(range, this.getFractionalRotationTransform(i / numStep));
    }
}
exports.RotationalSweep = RotationalSweep;


/***/ }),

/***/ "./lib/solid/RuledSweep.js":
/*!*********************************!*\
  !*** ./lib/solid/RuledSweep.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const CurveCollection_1 = __webpack_require__(/*! ../curve/CurveCollection */ "./lib/curve/CurveCollection.js");
const CurvePrimitive_1 = __webpack_require__(/*! ../curve/CurvePrimitive */ "./lib/curve/CurvePrimitive.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const SolidPrimitive_1 = __webpack_require__(/*! ./SolidPrimitive */ "./lib/solid/SolidPrimitive.js");
const SweepContour_1 = __webpack_require__(/*! ./SweepContour */ "./lib/solid/SweepContour.js");
const ConstructCurveBetweenCurves_1 = __webpack_require__(/*! ../curve/ConstructCurveBetweenCurves */ "./lib/curve/ConstructCurveBetweenCurves.js");
class RuledSweep extends SolidPrimitive_1.SolidPrimitive {
    constructor(contours, capped) {
        super(capped);
        this._contours = contours;
    }
    static create(contours, capped) {
        const sweepContours = [];
        for (const contour of contours) {
            const sweepable = SweepContour_1.SweepContour.createForLinearSweep(contour);
            if (sweepable === undefined)
                return undefined;
            sweepContours.push(sweepable);
        }
        return new RuledSweep(sweepContours, capped);
    }
    /** @returns Return a reference to the array of sweep contours. */
    sweepContoursRef() { return this._contours; }
    cloneSweepContours() {
        const result = [];
        for (const sweepable of this._contours) {
            result.push(sweepable.clone());
        }
        return result;
    }
    cloneContours() {
        const result = [];
        for (const sweepable of this._contours) {
            result.push(sweepable.curves.clone());
        }
        return result;
    }
    clone() {
        return new RuledSweep(this.cloneSweepContours(), this.capped);
    }
    tryTransformInPlace(transform) {
        for (const contour of this._contours) {
            contour.tryTransformInPlace(transform);
        }
        return true;
    }
    cloneTransformed(transform) {
        const result = this.clone();
        result.tryTransformInPlace(transform);
        return result;
    }
    /** Return a coordinate frame (right handed unit vectors)
     * * origin on base contour
     * * x, y directions from base contour.
     * * z direction perpenedicular
     */
    getConstructiveFrame() {
        if (this._contours.length === 0)
            return undefined;
        return this._contours[0].localToWorld.cloneRigid();
    }
    isSameGeometryClass(other) { return other instanceof RuledSweep; }
    isAlmostEqual(other) {
        if (other instanceof RuledSweep) {
            if (this.capped !== other.capped)
                return false;
            if (this._contours.length !== other._contours.length)
                return false;
            for (let i = 0; i < this._contours.length; i++) {
                if (!this._contours[i].isAlmostEqual(other._contours[i]))
                    return false;
            }
            return true;
        }
        return false;
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleRuledSweep(this);
    }
    /**
     * @returns Return the section curves at a fraction of the sweep
     * @param vFraction fractional position along the sweep direction
     */
    constantVSection(vFraction) {
        const numSection = this._contours.length;
        if (numSection < 2)
            return undefined;
        const q = vFraction * numSection;
        let section0 = 0;
        if (vFraction >= 1.0)
            section0 = numSection - 1;
        else
            section0 = Math.floor(q);
        if (section0 + 1 >= numSection)
            section0 = numSection - 2;
        const section1 = section0 + 1;
        const localFraction = Geometry_1.Geometry.clampToStartEnd(q - section0, 0, 1);
        return RuledSweep.mutatePartners(this._contours[section0].curves, this._contours[section1].curves, (primitive0, primitive1) => {
            const newPrimitive = ConstructCurveBetweenCurves_1.ConstructCurveBetweenCurves.InterpolateBetween(primitive0, localFraction, primitive1);
            if (newPrimitive instanceof CurvePrimitive_1.CurvePrimitive)
                return newPrimitive;
            return undefined;
        });
    }
    extendRange(rangeToExtend, transform) {
        for (const contour of this._contours)
            contour.curves.extendRange(rangeToExtend, transform);
    }
    /** Construct a CurveCollection with the same structure as collectionA and collectionB, with primitives constructed by the caller-supplied primitiveMutator function.
     * @returns Returns undefined if there is any type mismatch between the two collections.
     */
    static mutatePartners(collectionA, collectionB, primitiveMutator) {
        if (!collectionA.isSameGeometryClass(collectionB))
            return undefined;
        if (collectionA instanceof CurveCollection_1.CurveChain && collectionB instanceof CurveCollection_1.CurveChain) {
            const chainA = collectionA;
            const chainB = collectionB;
            const chainC = chainA.cloneEmptyPeer();
            const childrenA = chainA.children;
            const childrenB = chainB.children;
            if (childrenA.length !== childrenA.length)
                return undefined;
            for (let i = 0; i < childrenA.length; i++) {
                const newChild = primitiveMutator(childrenA[i], childrenB[i]);
                if (!newChild)
                    return undefined;
                chainC.children.push(newChild);
            }
            return chainC;
        }
        else if (collectionA instanceof CurveCollection_1.CurveCollection && collectionB instanceof CurveCollection_1.CurveCollection) {
            const collectionC = collectionA.cloneEmptyPeer();
            const childrenA = collectionA.children;
            const childrenB = collectionB.children;
            const childrenC = collectionC.children;
            if (!childrenA || !childrenB || !childrenC)
                return undefined;
            for (let i = 0; i < childrenA.length; i++) {
                const childA = childrenA[i];
                const childB = childrenB[i];
                if (childA instanceof CurvePrimitive_1.CurvePrimitive && childB instanceof CurvePrimitive_1.CurvePrimitive) {
                    const newPrimitive = primitiveMutator(childA, childB);
                    if (!newPrimitive)
                        return undefined;
                    childrenC.push(newPrimitive);
                }
                else if (childA instanceof CurveCollection_1.CurveCollection && childB instanceof CurveCollection_1.CurveCollection) {
                    const newChild = this.mutatePartners(childA, childB, primitiveMutator);
                    if (!newChild)
                        return undefined;
                    if (newChild instanceof CurveCollection_1.CurveCollection)
                        childrenC.push(newChild);
                }
            }
            return collectionC;
        }
        return undefined;
    }
}
exports.RuledSweep = RuledSweep;


/***/ }),

/***/ "./lib/solid/SolidPrimitive.js":
/*!*************************************!*\
  !*** ./lib/solid/SolidPrimitive.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const GeometryQuery_1 = __webpack_require__(/*! ../curve/GeometryQuery */ "./lib/curve/GeometryQuery.js");
/**
 * Base class for SolidPrimitve variants.
 *
 * * Base class holds capped flag for all derived classes.
 */
class SolidPrimitive extends GeometryQuery_1.GeometryQuery {
    constructor(capped) { super(); this._capped = capped; }
    /** Ask if this is a capped solid */
    get capped() { return this._capped; }
    /** Set the capped flag */
    set capped(capped) { this._capped = capped; }
}
exports.SolidPrimitive = SolidPrimitive;


/***/ }),

/***/ "./lib/solid/Sphere.js":
/*!*****************************!*\
  !*** ./lib/solid/Sphere.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const Matrix3d_1 = __webpack_require__(/*! ../geometry3d/Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const StrokeOptions_1 = __webpack_require__(/*! ../curve/StrokeOptions */ "./lib/curve/StrokeOptions.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const AngleSweep_1 = __webpack_require__(/*! ../geometry3d/AngleSweep */ "./lib/geometry3d/AngleSweep.js");
const SolidPrimitive_1 = __webpack_require__(/*! ./SolidPrimitive */ "./lib/solid/SolidPrimitive.js");
const Loop_1 = __webpack_require__(/*! ../curve/Loop */ "./lib/curve/Loop.js");
const Arc3d_1 = __webpack_require__(/*! ../curve/Arc3d */ "./lib/curve/Arc3d.js");
const LineString3d_1 = __webpack_require__(/*! ../curve/LineString3d */ "./lib/curve/LineString3d.js");
const Plane3dByOriginAndVectors_1 = __webpack_require__(/*! ../geometry3d/Plane3dByOriginAndVectors */ "./lib/geometry3d/Plane3dByOriginAndVectors.js");
/**
 * A Sphere is
 *
 * * A unit sphere (but read on ....)
 * * mapped by an arbitrary (possibly skewed, non-uniform scaled) transform
 * * hence possibly the final geometry is ellipsoidal
 */
class Sphere extends SolidPrimitive_1.SolidPrimitive {
    /** Return the latitude (in radians) all fractional v. */
    vFractionToRadians(v) {
        return this._latitudeSweep.fractionToRadians(v);
    }
    /** Return the longitude (in radians) all fractional u. */
    uFractionToRadians(u) {
        return u * Math.PI * 2.0;
    }
    constructor(localToWorld, latitudeSweep, capped) {
        super(capped);
        this._localToWorld = localToWorld;
        this._latitudeSweep = latitudeSweep ? latitudeSweep : AngleSweep_1.AngleSweep.createFullLatitude();
    }
    clone() {
        return new Sphere(this._localToWorld.clone(), this._latitudeSweep.clone(), this.capped);
    }
    tryTransformInPlace(transform) {
        transform.multiplyTransformTransform(this._localToWorld, this._localToWorld);
        return true;
    }
    cloneTransformed(transform) {
        const sphere1 = this.clone();
        transform.multiplyTransformTransform(sphere1._localToWorld, sphere1._localToWorld);
        return sphere1;
    }
    /** Return a coordinate frame (right handed, unit axes)
     * * origin at sphere center
     * * equator in xy plane
     * * z axis perpendicular
     */
    getConstructiveFrame() {
        return this._localToWorld.cloneRigid();
    }
    static createCenterRadius(center, radius, latitudeSweep) {
        const localToWorld = Transform_1.Transform.createOriginAndMatrix(center, Matrix3d_1.Matrix3d.createUniformScale(radius));
        return new Sphere(localToWorld, latitudeSweep ? latitudeSweep : AngleSweep_1.AngleSweep.createFullLatitude(), false);
    }
    /** Create an ellipsoid which is a unit sphere mapped to position by an (arbitrary, possibly skewed and scaled) transform. */
    static createEllipsoid(localToWorld, latitudeSweep, capped) {
        return new Sphere(localToWorld, latitudeSweep, capped);
    }
    /** Create a sphere from the typical parameters of the Dgn file */
    static createDgnSphere(center, vectorX, vectorZ, radiusXY, radiusZ, latitudeSweep, capped) {
        const vectorY = vectorX.rotate90Around(vectorZ);
        if (vectorY) {
            const matrix = Matrix3d_1.Matrix3d.createColumns(vectorX, vectorY, vectorZ);
            matrix.scaleColumns(radiusXY, radiusXY, radiusZ, matrix);
            const frame = Transform_1.Transform.createOriginAndMatrix(center, matrix);
            return new Sphere(frame, latitudeSweep.clone(), capped);
        }
        return undefined;
    }
    /** Create a sphere from the typical parameters of the Dgn file */
    static createFromAxesAndScales(center, axes, radiusX, radiusY, radiusZ, latitudeSweep, capped) {
        const localToWorld = Transform_1.Transform.createOriginAndMatrix(center, axes);
        localToWorld.matrix.scaleColumnsInPlace(radiusX, radiusY, radiusZ);
        return new Sphere(localToWorld, latitudeSweep ? latitudeSweep.clone() : AngleSweep_1.AngleSweep.createFullLatitude(), capped);
    }
    /** return (copy of) sphere center */
    cloneCenter() { return this._localToWorld.getOrigin(); }
    /** return the (full length, i.e. scaled by radius) X vector from the sphere transform */
    cloneVectorX() { return this._localToWorld.matrix.columnX(); }
    /** return the (full length, i.e. scaled by radius) Y vector from the sphere transform */
    cloneVectorY() { return this._localToWorld.matrix.columnY(); }
    /** return the (full length, i.e. scaled by radius) Z vector from the sphere transform */
    cloneVectorZ() { return this._localToWorld.matrix.columnZ(); }
    /** return (a copy of) the sphere's angle sweep. */
    cloneLatitudeSweep() { return this._latitudeSweep.clone(); }
    trueSphereRadius() {
        const factors = this._localToWorld.matrix.factorRigidWithSignedScale();
        if (!factors)
            return undefined;
        if (factors && factors.scale > 0)
            return factors.scale;
        return undefined;
    }
    /**
     * @returns Return a (clone of) the sphere's local to world transformation.
     */
    cloneLocalToWorld() { return this._localToWorld.clone(); }
    isSameGeometryClass(other) { return other instanceof Sphere; }
    isAlmostEqual(other) {
        if (other instanceof Sphere) {
            if (this.capped !== other.capped)
                return false;
            if (!this._localToWorld.isAlmostEqual(other._localToWorld))
                return false;
            return true;
        }
        return false;
    }
    /**
     *  return strokes for a cross-section (elliptic arc) at specified fraction v along the axis.
     * @param v fractional position along the cone axis
     * @param strokes stroke count or options.
     */
    strokeConstantVSection(v, strokes) {
        let strokeCount = 16;
        if (strokes === undefined) {
            // accept the default above.
        }
        else if (strokes instanceof Number) {
            strokeCount = strokes;
        }
        else if (strokes instanceof StrokeOptions_1.StrokeOptions) {
            strokeCount = strokes.defaultCircleStrokes; // NEEDS WORK -- get circle stroke count with this.maxRadius !!!
        }
        strokeCount = Geometry_1.Geometry.clampToStartEnd(strokeCount, 4, 64);
        const phi = this.vFractionToRadians(v);
        const c1 = Math.cos(phi);
        const s1 = Math.sin(phi);
        const result = LineString3d_1.LineString3d.create();
        const deltaRadians = Math.PI * 2.0 / strokeCount;
        let radians = 0;
        const transform = this._localToWorld;
        for (let i = 0; i <= strokeCount; i++) {
            if (i * 2 <= strokeCount)
                radians = i * deltaRadians;
            else
                radians = (i - strokeCount) * deltaRadians;
            const xyz = transform.multiplyXYZ(c1 * Math.cos(radians), c1 * Math.sin(radians), s1);
            result.addPoint(xyz);
        }
        return result;
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleSphere(this);
    }
    /**
     * @returns Return the Arc3d section at vFraction.  For the sphere, this is a latitude circle.
     * @param vFraction fractional position along the sweep direction
     */
    constantVSection(vFraction) {
        const phi = this._latitudeSweep.fractionToRadians(vFraction);
        const s1 = Math.sin(phi);
        const c1 = Math.cos(phi);
        const transform = this._localToWorld;
        const center = transform.multiplyXYZ(0, 0, s1);
        const vector0 = transform.matrix.multiplyXYZ(c1, 0, 0);
        const vector90 = transform.matrix.multiplyXYZ(0, c1, 0);
        return Loop_1.Loop.create(Arc3d_1.Arc3d.create(center, vector0, vector90));
    }
    extendRange(range, transform) {
        let placement = this._localToWorld;
        if (transform) {
            placement = transform.multiplyTransformTransform(placement);
        }
        range.extendTransformedXYZ(placement, -1, -1, -1);
        range.extendTransformedXYZ(placement, 1, -1, -1);
        range.extendTransformedXYZ(placement, -1, 1, -1);
        range.extendTransformedXYZ(placement, 1, 1, -1);
        range.extendTransformedXYZ(placement, -1, -1, 1);
        range.extendTransformedXYZ(placement, 1, -1, 1);
        range.extendTransformedXYZ(placement, -1, 1, 1);
        range.extendTransformedXYZ(placement, 1, 1, 1);
    }
    /** Evaluate as a uv surface
     * @param uFraction fractional position in minor (phi)
     * @param vFraction fractional position on major (theta) arc
     */
    UVFractionToPoint(uFraction, vFraction, result) {
        // sphere with radius 1 . . .
        const thetaRadians = this.uFractionToRadians(uFraction);
        const phiRadians = this.vFractionToRadians(vFraction);
        const cosTheta = Math.cos(thetaRadians);
        const sinTheta = Math.sin(thetaRadians);
        const sinPhi = Math.sin(phiRadians);
        const cosPhi = Math.cos(phiRadians);
        return this._localToWorld.multiplyXYZ(cosTheta * cosPhi, sinTheta * cosPhi, sinPhi, result);
    }
    /** Evaluate as a uv surface, returning point and two vectors.
     * @param u fractional position in minor (phi)
     * @param v fractional position on major (theta) arc
     */
    UVFractionToPointAndTangents(uFraction, vFraction, result) {
        const thetaRadians = this.uFractionToRadians(uFraction);
        const phiRadians = this.vFractionToRadians(vFraction);
        const fTheta = Math.PI * 2.0;
        const fPhi = this._latitudeSweep.sweepRadians;
        const cosTheta = Math.cos(thetaRadians);
        const sinTheta = Math.sin(thetaRadians);
        const sinPhi = Math.sin(phiRadians);
        const cosPhi = Math.cos(phiRadians);
        return Plane3dByOriginAndVectors_1.Plane3dByOriginAndVectors.createOriginAndVectors(this._localToWorld.multiplyXYZ(cosTheta * cosPhi, sinTheta * cosPhi, sinPhi), this._localToWorld.multiplyVectorXYZ(-fTheta * sinTheta * cosPhi, fTheta * cosTheta * cosPhi, 0), this._localToWorld.multiplyVectorXYZ(-fPhi * cosTheta * sinPhi, -fPhi * sinTheta, fPhi * cosPhi), result);
    }
}
exports.Sphere = Sphere;


/***/ }),

/***/ "./lib/solid/SweepContour.js":
/*!***********************************!*\
  !*** ./lib/solid/SweepContour.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const FrameBuilder_1 = __webpack_require__(/*! ../geometry3d/FrameBuilder */ "./lib/geometry3d/FrameBuilder.js");
const PolyfaceBuilder_1 = __webpack_require__(/*! ../polyface/PolyfaceBuilder */ "./lib/polyface/PolyfaceBuilder.js");
const Triangulation_1 = __webpack_require__(/*! ../topology/Triangulation */ "./lib/topology/Triangulation.js");
const LineString3d_1 = __webpack_require__(/*! ../curve/LineString3d */ "./lib/curve/LineString3d.js");
const ParityRegion_1 = __webpack_require__(/*! ../curve/ParityRegion */ "./lib/curve/ParityRegion.js");
const Loop_1 = __webpack_require__(/*! ../curve/Loop */ "./lib/curve/Loop.js");
const PointHelpers_1 = __webpack_require__(/*! ../geometry3d/PointHelpers */ "./lib/geometry3d/PointHelpers.js");
/**
 * Sweepable contour with Transform for local to world interaction.
 */
class SweepContour {
    constructor(contour, map) {
        this.curves = contour;
        this.localToWorld = map;
    }
    static createForLinearSweep(contour, defaultNormal) {
        const localToWorld = FrameBuilder_1.FrameBuilder.createRightHandedFrame(defaultNormal, contour);
        if (localToWorld) {
            return new SweepContour(contour, localToWorld);
        }
        return undefined;
    }
    static createForRotation(contour, axis) {
        // createRightHandedFrame -- the axis is a last-gasp resolver for in-plane vectors.
        const localToWorld = FrameBuilder_1.FrameBuilder.createRightHandedFrame(undefined, contour, axis);
        if (localToWorld) {
            return new SweepContour(contour, localToWorld);
        }
        return undefined;
    }
    getCurves() { return this.curves; }
    tryTransformInPlace(transform) {
        transform.multiplyTransformTransform(this.localToWorld, this.localToWorld);
        return true;
    }
    clone() {
        return new SweepContour(this.curves.clone(), this.localToWorld.clone());
    }
    cloneTransformed(transform) {
        const newContour = this.clone();
        if (newContour.tryTransformInPlace(transform))
            return newContour;
        return undefined;
    }
    isAlmostEqual(other) {
        if (other instanceof SweepContour) {
            return this.curves.isAlmostEqual(other.curves) && this.localToWorld.isAlmostEqual(other.localToWorld);
        }
        return false;
    }
    /**
     * build the (cached) internal facets.
     * @param _builder (NOT USED -- an internal builder is constructed for the triangulation)
     * @param options options for stroking the curves.
     */
    buildFacets(_builder, options) {
        if (!this._facets) {
            if (this.curves instanceof Loop_1.Loop) {
                this._xyStrokes = this.curves.cloneStroked(options);
                if (this._xyStrokes instanceof Loop_1.Loop && this._xyStrokes.children.length === 1) {
                    const children = this._xyStrokes.children;
                    const linestring = children[0];
                    const points = linestring.points;
                    this.localToWorld.multiplyInversePoint3dArrayInPlace(points);
                    if (PointHelpers_1.PolygonOps.sumTriangleAreasXY(points) < 0)
                        points.reverse();
                    const graph = Triangulation_1.Triangulator.earcutSingleLoop(points);
                    const unflippedPoly = PolyfaceBuilder_1.PolyfaceBuilder.graphToPolyface(graph, options);
                    this._facets = unflippedPoly;
                    this._facets.tryTransformInPlace(this.localToWorld);
                }
            }
            else if (this.curves instanceof ParityRegion_1.ParityRegion) {
                this._xyStrokes = this.curves.cloneStroked(options);
                if (this._xyStrokes instanceof (ParityRegion_1.ParityRegion)) {
                    this._xyStrokes.tryTransformInPlace(this.localToWorld);
                    const strokes = [];
                    for (const childLoop of this._xyStrokes.children) {
                        const loopCurves = childLoop.children;
                        if (loopCurves.length === 1) {
                            const c = loopCurves[0];
                            if (c instanceof LineString3d_1.LineString3d)
                                strokes.push(c.packedPoints);
                        }
                    }
                    const graph = Triangulation_1.Triangulator.triangulateStrokedLoops(strokes);
                    if (graph) {
                        const unflippedPoly = PolyfaceBuilder_1.PolyfaceBuilder.graphToPolyface(graph, options);
                        this._facets = unflippedPoly;
                        this._facets.tryTransformInPlace(this.localToWorld);
                    }
                }
            }
        }
    }
    /** Emit facets to a builder.
     * This method may cache and reuse facets over multiple calls.
     */
    emitFacets(builder, reverse, transform) {
        this.buildFacets(builder, builder.options);
        if (this._facets)
            builder.addIndexedPolyface(this._facets, reverse, transform);
    }
}
exports.SweepContour = SweepContour;


/***/ }),

/***/ "./lib/solid/TorusPipe.js":
/*!********************************!*\
  !*** ./lib/solid/TorusPipe.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const AngleSweep_1 = __webpack_require__(/*! ../geometry3d/AngleSweep */ "./lib/geometry3d/AngleSweep.js");
const SolidPrimitive_1 = __webpack_require__(/*! ./SolidPrimitive */ "./lib/solid/SolidPrimitive.js");
const Loop_1 = __webpack_require__(/*! ../curve/Loop */ "./lib/curve/Loop.js");
const Path_1 = __webpack_require__(/*! ../curve/Path */ "./lib/curve/Path.js");
const Arc3d_1 = __webpack_require__(/*! ../curve/Arc3d */ "./lib/curve/Arc3d.js");
const Plane3dByOriginAndVectors_1 = __webpack_require__(/*! ../geometry3d/Plane3dByOriginAndVectors */ "./lib/geometry3d/Plane3dByOriginAndVectors.js");
/**
 * the stored form of the torus pipe is oriented for positive volume:
 *
 * * Both radii are positive, with r0 >= r1 > 0
 * * The sweep is positive
 * * The coordinate system has positive determinant.
 */
class TorusPipe extends SolidPrimitive_1.SolidPrimitive {
    constructor(map, radiusA, radiusB, sweep, capped) {
        super(capped);
        this._localToWorld = map;
        this._radiusA = radiusA;
        this._radiusB = radiusB;
        this._sweep = sweep;
        this._isReversed = false;
    }
    clone() {
        const result = new TorusPipe(this._localToWorld.clone(), this._radiusA, this._radiusB, this._sweep.clone(), this.capped);
        result._isReversed = this._isReversed;
        return result;
    }
    tryTransformInPlace(transform) {
        transform.multiplyTransformTransform(this._localToWorld, this._localToWorld);
        return true;
    }
    cloneTransformed(transform) {
        const result = this.clone();
        transform.multiplyTransformTransform(result._localToWorld, result._localToWorld);
        return result;
    }
    static createInFrame(frame, majorRadius, minorRadius, sweep, capped) {
        // force near-zero radii to true zero
        majorRadius = Math.abs(Geometry_1.Geometry.correctSmallMetricDistance(majorRadius));
        minorRadius = Math.abs(Geometry_1.Geometry.correctSmallMetricDistance(minorRadius));
        if (majorRadius < minorRadius)
            return undefined;
        if (majorRadius === 0.0)
            return undefined;
        if (minorRadius === 0.0)
            return undefined;
        if (sweep.isAlmostZero)
            return undefined;
        const xScale = 1.0;
        let yScale = 1.0;
        let zScale = 1.0;
        if (frame.matrix.determinant() < 0.0)
            zScale *= -1.0;
        let isReversed = false;
        const sweep1 = sweep.clone();
        if (sweep.radians < 0.0) {
            sweep1.setRadians(-sweep.radians);
            zScale *= -1.0;
            yScale *= -1.0;
            isReversed = true;
        }
        const frame1 = frame.clone();
        frame1.matrix.scaleColumns(xScale, yScale, zScale, frame1.matrix);
        const result = new TorusPipe(frame1, majorRadius, minorRadius, sweep1, capped);
        result._isReversed = isReversed;
        return result;
    }
    /** Create a TorusPipe from the typical parameters of the Dgn file */
    static createDgnTorusPipe(center, vectorX, vectorY, majorRadius, minorRadius, sweep, capped) {
        const vectorZ = vectorX.crossProduct(vectorY);
        vectorZ.scaleToLength(vectorX.magnitude(), vectorZ);
        const frame = Transform_1.Transform.createOriginAndMatrixColumns(center, vectorX, vectorY, vectorZ);
        return TorusPipe.createInFrame(frame, majorRadius, minorRadius, sweep, capped);
    }
    /** Return a coordinate frame (right handed, unit axes)
     * * origin at center of major circle
     * * major circle in xy plane
     * * z axis perpendicular
     */
    getConstructiveFrame() {
        return this._localToWorld.cloneRigid();
    }
    cloneCenter() { return this._localToWorld.getOrigin(); }
    cloneVectorX() { return this._localToWorld.matrix.columnX(); }
    cloneVectorY() { return this._localToWorld.matrix.columnY(); }
    getMinorRadius() { return this._radiusB; }
    getMajorRadius() { return this._radiusA; }
    getSweepAngle() { return this._sweep.clone(); }
    getIsReversed() { return this._isReversed; }
    getThetaFraction() { return this._sweep.radians / (Math.PI * 2.0); }
    isSameGeometryClass(other) { return other instanceof TorusPipe; }
    isAlmostEqual(other) {
        if (other instanceof TorusPipe) {
            if (this.capped !== other.capped)
                return false;
            if (!this._localToWorld.isAlmostEqual(other._localToWorld))
                return false;
            return Geometry_1.Geometry.isSameCoordinate(this._radiusA, other._radiusA)
                && Geometry_1.Geometry.isSameCoordinate(this._radiusB, other._radiusB)
                && this._sweep.isAlmostEqualNoPeriodShift(other._sweep);
        }
        return false;
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleTorusPipe(this);
    }
    /**
     * @returns Return the Arc3d section at vFraction.  For the TorusPipe, this is a minor circle.
     * @param vFraction fractional position along the sweep direction
     */
    constantVSection(vFraction) {
        const thetaRadians = this._sweep.radians * vFraction;
        const c0 = Math.cos(thetaRadians);
        const s0 = Math.sin(thetaRadians);
        const majorRadius = this.getMajorRadius();
        const minorRadius = this.getMinorRadius();
        const center = this._localToWorld.multiplyXYZ(majorRadius * c0, majorRadius * s0, 0);
        const vector0 = this._localToWorld.multiplyVectorXYZ(minorRadius * c0, minorRadius * s0, 0);
        const vector90 = this._localToWorld.multiplyVectorXYZ(0, 0, minorRadius);
        return Loop_1.Loop.create(Arc3d_1.Arc3d.create(center, vector0, vector90));
    }
    constantUSection(uFraction) {
        const theta1Radians = this._sweep.radians;
        const phiRadians = uFraction * Math.PI;
        const majorRadius = this.getMajorRadius();
        const minorRadius = this.getMinorRadius();
        const transform = this._localToWorld;
        const axes = transform.matrix;
        const center = this._localToWorld.multiplyXYZ(0, 0, minorRadius * Math.sin(phiRadians));
        const rxy = majorRadius + minorRadius * Math.cos(phiRadians);
        const vector0 = axes.multiplyXYZ(rxy, 0, 0);
        const vector90 = axes.multiplyXYZ(0, rxy, 0);
        return Path_1.Path.create(Arc3d_1.Arc3d.create(center, vector0, vector90, AngleSweep_1.AngleSweep.createStartEndRadians(0.0, theta1Radians)));
    }
    extendRange(range, transform) {
        const theta1Radians = this._sweep.radians;
        const majorRadius = this.getMajorRadius();
        const minorRadius = this.getMinorRadius();
        const transform0 = this._localToWorld;
        const numThetaSample = Math.ceil(theta1Radians / (Math.PI * 0.125));
        const numHalfPhiSample = 8;
        let phi0 = 0;
        let dphi = 0;
        let numPhiSample = 0;
        let theta = 0;
        let cosTheta = 0;
        let sinTheta = 0;
        let rxy = 0;
        let phi = 0;
        let j = 0;
        const dTheta = theta1Radians / numThetaSample;
        for (let i = 0; i <= numThetaSample; i++) {
            theta = i * dTheta;
            cosTheta = Math.cos(theta);
            sinTheta = Math.sin(theta);
            // At the ends, do the entire phi circle.
            // Otherwise only do the outer half
            if (i === 0 || i === numThetaSample) {
                phi0 = -Math.PI;
                dphi = 2.0 * Math.PI / numHalfPhiSample;
                numPhiSample = numHalfPhiSample;
            }
            else {
                phi0 = -0.5 * Math.PI;
                dphi = Math.PI / numHalfPhiSample;
                numPhiSample = 2 * numHalfPhiSample - 1;
            }
            if (transform) {
                for (j = 0; j <= numPhiSample; j++) {
                    phi = phi0 + j * dphi;
                    rxy = majorRadius + minorRadius * Math.cos(phi);
                    range.extendTransformTransformedXYZ(transform, transform0, cosTheta * rxy, sinTheta * rxy, Math.sin(phi) * minorRadius);
                }
            }
            else {
                for (j = 0; j <= numPhiSample; j++) {
                    phi = phi0 + j * dphi;
                    rxy = majorRadius + minorRadius * Math.sin(phi);
                    range.extendTransformedXYZ(transform0, cosTheta * rxy, sinTheta * rxy, Math.sin(phi) * minorRadius);
                }
            }
        }
    }
    /** Evaluate as a uv surface
     * @param u fractional position in minor (phi)
     * @param v fractional position on major (theta) arc
     */
    UVFractionToPoint(u, v, result) {
        const thetaRadians = v * this._sweep.radians;
        const phiRadians = u * Math.PI * 2.0;
        const cosTheta = Math.cos(thetaRadians);
        const sinTheta = Math.sin(thetaRadians);
        const minorRadius = this.getMinorRadius();
        const rxy = this.getMajorRadius() + Math.cos(phiRadians) * minorRadius;
        return this._localToWorld.multiplyXYZ(rxy * cosTheta, rxy * sinTheta, minorRadius * Math.sin(phiRadians), result);
    }
    /** Evaluate as a uv surface, returning point and two vectors.
     * @param u fractional position in minor (phi)
     * @param v fractional position on major (theta) arc
     */
    UVFractionToPointAndTangents(u, v, result) {
        const thetaRadians = v * this._sweep.radians;
        const phiRadians = u * Math.PI * 2.0;
        const fTheta = this._sweep.radians;
        const fPhi = Math.PI * 2.0;
        const cosTheta = Math.cos(thetaRadians);
        const sinTheta = Math.sin(thetaRadians);
        const sinPhi = Math.sin(phiRadians);
        const cosPhi = Math.cos(phiRadians);
        const minorRadius = this.getMinorRadius();
        const rxy = this.getMajorRadius() + Math.cos(phiRadians) * minorRadius;
        const rSinPhi = minorRadius * sinPhi;
        const rCosPhi = minorRadius * cosPhi; // appears only as derivative of rSinPhi.
        return Plane3dByOriginAndVectors_1.Plane3dByOriginAndVectors.createOriginAndVectors(this._localToWorld.multiplyXYZ(cosTheta * rxy, sinTheta * rxy, rSinPhi), this._localToWorld.multiplyVectorXYZ(-rxy * sinTheta * fTheta, rxy * cosTheta * fTheta, 0), this._localToWorld.multiplyVectorXYZ(-cosTheta * rSinPhi * fPhi, -sinTheta * rSinPhi * fPhi, rCosPhi * fPhi), result);
    }
}
exports.TorusPipe = TorusPipe;


/***/ }),

/***/ "./lib/topology/Graph.js":
/*!*******************************!*\
  !*** ./lib/topology/Graph.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Topology */
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const LineSegment3d_1 = __webpack_require__(/*! ../curve/LineSegment3d */ "./lib/curve/LineSegment3d.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
/**
 *
 * * A HalfEdge is "one side of an edge" in a structure of faces, edges and vertices.  From a node there are navigational links to:
 * ** "faceSuccessor" -- the next half edge in a loop around a face.
 * ** "facePredecessor" -- the previous half edge in a loop around a face.
 * ** "edgeMate"  -- the node's partner on the other side of the edge.
 * * The next, prev, and mate are the essential connectivity.  Additional node content is for application-specific
 *     uses.  The most useful ones are:
 * ** x,y -- coordinates in the xy plane
 * ** z -- z coordinate.  This is normally ignored during planar setup, but used for output.
 * ** buffer -- a integer value manipulated as individual bits.
 * * In properly connected planar graph, interior face loops are counterclockwise.  But that property (along with
 *      expected masking) is a result of extensive validation of inputs, and is not true in intermediate phases
 *      of graph manipulation.
 */
class HalfEdge {
    constructor(x = 0, y = 0, z = 0, i = 0) {
        this._id = HalfEdge._totalNodesCreated++;
        this.i = i;
        this.maskBits = 0x00000000;
        this.x = x;
        this.y = y;
        this.z = z;
        this.steiner = false;
        // Other variables are by default undefined
    }
    get id() { return this._id; }
    /** previous half edge "around the face"
     */
    get facePredecessor() { return this._facePredecessor; }
    /** next half edge "around the face" */
    get faceSuccessor() { return this._faceSuccessor; }
    /** Half edge on the other side of this edge.
     */
    get edgeMate() { return this._edgeMate; }
    /**
     * * Create 2 half edges.
     * * The two edges are joined as edgeMate pair.
     * * The two edges are a 2-half-edge face loop in both the faceSuccessor and facePredecessor directions.
     * @returns Returns the reference to the first half edge created
     */
    static createHalfEdgePair(heArray) {
        const a = new HalfEdge();
        const b = new HalfEdge();
        if (heArray) {
            heArray.push(a);
            heArray.push(b);
        }
        HalfEdge.setFaceLinks(a, b);
        HalfEdge.setFaceLinks(b, a);
        HalfEdge.setEdgeMates(a, b);
        return a;
    }
    /**
     * * Create 2 half edges.
     * * The two edges are joined as edgeMate pair.
     * * The two edges are a 2-half-edge face loop in both the faceSuccessor and facePredecessor directions.
     * * Properties x,y,z,i are inserted in each
     * @returns Returns the reference to the first half edge created
     */
    static createHalfEdgePairWithCoordinates(xA = 0, yA = 0, zA = 0, iA = 0, xB = 0, yB = 0, zB = 0, iB = 0, heArray) {
        const a = HalfEdge.createHalfEdgePair(heArray);
        const b = a._edgeMate;
        a.x = xA;
        a.y = yA;
        a.z = zA;
        a.i = iA;
        b.x = xB;
        b.y = yB;
        b.z = zB;
        b.i = iB;
        return a;
    }
    /**
     * * set heA <==> heB pointer relation through heA._faceSuccessor and heB._facePredecessor
     * * This changes heA._faceSuccessor and heB._facePredecessor, but not heA._facePredecessor and heB._faceSuccessor.
     * * this must always be done with another call to restablish the entire double-linked list.
     */
    static setFaceLinks(heA, heB) {
        heA._faceSuccessor = heB;
        heB._facePredecessor = heA;
    }
    /**
     * * set heA <==> heB pointer relation edgeMate
     */
    static setEdgeMates(heA, heB) {
        heA._edgeMate = heB;
        heB._edgeMate = heA;
    }
    /**
     * * Create a new vertex within the edge from base.
     * * Insert it "within" the base edge.
     * * This requires two new half edges.
     * * if the base is undefined, create a single-edge loop.
     * * This (unlike pinch) breaks the edgeMate pairing of the base edge.
     * * This preserves xyzi properties at all existing vertices.
     * @returns Returns the reference to the half edge created.
     */
    static splitEdge(base, xA = 0, yA = 0, zA = 0, iA = 0, heArray) {
        const newA = new HalfEdge(xA, yA, zA, iA);
        const newB = new HalfEdge(xA, yA, zA, iA);
        if (heArray) {
            heArray.push(newA);
            heArray.push(newB);
        }
        if (base === undefined) {
            newA._faceSuccessor = newA._facePredecessor = newA;
            newB._faceSuccessor = newB._facePredecessor = newB;
            HalfEdge.setEdgeMates(newA, newB);
        }
        else {
            const nextA = base._faceSuccessor;
            const mateA = base._edgeMate;
            const vpredA = mateA._faceSuccessor;
            HalfEdge.setFaceLinks(newA, nextA);
            HalfEdge.setFaceLinks(base, newA);
            HalfEdge.setFaceLinks(mateA, newB);
            HalfEdge.setFaceLinks(newB, vpredA);
            HalfEdge.setEdgeMates(newA, mateA);
            HalfEdge.setEdgeMates(newB, base);
        }
        return newA;
    }
    /**
     * @returns Return the next outbound half edge around this vertex in the CCW direction
     */
    get vertexSuccessor() { return this.facePredecessor.edgeMate; }
    /**
     * @returns Return the next outbound half edge around this vertex in the CW direction
     */
    get vertexPredecessor() { return this.edgeMate.faceSuccessor; }
    /**
     * Set mask bits on this HalfEdge
     * @param mask mask to apply
     */
    setMask(mask) { this.maskBits |= mask; }
    /**
     * Get mask bits from this HalfEdge
     * @param mask mask to query
     */
    getMask(mask) { return (this.maskBits & mask); }
    /**
     * Clear mask bits from this HalfEdge
     * @param mask mask to clear
     */
    clearMask(mask) { this.maskBits &= ~mask; }
    /**
     *
     * @param mask mask to apply to the half edges around this HalfEdge's vertex loop
     */
    setMaskAroundVertex(mask) {
        let node = this;
        do {
            node.setMask(mask);
            node = node.vertexSuccessor;
        } while (node !== this);
    }
    /**
     *
     * @param mask mask to apply to the half edges around this HalfEdge's face loop
     */
    setMaskAroundFace(mask) {
        let node = this;
        do {
            node.setMask(mask);
            node = node.faceSuccessor;
        } while (node !== this);
    }
    /**
     * @returns Returns the number of edges around this face.
     */
    countEdgesAroundFace() {
        let count = 0;
        let node = this;
        do {
            count++;
            node = node.faceSuccessor;
        } while (node !== this);
        return count;
    }
    /**
     * @returns Returns the number of edges around vertex.
     */
    countEdgesAroundVertex() {
        let count = 0;
        let node = this;
        do {
            count++;
            node = node.vertexSuccessor;
        } while (node !== this);
        return count;
    }
    /**
     * @returns Returns the number of nodes found with the given mask value around this vertex loop.
     */
    countMaskAroundFace(mask, value = true) {
        let count = 0;
        let node = this;
        if (value) {
            do {
                if (node.isMaskSet(mask))
                    count++;
                node = node.faceSuccessor;
            } while (node !== this);
        }
        else {
            do {
                if (!node.isMaskSet(mask))
                    count++;
                node = node.faceSuccessor;
            } while (node !== this);
        }
        return count;
    }
    /**
     * @returns Returns the number of nodes found with the given mask value around this vertex loop.
     */
    countMaskAroundVertex(mask, value = true) {
        let count = 0;
        let node = this;
        if (value) {
            do {
                if (node.isMaskSet(mask))
                    count++;
                node = node.vertexSuccessor;
            } while (node !== this);
        }
        else {
            do {
                if (!node.isMaskSet(mask))
                    count++;
                node = node.vertexSuccessor;
            } while (node !== this);
        }
        return count;
    }
    /**
     * @returns the mask value prior to the call to this method.
     * @param mask mask to apply
     */
    testAndSetMask(mask) {
        const oldMask = this.maskBits & mask;
        this.maskBits |= mask;
        return oldMask;
    }
    /**
     * Test if mask bits are set in the node's bitMask.
     * @return Return true (as a simple boolean, not a mask) if any bits of the mask parameter match bits of the node's bitMask
     */
    isMaskSet(mask) { return (this.maskBits & mask) !== 0; }
    /** (static!) method to test if a mask is set on a node.
     * This is used as filter in searches.
     * @returns true iff `node.isMaskSet (mask)`
     */
    static filterIsMaskOn(node, mask) {
        return node.isMaskSet(mask);
    }
    /** (static!) method to test if a mask is set on a node.
     * This is used as filter in searches.
     * @returns true iff `!node.isMaskSet (mask)`
     */
    static filterIsMaskOff(node, mask) {
        return !node.isMaskSet(mask);
    }
    /**
     * @param id0 id for first node
     * @param x0  x coordinate for first node
     * @param y0  y coordinate for first node
     * @param id1 id for second node
     * @param x1 x coordinate for second node
     * @param y1 y coordinate for second node
     */
    static createEdgeXYXY(id0, x0, y0, id1, x1, y1) {
        const node0 = new HalfEdge(x0, y0);
        const node1 = new HalfEdge(x1, y1);
        node0._faceSuccessor = node0._facePredecessor = node0._edgeMate = node1;
        node1._faceSuccessor = node1._facePredecessor = node1._edgeMate = node0;
        node0._id = id0;
        node1._id = id1;
        return node0;
    }
    /** "pinch" ...
     *
     * * is the universal manipulator for manipulating a node's next and prev pointers
     * * swaps face precessors of nodeA and nodeB.
     * *  is its own inverse.
     * *  does nothing if either node does not have a predecessor (this is obviously a logic error in the caller algorithm)
     * *  if nodeA, nodeB are in different face loops, the loops join to one loop.
     * *  if nodeA, nodeB are in the same face loop, the loop splits into two loops.
     */
    static pinch(nodeA, nodeB) {
        const predA = nodeA._facePredecessor;
        const predB = nodeB._facePredecessor;
        if (predA && predB) {
            nodeB._facePredecessor = predA;
            nodeA._facePredecessor = predB;
            predB._faceSuccessor = nodeA;
            predA._faceSuccessor = nodeB;
        }
    }
    /** Turn all pointers to undefined so garbage collector can reuse the object.
     *  This is to be called only by a Graph object that is being decomissioned.
     */
    decomission() {
        this._facePredecessor = undefined;
        this._faceSuccessor = undefined;
        this._edgeMate = undefined;
        this.nextZ = undefined;
        this.prevZ = undefined;
    }
    /** @returns Return the node. This identity function is useful as the NodeFunction in collector methods. */
    static nodeToSelf(node) { return node; }
    /** @returns Return the id of a node.  Useful for collector methods. */
    static nodeToId(node) { return node.id; }
    /** @returns Return the id of a node.Useful for collector methods. */
    static nodeToIdString(node) { return node.id.toString(); }
    /** @returns Return the [id, [x,y]] of a node.  Useful for collector methods. */
    static nodeToIdMaskXY(node) {
        return { id: node.id, mask: HalfEdge.nodeToMaskString(node), xy: [node.x, node.y] };
    }
    /** @returns Return the [id, [x,y]] of a node.  Useful for collector methods. */
    static nodeToIdXYString(node) {
        const s = node.id.toString() + " " +
            HalfEdge.nodeToMaskString(node) + " [" + node.x + "," + node.y + "]";
        return s;
    }
    /**  */
    static nodeToMaskString(node) {
        let s = "";
        if (node.isMaskSet(2 /* BOUNDARY */))
            s += "B";
        if (node.isMaskSet(512 /* PRIMARY_EDGE */))
            s += "P";
        if (node.isMaskSet(1 /* EXTERIOR */))
            s += "X";
        return s;
    }
    /** @returns Return [x,y] with coordinates of node */
    static nodeToXY(node) { return [node.x, node.y]; }
    /** @returns Return Vector2d to face successor, with only xy coordinates */
    vectorToFaceSuccessorXY(result) {
        return Point2dVector2d_1.Vector2d.create(this.faceSuccessor.x - this.x, this.faceSuccessor.y - this.y, result);
    }
    /** @returns Return Vector3d to face successor */
    vectorToFaceSuccessor(result) {
        return Point3dVector3d_1.Vector3d.create(this.faceSuccessor.x - this.x, this.faceSuccessor.y - this.y, this.faceSuccessor.z - this.z, result);
    }
    /** @returns Returns true if the node does NOT have Mask.EXTERIOR_MASK set. */
    static testNodeMaskNotExterior(node) { return !node.isMaskSet(1 /* EXTERIOR */); }
    /** @return Return true if x and y coordinates of this and other are exactly equal */
    isEqualXY(other) {
        return this.x === other.x && this.y === other.y;
    }
    /** @return Return true if x and y coordinates of this and other are exactly equal */
    distanceXY(other) {
        return Geometry_1.Geometry.distanceXYXY(this.x, this.y, other.x, other.y);
    }
    /**
     *
     * * Evaluate f(node) at each node around a face loop.
     * * Collect the function values.
     * @returns Return the array of function values.
     */
    collectAroundFace(f) {
        const nodes = [];
        let node = this;
        do {
            nodes.push(f ? f(node) : node);
            node = node.faceSuccessor;
        } while (node !== this);
        return nodes;
    }
    /**
     *
     * * Evaluate f(node) at each outbound node around this node's vertex loop.
     * * Collect the function values.
     * @returns Return the array of function values.
     */
    collectAroundVertex(f) {
        const nodes = [];
        let node = this;
        do {
            nodes.push(f ? f(node) : node);
            node = node.vertexSuccessor;
        } while (node !== this);
        return nodes;
    }
    /**
     *
     * * Evaluate f(node) at each node around a face loop.
     * * Sum the function values
     * @returns Return the sum
     */
    sumAroundFace(f) {
        let node = this;
        let sum = 0;
        do {
            sum += f(node);
            node = node.faceSuccessor;
        } while (node !== this);
        return sum;
    }
    /**
     *
     * * Evaluate f(node) at each outbound node around this node's vertex loop.
     * * Sum the function values
     * @returns Return the sum
     */
    sumAroundVertex(f) {
        let node = this;
        let sum = 0;
        do {
            sum += f(node);
            node = node.vertexSuccessor;
        } while (node !== this);
        return sum;
    }
    /** For all the nodes in the face loop of the given node, clear out the mask given */
    clearMaskAroundFace(mask) {
        let node = this;
        do {
            node.clearMask(mask);
            node = node.faceSuccessor;
        } while (node !== this);
    }
    /** For all the nodes in the vertex loop of the given node, clear out the mask given */
    clearMaskAroundVertex(mask) {
        let node = this;
        do {
            node.clearMask(mask);
            node = node.vertexSuccessor;
        } while (node !== this);
    }
    /** Returns the signed sum of a loop of nodes.
     *
     * * A positive area is counterclockwise.
     * * A negative area is clockwise.
     */
    signedFaceArea() {
        let sum = 0;
        // sum area of trapezoids.
        // * the formula in the loop gives twice the area (because it does nto average the y values).
        // * this is fixed up at the end by a single multiply by 0.5
        // * indidual trapezoid heights are measured from y at the start node to keep area values numericall smaller.
        const y0 = this.y;
        let dy0 = 0.0;
        let dy1 = 0.0;
        let x0 = this.x;
        let x1 = x0;
        let node1 = this; // just to initialize -- reassigned in each loop pass.
        let node0 = this;
        do {
            node1 = node0.faceSuccessor;
            x1 = node1.x;
            dy1 = node1.y - y0;
            sum += (x0 - x1) * (dy0 + dy1);
            x0 = x1;
            dy0 = dy1;
            node0 = node1;
            node0 = node1;
        } while (node0 !== this);
        return 0.5 * sum;
    }
}
HalfEdge._totalNodesCreated = 0;
exports.HalfEdge = HalfEdge;
/**
 * A HalfEdgeGraph has:
 * * An array of (pointers to ) HalfEdge objects.
 */
class HalfEdgeGraph {
    constructor() {
        this._numNodesCreated = 0;
        this.allHalfEdges = [];
    }
    /**
     * * Create 2 half edges forming 2 vertices, 1 edge, and 1 face
     * * The two edges are joined as edgeMate pair.
     * * The two edges are a 2-half-edge face loop in both the faceSuccessor and facePredecessor directions.
     * * The two edges are added to the graph's HalfEdge set
     * @returns Return pointer to the first half edge created.
     */
    createEdgeXYZXYZ(xA = 0, yA = 0, zA = 0, iA = 0, xB = 0, yB = 0, zB = 0, iB = 0) {
        const a = HalfEdge.createHalfEdgePairWithCoordinates(xA, yA, zA, iA, xB, yB, zB, iB, this.allHalfEdges);
        return a;
    }
    /**
     * * Insert a vertex in the edge begining at base.
     * * this creates two half edges.
     * * The base of the new edge is 'after' the (possibly undefined) start node in its face loop.
     * * The existing mate retains its base xyzi properties but is no longer the mate of base.
     * * The base and existing mate each become mates with a new half edge.
     * @returns Returns the reference to the half edge created.
     */
    splitEdge(base, xA = 0, yA = 0, zA = 0, iA = 0) {
        const he = HalfEdge.splitEdge(base, xA, yA, zA, iA, this.allHalfEdges);
        return he;
    }
    /** This is a destructor-like action that elminates all interconnection among the graph's nodes.
     * After this is called the graph is unusable.
     */
    decommission() {
        for (const node of this.allHalfEdges) {
            node.decomission();
        }
        this.allHalfEdges.length = 0;
        this.allHalfEdges = undefined;
    }
    /** create two nodes of a new edge.
     * @returns Return one of the two nodes, which the caller may consider as the start of the edge.
     */
    addEdgeXY(x0, y0, x1, y1) {
        const baseNode = HalfEdge.createEdgeXYXY(this._numNodesCreated, x0, y0, this._numNodesCreated + 1, x1, y1);
        this._numNodesCreated += 2;
        this.allHalfEdges.push(baseNode);
        this.allHalfEdges.push(baseNode.faceSuccessor);
        return baseNode;
    }
    /** Clear selected bits in all nodes of the graph. */
    clearMask(mask) {
        for (const node of this.allHalfEdges)
            node.maskBits &= ~mask;
    }
    /** Set selected bits in all nodes of the graph. */
    setMask(mask) {
        for (const node of this.allHalfEdges)
            node.maskBits |= mask;
    }
    /** toggle selected bits in all nodes of the graph. */
    reverseMask(mask) {
        for (const node of this.allHalfEdges) {
            node.maskBits ^= mask;
        }
    }
    /**
     * @returns Return the number of nodes that have a specified mask bit set.
     * @param mask mask to count
     */
    countMask(mask) {
        let n = 0;
        for (const node of this.allHalfEdges)
            if (node.isMaskSet(mask))
                n++;
        return n;
    }
    /** Return an array LineSegment3d.
     * * The array has one segment per edge
     * * The coordinates are taken from a node and its face successor.
     * * On each edge, the line segment start at the HalfEdge with lower id than its edgeMate.
     */
    collectSegments() {
        const segments = [];
        for (const node of this.allHalfEdges) {
            if (node.id < node.edgeMate.id)
                segments.push(LineSegment3d_1.LineSegment3d.create(Point3dVector3d_1.Point3d.create(node.x, node.y), Point3dVector3d_1.Point3d.create(node.faceSuccessor.x, node.faceSuccessor.y)));
        }
        return segments;
    }
    /** Returns the number of vertex loops in a graph structure */
    countVertexLoops() {
        this.clearMask(8192 /* VISITED */);
        let count = 0;
        this.announceVertexLoops((_graph, _seed) => { count++; return true; });
        return count;
    }
    /** @returns Returns the number of face loops */
    countFaceLoops() {
        this.clearMask(8192 /* VISITED */);
        let count = 0;
        this.announceFaceLoops((_graph, _seed) => { count++; return true; });
        return count;
    }
    /**
     * @returns Returns the number of face loops satisfying a filter function with mask argument.
     *
     */
    countFaceLoopsWithMaskFilter(filter, mask) {
        this.clearMask(8192 /* VISITED */);
        let count = 0;
        this.announceFaceLoops((_graph, seed) => {
            if (filter(seed, mask))
                count++;
            return true;
        });
        return count;
    }
    /** @returns Returns an array of nodes, where each node represents a starting point of a face loop.
     */
    collectFaceLoops() {
        const returnArray = [];
        this.announceFaceLoops((_graph, node) => { returnArray.push(node); return true; });
        return returnArray;
    }
    /** @returns Returns an array of nodes, where each node represents a starting point of a vertex loop.
     */
    collectVertexLoops() {
        this.clearMask(8192 /* VISITED */);
        const returnArray = [];
        for (const node of this.allHalfEdges) {
            if (node.getMask(8192 /* VISITED */))
                continue;
            returnArray.push(node);
            node.setMaskAroundVertex(8192 /* VISITED */);
        }
        return returnArray;
    }
    /**
     * * Visit each facet of the graph once.
     * * Call the announceFace function
     * * continue search if announceFace(graph, node) returns true
     * * terminate search if announceface (graph, node) returns false
     * @param  announceFace function to apply at one node of each face.
     */
    announceFaceLoops(announceFace) {
        this.clearMask(8192 /* VISITED */);
        for (const node of this.allHalfEdges) {
            if (node.getMask(8192 /* VISITED */))
                continue;
            node.setMaskAroundFace(8192 /* VISITED */);
            if (!announceFace(this, node))
                break;
        }
    }
    /**
     * * Visit each vertex loop of the graph once.
     * * Call the announceVertex function
     * * continue search if announceFace(graph, node) returns true
     * * terminate search if announceface (graph, node) returns false
     * @param  annonceFace function to apply at one node of each face.
     */
    announceVertexLoops(announceVertex) {
        this.clearMask(8192 /* VISITED */);
        for (const node of this.allHalfEdges) {
            if (node.getMask(8192 /* VISITED */))
                continue;
            node.setMaskAroundVertex(8192 /* VISITED */);
            if (!announceVertex(this, node))
                break;
        }
    }
    /** @returns Return the number of nodes in the graph */
    countNodes() { return this.allHalfEdges.length; }
}
exports.HalfEdgeGraph = HalfEdgeGraph;
var HalfEdgeMask;
(function (HalfEdgeMask) {
    HalfEdgeMask[HalfEdgeMask["EXTERIOR"] = 1] = "EXTERIOR";
    HalfEdgeMask[HalfEdgeMask["BOUNDARY"] = 2] = "BOUNDARY";
    HalfEdgeMask[HalfEdgeMask["CONSTU_MASK"] = 4] = "CONSTU_MASK";
    HalfEdgeMask[HalfEdgeMask["CONSTV_MASK"] = 8] = "CONSTV_MASK";
    HalfEdgeMask[HalfEdgeMask["USEAM_MASK"] = 16] = "USEAM_MASK";
    HalfEdgeMask[HalfEdgeMask["VSEAM_MASK"] = 32] = "VSEAM_MASK";
    HalfEdgeMask[HalfEdgeMask["BOUNDARY_VERTEX_MASK"] = 64] = "BOUNDARY_VERTEX_MASK";
    HalfEdgeMask[HalfEdgeMask["PRIMARY_VERTEX_MASK"] = 128] = "PRIMARY_VERTEX_MASK";
    HalfEdgeMask[HalfEdgeMask["DIRECTED_EDGE_MASK"] = 256] = "DIRECTED_EDGE_MASK";
    HalfEdgeMask[HalfEdgeMask["PRIMARY_EDGE"] = 512] = "PRIMARY_EDGE";
    HalfEdgeMask[HalfEdgeMask["HULL_MASK"] = 1024] = "HULL_MASK";
    HalfEdgeMask[HalfEdgeMask["SECTION_EDGE_MASK"] = 2048] = "SECTION_EDGE_MASK";
    HalfEdgeMask[HalfEdgeMask["POLAR_LOOP_MASK"] = 4096] = "POLAR_LOOP_MASK";
    HalfEdgeMask[HalfEdgeMask["VISITED"] = 8192] = "VISITED";
    HalfEdgeMask[HalfEdgeMask["TRIANGULATED_NODE_MASK"] = 16384] = "TRIANGULATED_NODE_MASK";
    HalfEdgeMask[HalfEdgeMask["NULL_MASK"] = 0] = "NULL_MASK";
    HalfEdgeMask[HalfEdgeMask["ALL_MASK"] = 4294967295] = "ALL_MASK";
})(HalfEdgeMask = exports.HalfEdgeMask || (exports.HalfEdgeMask = {}));


/***/ }),

/***/ "./lib/topology/Triangulation.js":
/*!***************************************!*\
  !*** ./lib/topology/Triangulation.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2018 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Topology */
const Graph_1 = __webpack_require__(/*! ./Graph */ "./lib/topology/Graph.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Range_1 = __webpack_require__(/*! ../geometry3d/Range */ "./lib/geometry3d/Range.js");
class Triangulator {
    /** Given the six nodes that make up two bordering triangles, "pinch" and relocate the nodes to flip them */
    static flipTriangles(a, b, c, d, e, f) {
        // Reassign all of the pointers
        Graph_1.HalfEdge.pinch(a, e);
        Graph_1.HalfEdge.pinch(c, d);
        Graph_1.HalfEdge.pinch(f, c);
        Graph_1.HalfEdge.pinch(e, b);
        // Move alpha and beta into the xy coordinates of their predecessors
        e.x = b.x;
        e.y = b.y;
        e.z = b.z;
        e.i = b.i;
        c.i = f.i;
        c.x = f.x;
        c.y = f.y;
        c.z = f.z;
    }
    /**
     * * nodeA is a given node
     * * nodeA1 is its nodeA.faceSuccessor
     * * nodeA2 is nodeA1.faceSuccessor, i.e. 3rd node of triangle A
     * * nodeB  is nodeA.edgeMate, i.e. a node in the "other" triangle at nodeA's edge
     * * nodeB1 is nodeB.faceSucessor
     * * nodeB2 is nodeB1.faceSuccessor, i.e the 3rd node of triangle B
     * Construct (as simple doubles, to avoid object creation) xy vectors from:
     * * (ux,uy): nodeA to nodeA1, i.e. the shared edge
     * * (vx,vy): nodeA to ndoeA2,
     * * (wx,wy): nodeA to nodeB2
     * * this determinant is positive if nodeA is "in the circle" of nodeB2, nodeA1, nodeA2
     * @param nodeA node on the diagonal edge of candidate for edge flip.
     * @return the determinant (but undefined if the faces are not triangles as expected.)
     */
    static computeInCircleDeterminant(nodeA) {
        const nodeA1 = nodeA.faceSuccessor;
        const nodeA2 = nodeA1.faceSuccessor;
        if (nodeA2.faceSuccessor !== nodeA)
            return undefined;
        const nodeB = nodeA.edgeMate;
        const nodeB1 = nodeB.faceSuccessor;
        const nodeB2 = nodeB1.faceSuccessor;
        if (nodeB2.faceSuccessor !== nodeB)
            return undefined;
        const ux = nodeA1.x - nodeA.x;
        const uy = nodeA1.y - nodeA.y;
        const vx = nodeA2.x - nodeA.x;
        const vy = nodeA2.y - nodeA.y;
        // we assume identical coordinates in pairs (nodeA, nodeB1)  and (nodeA1, nodeB)
        const wx = nodeB2.x - nodeA.x;
        const wy = nodeB2.y - nodeA.y;
        return Geometry_1.Geometry.tripleProduct(wx, wy, wx * wx + wy * wy, vx, vy, vx * vx + vy * vy, ux, uy, ux * ux + uy * uy);
    }
    /**
     *  *  Visit each node of the graph array
     *  *  If a flip would be possible, test the results of flipping using incircle condition
     *  *  If revealed to be an improvement, conduct the flip, mark involved nodes as unvisited, and repeat until all nodes are visited
     */
    static cleanupTriangulation(graph) {
        const nodeArray = graph.allHalfEdges;
        graph.clearMask(8192 /* VISITED */);
        let foundNonVisited = false;
        for (let i = 0; i < nodeArray.length; i++) {
            const node = nodeArray[i];
            // HalfEdge has already been visited or is exterior node
            if (node.isMaskSet(8192 /* VISITED */))
                continue;
            node.setMask(8192 /* VISITED */);
            if (node.edgeMate === undefined || node.isMaskSet(1 /* EXTERIOR */) || node.isMaskSet(512 /* PRIMARY_EDGE */)) // Flip not allowed
                continue;
            foundNonVisited = true;
            const incircle = Triangulator.computeInCircleDeterminant(node);
            if (incircle !== undefined && incircle > 0.0) {
                // Mark all nodes involved in flip as needing to be buffer (other than alpha and beta node we started with)
                node.facePredecessor.clearMask(8192 /* VISITED */);
                node.faceSuccessor.clearMask(8192 /* VISITED */);
                node.edgeMate.facePredecessor.clearMask(8192 /* VISITED */);
                node.edgeMate.faceSuccessor.clearMask(8192 /* VISITED */);
                // Flip the triangles
                Triangulator.flipTriangles(node.edgeMate.faceSuccessor, node.edgeMate.facePredecessor, node.edgeMate, node.faceSuccessor, node, node.facePredecessor);
            }
            // If at the end of the loop, check if we found an unvisited node we tried to flip.. if so, restart loop
            if (i === nodeArray.length - 1 && foundNonVisited) {
                i = -1;
                foundNonVisited = false;
            }
        }
        graph.clearMask(8192 /* VISITED */);
    }
    /**
     *
     * @param strokedLoops an array of loops as GrowableXYZArray.
     * @returns triangulated graph, or undefined if bad data.
     */
    static triangulateStrokedLoops(strokedLoops) {
        if (strokedLoops.length < 1)
            return undefined;
        Triangulator._returnGraph = new Graph_1.HalfEdgeGraph();
        let maxArea = strokedLoops[0].areaXY();
        let largestLoopIndex = 0;
        for (let i = 0; i < strokedLoops.length; i++) {
            const area = Math.abs(strokedLoops[i].areaXY());
            if (area > maxArea) {
                maxArea = area;
                largestLoopIndex = i;
            }
        }
        // NOW WE KNOW ...
        // strokedLoops[largestAreaIndex] is the largest loop.  (Hence outer, but orientation is not guaranteed.)
        const holeLoops = [];
        let startingNode = Triangulator.createFaceLoopFromIndexedXYZCollection(strokedLoops[largestLoopIndex], true, true);
        if (!startingNode)
            return Triangulator._returnGraph;
        for (let i = 0; i < strokedLoops.length; i++) {
            if (i !== largestLoopIndex) {
                const holeLoop = Triangulator.createFaceLoopFromIndexedXYZCollection(strokedLoops[i], false, true);
                if (holeLoop)
                    holeLoops.push(Triangulator.getLeftmost(holeLoop));
            }
        }
        startingNode = Triangulator.spliceLeftMostNodesOfHoles(startingNode, holeLoops, false);
        Triangulator.earcutLinked(startingNode);
        return Triangulator._returnGraph;
    }
    /**
     * Triangulate the polygon made up of by a series of points.
     * * To triangulate a polygon with holes, use earcutFromOuterAndInnerLoops
     * * The loop may be either CCW or CW -- CCW order will be used for triangles.
     */
    static earcutSingleLoop(data) {
        Triangulator._returnGraph = new Graph_1.HalfEdgeGraph();
        const startingNode = Triangulator.createFaceLoopFromXAndYArray(data, true, true);
        if (!startingNode)
            return Triangulator._returnGraph;
        let minX;
        let minY;
        let maxX;
        let maxY;
        let x;
        let y;
        let size;
        // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
        if (data.length > 80) {
            minX = maxX = data[0].x;
            minY = maxY = data[0].y;
            const n = data.length;
            for (let i = 1; i < n; i++) {
                x = data[i].x;
                y = data[i].y;
                if (x < minX)
                    minX = x;
                if (y < minY)
                    minY = y;
                if (x > maxX)
                    maxX = x;
                if (y > maxY)
                    maxY = y;
            }
            // minX, minY and size are later used to transform coords into integers for z-order calculation
            size = Math.max(maxX - minX, maxY - minY);
        }
        Triangulator.earcutLinked(startingNode, minX, minY, size);
        return Triangulator._returnGraph;
    }
    /**
     * Triangulate the polygon made up of multiple loops.
     * * only xy parts are considered.
     * * First loop is assumed outer -- will be reordered as CCW
     * * Additional loops assumed inner -- will be reordered as CW
     */
    static earcutOuterAndInnerLoops(loops) {
        Triangulator._returnGraph = new Graph_1.HalfEdgeGraph();
        const range = Range_1.Range2d.createNull();
        const numLoops = loops.length;
        // let totalPoints = 0;
        // trim trailing duplicates from each array.
        for (const loop of loops) {
            // totalPoints += n;
            const n = loop.length;
            for (let i = 0; i < n; i++)
                range.extendXY(loop[i].x, loop[i].y);
        }
        let startingNode = Triangulator.createFaceLoopFromXAndYArray(loops[0], true, true);
        if (!startingNode)
            return Triangulator._returnGraph;
        if (numLoops > 1)
            startingNode = Triangulator.constructAndSpliceHoles(loops, startingNode);
        // NEEDS WORK: When 80 or more points, pass range go earcutLinked.  This triggers hashing for performance.
        Triangulator.earcutLinked(startingNode);
        return Triangulator._returnGraph;
    }
    /**
     * cautiously split the edge starting at baseNode.
     * * If baseNode is null, create a trivial loop with the single vertex at xy
     * * if xy is distinct from the coordinates at both baseNode and its successor, insert xy as a new node within that edge.
     * * also include z coordinate if present.
     */
    static interiorEdgeSplit(graph, baseNode, xy) {
        const z = xy.hasOwnProperty("z") ? xy.z : 0.0;
        if (!baseNode)
            return graph.splitEdge(baseNode, xy.x, xy.y, z);
        if (Triangulator.equalXAndY(baseNode, xy))
            return baseNode;
        if (Triangulator.equalXAndY(baseNode.faceSuccessor, xy))
            return baseNode;
        return graph.splitEdge(baseNode, xy.x, xy.y, z);
    }
    static directcreateFaceLoopFromIndexedXYZCollection(graph, data) {
        let i;
        // Add the starting nodes as the boundary, and apply initial masks to the primary edge and exteriors
        let baseNode;
        const xyz = Point3dVector3d_1.Point3d.create();
        for (i = 0; i < data.length; i++) {
            data.atPoint3dIndex(i, xyz);
            baseNode = Triangulator.interiorEdgeSplit(graph, baseNode, xyz);
        }
        return baseNode;
    }
    static directCreateFaceLoopFromXAndYArray(graph, data) {
        // Add the starting nodes as the boundary, and apply initial masks to the primary edge and exteriors
        let baseNode;
        for (const xy of data) {
            baseNode = Triangulator.interiorEdgeSplit(graph, baseNode, xy);
        }
        return baseNode;
    }
    /**
     * @param graph the containing graph
     * @param base The last node of a newly created loop.  (i.e. its `faceSuccessor` has the start xy)
     * @param returnPositiveAreaLoop if true, return the start node on the side with positive area.  otherwise return the left side as given.
     * @param markExterior
     * @return the loop's start node or its vertex sucessor, chosen to be the positive or negative loop per request.
     */
    static assignMasksToNewFaceLoop(_graph, base, returnPositiveAreaLoop, markExterior) {
        // base is the final coordinates
        if (base) {
            base = base.faceSuccessor; // because typical construction process leaves the "live" edge at the end of the loop.
            const area = base.signedFaceArea();
            const mate = base.edgeMate;
            base.setMaskAroundFace(2 /* BOUNDARY */ | 512 /* PRIMARY_EDGE */);
            mate.setMaskAroundFace(2 /* BOUNDARY */ | 512 /* PRIMARY_EDGE */);
            let preferredNode = base;
            if (returnPositiveAreaLoop === (area < 0))
                preferredNode = mate;
            const otherNode = preferredNode.vertexSuccessor;
            if (markExterior)
                otherNode.setMaskAroundFace(1 /* EXTERIOR */);
            return preferredNode;
        }
        return undefined; // caller should not be calling with start <= end
    }
    /**
     * create a circular doubly linked list of internal and external nodes from polygon points in the specified winding order
     * * If start and end are both zero, use the whole array.
     */
    static createFaceLoopFromXAndYArray(data, returnPositiveAreaLoop, markExterior) {
        const graph = Triangulator._returnGraph;
        const base = Triangulator.directCreateFaceLoopFromXAndYArray(graph, data);
        return Triangulator.assignMasksToNewFaceLoop(graph, base, returnPositiveAreaLoop, markExterior);
    }
    /**
     * create a circular doubly linked list of internal and external nodes from polygon points in the specified winding order
     */
    static createFaceLoopFromIndexedXYZCollection(data, returnPositiveAreaLoop, markExterior) {
        const graph = Triangulator._returnGraph;
        const base = Triangulator.directcreateFaceLoopFromIndexedXYZCollection(graph, data);
        return Triangulator.assignMasksToNewFaceLoop(graph, base, returnPositiveAreaLoop, markExterior);
    }
    /** eliminate colinear or duplicate points using starting and ending nodes */
    static filterPoints(start, end) {
        if (!start)
            return start;
        if (!end)
            end = start;
        let p = start;
        let again;
        do {
            again = false;
            if (!p.steiner && (Triangulator.equalXAndY(p, p.faceSuccessor) || Triangulator.signedTriangleArea(p.facePredecessor, p, p.faceSuccessor) === 0)) {
                Triangulator.joinNeighborsOfEar(p);
                p = end = p.facePredecessor;
                if (p === p.faceSuccessor)
                    return undefined;
                again = true;
            }
            else {
                p = p.faceSuccessor;
            }
        } while (again || p !== end);
        return end;
    }
    /** Cut off an ear, forming a new face loop of nodes
     * @param ear the vertex being cut off.
     * *  Form two new nodes, alpha and beta, which have the coordinates one step away from the ear vertex.
     * *  Reassigns the pointers such that beta is left behind with the new face created
     * *  Reassigns the pointers such that alpha becomes the resulting missing node from the remaining polygon
     * * Reassigns prevZ and nextZ pointers
     */
    static joinNeighborsOfEar(ear) {
        const alpha = Triangulator._returnGraph.createEdgeXYZXYZ(ear.facePredecessor.x, ear.facePredecessor.y, ear.facePredecessor.z, ear.facePredecessor.i, ear.faceSuccessor.x, ear.faceSuccessor.y, ear.faceSuccessor.z, ear.faceSuccessor.i);
        const beta = alpha.edgeMate;
        // Take care of z-ordering
        if (ear.prevZ)
            ear.prevZ.nextZ = ear.nextZ;
        if (ear.nextZ)
            ear.nextZ.prevZ = ear.prevZ;
        // Add two nodes alpha and beta and reassign pointers (also mark triangle nodes as part of triangle)
        Graph_1.HalfEdge.pinch(ear.faceSuccessor, beta);
        Graph_1.HalfEdge.pinch(ear.facePredecessor, alpha);
        ear.setMaskAroundFace(16384 /* TRIANGULATED_NODE_MASK */);
    }
    /**
     * main ear slicing loop which triangulates a polygon (given as a linked list)
     * While there still exists ear nodes that have not yet been triangulated...
     *
     * *  Check if the ear is hashed, and can easily be split off. If so, "join" that ear.
     * *  If not hashed, move on to a seperate ear.
     * *  If no ears are currently hashed, attempt to cure self intersections or split the polygon into two before continuing
     */
    static earcutLinked(ear, minX, minY, size, pass) {
        if (!ear)
            return;
        // interlink polygon nodes in z-order
        if (!pass && size)
            Triangulator.indexCurve(ear, minX, minY, size);
        let stop = ear;
        let next;
        // iterate through ears, slicing them one by one
        while (!ear.isMaskSet(16384 /* TRIANGULATED_NODE_MASK */)) {
            next = ear.faceSuccessor;
            if (size ? Triangulator.isEarHashed(ear, minX, minY, size) : Triangulator.isEar(ear)) {
                // skipping the next vertice leads to less sliver triangles
                stop = next.faceSuccessor;
                // If we already have a seperated triangle, do not join
                if (ear.faceSuccessor.faceSuccessor !== ear.facePredecessor) {
                    Triangulator.joinNeighborsOfEar(ear);
                    ear = ear.faceSuccessor.edgeMate.faceSuccessor.faceSuccessor;
                }
                else {
                    ear.setMask(16384 /* TRIANGULATED_NODE_MASK */);
                    ear.faceSuccessor.setMask(16384 /* TRIANGULATED_NODE_MASK */);
                    ear.facePredecessor.setMask(16384 /* TRIANGULATED_NODE_MASK */);
                    ear = next.faceSuccessor;
                }
                continue;
            }
            ear = next;
            // if we looped through the whole remaining polygon and can't find any more ears
            if (ear === stop) {
                // try filtering points and slicing again
                // if (!pass) {
                //  Triangulator.earcutLinked(Triangulator.filterPoints(ear), minX, minY, size, 1);
                // }
                // if this didn't work, try curing all small self-intersections locally
                if (!pass) {
                    ear = Triangulator.cureLocalIntersections(ear);
                    Triangulator.earcutLinked(ear, minX, minY, size, 2);
                    // as a last resort, try splitting the remaining polygon into two
                }
                else if (pass === 2) {
                    Triangulator.splitEarcut(ear, minX, minY, size);
                }
                break;
            }
        }
    }
    /** Check whether a polygon node forms a valid ear with adjacent nodes */
    static isEar(ear) {
        const a = ear.facePredecessor;
        const b = ear;
        const c = ear.faceSuccessor;
        if (Triangulator.signedTriangleArea(a, b, c) >= 0)
            return false; // reflex, can't be an ear
        // now make sure we don't have other points inside the potential ear
        let p = ear.faceSuccessor.faceSuccessor;
        while (p !== ear.facePredecessor) {
            if (Triangulator.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                Triangulator.signedTriangleArea(p.facePredecessor, p, p.faceSuccessor) >= 0)
                return false;
            p = p.faceSuccessor;
        }
        return true;
    }
    /** Check whether a polygon node forms a valid ear with adjacent nodes using bounded boxes of z-ordering of this and adjacent nodes */
    static isEarHashed(ear, minX, minY, size) {
        const a = ear.facePredecessor;
        const b = ear;
        const c = ear.faceSuccessor;
        if (Triangulator.signedTriangleArea(a, b, c) >= 0)
            return false; // reflex, can't be an ear
        // triangle bbox; min & max are calculated like this for speed
        const minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x);
        const minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y);
        const maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x);
        const maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);
        // z-order range for the current triangle bbox;
        const minZ = Triangulator.zOrder(minTX, minTY, minX, minY, size);
        const maxZ = Triangulator.zOrder(maxTX, maxTY, minX, minY, size);
        // first look for points inside the triangle in increasing z-order
        let p = ear.nextZ;
        while (p && p.zOrder <= maxZ) {
            if (p !== ear.facePredecessor && p !== ear.faceSuccessor &&
                Triangulator.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                Triangulator.signedTriangleArea(p.facePredecessor, p, p.faceSuccessor) >= 0)
                return false;
            p = p.nextZ;
        }
        // then look for points in decreasing z-order
        p = ear.prevZ;
        while (p && p.zOrder >= minZ) {
            if (p !== ear.facePredecessor && p !== ear.faceSuccessor &&
                Triangulator.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                Triangulator.signedTriangleArea(p.facePredecessor, p, p.faceSuccessor) >= 0)
                return false;
            p = p.prevZ;
        }
        return true;
    }
    /** Go through all polygon nodes and cure small local self-intersections */
    static cureLocalIntersections(start) {
        let p = start;
        do {
            const a = p.facePredecessor;
            const b = p.faceSuccessor.faceSuccessor;
            if (!Triangulator.equalXAndY(a, b) && Triangulator.intersects(a, p, p.faceSuccessor, b) &&
                Triangulator.locallyInside(a, b) && Triangulator.locallyInside(b, a)) {
                // remove two nodes involved
                Triangulator.joinNeighborsOfEar(p);
                Triangulator.joinNeighborsOfEar(p.faceSuccessor);
                p = start = b;
            }
            p = p.faceSuccessor;
        } while (p !== start);
        return p;
    }
    /** try splitting polygon into two and triangulate them independently */
    static splitEarcut(start, minX, minY, size) {
        // look for a valid diagonal that divides the polygon into two
        let a = start;
        do {
            let b = a.faceSuccessor.faceSuccessor;
            while (b !== a.facePredecessor) {
                if (a.i !== b.i && Triangulator.isValidDiagonal(a, b)) {
                    // split the polygon in two by the diagonal
                    let c = Triangulator.splitPolygon(a, b);
                    // filter colinear points around the cuts
                    a = Triangulator.filterPoints(a, a.faceSuccessor);
                    c = Triangulator.filterPoints(c, c.faceSuccessor);
                    // run earcut on each half
                    Triangulator.earcutLinked(a, minX, minY, size);
                    Triangulator.earcutLinked(c, minX, minY, size);
                    return;
                }
                b = b.faceSuccessor;
            }
            a = a.faceSuccessor;
        } while (a !== start);
    }
    /** link loops[1], loops[2] etc into the outer loop, producing a single-ring polygon without holes
     *
     */
    static constructAndSpliceHoles(loops, outerNode) {
        const queue = [];
        let list;
        for (let holeIndex = 1; holeIndex < loops.length; holeIndex++) {
            list = Triangulator.createFaceLoopFromXAndYArray(loops[holeIndex], false, true);
            if (list && list === list.faceSuccessor)
                list.steiner = true;
            queue.push(Triangulator.getLeftmost(list));
        }
        outerNode = Triangulator.spliceLeftMostNodesOfHoles(outerNode, queue, true);
        return outerNode;
    }
    /** link holeLoopNodes[1], holeLoopNodes[2] etc into the outer loop, producing a single-ring polygon without holes
     *
     */
    static spliceLeftMostNodesOfHoles(outerNode, leftMostHoleLoopNode, applyFilter = true) {
        leftMostHoleLoopNode.sort(Triangulator.compareX);
        // process holes from left to right
        for (const holeStart of leftMostHoleLoopNode) {
            Triangulator.eliminateHole(holeStart, outerNode, applyFilter);
            if (applyFilter)
                outerNode = Triangulator.filterPoints(outerNode, (outerNode) ? outerNode.faceSuccessor : undefined);
        }
        return outerNode;
    }
    /** For use in sorting -- return (signed) difference (a.x - b.x) */
    static compareX(a, b) {
        return a.x - b.x;
    }
    /** find a bridge between vertices that connects hole with an outer ring and and link it */
    static eliminateHole(hole, outerNode, applyFilter) {
        outerNode = Triangulator.findHoleBridge(hole, outerNode);
        if (outerNode) {
            const b = Triangulator.splitPolygon(outerNode, hole);
            if (applyFilter)
                Triangulator.filterPoints(b, b.faceSuccessor);
        }
    }
    /**
     *  David Eberly's algorithm for finding a bridge between hole and outer polygon:
     *  https://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf
     */
    static findHoleBridge(hole, outerNode) {
        let p = outerNode;
        if (!p)
            return undefined;
        const hx = hole.x;
        const hy = hole.y;
        let qx = -Infinity;
        let m;
        // find a segment intersected by a ray from the hole's leftmost point to the left;
        // segment's endpoint with lesser x will be potential connection point
        do {
            if (hy <= p.y && hy >= p.faceSuccessor.y && p.faceSuccessor.y !== p.y) {
                const x = p.x + (hy - p.y) * (p.faceSuccessor.x - p.x) / (p.faceSuccessor.y - p.y);
                if (x <= hx && x > qx) {
                    qx = x;
                    if (x === hx) {
                        if (hy === p.y)
                            return p;
                        if (hy === p.faceSuccessor.y)
                            return p.faceSuccessor;
                    }
                    m = p.x < p.faceSuccessor.x ? p : p.faceSuccessor;
                }
            }
            p = p.faceSuccessor;
        } while (p !== outerNode);
        if (!m)
            return undefined;
        if (hx === qx)
            return m.facePredecessor; // hole touches outer segment; pick lower endpoint
        // look for points inside the triangle of hole point, segment intersection and endpoint;
        // if there are no points found, we have a valid connection;
        // otherwise choose the point of the minimum angle with the ray as connection point
        const stop = m;
        const mx = m.x;
        const my = m.y;
        let tanMin = Infinity;
        let tan;
        p = m.faceSuccessor;
        while (p !== stop) {
            if (hx >= p.x && p.x >= mx && hx !== p.x &&
                Triangulator.pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
                tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
                if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && Triangulator.locallyInside(p, hole)) {
                    m = p;
                    tanMin = tan;
                }
            }
            p = p.faceSuccessor;
        }
        return m;
    }
    /** interlink polygon nodes in z-order */
    static indexCurve(start, minX, minY, size) {
        let p = start;
        do {
            if (p.zOrder === undefined)
                p.zOrder = Triangulator.zOrder(p.x, p.y, minX, minY, size);
            p.prevZ = p.facePredecessor;
            p.nextZ = p.faceSuccessor;
            p = p.faceSuccessor;
        } while (p !== start);
        p.prevZ.nextZ = undefined;
        p.prevZ = undefined;
        Triangulator.sortLinked(p);
    }
    /**
     * Simon Tatham's linked list merge sort algorithm
     * http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
     */
    static sortLinked(list) {
        let i;
        let p;
        let q;
        let e;
        let tail;
        let numMerges;
        let pSize;
        let qSize;
        let inSize = 1;
        do {
            p = list;
            list = undefined;
            tail = undefined;
            numMerges = 0;
            while (p) {
                numMerges++;
                q = p;
                pSize = 0;
                for (i = 0; i < inSize; i++) {
                    pSize++;
                    q = q.nextZ;
                    if (!q)
                        break;
                }
                qSize = inSize;
                while (pSize > 0 || (qSize > 0 && q)) {
                    if (pSize !== 0 && (qSize === 0 || !q || p.zOrder <= q.zOrder)) {
                        e = p;
                        p = p.nextZ;
                        pSize--;
                    }
                    else {
                        e = q;
                        q = q.nextZ;
                        qSize--;
                    }
                    if (tail)
                        tail.nextZ = e;
                    else
                        list = e;
                    e.prevZ = tail;
                    tail = e;
                }
                p = q;
            }
            tail.nextZ = undefined;
            inSize *= 2;
        } while (numMerges > 1);
        return list;
    }
    /**
     * z-order of a point given coords and size of the data bounding box
     */
    static zOrder(x, y, minX, minY, size) {
        // coords are transformed into non-negative 15-bit integer range
        x = 32767 * (x - minX) / size;
        y = 32767 * (y - minY) / size;
        x = (x | (x << 8)) & 0x00FF00FF;
        x = (x | (x << 4)) & 0x0F0F0F0F;
        x = (x | (x << 2)) & 0x33333333;
        x = (x | (x << 1)) & 0x55555555;
        y = (y | (y << 8)) & 0x00FF00FF;
        y = (y | (y << 4)) & 0x0F0F0F0F;
        y = (y | (y << 2)) & 0x33333333;
        y = (y | (y << 1)) & 0x55555555;
        return x | (y << 1);
    }
    // find the leftmost node of a polygon ring
    static getLeftmost(start) {
        let p = start;
        let leftmost = start;
        do {
            if (p.x < leftmost.x)
                leftmost = p;
            p = p.faceSuccessor;
        } while (p !== start);
        return leftmost;
    }
    /** check if a point lies within a convex triangle */
    static pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
            (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
            (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
    }
    /** check if a diagonal between two polygon nodes is valid (lies in polygon interior) */
    static isValidDiagonal(a, b) {
        return a.faceSuccessor.i !== b.i && a.facePredecessor.i !== b.i && !Triangulator.intersectsPolygon(a, b) &&
            Triangulator.locallyInside(a, b) && Triangulator.locallyInside(b, a) && Triangulator.middleInside(a, b);
    }
    /** signed area of a triangle */
    static signedTriangleArea(p, q, r) {
        return 0.5 * ((q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y));
    }
    /** check if two points are equal */
    static equalXAndY(p1, p2) {
        return Geometry_1.Geometry.isSameCoordinate(p1.x, p2.x) && Geometry_1.Geometry.isSameCoordinate(p1.y, p2.y);
    }
    /** check if two segments intersect */
    static intersects(p1, q1, p2, q2) {
        if ((Triangulator.equalXAndY(p1, q1) && Triangulator.equalXAndY(p2, q2)) ||
            (Triangulator.equalXAndY(p1, q2) && Triangulator.equalXAndY(p2, q1)))
            return true;
        return Triangulator.signedTriangleArea(p1, q1, p2) > 0 !== Triangulator.signedTriangleArea(p1, q1, q2) > 0 &&
            Triangulator.signedTriangleArea(p2, q2, p1) > 0 !== Triangulator.signedTriangleArea(p2, q2, q1) > 0;
    }
    /** check if a polygon diagonal intersects any polygon segments */
    static intersectsPolygon(a, b) {
        let p = a;
        do {
            if (p.i !== a.i && p.faceSuccessor.i !== a.i && p.i !== b.i && p.faceSuccessor.i !== b.i &&
                Triangulator.intersects(p, p.faceSuccessor, a, b))
                return true;
            p = p.faceSuccessor;
        } while (p !== a);
        return false;
    }
    /** check if a polygon diagonal is locally inside the polygon */
    static locallyInside(a, b) {
        return Triangulator.signedTriangleArea(a.facePredecessor, a, a.faceSuccessor) < 0 ?
            Triangulator.signedTriangleArea(a, b, a.faceSuccessor) >= 0 && Triangulator.signedTriangleArea(a, a.facePredecessor, b) >= 0 :
            Triangulator.signedTriangleArea(a, b, a.facePredecessor) < 0 || Triangulator.signedTriangleArea(a, a.faceSuccessor, b) < 0;
    }
    /** check if the middle point of a polygon diagonal is inside the polygon */
    static middleInside(a, b) {
        let p = a;
        let inside = false;
        const px = (a.x + b.x) / 2;
        const py = (a.y + b.y) / 2;
        do {
            if (((p.y > py) !== (p.faceSuccessor.y > py)) && p.faceSuccessor.y !== p.y &&
                (px < (p.faceSuccessor.x - p.x) * (py - p.y) / (p.faceSuccessor.y - p.y) + p.x))
                inside = !inside;
            p = p.faceSuccessor;
        } while (p !== a);
        return inside;
    }
    /**
     * link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
     * if one belongs to the outer ring and another to a hole, it merges it into a single ring
     * * Returns the base of the new edge at the "a" end.
     * * "a" and "b" still represent the same physical pieces of edges
     * @returns Returns the (base of) the new half edge, at the "a" end.
     */
    static splitPolygon(a, b) {
        const a2 = Triangulator._returnGraph.createEdgeXYZXYZ(a.x, a.y, a.z, a.i, b.x, b.y, b.z, b.i);
        const b2 = a2.faceSuccessor;
        Graph_1.HalfEdge.pinch(a, a2);
        Graph_1.HalfEdge.pinch(b, b2);
        return a2;
    }
}
exports.Triangulator = Triangulator;


/***/ })

},[["./lib/geometry-core.js","runtime"]]]);
});
//# sourceMappingURL=geometry-core.js.map